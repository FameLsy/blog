<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2Fblog%2F2018%2F02%2F20%2Fgit.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DesignPatterns]]></title>
    <url>%2Fblog%2F2018%2F02%2F19%2FDesignPatterns.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm]]></title>
    <url>%2Fblog%2F2018%2F02%2F18%2FAlgorithm.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataStructure]]></title>
    <url>%2Fblog%2F2018%2F02%2F17%2FDataStructure.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos]]></title>
    <url>%2Fblog%2F2018%2F02%2F16%2FCentos.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2Fblog%2F2018%2F02%2F15%2FHexo.all%2F</url>
    <content type="text"><![CDATA[hexo官网文档 安装Hexo安装前提安装hexo前，还需还装Node.js和Git*两个程序 安装 Gitgit官网Linux (Ubuntu, Debian) 1sudo apt-get install git Linux (Fedora, Red Hat, CentOS) 1sudo yum install git 安装Node.jsNode.js官网安装Node.js,推荐使用nvm方式安装下载并安装nvmnvm github地址CURL方式 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash Wget方式 1wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 安装完成后,重新打开一个终端.开始安装Node.js 1nvm install stable 安装Hexo使用nmp命令进行安装 1npm install -g hexo-cli 建站建立博客站先初始化一个站，folder为自己填写的站名 1hexo init &lt;folder&gt; 完成后，在用户目录下，多出了一个以folder 为名的文件夹进入该文件夹 1cd &lt;folder&gt; 该文件夹下，有如下文件 文件名 描述 _config.yml 存有网站的配置信息，大部分配置都在这里修改 package.json 应用程序的信息 scaffolds 模版文件夹。当新建文章时，Hexo 会根据 scaffold 来建立文件 source 资源文件夹是存放用户资源的地方。开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 themes 主题 文件夹。Hexo 会根据主题来生成静态页面 安装相关依赖 1npm install 此时基本可以运行，首先生成静态文件 1hexo d 然后运行 1hexo s 运行正确的话，系统会输出 1Hexo is running at http://localhost:4000 在自己的浏览器打开访问,就可以浏览到一个什么都没有的博客了。 配置网站配置打开配置文件,接下来我将以blog为设置的站文件夹 1sudo vim ~/blog/_config.yml 配置网站,关键字Site 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York,Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址配置关键字，Url 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的永久链接格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 配置目录关键字，Directory 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 配置未完待续 更新博客文件1234# 进入博客文件文件夹cd ~/blog/source/_posts# 更新博客hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 挂载到Github安装依赖 1npm install hexo-deployer-git --save 修改站点配置文件仓库名必须是 famelsy.github.io 1234deploy: type: git repo : git@github.com:FameLsy/famelsy.github.io.git branch: master 个性化Hexo自定义CSS样式创建一个.styl文件 12# 内容就放css的内容即可vim ~/blog/themes/next/source/css/_custom/mystyle.styl 打开custom.styl文件，并将刚刚创建的.styl文件导入 12#输入@impolt &quot;mystyle.styl&quot;导入sudo vim ~/blog/themes/next/source/css/_custom/custom.styl 自定义JS代码首先,如果根目录没有scripts目录，就创建一个。然后，创建js文件 12# 直接创建并打开vim ~/blog/scripts/myjs.js hexo会自动加载该目录下的js文件 修改代码块首先,如果根目录没有scripts目录，就创建一个。然后，创建js文件 12# 直接创建并打开vim ~/blog/scripts/codeblock.js 复制以下内容进去 123456789101112131415161718192021var attributes = [ 'autocomplete="off"', 'autocorrect="off"', 'autocapitalize="off"', 'spellcheck="false"', 'contenteditable="true"']var attributesStr = attributes.join(' ')hexo.extend.filter.register('after_post_render', function (data) &#123; while (/&lt;figure class="highlight ([a-zA-Z]+)"&gt;.*?&lt;\/figure&gt;/.test(data.content)) &#123; data.content = data.content.replace(/&lt;figure class="highlight ([a-zA-Z]+)"&gt;.*?&lt;\/figure&gt;/, function () &#123; var language = RegExp.$1 || 'plain' var lastMatch = RegExp.lastMatch lastMatch = lastMatch.replace(/&lt;figure class="highlight /, '&lt;figure class="iseeu highlight /') return '&lt;div class="highlight-wrap"' + attributesStr + 'data-rel="' + language.toUpperCase() + '"&gt;' + lastMatch + '&lt;/div&gt;' &#125;) &#125; return data&#125;) 然后，创建一个.style文件 1vim ~/blog/themes/next/source/css/_custom/mystyle.styl 加入内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.highlight &#123; margin: 38px 0 0 0 !important;&#125;.highlight-wrap[data-rel] &#123; position: relative; overflow: hidden; border-radius: 5px; box-shadow: 0 10px 30px 0px rgba(0, 0, 0, 0.4); margin: 35px 0; ::-webkit-scrollbar &#123; height: 10px; &#125; ::-webkit-scrollbar-track &#123; -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3); border-radius: 10px; &#125; ::-webkit-scrollbar-thumb &#123; border-radius: 10px; -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.5); &#125; &amp;::before &#123; color: white; content: attr(data-rel); height: 38px; line-height: 38px; background: #21252b; color: #fff; font-size: 16px; position: absolute; top: 0; left: 0; width: 100%; font-family: 'Source Sans Pro', sans-serif; font-weight: bold; padding: 0px 80px; text-indent: 15px; float: left; &#125; &amp;::after &#123; content: ' '; position: absolute; -webkit-border-radius: 50%; border-radius: 50%; background: #fc625d; width: 12px; height: 12px; top: 0; left: 20px; margin-top: 13px; -webkit-box-shadow: 20px 0px #fdbc40, 40px 0px #35cd4b; box-shadow: 20px 0px #fdbc40, 40px 0px #35cd4b; z-index: 3; &#125;&#125; 打开custom.styl文件，并将刚刚创建的.styl文件导入 12#输入@import &quot;mystyle.styl&quot;导入sudo vim ~/blog/themes/next/source/css/_custom/custom.styl 主题下载next主题 1234 git clone https://github.com/theme-next/hexo-theme-next themes/next# 站点配置文件theme: next 不展开全部内容主题配置文件搜索关键字auto_excerpt,enable改为true 123auto_excerpt: enable: true length: 150 添加「标签/分类」页面新建页面 123cd ~/bloghexo new page tagshexo new page tags categories 编辑刚刚新建的页面 12vim source/tags/index.mdvim source/categories/index.md 添加 type: “tags” 12345678910---title: tagstype: &quot;tags&quot;date: 2018-12-20 21:00:02---# 对于分类页面就是title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;--- 修改主题配置文件 12345menu: home: / archives: /archives tags: /tags categories: /categories 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 以下所有终端执行的命令都在你的Hexo根目录下 基本信息配置打开 站点配置文件 ，找到Site模块 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 关于 站点配置文件 中的其他配置可参考站点配置 菜单设置菜单包括：首页、归档、分类、标签、关于等等 我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 主题配置文件 找到Menu Settings 看看你需要哪个菜单就把哪个取消注释打开就行了； 关于后面的格式，以archives: /archives/ || archive为例： || 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改 ||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 主题配置文件 找到Scheme Settings 12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 4种风格大同小异，本人用的是Gemini风格，你们可以选择自己喜欢的风格 侧栏设置开启侧边栏社交链接1234567891011# Social linkssocial: GitHub: https://github.com/hydcoder Weibo: https://weibo.com/3180967953/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo # 等等social_icons: enable: true # Icon Mappings. GitHub: github Weibo: weibo 开启打赏功能123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: 你的微信收款码链接alipay: 你的支付宝收款码链接 开启友情链接1234links_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 开启订阅微信公众号1234wechat_subscriber:enabled: trueqcode: /uploads/wechat-qcode.jpgdescription: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 头像设置打开 主题配置文件 找到Sidebar Avatar字段 12# Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 设置侧边栏设置圆形可旋转头像 找到生成的Hexo目录\themes\next\source\css_common\components\sidebar下的sidebar-author.styl，将里面的css样式内容全部替换为： 123456789101112131415161718192021222324252627282930313233.site-author-image &#123; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; transition: 1.4s all;&#125;.site-author-image:hover &#123; -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg);&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 设置首页不显示全文(只显示预览)打开主题配置文件_config.yml，ctrl + F搜索找到”auto_excerpt”，可以看见 12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt:enable: falselength: 150 把enable改为对应的false改为true，length就是预览显示的文字长度，你可以根据你的需要进行更改，然后重新部署，再进主页，你就发现你首页的文章多了一个阅读全文的按钮。 添加动态背景先上张图 打开生成的Hexo目录\themes\next/layout/_layout.swig文件，在 &lt; head&gt;中的添加代码 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，搜索canvas_nest，将其改成true 1canvas_nest: true 什么？线条太多了？没事，来看看怎么让线条变少点 在上一步修改的主题配置文件中，把刚才的那些代码改成下面这样： 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% e 配置项说明 color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 分类和标签设置这里主要说的是在编写文章的时候，怎么给文章设置标签和分类。 首先通过hexo n &quot;name&quot;命令来新建一个页面，在source/_posts目录下找到刚才新建的name.md文件，用Typora或者notepad++t打开(推荐Typora) 1234title: namedate: 2014-08-05 11:15:00 tags: --- 页面默认就是长这样的，可以编辑标题、日期、标签和内容，但是没有分类的选项。我们可以手动加入categories:项,但是下次创建新的页面的时候还是没有，所以我们直接打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，重新执行hexo n ‘name’命令，会发现新建的页面里有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 设置分类列表在我们编辑文章的时候，直接在categories:项填写属于哪个分类，但如果分类是中文的时候，路径也会包含中文。 比如分类我们设置的是： 1categories: 开车 那在生成页面后，分类列表就会出现开车这个选项，他的访问路径是： 1*/categories/开车 我们都知道，有时候中文路径可能会出现一些奇奇怪怪的问题，所以我们需要路径名和分类名分别设置。 打开站点配置文件_config.yml，找到如下位置做更改： 1234567# Category &amp; Tagdefault_category: uncategorizedcategory_map: 开车: drive 生活: life 其他: othertag_map: 在这里category_map:是设置分类的地方，每行一个分类，冒号前面是分类名称，后面是访问路径。可以提前在这里设置好一些分类，当编辑的文章填写了对应的分类名时，就会自动的按照对应的路径来访问。 设置标签在编辑文章的时候，tags:后面是设置标签的地方，如果有多个标签的话，可以用下面两种办法来设置： 第一种： 1tages: [标签1,标签2,...标签n] 第二种： 12345 tages: - 标签1- 标签2...- 标签n 添加文章更新时间修改（博客主目录）/themes/next/layout/_macro/post.swig 文件，在&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;标签后添加 12345678&#123;%if post.updated and post.updated &gt; post.date%&#125; &lt;span class=&quot;post-updated&quot;&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123; __(&apos;post.updated&apos;) &#125;&#125; &lt;time itemprop=&quot;dateUpdated&quot; datetime=&quot;&#123;&#123; moment(post.updated).format() &#125;&#125;&quot; content=&quot;&#123;&#123; date(post.updated, config.date_format) &#125;&#125;&quot;&gt; &#123;&#123; date(post.updated, config.date_format) &#125;&#125; &lt;/time&gt; &lt;/span&gt;&#123;% endif %&#125; 根据博客配置文件中的 language 参数修改对应的语言配置文件（博客主目录）/themes/next/languages/zh_Hans.yml 12post: updated: 更新于 修改主题配置文件（博客主目录）/themes/next/_config.yml，增加一行 1display_updated: true 或者写文章的时候可以直接在文章开头设置更新时间，没有这参数的话将会显示md文件的修改日期 1updated: 2018-01-01 12:00:00 添加搜索功能 安装 hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 打开 站点配置文件 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 添加阅读全文按钮因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加 1&lt;!--more--&gt; 其后面的部分就不会显示了，只能点击阅读全文才能看 修改文章内链接文本样式 打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加 12345678910.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 设置网站缩略图标从网上看了很多设置方法都是说把favicon.ico放到站点目录的source目录下就可以了，可是我试了好多遍，并不行 我的设置方法是这样的：把你的图片（png或jpg格式，不是favicon.ico）放在themes/next/source/images里，然后打开 主题配置文件 找到favicon，将small、medium、apple_touch_icon三个字段的值都设置成/images/图片名.jpg就可以了，其他字段都注释掉。 设置文章字体的颜色、大小 如果想设置某一句的颜色或大小，只需用html语法写出来就行了 1234接下来就是见证奇迹的时刻&lt;font color="#FF0000"&gt; 我可以设置这一句的颜色哈哈 &lt;/font&gt; &lt;font size=6&gt; 我还可以设置这一句的大小嘻嘻 &lt;/font&gt; &lt;font size=5 color="#FF0000"&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;/font&gt; 设置文字居中1&lt;center&gt;这一行需要居中&lt;/center&gt; 添加评论系统目前国内比较有名的多说、网易云跟帖评论系统都已停止服务了，国外的Disqus评论系统还得需要翻墙，所以不推荐使用，剩下的还有搜狐畅言、友言、来必力等。本来想使用畅言的，结果注册完之后还得要求备案，我只想说F开头的那个单词，果断放弃。后来选择了友言 1、进入友言官网注册、登录步骤我就不介绍了2、登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的uid=12345673、打开 主题配置文件 找到youyan_uid将值设置为上面的uid就可以了 添加站点访问计数站点访问计数有名的就是不蒜子，使用起来非常方便1、安装脚本打开 themes/next/layout/_partial/footer.swig，将下面这段代码添加到里面 12345678910&lt;div&gt;&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot; style=&apos;display:none&apos;&gt; 本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次 &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot; style=&apos;display:none&apos;&gt; 有&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人看过我的博客啦&lt;/span&gt;&lt;/div&gt; 添加的位置如下图，可自行根据个人喜好更换位置 以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 themes/next/layout/_macro/post.swig，在第一行增加is_pv字段 1&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125; 然后将这段代码插入到里面 1234&#123;% if is_pv %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&#123;% endif %&#125; 插入的位置 然后再打开 themes/next/layout/post.swig，这个文件是文章的模板，给render方法传入参数（对应刚才添加的is_pv字段） 最后再打开 themes/next/layout/index.swig，这个文件是首页的模板，给render方法传入参数（对应刚才添加的is_pv字段） OK！设置完毕 去掉文章目录标题的自动编号我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？打开主题配置文件，找到 123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 将number改为false即可 自定义样式 引用需加入custom.styl的代码 文件位置：~/blog/themes/next/source/css/_custom/custom.styl 123456789// 自定义的引用样式blockquote.question &#123; color: #555; border-left: 4px solid rgb(16, 152, 173); background-color: rgb(227, 242, 253); border-top-right-radius: 3px; border-bottom-right-radius: 3px; margin-bottom: 20px;&#125; 文字颜色改color的值 背景色改background-color的值 边框颜色和粗细改border-left的值 效果： 内容 使用方法： 1内容 修改hexo的主题nexT中的Pisces主题宽度在source/css/_schemes/Picses/_layout.styl文件末尾添加如下代码 12345678910111213141516171819202122232425262728293031323334// 以下为新增代码！！header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125; 更多主题和插件还有其他更多的主题配置，请查看主题配置 还有其他更多的插件，请查看Hexo插件]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2Fblog%2F2018%2F02%2F14%2FSpringBoot.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2Fblog%2F2018%2F02%2F13%2FSpring.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro]]></title>
    <url>%2Fblog%2F2018%2F02%2F12%2FShiro.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Verification</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2Fblog%2F2018%2F02%2F11%2FServlet.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reids]]></title>
    <url>%2Fblog%2F2018%2F02%2F10%2FRedis.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Reids</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2Fblog%2F2018%2F02%2F09%2FMyBatis.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mockito]]></title>
    <url>%2Fblog%2F2018%2F02%2F08%2Fmockito.all%2F</url>
    <content type="text"><![CDATA[maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; &lt;version&gt;2.25.1&lt;/version&gt;&lt;/dependency&gt; 静态导入工具包，方便使用1import static org.mockito.Mockito.*; Stub(桩/存根)桩：用来替换一部分功能的程序段。桩程序可以用来模拟已有程序的行为（比如一个远端机器的过程）或是对将要开发的代码的一种临时替代 如1234567# 建立一个LinkedList类型的mock对线 LinkedList mockedList = mock(LinkedList.class);# 存根 when(mockedList.get(0)).thenReturn("first");# 存根后，当执行mockedList.get(0)方法时，就返回定义的值 System.out.println(mockedList.get(0)); Mock对象的创建方式一：利用Class文件进行Mock创建1mock(SomeClass.class); 方式二：使用注解12345678//首先需要调用初始化方法，将测试类作为参数传入@Beforepublic void init()&#123; MockitoAnnotations.initMocks(this);&#125;//需要模拟化的类上使用@Mock注解@MockLinkedList mockedList; 论证参数匹配Mockito提供的匹配类: ArgumentMatchers123456789101112LinkedList mockedList = mock(LinkedList.class); // anyInt():ArgumentMatchers中的方法，表示参数可以是任何整数 when(mockedList.get(anyInt())).thenReturn("element"); System.out.println(mockedList.get(999)); //isValid(): 用户自定义的匹配方法，返回自定义的匹配器实现 //使用用户自定义的参数匹配方式 when(mockedList.contains(argThat(isValid()))).thenReturn("element"); //可以使用lambd表达式 //验证如何长度大于5的字符串 verify(mockedList).add(argThat(someString -&gt; someString.length() &gt; 5)); 需要注意的是，如果使用了参数匹配器，则所有参数都必须使用匹配器123456//正确，anyInt(), anyString(), eq()都是匹配器 verify(mock).someMethod(anyInt(), anyString(), eq("third argument")); //above is correct - eq() is also an argument matcher//错误，"third argument"并不是匹配器 verify(mock).someMethod(anyInt(), anyString(), "third argument"); 验证调用次数 123456789101112131415161718192021222324252627LinkedList mockedList = mock(LinkedList.class);//using mockmockedList.add("once");mockedList.add("twice");mockedList.add("twice");mockedList.add("three times");mockedList.add("three times");mockedList.add("three times");//默认验证一次，如下代码效果相同verify(mockedList).add("once");verify(mockedList, times(1)).add("once");//验证多次verify(mockedList, times(2)).add("twice");verify(mockedList, times(3)).add("three times");//验证从没执行过的verify(mockedList, never()).add("never happened");//验证至多/至少_次verify(mockedList, atLeastOnce()).add("three times");verify(mockedList, atLeast(2)).add("three times");verify(mockedList, atMost(5)).add("three times"); 按顺序验证验证一：单个Mock1234567891011List singleMock = mock(List.class);singleMock.add("was added first");singleMock.add("was added second");//为mock对线创建InOrderInOrder inOrder = inOrder(singleMock);//验证执行顺序，以下两个方法顺序互换，则报错inOrder.verify(singleMock).add("was added first");inOrder.verify(singleMock).add("was added second"); 验证二：多个Mock1234567891011121314//创建对各Mock对线List secondMock = mock(List.class);List firstMock = mock(List.class);firstMock.add("was called first");secondMock.add("was called second");////为多个Mock对线创建InOrderInOrder inOrder = inOrder(firstMock, secondMock);//将确保在secondMock.add之前调用firstMock.addinOrder.verify(firstMock).add("was called first");inOrder.verify(secondMock).add("was called second"); 查找冗余的调用个人理解：verifyNoMoreInteractions用于验证Mock方法调用后是否有验证，而如果只调用了方法啊，但没有验证的话，表明这个方法还处于交互状态。123456789//using mocksmockedList.add("one");mockedList.add("two");verify(mockedList).add("one");//following verification will fail// 下面的验证将会失败,mockedList.add("two");还处于交互状态verifyNoMoreInteractions(mockedList); 确保在模拟上从未发生过互动verifyZeroInteractions就是调用了verifyNoMoreInteractions方法，只是语义不同而已123456789//using mocks - only mockOne is interactedmockOne.add("one");//ordinary verificationverify(mockOne).add("one");//verify that other mocks were not interactedverifyZeroInteractions(mockTwo, mockThree); 连续调用（迭代器式存根）123456789101112131415LinkedList mockedList = mock(LinkedList.class);when(mockedList.add("some arg"))， .thenReturn(false)//thenReturn的返回类型与add返回类型相同 .thenReturn(true) .thenReturn(true);//第一次调用 输出falseSystem.out.println(mockedList.add("some arg"));//第二次调用 输出trueSystem.out.println(mockedList.add("some arg"));//第三次调用 输出true，如果接下来还有嗲用，继续执行最后一个存根System.out.println(mockedList.add("some arg")); 此外，还可以简写12when(mockedList.add(&quot;some arg&quot;)) .thenReturn(false, true, false); thenReturn() 使用具有相同匹配器或参数的多个存根而不是链接调用，则每个存根将覆盖前一个存根 使用回调函数进行存根使用thenReturn()或thenThrow()基本可以满足测试需求，但还可以通过通用的Answer接口来实现复杂的存根1234567891011when(mock.someMethod(anyString())).thenAnswer( new Answer() &#123; public Object answer(InvocationOnMock invocation) &#123; Object[] args = invocation.getArguments(); Object mock = invocation.getMock(); return "called with arguments: " + Arrays.toString(args); &#125;&#125;);//Following prints "called with arguments: [foo]"System.out.println(mock.someMethod("foo")); doReturn()| doThrow()| doAnswer()| doNothing()| doCallRealMethod()一系列方法 在存根为void时使用,如下使用异常对void方法进行存根 123456LinkedList mockedList = mock(LinkedList.class);//doXxxx().when().someMethod()doThrow(new RuntimeException()).when(mockedList).clear();//将会 throws RuntimeException:mockedList.clear(); 监视实例对象可以创建创建实例对象的Spy,当你使用Spy时，会调用真正的方法;但spy并不会将调用委托给实例对象，而是创建了它的副本。 12345678910111213141516171819202122//创建实例List list = new LinkedList();//创建实例的spyList spy = spy(list);//存根when(spy.size()).thenReturn(100);//使用spy来使用真正的add()方法spy.add("one");spy.add("two");//prints "one"System.out.println(spy.get(0));//size()输出存根：100//如果不size()方法没有存根，就会调用实例对象的方法System.out.println(spy.size());//spy也可以验证verify(spy).add("one");verify(spy).add("two"); 使用Spy 应该考虑与doXxxx联合使用12345678List list = new LinkedList();List spy = spy(list);//错误，spy.get(0)抛出IndexOutOfBoundsExceptionwhen(spy.get(0)).thenReturn("foo");//必须使用doXxxx进行存根doReturn("foo").when(spy).get(0); 真正的部分模拟(1.8)设置未存根方法的默认返回值(1.7)123Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); 捕获断言的参数(1.8)]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Mockito</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2Fblog%2F2018%2F02%2F07%2Fmaven.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL深入]]></title>
    <url>%2Fblog%2F2018%2F02%2F06%2Fmysql.deep.all%2F</url>
    <content type="text"><![CDATA[基础架构》 MySQL基础架构示意图，MySQL分为Server层和存储引擎层两部分 》 Server层： 包括连接器、查询缓存、分析器、优化器、执行器等，蕴含MySQL大量核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等 多个存储引擎共用一个Server层 》 存储引擎层： 负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。 现在最常用的存储引擎是InnoDB,从MySQL5.5开始变为默认存储引擎 连接器》 负责跟客户端建立连接，获取权限、维持和管理连接。 》 一般的连接命令： 1mysql -h$ip -P$port -u$user -p 》 连接命令中的mysql是客户端工具，用来跟服务器连接。在完成经典的 TCP 握手后，连接器开始认证身份，然后输入密码 用户名或密码不对， “Access denied for user”的错误，然后客户端程序结束执行 认证通过，连接器从权限表查询出用户的权限。之后这个连接里的权限判断逻辑，都依赖于此时读到的权限(也就意味着建立连接后用户的权限被修改也不会影响当前连接，除非建立新的连接才会生效改动) 》 连接之后，可以用以下命令查看连接状态 1show processlist 》 Command显示 Sleep 这一列，表示当前用户处于空闲状态 》 对于空闲状态，客户端如果长时间没有动作，连接器是会自动断开它的，默认为8h，由 wait_timeout 参数控制 断开之后再发请求，会受到错误提示:”Lost connection to MySQL server during query”,此时需要重新连接了 数据库连接: 长连接：如果客户端持续有请求，则一直使用同一个连接 短链接：每次执行完很少的查询就断开连接，下次查询再重新建立连接 》 建立连接过程复杂，所以尽量使用长连接 缺点：有时候MySQL占用内存涨得特别快 原因：MySQL在执行过程中临时使用的内存管理在连接对象里面。这些资源会在断开连接时才释放。所以长连接累积下来，会导致内存占用过大，被系统强制杀掉（OOM），从现象看是MySQL异常重启 》 解决长连接内存占用过大问题 定期断开长连接，使用一段时间或程序里面执行过一个占用内存过大的查询后 MySQL5.7及以上的版本，可以在每次执行一个比较大的操作后，通过 mysql_reset_connection来重新初始化连接资源（不需要重复验证，但连接会恢复成最初状态） 查询缓存》 MySQL可能会将执行过的查询语句和结果，会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果执行的查询语句能够直接在这个缓存中找到key，如果能命中缓存，那么这个value就会被直接返回给客户端，这样效率会高很多 》 并不推荐使用！！！原因如下 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空 将参数query_cache_type设置成DEMAND关闭 MySQL8.0删除 分析器》 没有命中缓存，分析器会如下运作 先做“词法分析”，如从 SELECT 识别出这是一个查询语句，从t_table识别成表名t_table,把id识别成列id 再做”语法分析”,语法分析器会检查你的SQL语句是否满足MySQL语法,如果语法出错，会提示”You have an error in your SQL syntax” 优化器》 经过分析器之后，MySQL已经知道需要做什么，但在执行之前，需要优化。 》 优化器是在表里面有多个索引的时候，决定使用那个索引。或者在一个语句有多表关联（join）的时候，决定各个表达的连接顺序。 》 如下代码 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。 两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案 1mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 执行器》 执行器首先会判断是否有相应的权限，无则返回错误提示。 》 有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口，如下代码 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 1mysql&gt; select * from T where ID=10; 》 在慢查询日志中可以看到一个 rows_examined 字段，表示这个语句执行过程中扫面了多少行（也有可能不完全相同） 更新语句执行流程》 流程： 首先，在执行语句前要先连接数据库，即连接器的工作； 一旦在一个表上有更新，那么整个表相关的查询语句都会被清空（一般不建议使用查询缓存的原因） 分析器会通过词法和语法解析知道这是一条更新语句 优化器决定使用ID这个索引 执行器负责具体执行，找到这一行，然后更新 》 与查询不同之处，更新流程还涉及两个重要的日志模块 redo log（重做日志） binlog（归档日志） redo log(InnoDB特有)》 在MySQL里存在一个问题：如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。 》 MySQL为了解决这个问题，使用了WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘.具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存;同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。 》 InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写 》 write pos:当前记录的位置，一边写一边后移，到末尾后返回0位置;checkpoint:当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件;它们之间的距离代表着redo log剩余空间，如果没checkpoint和write pos没有距离，说明redo log已满，则需要擦除一些记录（即cehckpoint右移） 》 有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。也就是说当故障发生时，MySQL可以通过redo log记录的数据修改信息结合磁盘上的数据，来保证数据没有丢失。 》 参数设置 》 》 innodb_flush_log_at_trx_commit: 这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。建议设置成1，这样可以保证MySQL异常重启之后数据不丢失。 binlog》 与redo log日志的不同点 redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。 redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。 redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 binlog主要用于备份，而redo log主要用于崩溃恢复 》 Binlog有两种模式，statement模式的话是记sql语句， row模式会记录行的内容（两条，更新前和更新后） 》 参数设置 》》 sync_binlog:这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。建议设置成1，这样可以保证MySQL异常重启之后binlog不丢失。 InnoDB引擎update语句时的内部流程》 建表语句 1mysql&gt; create table T(ID int primary key, c int); 》更新语句,C+1 1mysql&gt; update T set c=c+1 where ID=2; 》流程： 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。 执行器生成这个操作的binlog，并把binlog写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。 》 流程图如下： 》 两阶段提交：redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。 为什么要两阶段提交》 以让数据库恢复到半个月内任意一秒的状态为例，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果数据库半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog,同时系统会定期做整库备份 》 当需要恢复到指定的某一秒时 首先，找到最近的一次全量备份进行恢复 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。 》 如果不用两阶段提交会怎么样? 先写redo log后写binlog:假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。 先写binlog后写redo log:如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。 以上两种情况在系统异常后，都无法保证库值的一致性 》 利用了两阶段提交后 redo log记录的日志，即使异常重启，也会刷新到磁盘 而bin log主要用于记录 当redo log 处于prepare,而bin log写入失败，事务就会回滚 而redo log 处于commit状态，即使发生异常，也会刷新到磁盘中 事务隔离》 SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ） 》 实例代码 12mysql&gt; create table T(c int) engine=InnoDB;insert into T(c) values(1); 》 在不同事务下，V1、V2、V3的返回值分别是 若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。 若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。 》 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。 在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的 读未提交”隔离级别下直接返回记录上的最新值，没有视图概念； “串行化”隔离级别下直接用加锁的方式来避免并行访问。 》 如果是Oracle数据库迁移到MySQL,因为Oracle默认隔离级别其实就是“读提交”,所以需要修改MySQL（将启动参数transaction-isolation的值设置成READ-COMMITTED） 》 查看当前事务隔离级别 1show variables like &apos;transaction_isolation&apos;; 事务隔离的实现》 在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。 》 如图所示，以下是”可重复读“的回滚日志，假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。 》 不同时刻启动的事务会有不同的read-view。如图中看到的，当前值是4，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC），对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到 》 当没有事务再需要用到这些回滚日志时，回滚日志会被删除。也就是说，当系统里没有比这个回滚日志更早的read-view的时候，回滚日志会被删除 》 尽量不要使用长事务 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间 在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小 事务的启动方式》 MySQL的事务启动方式有以下几种 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback set autocommit=0，这个命令会将这个线程的自动提交关掉。当执行一个SQL语句，就会启动事务，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接(如果是长连接，就会导致长事务！！) 》 所以，建议使用set autocommit=1，显示启动事务;通过以下方式提交，可以在提交之后，开启一个新的事务 1COMMIT WORK AND CHAIN; 》 此外，可以在information_schema库的innodb_trx这个表中查询长事务 12#查找持续时间超过60s的事务select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60 》 注意：》》 begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句（第一个快照读语句），事务才真正启动；如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot 这个命令 索引索引的常见模型》 三种常见索引数据结构 哈希表:适用于只有等值查询的场景,比如Memcached及其他一些NoSQL引擎 有序数组:只适用于静态存储引擎，比如要保存的是2017年某个城市的所有人口信息,这类不会再修改的数据 搜索树 InnoDB 的索引模型》 在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。每一个索引在InnoDB里面对应一棵B+树。 123456# 主键列为ID的表，表中有字段k，并且在k上有索引mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine=InnoDB; 》 表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下 》 从图中可以看出，索引类型分为两类 主键索引:主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index） 非主键索引:非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index） 》 基于主键索引和普通索引的查询的区别 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树； 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表 非主键索引的查询需要多扫描一棵索引树，所以尽量使用组件索引 索引维护》 B+树为了维护索引有序性，在插入新值的时候需要做必要的维护 》 主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小，从性能和存储空间方面考量，自增主键往往是更合理的选择 回表有如下初始化数据库语句： 12345678create table T (ID int primary key,k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT &apos;&apos;,index k(k))engine=InnoDB;insert into T values(100,1, &apos;aa&apos;),(200,2,&apos;bb&apos;),(300,3,&apos;cc&apos;),(500,5,&apos;ee&apos;),(600,6,&apos;ff&apos;),(700,7,&apos;gg&apos;); 》 执行如下查询语句 1select * from T where k between 3 and 5 》 它的执行流程如下 在k索引树上找到k=3的记录，取得 ID = 300； 再到ID索引树查到ID=300对应的R3； 在k索引树取下一个值k=5，取得ID=500； 再回到ID索引树查到ID=500对应的R4； 在k索引树取下一个值k=6，不满足条件，循环结束。 》 回到主键索引树搜索的过程，称为回表,可以看出上述查询回表了两次(2和4) 》 如何通过索引优化，避免回表？ 覆盖索引 最左前缀原则 覆盖索引》 如果将执行语句改为 1select ID from T where k between 3 an 》 这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表;在这个查询里面，索引k已经“覆盖了”我们的查询需求，称为覆盖索引 》 问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？ 12345678910CREATE TABLE `tuser` ( `id` int(11) NOT NULL, `id_card` varchar(32) DEFAULT NULL, `name` varchar(32) DEFAULT NULL, `age` int(11) DEFAULT NULL, `ismale` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`), KEY `id_card` (`id_card`), KEY `name_age` (`name`,`age`)) ENGINE=InnoDB 》 身份证号是市民的唯一标识,根据身份证号查询市民信息的需求，只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引,有以下好处 如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间 (注意：索引字段的维护总是有代价,，在建立冗余索引来支持覆盖索引时需要权衡考虑) 最左前缀原则》 如果为每一种查询都设计一个索引，索引将会过多 》 继续以市民表为例，当需求变为根据身份证号查询家庭地址（业务出现概率不频繁），普通做法有 直接走全表扫描(没有索引，慢) 单独为一个不频繁的请求创建一个（身份证号，地址）的索引（有索引，但索引会越来越多） 》 以上两种做法都太过于浪费，但B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录;最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符 》 如，使用（name，age）这个联合索引,可以看到，索引项是按照索引定义里面出现的字段顺序排序的 》 那么，想要查的是所有名字第一个字是“张”的人，SQL语句的条件是”where name like ‘张%’，这样做的好处就是 没有为name建立索引(减少了一个索引) 但是通过(name, age)索引加快了查询 所以我们在建立联合索引的时候,如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的 》 在回到根据身份证号查询家庭地址,业务上用的多的是(身份证，姓名)这个联合索引，完全可以通过使用“最左前缀”，加快查询 索引下推》 以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩” 1mysql&gt; select * from tuser where name like &apos;张%&apos; and age=10 and ismale=1; 》 没有索引下推优化前 从ID3开始一个个进行回表(InnoDB并不会去看age的值,只是按顺序把“name第一个字是’张’”的记录一条条取出来回表) 到主键索引上找出数据行 再对比字段值(age是否等于10，ismale) 》 在MySQL 5.6 引入的索引下推优化后 InnoDB在(name,age)索引内部就判断了age是否等于10,对于不等于10的记录，直接判断并跳过 等于10的值再回表 到主键索引上找出数据行 再对比字段值(ismale) 索引选择》 以市民系统为例，如果利用身份证做索引，但由于身份证号字段比较大，并不建议把身份证号当做主键，那么只能 创建唯一索引 创建普通索引 》 从性能的角度考虑，哪个更高？ 查询过程》 以上图为例，执行 1select id from T where k=5 》 搜索步骤 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索 》 InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB（linux内存页大小为4k） 》 因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。 》 如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。但是，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。 》 结论：两种索引对查询过程带来的性能差距不大 更新过程》 先了解什么是change buffer 当更新数据时，如果数据页在内存中就直接更新 如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，不执行从磁盘中读入这个数据页。在下次查询需要访问这个数据页的时候，将数据页读入内存，执行change buffer中操作 将change buffer中的操作应用到原数据页，得到最新结果的过程称为mergea. 访问数据页会触发merge(即2中的方式) b. 系统有后台线程会定期merge c. 在数据库正常关闭（shutdown）的过程中，也会执行merge操作 change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置（如50，表示change buffer的大小最多只能占用buffer pool的50%） 》 利用change buffer的好处 将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升 数据读入内存是需要占用buffer poo,这种方式还能够避免占用内存，提高内存利用率 》 唯一索引的更新就不能使用change buffer 所有的更新操作都要先判断这个操作是否违反唯一性约束(如要插入(4,400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断)，既然读入了内存，自然不需要change buffer 》 性能对比，对于数据页已经在内存中读入的，仅仅只是多了步判断，差别不大 对于唯一索引来说，找到3和5之间的位置，判断到没有冲突, 插入这个值，语句执行结束； 对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束 》 如果数据页没有在内存中读入 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束； 对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了 》 很明显，普通索引利用change buffer减少了随机磁盘访问，对更新性能的提升明显 》 结论：更新过程利用普通索引性能更好 正确的选择》 一般情况下，对于查询，无论时普通索引和唯一索引性能几乎无差，但对于更新操作，需要考虑如下 一般情况下，尽量选择普通索引 如果所有的更新后面，都马上伴随着对这个记录的查询,应该关闭change buffer change buffer 和 redo log》 关于redo log和WAL，请看SQL更新语句执行过程章节 》 WAL和change buffer提升性能的核心机制，也的确是尽量减少随机读写，概念容易混淆 》 执行如下语句,假设k1数据页在内存中，而K2数据页不在内存中 1mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2); 》 从图中可以看，该语句分为四个部分:内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1） 》 更新语句主要执行了以下操作 Page 1在内存中，直接更新内存； Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息 将上述两个动作记入redo log中（图中3和4） 》 该操作一共执行了两次内存写入（1、2），一次磁盘写入（3） ，且图中的两个虚线箭头，是后台操作，不影响更新的响应时间 》 之后，执行一次查询请求 1select * from t where k in (k1, k2) 》 如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关 》 如下图所示 读Page 1的时候，直接从内存返回 要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果，此时这个数据页才会被读入内存 》 两者区别在于: redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写） change buffer主要节省的则是随机读磁盘的IO消耗 索引错选》 在MySQL中一张表其实是可以支持多个索引的,但具体使用哪个索引，并不是使用者来指定，而是通过优化器的来选择的 索引错选示例》 建表语句: 12345678CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `b` (`b`)) ENGINE=InnoDB； 》 往表t插入10万行记录从(1,1,1)到(100000,100000,100000) 123456789101112delimiter ;;create procedure idata()begin declare i int; set i=1; while(i&lt;=100000)do insert into t values(i, i, i); set i=i+1; end while;end;;delimiter ;call idata(); 》 通过以下语句查看,使用的是a索引 1explain select * from t where a between 10000 and 20000; 》 接下来，如下图所示执行 Session A:开启事务 Session B:删除数据，调用存储过程重新插入10W行数据 1234567891011# Time: 2019-04-08T08:02:08.692765Z# User@Host: root[root] @ localhost [] Id: 4# Query_time: 0.009771 Lock_time: 0.000132 Rows_sent: 10001 Rows_examined: 10001SET timestamp=1554710528;select * from t where a between 10000 and 20000;# Time: 2019-04-08T08:02:14.660639Z# User@Host: root[root] @ localhost [] Id: 4# Query_time: 0.009404 Lock_time: 0.000126 Rows_sent: 10001 Rows_examined: 10001SET timestamp=1554710534;select * from t force index(a) where a between 10000 and 20000;​``` --&gt; MySQL中的锁》 根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类 全局锁》 全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 12#让整个库处于只读状态（FTWRL）Flush tables with read lock 》 使用该a命令后，以下语句被阻塞:数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句 》 全局锁的典型使用场景是，做全库逻辑备份; 》 但是让库只读，有以下弊端 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆； 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟 》 官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的(可重复读隔离级别可以获取一致性视图) 》 有了single-transaction，为什么还要FTWRL? 并不是所有的引擎都支持事务，如MyISAM，备份就需要FTWRL方法了。 》 另一种让全库进入只读状态的方法 1set global readonly=true 》 但是推荐使用FTWRL，原因： 在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大 在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。 》 事务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都是会被锁住的 表级锁》 MySQL里面表级别的锁有两种： 表锁 元数据锁（meta data lock，MDL) 表锁》 语法 1234# 加锁 lock tables &lt;table-name&gt; read/write[,&lt;table-name&gt; read/write]# 释放锁,断开连接时也会自动释放 unlock tables 》 注意：lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象,如在线程A中执行以下语句 其他线程写t1、读写t2的语句都会被阻塞 线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作 1lock tables t1 read, t2 write; MDL锁》 MDL(MySQL 5.5版本引入)不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。当对一个表做增删改查（DML）操作的时候，加MDL读锁；当要对表做结构变更操作(DDL)的时候，加MDL写锁 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行 》 给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据，如果对表进行操作不慎，会出现问题 》 如上图所示 Seesion A 启动，表会自动加上MDL读锁 Seesion B启动，需要的也是MDL读锁，正常执行 Session C启动，需要写锁，因为MDL读锁未释放，阻塞 （关键）Session D启动，因为Session C阻塞后会对之后对锁的请求进行阻塞，所以Session D也被阻塞(客户端有重试机制，超时后会再起一个新session再请求的话，这个库的线程很快就会爆满) 》 那么如何安全的执行DDL? 解决长事务：在DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务 设定等待时间：在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句(MariaDB/AliSQL 已经支持 NOWAIT/WAIT 语法) 123# 遗憾的是MySQL不支持ALTER TABLE &lt;tbl_name&gt; NOWAIT add column ...ALTER TABLE &lt;tbl_name&gt; WAIT N add column ... 行锁》 MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁.MyISAM引擎就不支持行锁,InnoDB是支持行锁;行锁就是针对数据表中行记录的锁 两阶段锁》 如下图所示，事务B的update语句会被阻塞(如果是MyISAM,不会阻塞，原因是只有表锁，DML语句都获取MDL读锁),这也说明了，事务A持有的两个记录的行锁 》 在InnoDB事务中，行锁是在需要的时候才加上的，而是要等到事务结束时才释放。这个就是两阶段锁协议。此外，行锁锁的是索引。 》 如何优化行锁？以电影票在线交易业务为例， 从顾客A账户余额中扣除电影票价； 顾客C要在影院B买票 给影院B的账户余额增加这张电影票价； 记录一条交易日志。 》 顾客A和C事务冲突，他们同时更新影院账户的余额，需要修改同一行数据。如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度;所以，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放 死锁和死锁检测》 如图所示 事务A等待事务B释放id=2的行锁 事务B等待事务A释放id=1的行锁 两者均处于等待对方的资源释放，就是进入了死锁状态 》 解决思索的策略 通过参数innodb_lock_wait_timeout来设置超时时间(默认50s) 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on（默认on），表示开启这个逻辑 》 对于第一种方案，时间设置过长显然不行，而时间设置过短，如果只是简单的等待而不是死锁，因此退出事务，那么就会误伤了 》 所以，正常情况下我们还是要采用第二种策略,但死锁检测存在一个问题，那就是要耗费大量的CPU资源 每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务 》 解决办法 如果能确保不发生死锁，可以临时关闭死锁检测（不推荐） 控制并发度，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低 》 对于控制并发度，一种是在客户端做并发控制，如每个客户端限制5个并发线程，但如果客户端数量过多，就不太行了。另一种是使用中间件，对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了；还有一种方法是将一条更新记录拆分成逻辑上的多行来减少锁冲突，但业务复杂度可能会大大提高 RR与行锁，隔离还是不隔离》对于RR隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样 》对于行锁，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，会被锁住，进入等待状态 》那么，如果事务进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么？ 》在MySQL里，有两个“视图”的概念： 一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。 另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。 快照在MVCC里是怎么工作的》 在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。（注意，这个快照是基于整库的） 在事务开始时，会向InnoDB事务系统申请一个唯一的事务ID，transaction id，该id按申请顺序严格递增 当每个事务更新数据时，会生成新的一个数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id 更新语句同时会生成undo log（回滚日志），用于获取到旧的数据 》 如下图是一行数据被多个事务连续更新后的状态（commit之后） 》 如图当前版本最新是V4，而V1,V2,V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的 》 那么，InnoDB是怎么定义那个“100G”的快照的？ InnoDB为每个事务构造了一个数组，用来保存所有启动了但还没提交的事务ID 组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位 》 那么，当启动一个事务时，一个数据版本的row trx_id,有以下几种情况 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；（低于低水位） 果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；（高于高水位） 如果落在黄色部分（数组部分），那就包括两种情况a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见 》 如何以后的更新，生成的版本肯定是在2或者3a条件下，即不可见 总结：对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况 版本未提交，不可见； 版本已提交，但是是在视图创建后提交的，不可见； 版本已提交，而且是在视图创建前提交的，可见。 实例解析1234567CREATE TABLE `t` ( `id` int(11) NOT NULL, `k` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;insert into t(id, k) values(1,1),(2,2); 》 如图所示结果为：事务B查到的k的值是3，而事务A查到的k的值是1（事务C没有begin/commit，表示这个update语句本身就是一个事务，语句完成的时候会自动提交；） 》 假设 事务A开始前，系统里面只有一个活跃事务ID是99； 事务A、B、C的版本号分别是100、101、102，且当前系统里只有这三个事务； 三个事务开始前，(1,1）这一行数据的row trx_id是90 》 可以看到 第一次更新操作由事务C完成，所以此时最新版本的row rex_id是102，90变为旧版本 第二次更新操作由事务B完成，此时最新版本的row rex_id是103 事务A开始读试图，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的a.找到(1,3)的时候，判断出row trx_id=101，比高水位大，处于红色区域，不可见； b.接着，找到上一个历史版本，一看row trx_id=102，比高水位大，处于红色区域，不可见； c.再往前找，终于找到了（1,1)，它的row trx_id=90，比低水位小，处于绿色区域，可见。 》 为什么事务B读出来的是(1,3)? 首先事务B创建试图肯定是先于事务C的 如果在更新之前执行一次查询语句，读出来的确是是(1,1) 但如果是更新操作，就会应用到一条规则：先读后写，而这个读，只能读当前的值，称为“当前读”（current read）a. 所以根据当前读的值，拿到的数据是(1,2),更新新版本后就是(1,3)了 SELECT 语句加锁实现当前读》 如果将A的查询语句加上lock in share mode 或 for update，也能读取版本号为101的数据 1234# 加了读锁（S锁，共享锁）select k from t where id=1 lock in share mode;# 加了写锁(写锁（X锁，排他锁）)select k from t where id=1 for update; 》 原理： 如果事务C更新语句且没有提交的话，那么必定会给该行添加了写锁 事务A添加读锁或者写锁，因为事务C而堵塞，直到事务C提交位置 以此事务B更新数据获取到行锁，如果事务C不提交的话，也会被堵塞 》 事务的可重复读的能力是怎么实现的？ 可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待 读提交》 读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图； 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图 事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻： (1,3)还没提交，属于情况1，不可见； (1,2)提交了，属于情况3，可见。]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2Fblog%2F2018%2F02%2F05%2Fmysql.all%2F</url>
    <content type="text"><![CDATA[命令行操作登录MySQL123mysql -u root -p //指定用户(-u)、密码登录(-p)、主机(-h,默认localhost)、端口(-P,3306)；mysql -u root -p -h myserver -P 9999 查看帮助文档12//例如查看指令**SELECT**help SELECT 退出操作123exit//或者quit 测试服务器》 查看mysql的一些基本信息： 1/usr/bin/mysqladmin -u root -p version 》 查看mysql的变量: 1/usr/bin/mysqladmin -u root -p variables 》 验证是否能关闭mysql: 1/usr/bin/mysqladmin -u root -p shutdown 》 再次启动Mysql: 1/usr/bin/mysqld_safe --user=mysql &amp; 》 查看数据库: 123/usr/bin/mysqlshow -u root -p//指定数据库则显示数据库中的表/usr/bin/mysqlshow -u root -p test 》 查看表中主句: 1/usr/bin/mysql -e "SELECT prod_name FROM products" -u root -p test 》 显示服务器状态： 1service mysql status 导入sql文件》 命令行模式： 12//（指定sql文件的完全路径）source [$&#123;path&#125;.*sql] 数据库相关操作创建数据库1CREATE DATABASE &lt;database-name&gt; [CHARACTER SET 字符集] 使用数据库1USE &lt;database-name&gt; 查看所有数据库1SHOW DATABASES; 显示创建数据库语句1SHOW CREATE DATABASE &lt;Databasee-name&gt; 删除数据库1DROP DATABASE &lt;database-name&gt; 查看正在使用的数据库1SELECT database() 表相关操作创建表12345678910CREATE TABLE &lt;table-name&gt; ( &lt;column-name&gt; 类型(长度) 约束, &lt;column-name&gt; 类型(长度) 约束);// 不存在则创建CREATE TABLE IF NOT EXISTS &lt;table-name&gt;( &lt;column-name&gt; 类型(长度) 约束, &lt;column-name&gt; 类型(长度) 约束) 》 约束 NULL或NOT NULL:在定义列时加入这两个关键字，表示允许NULL或不允许NULL,默认为NULL PRIMARY KEY (column1,column2 ): 定义主键/组合主键 AUTO_INCREMENT: 自动增量,每次执行INSERT，自动对该列增量，赋值下一个可用的值。可以在INSERT语句中插入指定值，只要是没有使用的，该值回代替自动生成的值。 DEFAULT &lt; value &gt;:指定默认值 查看当前数据库所有表:1SHOW TABLES; 显示创建表语句1SHOW CREATE TABLE &lt;table-name&gt; 查看表列(结构)1SHOW COLUMNS FROM &lt;table-name&gt; 查看表列另一种方式(效果一样)1DESCRIBE &lt;table-name&gt; 查看自动增量的值(该函数回获取最后一个AUTO_INCREATEMENT的值) 1SELECT last_insert_id() 修改表》 添加列 1ALTER TABLE &lt;table-name&gt; ADD &lt;column-name&gt; 类型(长度) 约束; 》 修改类类型、长度、约束 1ALTER TABLE &lt;table-name&gt; MODIFY &lt;column-name&gt; 类型(长度) 约束; 》 修改列名 1ALTER TABLE &lt;table-name&gt; CHANGE &lt;old-column-name&gt; &lt;new-column-name&gt; 类型(长度) 约束; 》 删除列 1ALTER TABLE &lt;table-name&gt; DROP &lt;column-name&gt; 》 修改表名 1RENAME TABLE &lt;old-table-name&gt; TO &lt;new-table-name&gt; 》 修改表的字符集 1ALTER TABLE &lt;table-name&gt; CHARACTER SET 字符集; 定义外键1234ALTER TABLE &lt;table-name&gt; ADD CONSTRAINT &lt;约束名称&gt; FOREIGN KEY(主表外键字段) REFERENCES 从表(从表主键) 》 示例： 123456789//外键属性//- fk_orderitems_orders：外键字段的名字//- FOREIGN KEY(order_num)：当前表的外键字段//- REFERENCES orders(order_num)：对应的表的字段(orders表的order_num字段)ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_ordersFOREIGN KEY(order_num) REFERENCES orders(order_num) 删除外键1ALTER TABLE DROP FOREIGN KEY 外键字段名 用户相关操作注意:日常开发不应使用root用户 获取所有账号列表,》 系统的 mysql 数据库存放了用户信息表 user 12USE mysql;SELECT user FORM user; 创建用户123CREATE USER 用户名 # 创建用户并指定密码CREATE USER 用户名 IDENTIFIED BY &apos;密码&apos; 重命名1RENAME USER 原名 TO 更改名 设置/更新密码1SET PASSWORD 》 示例1 ：设置指定用户密码， Password（） 函数加密 1SET PASSWORD FOR famel = Password(&apos;123456&apos;) 》 示例2 ：设置当前登录用户 1SET PASSWORD =Password(&apos;123456&apos;) 删除账号1DROP USER 用户名 》 查看用户权限(新用户没有任何权限，只能登录MySQL) 1SHOW GRANTS FOR 用户名 授权1GRANT 权限 ON 数据库.表 TO 用户 》 示例 123//赋予了 famle 用户关于数据库 crashcourse 下所有表的 SELECT 权限 GRANT SELECT ON crashcourse.* TO famel 授权多次,权限用 “,” 分隔 1GRANT SELECT, INSERT ON database.table TO famel; 删除权限1REVOKE 权限 ON 表 FROM 用户 》 GRENT 和 REVOKE 可以在几个层次上控制访问权限 整个服务器， GRANT ALL 和 REVOKE ALL 整个数据库, ON database.* 特定表, ON database.table 特定列 特定存储过程 可用权限 权 限 说 明 ALL 除GRANT OPTION外的所有权限 ALTER 使用ALTER TABLE ALTER ROUTINE 使用ALTER PROCEDURE CREATE 使用CREATE TABLE CREATE ROUTINE 使用CREATE PROCEDURE CREATE TEMPORARYTABLES 使用CREATE TEMPORARY TABLE CREATE USER 使用CREATE USER、DROP USER、RENAME USER和REVOKEALL PRIVILEGES CREATE VIEW 使用CREATE VIEW DELETE 使用DELETE DROP 使用DROP TABLE EXECUTE 使用CALL和存储过程 FILE 使用SELECT INTO OUTFILE和LOAD DATA INFILE GRANT OPTION 使用GRANT和REVOKE INDEX 使用CREATE INDEX和DROP INDEX INSERT 使用INSERT LOCK TABLES 使用LOCK TABLES PROCESS 使用SHOW FULL PROCESSLIST RELOAD 使用FLUSH REPLICATION CLIENT 服务器位置的访问 REPLICATION SLAVE 由复制从属使用 SELECT 使用SELECT SHOW DATABASES 使用SHOW DATABASES SHOW VIEW 使用SHOW CREATE VIEW SHUTDOWN 使用mysqladmin shutdown（用来关闭MySQL） SUPER 使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER和SET GLOBAL。还允许mysqladmin调试登录 UPDATE 使用UPDATE USAGE 无访问权限 SELECT查询语法》 通过DISTINCT关键字，将SELECT检索的结果，只返回不同值 123456SELECT [DISTINCT] &lt;column-name&gt;,&lt;column-name&gt;,... FROM &lt;table-name&gt; [WHERE 条件][GROUP BY][HAVING][ORDER BY][LIMIT] 查询原理》 单表查询原理 根据WHERE条件过滤表中的记录，形成中间表（用户不可见） 根据SELECT的选择列从中间表中选择相应的列进行返回最终结果 》 两表连接查询 对两表求积（笛卡儿积）并用ON条件和连接类型进行过滤形成中间表 根据WHERE条件过滤中间表记录 根据SELECT的选择列从中间表中选择相应的列进行返回最终结果 》 多表连接查询 先对第一个第二个表按照两表连接查询 查询结果和第三个表做连接，以此n+,知道所有表结束 最终形成一个中间表 根据WHERE条件过滤表中的记录，形成中间表（用户不可见） 根据SELECT的选择列从中间表中选择相应的列进行返回最终结果 别名查询123456//单列别名SELECT &lt;column-name&gt;,&lt;column-name&gt; AS &lt;alias-name&gt;,... FROM &lt;table-name&gt; //多列别名SELECT (&lt;column-name&gt;,&lt;column-name&gt;) AS &lt;alias-name&gt;,... FROM &lt;table-name&gt; //表别名SELECT &lt;column-name&gt;,&lt;column-name&gt; ,... FROM &lt;table-name&gt; AS &lt;alias-name&gt; 运算查询1SELECT &lt;column-name&gt;*10, &lt;column-name&gt;+20 AS &lt;alias-name&gt; ,... FROM &lt;table-name&gt; SELECT 子句SELECT 子句顺序 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在安祖计算聚焦时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 WHERE（位于ORDER BY之前）指定单个搜索条件12//WHERE 条件,条件由&lt;column-name&gt;、运算符、数据组成WHERE &lt;column-name&gt; 运算符 数据 WHERE 可用条件》 比较运算符： 运算符 描述 &gt;, &lt;, &lt;=, &gt;=, =, &lt;&gt; 大于、小于、小于等于、大于等于、等于，不等于 BETWEEN…AND 某区间的值（包含头尾） IN() 指定IN()中的特定值，如IN(100,200) LIKE ‘’ 模糊查询 IS NULL/IS NOT NULL 判空 》 逻辑运算符： 运算符 描述 AND 多条件同时成立 OR 多条件任一成立,优先级低于AND，可用()来提升优先级 NOT 否定其后的条,mysql仅支持对IN、BETWEEN、EXISTS句子取反 》 注： 字符串类型用单引号’’括起来 值与字符串类型比较时，字符串会转为值。系统采取截取方式，截取字符串前面的数值，如02asda那么就是02,而对于字母开头的,就直接转为0。 通配操作符LIKE》 % 通配符：匹配0、1或多个字符 12//找出所有以jet开头的数据WHERE prod_name LIKE 'jet%'; 》_ 通配符：匹配单个字符 12//将会匹配1 ton anvil,而不会匹配 .5 ton anvi WHERE prod_name LIKE '_ ton anvil' 》注: 尾空格会干扰通配符匹配。如anvil后多了一个或多个空格。”%anvil “将会不匹配到它，解决方法是在后面也加一个%. %anvil% 或使用函数去除。 %无法匹配NULL值，即”LIKE ‘%’”不会匹配到值NULL的行。 不要过度使用通配符，能使用其他操作符就使用其他操作符 通配符置于开始，搜索最慢（即尽量不要使用在开头） 正则表达式REGEXP》 MySQL用WHERE子句对正则表达式提供了支持,其用法与LIKE相似 进行OR匹配：使用 “|” 12//将匹配到包含1000或2000的行,两个以上则1000|2000|3000| WHERE prod_name REGEXP '1000|2000' 》 匹配几个字符之一,使用” [] “ 12//[123]表示匹配1或2或3，是[1|2|3]的缩写，[^123]将匹配除这几个字符外的任何数据。[]相当于一个字符集合。WHERE prod_name REGEXP '[123] ton' 》 匹配范围 12345[a-z][A-Z]：匹配字母 [0-9]: 匹配数字[a-z0-9]：组合使用 》匹配特殊字符,使用\ \ 123456如想要匹配点&quot;.“，则REGEXP &apos; \ \ . &apos;,也可以用来引用元字符，如 \ \ f：换页 \ \ n：换行 \ \ r：回车 \ \ t：制表 \ \ v：纵向制表 》 匹配字符类,即自定义的字符集称为字符类 1234567891011[:alnum:]：任意字符和字母（同[a-zA-Z0-9]） [:alpha:]：任意字符(同[a-zA-Z]) [:blank:]：空表和制表(同[\\t]) [:cntrl:]：ASCII控制符(ASCII 0到31和127) [:digit:]：任意数字（同[0-9]） [:graph:]：任意可打印字符，与[:print:]相同，但不包括空格 [:lower:]：任意小写字母(同[a-z]) [:print:]：任意可打印字符，与[:graph:]相同，且包括空格 [:punct:]：即不再[:alnum:]也不再[:cntrl:]中的任意字符 [:upper:]：任意大写字母（同[A-Z]） [:xdigit:]：任意十六进制数字(同[a-fA-F0-9]) 》 匹配多个实例，通过正则表达式重复元字符完成 1234567如[0-9][0-9][0-9][0-9]相当于[0-9]&#123;4&#125;相当于[:digit:]&#123;4&#125; &quot;*&quot;：0个或1个或多个 &quot;+&quot;：1个或多个，相当于&#123;1,&#125; &quot;?&quot;：0个或一个，相当于&#123;0,1&#125; &quot;&#123;n&#125;&quot;：n个 &quot;&#123;n,&#125;&quot;：n个或多于n个 &quot;&#123;n,m&#125;&quot;：n~m个 》 定位符，匹配特定位置的文本 12345如^[0-9\\.]，匹配以数字或小数点开始。(注意^的位置，如果是在集合里[^0-9\\.],则是否定该集合) &quot;^&quot;：文本的开始 &quot;$&quot;：文本的结尾 [[:&lt;:]]：词的开始 [[::]]：词的结尾 LIKE与RNGEXP的不同123456//匹配整个列的值，即要完全匹配LIKE &apos;1000&apos;//该值只要在列中出现，则匹配REGEXP &apos;1000&apos;//想要匹配整个列REGEXP &apos;^1000$&apos; GROUP BY(WHERE子句之后，ORDER BY之前)1GRPUP BY &lt;column-name&gt; 》 创建分组,通过GROUP BY将数据按vend_id分组后，COUNT（*）将会对分组后的数据分别计算一次。 123SELECT vend_id, COUNT(*) AS num_prodsFROM productsGOURP BY vend_id HAVING》 HAVING WHERE是过滤行，而HAVING是过滤分组 WHERE是在分组前过滤，而HAVING是在分组后过滤 HAVING支持所有WHERE操作符 12345//过滤分组,按cust_id分组，然后过滤出行数大于等于2组。SELECT cust_id, COUNT(*) AS ordersFROM ordersGROUP BY cust_idHAVING count(*) = 2 ORDER BY（位于 WHERE 之后）》 ORDER BY： DESC:降序 ASC:升序(默认) 12345ORDER BY &lt;column-name&gt; [DESC/ASC]//按多个列进行排序（先根据列1排，在根据列2排）ORDER BY &lt;column-name&gt;,&lt;column-name2&gt; [DESC/ASC]//指定排序方向的多个列排序，DESC/ASC只应用到直接位于其前面的列名ORDER BY &lt;column-name&gt; [DESC/ASC],&lt;column-name2&gt; [DESC/ASC] 》 ORDER BY 子句中使用的列通常为要显示的列，但用非检索的列排序数据也是完全合法的 LIMIT》 MySQL特有的语法，实现了物理分页 》 物理分页：直接在数据库中进行分页，最终只返回分页后的数据 12345//offset:起始位置//rows:每页多少行SELECT * FROM &lt;table-name&gt; LIMIT [offset,] rows;//另一种写法SELECT * FROM &lt;table-name&gt; LIMIT rows OFFSET [offset]; 》 示例 12//从第2位置开始返回3行(（第一行为0)：LIMIT 2,3 子查询》 又叫内部查询，即嵌套在其他查询中的查询；包含内部查询的被成为外部查询 利用子查询过滤》 将一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句 12345SELECT cust_idFROM ordersWHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &apos;TNT2&apos;) 作为计算字段使用子查询1234567SELECT cust_name, cust_state. (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS ordersFROM customersORDER BY cust_name 组合查询 UNION》 使用组合查询的两种情况 在单个查询中从不同的表返回类似结构的数据 对单个表执行多个查询，按单个查询返回数据 》 创建组合查询:如，通过UNION连接两个SELECT 1234567SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;=5UNIONSELECT vend_id, prod_id, prod_priceFROM productsWHERE vend_id IN(1001, 1002) 》 UNION规则 UNION必须由两条或以上SELECT语句组成，语句之间用UNION分割 UNION中的每个查询必须包含相同列、表达式或聚集函数（次序可以不同） 列数据列下必须兼容。（可不必完全相同，但必须隐含转换的类型） 》 包含或取消重复的行 UNION：自动去除重复的行 UNION ALLL：返回全部的行 》 对组合查询结果排序： 在最后一个SELECT后面加ORDER BY，将排序所有SELECT语句返回的结果。 全文本搜索》 搜索text数据（MyISAM支持，InnoDB不支持） 》 启用全文本搜索FULLTEXT Mysql会根据FULLTEXT（）的指示对它进行索引，自动维护该索引。在增加、更新或删除行时，索引随之自动跟新。 可以在创建表时指定FULLTEXT（不推荐），也可以稍后指定。 先导入数据，在定义FULLTEXT，有助于更快导入索引（更新索引需要时间） 123456789CREATE TABLE productnotes( note_id int NOT NULL ATUO_INCREMENT, prod_id char(10) NOT NULL, note_date datetime NOT NULL, note_nect text NULL, PRIMARY KEY(note_id), FULLTEXT(note_text)) ENGINE = MyISAM 》 进行全文本搜索Match()和Against() Match()指定所搜的列 Against()指定搜索表达式 12345//如，将会搜索包含rabbit的文本,不区分大小写SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit') 》 与LIKE的区别 LIKE以不特别有用的顺序返回数据 全文本搜索返回以文本匹配的良好程度排序的顺序(如rabbit作为第3个词的行等级比作为第20个词的行高) 》 查询扩展WITH QUERY EXPANSION 用来放宽返回的全文本搜索结果的范围 首先进行基本的全文本搜索，找出匹配的行， 其次，检查这些匹配行并选择所有有用的词，最后，再次使用有用的词进行一次全文本上搜索。 123SELECT note_textFROM productnotesWHERE Match(note_text) Against(&apos;anvils&apos; WITH QUERY EXPANSION) 》 布尔文本搜索IN BOLEAN MODE，可以提供内容细节 要匹配的词 要排斥的词（如果某行包含这个词，则不反回改行。即使包含匹配的词） 排列提示（指定某些词比其他词更重要） 表达式分组 另外一些内容 12345//匹配heavy,但排除任何以rope开始的词或行SELECT note_textFROM productnotesWHERE Match(note_text) Against ('heavy -rope*' IN BOOLEAN MODE) 》 全文本布尔操作符 12345678+：包含，词必须存在-：排除，词必须不出现：包含，而且增加等级&lt;：包含，而且减少等级()：把词组成子表达式（允许子表达式作为一个组被包含、排除、排列）~：取消一个词的排序值*：词尾通配符&quot;&quot;：定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语） 》 示例1 12345//包含rabbit和bait的行SELECT note_textFROM productnotesWHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE) 》 示例2: 12345//至少包含rabbit和bait其中一个的行SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE) 》 示例3: 12345//匹配短语rabbit bait而不是匹配两个词SELECT note_textFROM productnotesWHERE Match(note_text) Against('"rabbit bait"' IN BOOLEAN MODE) 》 示例4: 12345//至少包含rabbit和bait其中一个的行，增加rabbit的等级，降低bait的等级SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit &lt;bait' IN BOOLEAN MODE) 》 示例5 12345//至少包含safe 和combination其中一个的行，降低combination的等级SELECT note_textFROM productnotesWHERE Match(note_text) Against('+safe +(&lt;combination)' IN BOOLEAN MODE) 》 全文本搜索使用说明 在索引全文本数据时，短词被忽略且从索引中排除。（短词：3个或3个一下字符的词） MySQL带有一个内建的非用词列表，这些词在索引时被忽略 高频词汇会被当做非用词（一个词出现在50%以上的行,该规则不用于IN BOOLEAN MODE） 如果表中的行数少于3行，则全文本搜索不反回结果(要么没有，要么至少出现在50%行中) 忽略此种的单引号。如don’t索引为dont 不具有此分隔符的语言不能恰当地返回全文本搜索结果（汉语、日语） 仅在MyISAM引擎中支持全文本搜索 INSERT插入完整的行》 插入规则： 列可以不按次序，但值与列次序一一对应，没有值的使用NULL值 可以省略某些列，但该列必须允许NULL值或在表定义中给出了默认值 提高性能：INSERT INTO耗时，且可能降低等待处理的SELECT语句的性能。如果数据检索是最重要的，可以使用INSERT LOW_PRIORITY INTO来降低INSERT语句的优先级(同样适用UPDATE和DELETE) 1234567891011INSERT INTO &lt;table-name&gt;( &lt;column-name&gt;, &lt;column-name2&gt;, &lt;column-name3&gt;， ... ) VALUES( &lt;value&gt;, &lt;value&gt;, &lt;value&gt;, ... ) 插入多个行》 每组值用一堆圆括号括起来，用逗号分隔 12345678910111213141516171819INSERT INTO &lt;table-name&gt;( &lt;column-name&gt;, &lt;column-name2&gt;, &lt;column-name3&gt;， ...)VALUES( &lt;value&gt;, &lt;value&gt;, &lt;value&gt;, ...),( &lt;value&gt;, &lt;value&gt;, &lt;value&gt;, ...),... 插入检索出的数据:123456INSERT INTO &lt;table-name&gt; ( &lt;column-name&gt;, &lt;column-name2&gt;, &lt;column-name3&gt;， ...) SELECT * FROM &lt;table&gt; UPDATE》 使用前特别注意！： 不要省略WHERE子句，因为稍不注意，可能更新表中所有行 更新数据12345678910111213141516171819UPDATE &lt;table-name&gt; SET &lt;column-name&gt;=&lt;value&gt;, &lt;column-name2&gt;=&lt;value2&gt;, &lt;column-name3&gt;=&lt;value3&gt;, &lt;column-name4&gt;=&lt;value4&gt;, ... WHERE 条件;//忽略错误，继续更新(UPDATE在更新时如果出现错误，整个操作都会被取消)UPDATE INGNORE &lt;table-name&gt; SET &lt;column-name&gt;=&lt;value&gt;, &lt;column-name2&gt;=&lt;value2&gt;, &lt;column-name3&gt;=&lt;value3&gt;, &lt;column-name4&gt;=&lt;value4&gt;, ... WHERE 条件;//删除某个列的值,可以将其设置为NULL&lt;column-name&gt;=NULL DELETE使用前特别注意！！！ 不要省略WHERE子句，因为稍不注意，可能删除表中所有行 DELETE删除的是整行。想要删除列，还是要用UPDATE 删除行123DELETE FROM &lt;table-name&gt; WHERE 条件;//删除所有行DELETE FROM &lt;table-name&gt;; 更快的全部删除1TRUNCATE TABLE &lt;table-name&gt; 》 区别： TRUNCATE实际上是删除原表重新创建，而不是逐行删除,清空AUTO_INCREMENT记录数 DELETE是一条一条删除，不清空AUTO_INCREMENT记录数 更新和删除所遵循的习惯》 规则如下： 除非打算更新和删除所有行。否则不要用不带WHERE的UPDATE、DELETE语句 保证每个表都有逐渐，尽可能像`WHERE子句那样使用它 对UPDATE和DELETE语句使用WHERE子句前，先使用SELECT进行测试，保证正确的记录。 使用强制实施完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。 MySQL没有撤销按钮，所以要小心使用UPDATE和DELETE 函数常用的文本处理函数123456789101112Concat(): 拼接字段Left()：返回串左边的字符Length()：返回串的长度Lecate()：找出串的一个子串Lower()：将串转换为小写Upper()：将串转换为大写LTrim()：去掉串左边的空格RTrim()：去掉串右边的空格Trim()：去掉串两边的空格Right()：返回串右边的字符Soundex()：返回串的SOUNDEX值SubString()：返回子串的字符 常用时间和日期处理函数1234567891011121314151617AddDate()：增加一个日期（天、周等）AddTime()：增加一个时间（时、分等）CurDate()：返回当前日期CurTime()：返回当前时间Date()：返回日期时间的日期部分DateDiff()：计算两个日期之差Date_Add()：高度灵活的日期运算函数Date_Format()：返回一个格式化的日期或时间串Day()：返回一个日期的天数部分DayOfWeek()：对于一个日期，返回对应的星期几Hour()：返回一个时间的小时部分Minute()：返回一个时间的分钟部分Month()：返回一个日期的月份部分Now()：返回当前日期和时间Second()：返回一个时间的秒部分Time()：返回一个日期时间的时间部分Year()：返回一个日期的年份部分 》 检索日期 1234//假设order_date数据类型datetime，其格式为2005-09-01 21:21:53,所以需要使用Date()来提取order_date的日期部分SELECT cust_id, order_numFROM ordersWHERE Date(order_date) = '2005-09-01' 》 注意： 日期格式必须为 yyyy-mm-dd ,如2005年9月1日，则- 2005-09-01 数值处理函数123456789Abs()：返回一个数的绝对值Cos()：返回一个角度的余弦Exp()：返回一个数的指数值Mod()：返回一个除操作的余数Pi()：返回圆周率Rand()：返回一个随机数Sin()：返回一个角度的正弦Sqrt()：返回一个数的平方根Tan()：返回一个角度的正切 聚焦函数123456AVG()函数：返回某列的平均值(忽略值为NULL的行) COUNT(*):对表中行的数据进行计算，包含空值NULL COUNT(column):对特定列中具有值的行进行计数，忽略NULL值。 MAX()函数：返回某列的最大值(忽略NULL值)MIN()函数：返回某列的最小值（与MAX()相反）SUM()：返回某列值之和（忽略NULL值）,如，计算总金额时使用 字符集》 重要术语 字符集：字母和符号的集合 编码：某个字符集成员的内部表示 校对：规定字符如何比较的指令 字符集相关操作》 显示所有可用的字符集以及每个字符集的描述和默认校对 1SHOW CHARACTER SET 》 查看Mysql支持的校对完整列表 1SHOW COLLATION 》 查看数据库默认的字符集 1SHOW VARIABLES LIKE &apos;character%&apos; 》 查看数据库默认的校对： 1SHOW VARIABLES LIKE &apos;collation%&apos; 》 在创建表时指定字符集和校对 12345CREATE TABLE mytable( column1 INT, column2 VARCHAR(10)) DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; MySQL使用字符集和校对规则 明确指定两个 只指定CHARACTER SET，则使用此字符集及其默认的校对 都不知道，则使用数据库默认 列级别的字符和校对12345CRETE TABLE mytable(column3 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci) DEFAULT CHARACTER ser HEBREW COLLATRE hebrew_general_ci`` 数据类型常用数据类型 数据类型 说明 CHAR 1～255个字符的定长串。它的长度必须在创建时指定，否则MySQL假定为CHAR(1) ENUM 接受最多64 K个串组成的一个预定义集合的某个串 LONGTEXT 与TEXT相同，但最大长度为4 GB MEDIUMTEXT 与TEXT相同，但最大长度为16 K SET 接受最多64个串组成的一个预定义集合的零个或多个串 TEXT 最大长度为64 K的变长文本 TINYTEXT 与TEXT相同，但最大长度为255字节 VARCHAR 长度可变，最多不超过255字节。如果在创建时指定为VARCHAR(n)m则可存储0到n个字符的变长串（其中n≤255） 数值数据类型》 MySQL中没有专门存储货币的数据类型，一般情况下使用 1DECIMAL(8, 2) 数据类型 说 明 BIT 位字段，1～64位。（在MySQL 5之前，BIT在功能上等价于TINYINT BIGINT 整数值，支持9223372036854775808～9223372036854775807（如果是UNSIGNED，为0～18446744073709551615）的数 BOOLEAN（或BOOL） 布尔标志，或者为0或者为1，主要用于开/关（on/off）标志 DECIMAL（或DEC） 精度可变的浮点值 DOUBLE 双精度浮点值 FLOAT 单精度浮点值 INT（或INTEGER） 整数值，支持2147483648～2147483647（如果是UNSIGNED，为0～4294967295）的数 MEDIUMINT 整数值，支持8388608～8388607（如果是UNSIGNED，为0～16777215）的数 REAL 4字节的浮点值 SMALLINT 整数值，支持32768～32767（如果是UNSIGNED，为0～65535）的数 TINYINT 整数值，支持128～127（如果为UNSIGNED，为0～255）的数 日期和时间数据类型 数据类型 说 明 DATE 表示1000-01-01～9999-12-31的日期，格式为YYYY-MM-DD DATETIME DATE和TIME的组合 TIMESTAMP 功能和DATETIME相同（但范围较小） TIME 格式为HH:MM:SS YEAR 用2位数字表示，范围是70（1970年）～69（2069年），用4位数字表示，范围是1901年～2155年 二进制数据类型 数据类型 说 明 BLOB Blob最大长度为64 KB MEDIUMBLOB Blob最大长度为16 MB LONGBLOB Blob最大长度为4 GB TINYBLOB Blob最大长度为255字节 多表关系》 多表关系 一对一（一夫一妻） 一对多(会员与订单) 对多多(商品与订单) 一对一》 概述 主表添加外键字段，该字段的约束为唯一 添加外键约束 一对多》 概述 主表添加外键字段，该字段的约束为不唯一 添加外键约束 多对多》 概述 需要重建表完成多对多 实质为两个一对多的关系 首先创建中间表，并在其中创建多对多关系中两张表的外键列 中间表添加外键约束 中间表添加联合主键约束 联结》 当数据存储在多个表中，使用联结方式，在单条SELECT 语句检索出数据。 JOIN按照功能可分为 CROSS JOIN(交叉连接) INNER JOIN(内连接或等值连接) OUTER JOIN(外连接) 》 此外，还有其他连接 自连接: 双表都是自身时使用 自然联结: 多表连接查询所有列，保证出现重复列 交叉连接》 又名笛卡儿积连接,检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。 1234//隐式交叉连接SELECT * FROM A,B;//显示交叉连接SELECT * FROM A CROSS JOIN B; 内连接或等值连接》 内连接使用比较运算符根据每个表共有的列的值匹配两个表中的行 1234//隐式内连接SELECT * FROM A,B WHERE A.id = B.id;//显示内连接SELECT * FORM A INNER JOIN B ON A.id = B.id; 外连接》 外连接包括 左外连接 右外连接 》 此外，外连接需要有主表或者保留表的概念；查询结果会以主表为主，从表记录匹配不到，则补NULL 左外连接》 其中A为主表 123SELECT * FROM A LEFT JOIN B ON A.id = B.od;//或SELECT * FROM A LEFT OUTER JOIN B ON A.id = B.od; 右外连接》 其中B为主表 123SELECT * FROM A RIGHT JOIN B ON A.id = B.od;//或SELECT * FROM A RIGHT OUTER JOIN B ON A.id = B.od; 》 使用表别名(可以省写表名) 12345SELECT cust_name, cust_contactFROM customers AS c, orders AS o, orderitems AS oiWHERE c.cust_id = o.cust_idAND oi.order_num = o.order_numAND prod_id = &apos;TNT2&apos; 自联结》 使用情况，如一个货物id为DTNTR,想要查询这个货物对应厂商的其他货物，就需要使用自联结了。（p1、p2实际为一张表） 第一步：查询到id为DTNTR对应的vend_id 第二步：查询到vend_id对应的prod_id, prod_name 1234SELECT p1.prod_id, p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id = p2.vend_idAND p2.prod_id = &apos;DTNTR&apos; 自然联结》 使用情况，在对表进行联结时，肯定会有至少一个列的值时重复的。而自然联结，就是排除多次出现的列。使每个列只返回一次，具体做法 对一张表使用SELECT * 其他表的列使用明确的子集 12345678910SELECT c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_priceFROM customers AS c, orders AS o, orderitems AS oiWHERE c.cust_id = o.cust_idAND oi.order_num = o.order_numAND prod_id = &apos;FB&apos; 事务》 事务： 指的是逻辑上一组操作，组成这个事务的各个执行单元，要么一起成功,要么一起 InnoDB引擎支持 》 相关术语 事务（transaction）：指一组SQL语句； 回滚（rollback）：撤销指定SQL语句的过程 提交（commit）：将为存储的SQL语句结果写入数据库表 保留点（savepoint）：指事务处理中设置的临时占位符（placeholder），可以对它发布回滚（与回滚整个事务处理不同） 》 事务的特性(ACID) 原子性（Atomicity）原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚 一致性（Consistency）一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态(如转账，两个人怎么转，总金额是不会变的) 隔离性（Isolation）隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离 持久性（Durability）持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作 事务并发问题（隔离性导致）在事务的并发操作中可能会出现一些问题： 脏读：一个事务读取到另一个事务未提交的数据。 不可重复读：一个事务因读取到另一个事务已提交的数据。导致对同一条记录读取两次以上的结果不一致。(update操作，读取的内容改变) 幻读：一个事务因读取到另一个事务已提交的数据。导致对同一张表读取两次以上的结果不一致。(insert、delete操作,返回的结果行数改变) 事务隔离级别MySQL数据库为我们提供的四种隔离级别（由低到高）： Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 Read committed (读已提交)：可避免脏读的发生。 Repeatable read (可重复读)：可避免脏读、不可重复读的发生。[MySQL默认] Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 》 注意 》》 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观&gt;锁来控制。 事务SQL》 开始事务 1START TRANSACTION . 》 回滚事务 只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后） 事务处理可以用来管理INSERT、UPDATE、DELETE 不能回滚CREATE和DROP操作 1ROLLBACK 提交事务 数据库默认是自动提交的 但在事务处理快中，不会自动提交，需要手动COMMIT 1COMMIT 》 关闭事务：执行COMMIT和ROLLBACK后自动关闭 》 设置保留点 1SAVEPOINT point 》 回滚到保留点 1ROLLBACK TO point 》 释放保留点:（执行完ROLLBACK或COMMIT后自动释放，或RELEASE SAVEPOINT明确释放） 》 更改系统默认的提交行为 12//表示不自动提交。Mysql默认自动提交。SET autocommit=0 索引》 简介 使用索引的目的时为了优化查询速度 索引时一种特殊的文件或者叫数据结构（InnoDB数据表上的索引是表空间的一个组成部分），它包含对数据表里的所有记录的引用指针 通俗的讲，索引就相当一数据库的目录 》 因为索引是在存储引擎中实现，所以不同存储引擎有不同索引 MyISAM和InnoDB:只支持BTREE索引 MEMORY/HEAP存储引起：支持HASH和BTREE索引 索引分类》 索引分类 单列索引 组合索引 》 单列索引 普通索引：MySQL中基本索引类型，没有限制，允许定义索引的列中插入重复值和空值 唯一索引：索引列中的值必须是唯一的，但允许NULL 主键索引：特殊唯一索引，不允许NULL 》 组合索引 在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。 》 全文索引 全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引。 此外，还有空间索引，不常用. 创建索引》 普通索引的创建 12345678//创建索引CREATE INDEX &lt;index-name&gt; ON &lt;table-name&gt;( &lt;column-name&gt;(length))//另一种方式ALTER TABLE &lt;table-name&gt; ADD INDEX &lt;index-name&gt; ON ( &lt;column-name&gt;(length)) 》 唯一索引的创建 1234//创建索引CREATE UNIQUE INDEX &lt;index-name&gt; ON &lt;table-name&gt;( &lt;column-name&gt;(length)) 》 全文索引创建 1234//创建索引CREATE FULLTEXT INDEX &lt;index-name&gt; ON &lt;table-name&gt;( &lt;column-name&gt; (length)) 》 组合索引的创建 123456//创建索引CREATE [FULLTEXT/UNIQUE] INDEX &lt;index-name&gt; ON &lt;table-name&gt;( &lt;column-name&gt;(length), &lt;column-name&gt;(length) ...) 删除索引1DROP INDEX &lt;index-name&gt; ON &lt;table-name&gt; MySQL的锁》 简介： 事务在对某个数据对象（如表、记录等）操作之前，先向系统发出请求，对其加锁，加锁后事务就对数据库对象有一定的控制，在事务释放它的锁之前，其他事务不能更新此数据对象。 数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问访问 MySQL数据库由于存在多种数据存储引擎,每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别 》 MySQL各存储引擎使用了三种类型（级别）的锁定机制 行级锁定:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高 页级锁定:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 表级锁定:开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低 》 MySQL这三种锁定的特点和各自的优劣所在 按照锁的粒度来分：行级锁、表级锁、页级锁定 按照锁的功能来分：共享读锁和排他写锁 》 各引擎对锁的支持 MyISAM和MEMORY存储引擎采用的表级锁 BDB采用的是页面锁，也支持表级锁 InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。 排他锁》 介绍: 又称写锁，X锁 允许当前请求进行读取和修改，同时阻塞其他请求读取和修改 共享锁》 介绍: 又称读锁，S锁 允许当前请求进行读取，同时阻塞其他请求修改,但其他请求可以进行读取 行级锁》 特点 行级别粒度，最小的粒度 由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能 更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用 缺点 锁定资源的颗粒度很小，占用系统资源大,并发度最高 过多的锁也最容易发生死锁 表级锁》 特点 表级别粒度，最大的粒度 实现逻辑简单，带来的系统负面影响最小 获取锁和释放锁的速度很快 不会出现死锁 更适合于以查询为主，只有少量按索引条件更新数据的应用 》 缺点 出现锁定资源争用的概率高,并发度差 页级锁》 特点 MySQL特有的锁 所需资源和粒度都介于表级锁和行级锁之间 并发处理能力在三种锁之间最高 》 缺点 会发生死锁 MyISAM引擎的锁机制》 MyISAM只有表级锁 表共享读锁（table read lock） 表独占写锁（table write lock）。 》 MyISAM表的读、写操作之间、以及写操作之间的隔离级别是串行级别，其处理流程如下： MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁 在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁 用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁 》 注意:MyISAM是不支持事务的 MyISAM手动更改优先级》 方式: 通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。 给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。 MyISAM的并发插入》 MyISAM存储引擎有一个系统变量，concurrent_insert，专门用来控制并发插入行为的，值可以为0，1，2. 值为0：不允许插入 值为1：如果mysql没有空洞（中间没有被删除的行），MyISAM运行一个进程读表的时候，另一个进程从表尾插入记录，这也是mysql默认设置。 值为2，无论MyISAM表中有没有空洞，都允许在表尾并行的插入。 InnoDB引擎的锁机制》 与MyISAM不同: 支持事务 支持行级锁 》 流程 对于UPDATE、DELETE、INSERT语句，Innodb会自动给涉及的数据集加排他锁（X） 对于普通SELECT语句，Innodb不会加任何锁。 Innodb行锁模式以及加锁方法》 Innodb锁模式一共分为 共享锁 排他锁 意向锁(意向共享锁、意向排他锁) 》 冲突情况： 共享锁 排他锁 意向共享锁 意向排他锁 共享锁 兼容 冲突 兼容 冲突 排他锁 冲突 冲突 冲突 冲突 意向共享锁 兼容 冲突 兼容 兼容 意向排他锁 冲突 冲突 兼容 兼容 表级锁和行级锁之间的冲突》 如下情况 事务A：行级锁，锁定行H，只读 事务B：表级锁，锁定了行H的表，读写 》 数据库的解决办法: 意向锁 意向锁是一个表级锁，可以分为意向共享锁(IS)、意向排他锁（IX） 事务A必须先申请意向锁，再申请行级锁 事务B在申请表级锁时，发现表已经有了意向锁，会被阻塞 触发器(MySQL5)》 触发器：MySQL响应以下任意语句自动执行的的一条MySQL语句 其他MySQL语句不支持触发器 只有表支持触发器，视图不支持 每个表最多支持6个触发器（每条INSERT、UPDATE、DELETE的之前之后）. 123DELETEINSERTUPDATE 》 触发器失败 BEFORE触发器失败，不执行请求操作 BEFORE触发器或语句本身失败，不执行AFTER触发器 》 创建触发器 1CREATE TRIGGER 》 示例 12345678//触发器在INSERT语句成功后，对每个插入的行显示一次Product added- 创建了名为newproduct的触发器。- AFTER INSERT表示触发器在INSERT语句成功后执行- FOR EACH ROW表示代码对每个插入行执行- SLELECT 'Product added'触发器执行的操作，即显示文本信息Product addedCREATE TRIGGER newproduct AFERT INSERT ON productsFOR EACH ROW SLELECT 'Product added' 》 删除触发器: 触发器无法更新或覆盖，想要修改触发器，必须先删再创。 1DROP TRIGGER 触发器名 INSERT触发器》 INSERT触发器 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行 在BEFROE INSERT触发器中，NEW 的值也可以被更新。 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。 》 示例 1234//order_num是一个AUTO_INCREMENT列,当orders表成功插入一行数据时，这行数据会保存到NEW中。此触发器执行的操作是SELECT NEW.order_num,即把自动生成的标号显示出来。CREATE TRIGGER neworder AFTER INSERT ON ordersFOR EACH ROW SELECT NEW.order_num; DELETE触发器》DELETE触发器 在DELETE触发器代码内，可以引用名为OLD的虚拟表，访问被删除的行 OLD中的值都是只读，无法更新 12345678//将被删除的行的数据保存到archive_orders表中。BEGIN END块的好处是触发器器能容纳多条SQL语句。CREATE TRIGGER deleteorder BEFORE DELETE ON rodersFOR EACH ROWBEGIN INSERT INTO archive_orders(order_num, order_date, cust_id) VALUES (OLD.order_num, OLD.order_date, OLD.cust_id) END; UPDATE触发器》 UPDATE触发器 在UPDATE触发器代码中，可以引用名为OLD的虚拟表访问以前的值，引用名为NEW的虚拟表访问新更新的值 BEFORE UPDATE触发器中，NEW中的值可能也被更新OLD只读，不能更新 》示例： 1234//在更新以前出发，保证更改的值永远是大写。即在更新前，先对值进行处理。（这就是所谓的NEW值可能被更新）CREATE TRIGGER updatevendor BEFORE UPDATE ON vendorsFOR EACH ROW SET NEW.ven_state = Upper(NEW.vend_state); 视图（MySQL5 ）》 什么是视图 将一个SELECT的查询结果包装成一个虚拟的表 本身不包含数据，仅仅用来查看存储在别处的数据的一种设施。 》 视图的好处： 重复SQL语句 鸡蛋花复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节 使用表的组成部分而不是整个表 保护数据，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 》 规则和限制 与表一样，视图名唯一 对于可创建的视图数目没有限制 为了创建视图，必须具有足够的访问权限 可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图 ORDER BY可以用在视图中。但如果从该视图检索数据SELECT中也含有ORDER BY,那么视图中的ORDER BY被覆盖。 视图不能索引，也不能由关联的触发器或默认值 视图可以和表一起使用。例如编写一条联结表和视图的SELECT语句 创建视图1CREATE VIEW 视图名 》 示例： 12345CREATE VIEW prdouccustomers ASSELECT cust_name, cust_contact, prod_idFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_idAND orderitems.order_num = orders.order_num 查看创建视图的语句1SHOW CREATE VIEW viewname 更新视图》 方式一：先DROP在CREATE 》 方式二：不存在则创建，存在就覆盖 1CREATE OR REPLACE VIEW 》 个人理解： 创建完视图后，发现通过SHOW TABLES可以查看到视图（暂且理解为视图其实算是一种特殊的表） 通过SHOW CREATE TABLE 视图,也可以显示视图的创造语句（更加觉得视图是一种特殊的表） 在实际使用中，可以当表来进行操作(WHERE，ORDER BY等) 虽然视图也可以做到更新（改动基表），但视图本身是用于检索，所以想要更新数据，还是直接操作基表比较好 存储过程(MySQL5)创建存储过程PROCEDURE 存储过程名() BEGIN 语句; END123CREATE PROCEDURE productname()...END; 》 示例 12345CREATE PROCEDURE productpricing()BEGIN SELECT avg(prod_price) AS priceaverageFROM products;END; 命令行模式下的DELIMITER //》 MySQL命令行默认使用;来表示分隔符。而MySQL语句也使用;表示。这样还没执行到END，就在前面的;就结束了。DELIMITER //是将MySQL命令行的分隔符修改。 123456DELIMITER //CREATE PROCEDURE productpricing()BEGIN SELECT avg(prod_price) AS priceaverageFROM products;END// 使用存储过程1CALL productpricing() 删除存储过程》 过程不存在回产生错误，可使用DROP PROCEDURE IF EXISTS 存储过程名 12DROP PROCEDURE 存储过程名DROP PROCEDURE IF EXISTS 存储过程名 使用参数》 主要参数如下 IN：传递给存储过程 OUT：从存储过程传出 INOUT：可传入传出 1234567891011121314//IN需要传入数据（20005）,SELECT的数据通过INTO传入到ototal中。通过SELECT @total查看变量的值。CREATE PROCEDURE ordertotal( IN onumber INT, OUT ototal DECIMAL(8, 2))BEGIN SELECT sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO ototal;END;CALL ordertotal(20005, @total);SELECT @total; 检查存储过程1SHOW CREATE PROCEDURE 存储过程 列出所有存储过程1WHO PROCEDURE STATUS 可以使用LIKE过滤,如1WHO PROCEDURE STATUS LIKE &apos;ordertotal&apos; 使用游标(MySQL5)》 游标(cursor) 存储在MySQL服务器上的数据库查询，不是SELECT语句，而是被该语句检索出来的结果集。 根据需要滚动或浏览其中的数据 主要用于交互式应用 只能用于存储过程（和函数） 游标的使用 先声明游标，这个过程没有检索数据。只用来定义要使用的SELECT语句 声明后，打开游标。这个过程用前面定义的SELECT语句把数据检索出来 对于填有数据的游标，根据需要检索各行 在结束游标使用时，必须关闭游标（如果不明确关闭游标，MySQL会在达到END语句时自动关闭） 创建游标1DECLARE 游标名 CURSOR FOR 》 示例 12345678910111213//如,定义了名为ordernumbers的游标CREATE PROCEDURE processorders()BEGIN -- 定义游标DECLARE ordernumbers CURSORFOR SELECT order_num FROM orders;-- 打开游标OPEN ordernumbers;-- 关闭游标CLOSE ordernumbers;END; 打开游标1OPEN 游标名 关闭游标1CLOSE 游标名 使用游标数据1FETCH 》 示例 1234567891011121314151617//FETCH语句会自动从第一行开始把order_num列复制到变量o中(这里并没有操作变量o)CREATE PROCEDURE processorders()BEGIN -- 定义一个本地变量oDECLARE o INT;-- 定义游标DECLARE ordernumbers CURSORFOR SELECT order_num FROM orders;-- 打开游标OPEN ordernumbers;-- 获取数据FETCH ordernumbers INTO o;-- 关闭游标CLOSE ordernumbers;END; 》 该存储过程执行后，会循环检索数据，从第一行到最后一行 FETCH在REPEAT内，所以会反复执行。根据UNTIL done END REPEAT;，直到done为真时结束循环(done默认0，表示假) CONTINUE HANDER：在条件出现时被执行的代码。这里表名当SQLSTATE ‘02000’出现时，将SET done = 1 SQLSTATE ‘02000’表示一个未找到的条件，当REPEAT没有更多行出供循环而不能继续时，就会出现这个条件 12345678910111213141516171819202122232425CREATE PROCEDURE processorders()BEGIN -- 定义一个本地变量o和一个布尔值变量doneDECLARE done BOOLEAN DEFAULT 0;DECLARE o INT;-- 定义游标DECLARE ordernumbers CURSORFOR SELECT order_num FROM orders;-- 定义了一个continue handler,在条件出现时将done设置成1DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done=1;-- 打开游标OPEN ordernumbers;REPEAT -- 获取数据 FETCH ordernumbers INTO o;UNTIL done END REPEAT;-- 关闭游标CLOSE ordernumbers;END; 》 示例： 创建了一个ordertotals表 定义了一个变量t,使用ordertotal()存储过程为其复制 通过INSERT INTO 将o和t的值插入ordertotals表中 使用 CALL processorders();来使用存储过程,这时表ordertotals应该已经创建好并且有数据了 使用SELECT * FROM ordertotals;来查看下数据 1234567891011121314151617181920212223242526272829303132333435363738394041CREATE PROCEDURE processorders()BEGIN -- 定义一个本地变量o、t和一个布尔值变量doneDECLARE done BOOLEAN DEFAULT 0;DECLARE o INT;DECLARE t DECIMAL(8, 2);-- 定义游标DECLARE ordernumbers CURSORFOR SELECT order_num FROM orders;-- 定义了一个continue handlerDECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done=1;-- 创建一个表来存储结果CREATE TABLE IF NOT EXISTS ordertotals( order_num INT, total DECIMAL(8, 2));-- 打开游标OPEN ordernumbers;REPEAT -- 获取数据 FETCH ordernumbers INTO o; -- 这里是在学习存储过程中写的一个存储过程,用来计算t的值 CALL ordertotal(o, t); -- 把数据插入表 INSERT INTO ordertotals(order_num, total) VALUES(o, t);UNTIL done END REPEAT;-- 关闭游标CLOSE ordernumbers;END;CALL processorders();SELECT * FROM ordertotals; 备份》 mysqldump 转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。mysqlhotcopy 从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序）。 》 BACKUP TABLE或SELECT INTO OUTFILE 转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错 数据可以用RESTORE TABLE来复原。 》 FLUSH TABLES 为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2Fblog%2F2018%2F02%2F04%2Fjvm.all%2F</url>
    <content type="text"><![CDATA[JVM运行时数据区java将内存的管理权力全部交给了虚拟机，如下是JVM所管理的内存区域图 程序计数器 程序计数器 是一块较小的内存空间，属于线程私有的内存 可以看成是当前线程所指向的字节码的行号指示器，字节码解释器依靠计数器的值来选取下一个要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能也需要以来于计数器 由于java是多线程的切换的方式实现的，为了保证切换回后有恢复到正确的位置，所以每一条线程都有一个计数器 如果线程执行的是java代码，则计数器记录正在执行的虚拟机字节码指令的地址；如果是Native方法，计数器为Undefined 唯一一个没有规定任何OutOfMemoryError[1]情况的区域 Java虚拟机栈 Java虚拟机栈 线程私有的内存，为Java方法服务 虚拟机栈用来描述Java方法的内存模型，即每个方法在执行的同时会创建一个栈帧,用于存储局部变量表、操作数栈、动态链接、方法出口等信息;每一个方法调用直到完成的过程，对应一个栈帧在虚拟机栈中的入栈到出栈的过程 虚拟机栈中存在一个局部变量表 规定了两种异常状态： StackOverflowError和OutOfMemoryError 局部变量表 存放了编译期可知的基本数据类型、对象引用、returnAddress类型 对象引用：reference类型，可能是执行对象起始地址的引用指针，可以能是指向代表对象的句柄或其他与此对象相关的位置 returnAddress类型: 指向一条字节码指令的地址 局部变量空间(Solt)：基本数据类型的long和double会占据两个局部变量空间(Slot),其余数据类型占据一个 局部变量表在编译期就已经完成了内存空间的分配,运行期间不会改变 本地方法栈 本地方法栈 与虚拟机栈类似，线程私有的内存，为Native方法服务 规定了两种异常状态： StackOverflowError和OutOfMemoryError Java堆 Java堆： JVM内存最大的一块,被线程共享，在虚拟机启动时创建 用于存放对象示例 Java堆在物理空间上可以不连续，只要逻辑上连续即可 如果没有内存完成示例分配，会抛出OutOfMemoryError异常 方法区 方法区 线程间共享内存，别名Non-Heap(非堆); 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常 运行时常量池 属于方法区的一部分，用于存放编译期生成的各种字面量和符号引用 无法申请到内存时抛出OutOfMemoryError异常 直接内存 直接内存： 并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中的内存区域 ;在JDK1.4后加入了NIO类，引入了基于通道与缓冲区的I/O方式，该类可以使用Native函数库直接分配堆外内存，然后通过一个存储在 java堆 中的 DirectByteBuffer对象作为这块内存存的引用进行操作; 会受到本机总内存以及处理器寻址空间的限制。会抛出OutOfMemoryError异常 HotSpot虚拟机对象对象的创建 从语言层面上，创建一个对象只是使用new关键字，而在虚拟机中，当遇到一个new指令，执行步骤如下 检查这个指令的参数能够在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否被加载、解析、初始化；如果没有，则先进行类加载 在类加载检查通过后，虚拟机为新的对象分配内存，内存大小在类加载完后可以确定，而内存分配需要考虑两点: 内存的分配方式和分配的安全性 将分配到的内存空间初始化为0(不包括对象头)，如果使用TLAB，可以提前至TLAB分配时进行 对对象进行必要设置，如设置对象是哪个类的示例，对象的hash code等,而这些信息存放在 对象头 中，此时一个对象创建完成 执行init,初始化对象 内存分配方式： 指针碰撞：如果内存规整，用过的和没用过的各自一边。那么只需要往中间放置一个指针作为分界点指示器，分配内存仅仅就是移动指针而已。 空闲列表(Free List)： 如果内存不规整，即用过的和没用过的互相交错，那么就需要虚拟机来维护一个列表，该列表上记录了可用的内存 内存是否规整，取决于所采用的垃圾收集器 分配的安全性：即多线程下的指针指向 方式一： 对分配内存空间动作采用同步处理: 实际上虚拟机就是采用CAS配失败重试的方式保证原子性 方式二：将内存分配的动作划分在不同空间中进行，即在每个线程在Java堆中先划分出一小块内存,被称为本地线程分配缓冲(TLAB),只有TLAB用完并分配新的TLAB时，才需要同步锁定 对象的内存布局 在HotSpot虚拟机中，对象在内存中存储布局分三块区域 对象头 实例数据 对齐填充 对象头 对象头包括两部分信息 第一部分：存储对象自身的运行时数据 这部分数据被称为 Mark Word， 如HashCode,GC分代年龄，锁状态标志，线程持有锁，偏向线程id，偏向时间戳等；在32位和64位虚拟机中长度分别为32bit和64bit。它是一个非固定的数据结构，以便于尽量在极小的空间内存储更多的信息。 第二部分: 类型指针 虚拟机通过该指针确定对象是哪个类的实例，但并不是所有对象数据必须保留类型指针，即查找对象的元数据并不一定要经过对象本身 如果是数组，对象头还需要一个额外的数据记录数组长度。(虚拟机可以通过元数据确定Java对象大小，而从数组的元数据是不可能知道数组大小的) 实例数据 实例数据存储程序代码中定义的各种类型的字段内容，包括父类继承和子类本身定义。这部分的存储顺序受到虚拟机分配策略参数和字段在java源码中定义的顺序影响。 HotSpot默认分配策略: longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers),可以明显看出，相同宽度的字段会被分配在一起。 对齐填充对齐填充不是必须存在的，仅仅起到占位符的作用，因为HotSpot要求对象起始地址必须是8的倍数（即对象大小必须是8的整数倍），如果对象实例数据部分没有对齐，那么就需要通过对齐填充来补全 对象的访问定位为了使用对象，必须从栈上的renference数据来操作对上的具体对象。而renference只规定了一个指向对象的引用，并没有定义访问方式。所以，对于对象的访问方式，取决于虚拟机，目前主流方式有使用句柄和直接指针两种。 使用句柄访问步骤： java会在堆中划分出一块内存来当句柄池 reference中存储的对象就是句柄地址 句柄中包含了对象的实例数据与类型数据的具体地址 优势：使用句柄访问最大好处就是reference稳定，对象移动时无需更改reference,只会改变j句柄中的实例数据指针 使用直接指针reference中存储的对象就是对象实例数据的地址 优势：使用直接指针好处就是速度快，少一层指针定位的时间开销(HotSpot使用这种方式) 对象存活判定算法引用计数法 算法步骤 给对象添加一个引用计数器 每当有地方引用它，计数器+1 引用失效，计数器-1 计数器为0则表示没有任何地方使用这个对象 算法优点： 实现简单 判定效率高 算法缺点：难以解决对象之间相互循环引用，如下示例 12345objA.instance = objB;objB.instance = objA;//即使objeA,objB都为null了，但它们的Instance字段互相引用对方，使这两个对象的计数器永远不为0，GC收集器永远无法回收objA = null;objB = null; 可达性分析算法 算法步骤 通过一系列 GC Roots作为对象的起始点 从这些起始节点向下搜索，搜索走过的路径被称为 引用链 如果一个对象没有任何引用链，证明此对象不可用 如图 Object1、Object2、Object3都存在与GC Roots联通的 引用链,所以仍然存活 虽然object 5、6、7之间相互关联，但它们与 GC Roots无关联，所以会被判定为可回收对象 在Java语言中，可作为 GC Roots 的对象包括 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法去区中常量引用的对象 本地方法栈中JNI(即Native方法)引用的对象 活着的希望 在可达性分析算法中，对于不可用的对象，并不会马上回收，它至少要经理两次标记过程 第一次进行可达性分析后没有与GC Roots相连的引用链，则标记第一次； 在标记完后，进行依次筛选 如果当前对象没有覆盖finalize()方法或者finalize()方法已经被JVM调用过，JVM会将这两种情况视为“没必要执行”，其他的则视为有必要执行，进入下一步 对于有必要执行finalize()的对象，会把它放入到F-Queue队列中，并由一个虚拟机自动建立的，优先级低的Finalizer线程去执行它。GC 会对该队列进行第二次标记，如果在此时对象与引用链上的对象建立关联，则将该对象移出即将回收集合。如果第二次标记时仍然时不可达对象，那么就被真正回收 引用reference 什么是引用? 在JDK1.2 以前，引用被定义为：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用 在JDK1.2之后，引用被分为了四种: 强引用、软引用、弱引用、虚引用,四种引用强度依次减弱 强引用: 指在程序代码之中普遍存在的，类似”Object obj = new Object()”这类引用，只要强引用还在，垃圾收集器不会回收被引用的对象 软引用：软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果还没有足够的内存，则抛出内存溢出异常。在JKD1.2后使用 SoftReference 类 来实现软引用 弱引用：弱引用关联的对象，在垃圾收集器工作时，无论是否内存足够，都会被回收。在JKD1.2后使用 WeakReference 类来实现软引用 虚引用：又被称为幽灵引用或者幻影引用。对象被虚引用关联，完全不会对其生存时间造成任何影响，也无法通过虚引用来获取对象实例。该引用的唯一作用是在被关联对象回收后收到一个系统通知；在JKD1.2后使用 PhantomReference 类来实现软引用 方法区的回收 方法区（即永久代）垃圾回收率较低，主要回收的时废弃常量和无用的类。废如字符串”abc”在常量池但没有任何对象引用用它，则该字符串就是废弃常量；而判断无用的类，则必须满足以下三个条件 该类实例都已经被回收 加载该类的ClassLoader已被回收 该类的java.lang.Class对象没有被引用，无法在任何地方通过反射访问该类方法 满足三个条件，只能说是可以回收，是否要回收，HotSpot提供了 -Xnoclassgc 参数对齐进行控制;还可以使用 -verbose:class(Product版虚拟机中使用) 和 -XX:+TraceClassLoadd(Product版虚拟机中使用) 、 -XX:+TraceClassUnLoading(FastDebug版虚拟机中使用) 查看加载和卸载信息; 垃圾回收算法标记-清除算法(Mark-Sweep) 算法分为 标记 和 清除两个阶段 标记处所有需要回收的对象(标记过程看 ”可达性分析算法” 这一章的内容) 标记完成后统一回收 该算法有两处不足 效率低，无论是标记还是清除效率都不高 空间问题，清除后会产生大量不连续内存碎片 复制算法(Copying) 算法步骤 将内存分为大小相等的两块 每次使用其中一块，当被使用的内存块用玩了，则将该内存块中存货对象复制到另一块上，然后一次性清空该块。 算法不足之处：有一半空间是没有使用的 算法改进： ​ 如果1：1分的话，有点浪费内存;实际上大多数对象都是很快被回收，所以可以将内存分为一块较大的 Eden 空间和两块较小的Survivor 空间；使用 Eden 空间和其中一块 Survivor 。回首时，将 Eden和 Survivor 复制到另一块Survivor中，然后一次性清理。HotSpot默认的比例为8:1:1,也就是说内存空间的使用率为90%（新生代）;当 Survivor内存不足时，需要依赖其他内存（老年代）进行分配担保 标记整理法标记整理法是针对老年代的算法，它的步骤与 标记清除法 类似 标记处所有需要回收的对象(标记过程看 ”可达性分析算法” 这一章的内容) 所有存活对象移动到一端，然后直接清理端边界意外的内存 分代收集算法（Generational Collection）该算法是根据对象存货周期的不同将内存划几块，一般将Java堆分为 新生代和老年代,然后根据各个年代的特点选择不同的算法 新生代对象存活少，就选用复制算法 老年代存活率高，没有额外空间对它进行分配担保，则必须使用 标记清除法 或 标记整理法 HotSpot算法实现todo 枚举根节点的效率问题 》 影响可达性分析效率的因素： GC Roots节点主要在全局性的引用（常量或静态属性）与执行上下文（栈帧中的本地变量表），而如今应用仅仅方法区就有数百兆，想要逐个检查必然会消耗大量时间。 GC停顿所带来的时间消耗，分析工作必须确保一致性，所以在分析过程中必须停止所有Java执行线程（防止对象引用在分析过程中不断变化） 》 目标主流JVM使用的都是准确式GC,即虚拟机知道某个数据具体类型，以此减少了定位对象的依次间接查找开销;在HotSpot的实现中，使用一组称为 OopMap的数据结构达到这个目的，具体做法为 在类加载完成时，HotSpot就将内存偏移量和对应的数据的类型计算出来 在JIT编译过程中，也会在特定位置记录下栈和寄存器中哪些位置时引用 》在 OopMap 的帮助下，HotSpot可以快速准确完成 GC Roots的枚举 安全点(Safepoint) 》 HotSpot 并非为每条指令都生成OopMap，而是在特定位置记录这些信息，这些位置被称为安全点。即程序执行时只有在安全点才停顿下来开始GC。Safeponit不能太少，否则将导致GC等待时间过长，太短，则导致增大运行符合。安全点的选定基本以”是否具有让程序长时间执行的特征”为标准，而长时间执行的最明显特征时指令序列服用，如方法嗲用、循环跳转、异常跳转等，具有这些功能的指令才会产生Safepoint 垃圾收集器 相关概念补充： 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。 吞吐量：CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾回收时间) HotSpot 提供的收集器，收集器的连线表示它们可以配合使用 Serial 收集器Serial收集器 新生代收集器，单线程 JVM运行在 Client模式 下的默认 新生代收集器 它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（有一种叫法，叫 Stop The World ），直到它收集结束; Serial收集器优点： 简单高效，尤其是单个CPU环境。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率；只需要控制好能接受的停顿时间，那还是一个很好的选择 ParNew 收集器 ParNew收集器 新生代收集器,Serial收集器的并行多线程版本,其余行为与Serial收集器相同； 是运行在Server模式下的JVM的首选新生代收集器 唯一一个可以配合CMS的收集器 在单CPU下由于存在线程交互开销，性能可能低于Serial收集器 默认开启的线程数与CPU数量相同 Parallel Scsvenge收集器Parallel Scsvenge 新生代收集器，,同时也是并行的多线程收集器,与ParNew 收集器几乎一致 Parallel Scsvenge与其他浏览器的区别：关注点与其他收集器不同 其他浏览器关注点：尽可能缩短垃圾收集时用户线程的停顿时间 Parallel Scsvenge关注点：控制吞吐量 Parallel Scsvenge提供了两个参数用于精确控制吞吐量 -XX:MaxGCPauseMillis : 控制最大垃圾收集停顿时间(大于0的毫秒数)，收集器尽可能保证内存回收花费时间不超过设定值，时间缩短靠的是牺牲吞吐量和新生代空间换取的 -XX:GCTimeRatio : 直接设置大小（大于0小于100，垃圾手机时间占总时间的比率，即吞吐量的倒数）,如设置成19，那么GC时间就是 1/(1+19)= 5%,默认值99，即GC时间1%(1/(1+99)) Parallel Scsvenge其他参数 XX:+UserAdaptiveSizePolicy: 开关参数，用于打开GC自适应的调节策略, 打开后，无需手工指定新生代大小、Eden与Survior的比例等细节参数，JVM会自动调节。 Serial Old 收集器Serial Old Serial 老年代版本，单线程收集器，使用标记-整理算法 主要用于Client模式下的虚拟机 在Server模式下，有两大用途 a. 与Parallel Scsvenge收集器搭配使用 b. 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用 Parallel Old收集器Parallel Old Parallel Scsvenge老年代版本，多线程收集器，使用标记-整理算法 Parallel Old + Parallel Scsvenge 组合，适用于注重吞吐量以及CPU资源敏感的场合 CMS收集器 CMS收集器 是以获取最短回收停顿时间为目标的收集器，它是基于 标记清除算法实现的 它的运作过程如下 初始标记： 暂停所有的其他线程，并记录下直接与GC Roots相连的对象，速度很快 ；需要Stop The World 并发标记： 进行GC Roots Tracing(GC Root 追踪过程),同时开启GC和用户线程 重新标记： 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要Stop The World 并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫 CMD也被称为 并发低停顿收集器，但存在3个缺点： CMS对CPU敏感 默认启动的回收线程数为(CPU数量+3)/4，比如CPU数是2个，那么开启的线程数为1，占了50%的CPU资源，这样很可能导致用户程序的执行速度降低50%。 CMS收集器无法处理浮动垃圾 CMS式基于标记清除算法实现，所以会产生大量空间碎片 浮动垃圾： ​ 在并发清除阶段，用户线程依旧在运行，那么可能产生新的垃圾，而这些垃圾已经是在标记之后了，所以这次清楚并不会清理，只能留在下次。这样的垃圾，就被成为浮动垃圾 G1收集器 G1收集器 面向服务端应用的垃圾收集器 并发与并行：G1可以利用多个CPU以并发的方式让Java程序在执行GC的时候继续执行，以此来缩短 Stop The World 停顿时间， 分代收集：保留了分代的概念,以不同的方式去处理对象，且不需要其他收集器配合就可以完成整个GC 空间整合： a. 从整体看，G1是基于 标记整理算法实现的； b. 从局部(Region)来看，G1是基于 复制算法实现的；这两种算法都不会产生内存空间碎片 可预测的停顿：相对于CMS的大优势，G1可以建立可预测的停顿时间模型，让使用者明确指定一个长度为M毫秒的时间片段，消耗在垃圾收集上的时间不得超过M秒 G1收集器的Java堆内存布局 它将整个Java堆划分成大小相等的独立区域(Region),虽然保留新生代和老年代概念，但新生代和老年代不再物理隔离，都属于Region(不需要连续)的集合； G1可预测的停顿原因 ​ 它可以避免在整个Java堆中进行垃圾收集。由于划分成了多个Region，G1会根据Region的价值大小(回收所获取的空间大小和回收所需时间的经验值)，在后台维护一个优先级列表，优先回收最大的Region,从而保证在有限时间内获得更高的回收小路 Remembered Set 虚拟机使用它来避免垃圾收集器（G1收集器和其他类型收集器都是）进行堆扫描 G1收集器的运作大致分为以下几个步骤： 初始标记： a. 标记 GC Roots能直接关联的对象,需要Stop The World b. 修改TAMS（Next Top at Mark Start）的值，目的是让一下阶段用户程序并发运行时，能正确在Region中创建新对象 并发标记： 进行可达性分析，找出存活对象，耗时长 最终标记： a. 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要Stop The World b. 将这段时间对象变化记录在线程Remebered Set Logs里，然后将其合并到Remebered Set中 筛选回收： 对各个Region的回收价值和成本进行排序，根据用户希望的GC停顿时间来指定回收计划 GC 日志垃圾收集器参数总结 参数 描述 UseSerialGC 虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收 UseParNewGC 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收 UseConcMarkSweepGC 打开此开关后，使用ParNew+ CMS + Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 UseParallelGC 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old (PS Mark Sweep)的收集器组合进行内存回收 UserParallelOldGC 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收 SurvivorRatio 新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Survivor = 8:1 PretenureSizeThreshold 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 MaxTenuringThreshold 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代 UseAdaptiveSizePolicy 动态调整Java堆中各个区域的大小以及进入老年代的年龄 HandlePromotionFailure 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况 ParallelGCThreads 设置并行GC时进行内存回收的线程数 GCTimeRatio GC时间占总时间的比率，默认值是99， 即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效 MaxGCPauseMillis 设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效 CMSInitiatingOccupancyFraction 设置CMS收集器在老年代时间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效 UseCMSCompactAtFullCollection 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效 CMSFullGCsBeforeCompaction 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用CMS收集器时生效 相关注脚1.从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC ↩2.Full GC 是清理整个堆空间—包括年轻代和老年代[^ 3 ]: 清理老年代 ↩]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 并发]]></title>
    <url>%2Fblog%2F2018%2F02%2F03%2Fjava-thread.all%2F</url>
    <content type="text"><![CDATA[线程基础什么是线程》 现代操作系统在运行一个程序时，会为其创建一个进程 现代操作系统调度的最小单元是程也叫量级进程在一个进程里可以创建多个线程，这些线程都拥有各自的数器、堆栈和局部变量属性，并且能够访问共享的内存变量 》 线程好处 更好的利用处理器核心 更快的响应时间 更好的编程模型 线程的安全性》 想要编写线程安全的代码，核心在于要对态访问操作行管理，特别是对共享的和可变的状态的访问 》 所谓的线程的状态指的是存储在状态变量(如实例、静态域)中的数据，当然也可能包括其他以来对象的域(如HashMap的状态不仅是其本身，还存储在多个Map.Entry对象中) 》 共享意味着状态变量可以由多个线程同时访问，而变味着状态变量的值在生命周期内发生变化，当多个线程对一个对象的可变状态变量进行访问时，就可能引发线程安全性问题；所以必须得采用同步机制来协同这些线程对状态变量的访问； 》 java主要的同步机制有 synchronized 关键字 volatile Lock 原子变量 创建线程》 既然要运行线程，必然需要创建线程对象，java有两种创建线程的方式 通过java.lang.Runnable接口(推荐) 继承java.lang.Thread类 通过java.lang.Runnable接口(推荐)》 Runnable接口只有一个run()方法，是一个函数式接口，所以可以运用lambda表达式 12345//Runnable接口源码@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; 》 具体实现方式为 12345//使用lambda表达式，省去了实现Runnable接口//task code 写run()方法的实际逻辑处理Runnable runnable = () -&gt;&#123;task code&#125;Thread threadA = new Thread(runnable);Thread threadB = new Thread(runnable); 继承java.lang.Thread》 具体实现方式为 1234567//继承Thread并重写run()方法public class MyThread extends Thread &#123; @Override public void run() &#123; task code &#125;&#125; 两种方式的区别》 为什么要选择通过java.lang.Runnable接口的方式创建线程？ 将运行机制和任务进行分开解耦,Thread类负责运行机制，Runnable接口负责任务方法 减少线程开销，如果使用方式二，对于每个任务都需要创建一个线程；而方式一可以通过传入不同的Runnable,来实现一个线程执行不同任务 Thread 源码解析》 如下是java.lang.Thread的构造器的部分函数 12345678910111213141516171819202122private Thread(ThreadGroup g, Runnable target, String name,long stackSize, AccessControlContext acc,boolean inheritThreadLocals) &#123; ... if (name == null) &#123; throw new NullPointerException("name cannot be null"); &#125; // 当前线程就是该线程的父线程 Thread parent = currentThread(); this.group = g; // 将daemon、priority属性设置为父线程的对应属性 this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); this.name = name.toCharArray(); this.target = target; setPriority(priority); // 将父线程的InheritableThreadLocal复制过来 if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent. inheritableThreadLocals); // 分配一个线程ID tid = nextThreadID(); ...&#125; 》 可以看出： 一个新构造的线程对象是由其parent线程来进行空间分配的 child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal,同时还会分配一个唯一的ID来标识这个child线程 》 启动一个线程前，最好为这个线程设置线程名称，这么做的好处式在使用jstack分析程序或者进行问题排查时，就会给开发人员提供一些提示 12//java提供了为线程取名的构造函数public Thread(Runnable target, String name) 启动线程》 线程对象在初始化完成之后,调用如下方法启动线程 1aThread.start() 》 aThread.run()并不是启动线程，只是运行了run()方法 中断线程》 线程在以下两种情况下会终止 run方法执行到最后一句，并且return返回 出现了方法中没有捕获的异常 》 以上的两种终止方式，都是被动的去终止，那么如何手动的去终止？ 使用stop()，已经废弃 使用interrupt()方法请求中断线程 》 断理解为线程的一个标识位属性，来表示该线程是否被中断； 123456789//中断某个线程aThread.interrupt();//判断线程是否中断//如果线程中断，则返回true；但如果线程已经终止，那么无论是否被中断过，都会返回falseaThread.isInterrupted();//静态方法，对当前线程的中断标识位进行复位Thread.interrupted(); 》 此外，许多声明抛出InterruptedException的方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除 Thread.join()的使用》 含义： 线程A拥有线程B的索引，并再内部方法调用了线程B的threadB.join() 线程A必须等待线程B终止，才能从threadB.join()方法返回 join()内部利用了通知/等待机制 》 此外还有join(long millis)和join(long millis,int nanos):到达指定时间后，返回。 》 join()的部分源码 12345678// 加锁当前线程对象public final synchronized void join() throws InterruptedException &#123; // 条件不满足,继续等待 while (isAlive()) &#123; wait(0); &#125;// 条件符合,方法返回&#125; 》 可以发现，符合先前通知/等待经典范式的加锁、通知、处理逻辑三个步骤 线程其他方法1234567891011//使线程休 眠//单位毫秒。抛出InterruptedException异常 public static native void sleep(long millis) throws InterruptedException;//返回代表当前执行线程的对象，静态方法Thread.currentThread();//过期方法,原因是无法保证能释放占有的资源，容易引发死锁suspend()：暂停 resume()：恢复 stop()：停止 ThreadLocal的使用》ThreadLocal,即线程变量(泛型),是一个以ThreadLocal对象为键、任意对象为值的存储结构；一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值 123456// 创建ThreadLocal&lt;T&gt; aThreadLocal = new ThreadLocal&lt;T&gt;();// 设置值aThreadLocal.set(T);// 获取值aThreadLocal.get(); 线程状态 》 获取线程状态 12//java 5新增public State getState(); 》 Thread在内部定义了一个枚举类 1234567891011121314public enum State &#123; NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;&#125; NEW（新创建）状态》 创建了线程但没有执行start()方法，此时处于新创建状态 RUNNABLE (可运行) 状态》 调用了start()方法的线程就处于RUNNABLE状态，需要注意的是，该状态下的线程可能正在运行，也可能没有运行，所以是运行态 BLOCKED （阻塞）状态》 当系统试图获取一个内部的对象锁（注意，不是java.util.concurrent库中的锁），但该锁已被其他锁持有，当前线程就会进入阻塞状态 WAITING (等待)状态》 调用Object.wait方法、Thread.join方法，或者等待java.util.concurrent库中的Lock或Condition时,会进入等待状态 TIME_WAITING (计时等待)状态》 线程因调用了某些带超时参数的方法时，会计入该状态。该状态会持续到超时期满或者接收到适当的通知 TERMINATER (终止)状态》 线程终止时的状态 线程状态的变迁 》 Java将操作系统中的运行和就绪两个状态合并称为可运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法 线程的属性线程优先级》 Thred类定义了三个优先级常量和一个成员变量 *priority* ，利用该成员变量来控制优先级;优先级的范围: 1~10,默认5 1234567891011121314private int priority;/*** The minimum priority that a thread can have.*/public final static int MIN_PRIORITY = 1;/*** The default priority that is assigned to a thread.*/public final static int NORM_PRIORITY = 5;/*** The maximum priority that a thread can have.*/public final static int MAX_PRIORITY = 10; 》 设置优先级 ，需要注意的是，优先级收操作系统的影响，如在ubuntu下会忽略线程优先级 1aThread.setPriority(int level) 守护线程》 Thread类定义了一个成员变量 *daemon* 来标识该线程是否为守护线程,守护线程是一种支持型线程,它主要被用作程序中后台调度以及支持性工作，当只有守护线程时，Java虚拟机会退出 12/* Whether or not the thread is a daemon thread. */private boolean daemon = false; 》 将线程设置成守护线程 1aThread.setDaemon(true); 》 需要注意的是 Daemon属性需要在启动线程之前设置，不能在启动线程之后设置 Daemon中的finally块并不一定执行(JVM提前退出) 未捕获异常处理器》 Thread中定义了两个处理器，用来处理run()方法可能出现的异常。run()方法不能抛出受查异常，而非受查异常会导致线程终止，但在线程终止之前，异常会被传到处理器中。 1234567//如果不设置，则未捕获异常处理器为空// null unless explicitly setprivate volatile UncaughtExceptionHandler uncaughtExceptionHandler;// null unless explicitly set//静态的默认处理private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler; 》 设置未捕获异常处理器 1234public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)// 静态方法为每一个线程设置一个默认的处理器public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) 》 如果没有设置未捕获异常处理器的话，那么默认的异常处理器为java.lang.ThreadGroup类,该类是UncaughtExceptionHandler的实现类，其处理异常方式如下 该线程有父线程，则执行父线程的uncaughtException()方法;没有，则进入2 调用Thread.getDefaultUncaughtExceptionHandler(),调用静态的默认处理器；如果返回null,则进入3 如果异常(Throwable)是TreadDeath的一个实例，则什么都不做；否则，进入4 线程名字一集Throwable的栈轨迹输出到System.err上 123456789101112131415public void uncaughtException(Thread t, Throwable e) &#123; if (parent != null) &#123; parent.uncaughtException(t, e); &#125; else &#123; Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler(); if (ueh != null) &#123; ueh.uncaughtException(t, e); &#125; else if (!(e instanceof ThreadDeath)) &#123; System.err.print("Exception in thread \"" + t.getName() + "\" "); e.printStackTrace(System.err); &#125; &#125;&#125; 什么是竞争条件》 当两个或两个以上线程同时对同一数据进行访问修改，可能会出现错误。这种情况被称为竞争条件(race condition) 1234567//代码会执行以下几个步骤//1. 将account[1]加载到寄存器//2. i +1//3. 将结果写回account[1]//如果线程A执行了第1、2步，被抢夺了运行权。线程B夺过并修改了i的值，此时再回到线程A执行第3步，就会发生错误。account[1] = i++; 锁对象和条件对象》 为了实现对 代码块 并发访问的防干扰，java提供了两种机制 synchronized 关键字 显示锁的使用 》不过 在此之前，先理解锁对象和条件对象 锁对象》 如下代码，一旦一个线程封锁了锁对象，其他任何线程都无法通过lock()语句，会被阻塞，直到第一个线程释放锁对象 1234567myLock.lock();try&#123; do something&#125;finally&#123; myLock.unlock();&#125; 条件对象》 条件对象用于管理那些获得锁但无法执行有用工作的线程，当条件不满足时，先释放掉锁，等到条件满足在进行操作。一个锁对象，可以对应对各条件对象 12345678910111213//ThreadAmyLcok.lock();//锁定try&#123; //获取一个条件对象 aCondtion = myLock.newCondition(); //当条件不满足时，通过条件对象让线程阻塞，并释放锁 //该线程很一直处于阻塞状态，直到其他线程aCondition.signal()，唤醒等待的线程 //被唤醒后如果条件满足，则可以退出循环，继续操作了 while(!(ok to proceed))&#123; aCondition.await(); &#125;&#125; 》 条件对象需要设置几个方法 123456//让线程阻塞并释放锁await();//唤醒单个被await()阻塞的队列signal();//唤醒所有被await()阻塞的队列signalAll() 》 在Object中，已经定义了三个类似的方法 123456//让线程阻塞并释放锁wait();//唤醒单个被await()阻塞的队列notify();//唤醒所有被await()阻塞的队列notifyAll(); 》 Condition和Object的三个方法使用了不同的方法名，这样可以避免方法之间的冲突 synchronized关键字》 java从1.0开始，每个对象都有一个内部的对象锁，关键字synchronized可以修饰方法或者方法块所使用的就是该对象的内部对象锁和相关的条件 1234567891011121314public synchronized void method()&#123; do something;&#125;//可以把它看成public void method()&#123; //this.intrinsicLock相当于内部对象锁 this.intrinsicLock.lock(); try&#123; do something; &#125;finally&#123; this.intrinsicLock.unlock(); &#125;&#125; 》 不同的是，内部对象只有一个条件对象(毕竟，不能显式的newCondition来获取条件对象) 123this.intrinsiCondition.await();this.intrinsiCondition.signal();this.intrinsiCondition.signalAll(); 》 事实上，synchronized关键字锁的是this,可以通过如下代码来验证 1234//这种synchronized(obj)的方式通过一个对象来实现额外的原子操作，被称为客户端锁定，但并不推荐使用synchronized(this)&#123; ...&#125; 》 此外，可以通过如下代码来验证关键字也可以使用在静态方法上，此时锁的是对象的class文件,可以通过如下代码来验证 123synchronized(aObject.class)&#123; ...&#125; 》 synchronized带来便捷的同时，也存在了一些局限性 不能中断一个试图获取锁的程序 试图获取锁不能设置超时 只能单一条件 JVM中的synchronized》对于同步块的实现使用了monitorenter和monitorexit指令；同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED。本质是对一个对象的监视器（monitor）进行获取，而这个获取过程是排他的。 》监视器 任意一个对象都拥有自己的监视器 同步块或同步方法执行时必须获取该对象的监视器，才能进入； 没有获取到监视的线程将会被阻塞在同步块和同步方法的入口处，线程进入同步队列，状态变为BLOCKED状态。 》名词解释： 可见性：一个线程对共享变量值的修改，能够及实地被其他线程看到 排他性：即线程对块或方法的独立占有 volatile关键字》 java是支持多个线程访问同一个对象或者对象的成员变量，但每个线程，拥有的是它们的拷贝.因此，这个拷贝的对象可能不是最新的。当然，如果使用锁机制的话肯定没问题，但如果仅仅为了读写一两个实例域而使用锁，开销就显得有点大了。volatile关键字就是为实例域提供了一种免锁的机制。 》volatile 访问数据时，告知程序需要从共享内存中获取 改变数据时，告知程序需要同步刷新回共享内存。 保证所有线程对变量访问的可见性，但不保证其原子性 》 如果想要使用volatile来打到线程安全，必须同时满足下面两个条件 对变量的写操作不依赖于当前值(如x++,其操作其实是读-&gt;添加-&gt;赋值三个操作，需要保证原子性，所以不能使用volatile) 该变量没有包含在具有其他变量的不变式中 正确使用 volatile 的模式状态标志》 实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件 123456789101112volatile boolean shutdownRequested; ... public void shutdown() &#123; shutdownRequested = true; &#125; public void doWork() &#123; //每次循环，都会读取最新的shutdownRequested值，如果使用synchronized,就需要加锁，阻塞、唤醒等一些列操作 while (!shutdownRequested) &#123; // do stuff &#125;&#125; 一次性安全发布》对于以下语句，实际上又三个步骤 分配内存空间 初始化对象 对象指向内存空间 1theFlooble = new Flooble(); 》 但实际上，2，3可能重排，变为 分配内存空间 对象指向内存空间 初始化对象 》 再看如下代码 Thread A进行initInBackground()时，到达第二步，对象指向内存空间 Thread B在此时读取theFlooble,不为空，但对象却还没初始化 使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前 123456789101112131415161718192021//Thread Apublic class BackgroundFloobleLoader &#123; public volatile Flooble theFlooble; public void initInBackground() &#123; // do lots of stuff theFlooble = new Flooble(); // this is the only write to theFlooble &#125;&#125; // Thread Bpublic class SomeOtherClass &#123; public void doWork() &#123; while (true) &#123; // do some stuff... // use the Flooble, but only if it is ready if (floobleLoader.theFlooble != null) doSomething(floobleLoader.theFlooble); &#125; &#125;&#125; 队列同步器(AbstractQueuedSynchronizer)》 简称AQS，是一个抽象类，用来构建锁或者其他同步组件的基础框架，同步器设计是基于模板方法模式，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。子类通过继承他，来进行管理同步状态，AQS主要提供三个方法来改变或访问同步状态 123456//获取当前同步状态。getState()//设置当前同步状态。setState(int newState)：//使用CAS设置当前状态，该方法能够保证状态设置的原子性。传递当前线程“认为”的尾节点和当前节点，如果设置成功（即tail成功指向当前节点）,则返回truecompareAndSetState(int expect,int update)： 同步器可重写的方法 同步器的模板方法》 实现自定义同步组件时，将会调用同步器提供的模板方法，同步器提供的模板方法如下,其大致分为三类 独占式获取与释放同步状态 共享式获取与释放同步状态 查询同步队列中的等待线程情况 队列同步器的实现分析》 实现一个同步器，主要包括 同步队列 提供独占式同步状态获取与释放方法 提供共享式同步状态获取与释放方法 提供超时获取同步状态等同步器的核心数据结构与模板方法。 123456789101112131415//--------------同步队列结构---------------------------//头节点 private transient volatile Node head;//尾节点 private transient volatile Node tail;//同步状态 private volatile int state;//一个Node节点类 static final class Node&#123;...&#125;//--------------独占式同步状态获取与释放方法---------------------------public final void acquire(int arg)&#123;...&#125;//--------------共享式同步状态获取与释放方法---------------------------public final void acquireShared(int arg)&#123;...&#125; 》 当我们调用锁的lock()和unlock()方法时，实际上操作的就是同步器获取和释放同步状态 同步队列》 同步队列是为了将没有获取同步状态的线程先保存，然后通过FIFO双向队列完成 *`同步状态`* 的管理,其处理逻辑如下 线程A和线程B同时获取同步状态，A获取成功，相当于获取到了锁；B获取失败后进入线程中断，将B打包成节点放入到队列尾部 线程A执行完毕，释放同步状态（释放锁），因为FIFO的原则，获取到队列的首节点，从节点获取到相应的线程信息，唤醒该线程，线程被唤醒后，再次尝试获取同步状态； 》 节点属性描述： 》 此外，同步器拥有首节点（head）和尾节点（tail），以下是同步器的基本结构 入队操作》 对于入列操作，因为可能又多个线程同时操作入列，所以需要保证其安全性，同步器提供了一个基于CAS的设置尾节点的方法 12345678910//该方法时调用了Unsafe类的方法，Unsafe可以保证原子操作compareAndSetTail(Node expect,Node update)&#123; //this为需要更新的对象 //tailOffset:对象中变量的偏移量，可以理解为尾节点的引用地址 //expect:期望的值 //updaet: 更新值 //如果expect的值与update值一样，则更新tailOffset;相当于将tail指向update节点 return unsafe.compareAndSwapObject(this, tailOffset, expect, update);&#125; 》 入队的完整操作需要实现三个操作 node.prev指向原tail节点 tail节点指向node 原tail节点的后继节点指向node 123456789//node为需要入列的节点//先将node的前驱节点设置为tailnode.prev = t;//然后通过同步器提供的CAS设置尾节点方式，将tail节点指向node节点//如果成功，那么再将原tail节点的后继结点指向nodeif (compareAndSetTail(t, node)) &#123; t.next = node; return t;&#125; 出队操作》 对于获取首节点而言，并不需要使用CAS来保证，只需要正常的出队列即可 独占式同步状态获取与释放》 独占式同步状态获取释放流程 获取流程》 源码:AQS通过模板方法acquire()方法来进行独占式的同步状态获取，获取成功，则由该方法返回；失败，则进入等待队列 123456//AQS源码 public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; 》 对于tryAcquire(int arg)方法，它是同步器自定义的获取同步状态的方法,如果不重写，原方法只是抛出一个UnsupportedOperationException；(具体实现在后面的锁中讲，因为根据非公平性和公平性，实现方式是不同的) 1234//AQS中的tryAcquire protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException(); &#125; 》 对于addWaiter()方法,它会构造一个节点并加入队列列尾，在AQS，构造的是Node.EXCLUSIVE的节点；他会现场时快速添加一个节点，如果失败，在进入enq(node),进入死循环中进行CAS添加 12345678910111213141516171819202122232425262728293031323334353637private Node addWaiter(Node mode) &#123; //创建节点 Node node = new Node(Thread.currentThread(), mode); //尾节点 Node pred = tail; //尝试快速添加，可能由于多个请求并发进行而添加失败 if (pred != null) &#123; //尾节点设置为新节点的前驱节点 node.prev = pred; //使用compareAndSetTail,确保节点能够被线程安全添加列尾 if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //快速添加失败，进入死循环添加，将并发添加节点的请求通过CAS变得“串行化” enq(node); return node; &#125; //通过“死循环”来保证节点的正确添加，CAS private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; 》 对于acquireQueued()方法,可以看到，它会以死循环的方式从头节点开始获取同步状态，获取同步状态依旧是利用了tryAcquire()方法 1234567891011121314151617181920212223242526//AQS//在“死循环”中尝试获取同步状态，而只有 前驱节点 是头节点才能够尝试获取同步状态 final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; //设置中断标记 boolean interrupted = false; for (;;) &#123; //获取前驱节点 final Node p = node.predecessor(); //判断结点的前驱节点是否为头节点，因为头节点是获取成功状态的节点，如果当前节点的前驱节点是头节点的话，那么下一个获取同步状态的就是这个节点了 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 》 对于selfInterrupt()，它是当两种方式获取状态都失败后，让线程中断等待唤醒 123static void selfInterrupt() &#123; Thread.currentThread().interrupt(); &#125; 释放流程》 当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，唤醒其后继节点能够继续获取同步状态。 12345678910public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; //unparkSuccessor()使用LockSupport来唤醒处于等待状态的线程 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 共享式同步状态获取与释放》 与独占式的区别在于:同一时刻能否有多个线程同时获取到同步状态，如对于同一份文件的读操作，对于共享式的访问均被允许，而独占式只能有一个被访问，其他的独占式访问均被拒绝 获取流程123456789101112131415161718192021222324252627282930313233//tryAcquireShared(int arg)方法会返回一个int，如果int大于0，说明能够获取同步状态public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125; //doAcquireShared()在当前节点的前驱节点为头节点时，会尝试获取同步状态，如果返回值大于等于0，表示获取成功private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 释放流程》 通过调用releaseShared(int arg)方法释放同步状态 12345678public final boolean releaseShared(int arg) &#123; //tryReleaseShared:必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证,，因为释放同步状态的操作会同时来自多个线程。(独占式则不需要，因为是一个线程释放) if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 独占式超时获取同步状态》 独占式超时同步状态获取流程 》 同步器通过调用doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状态，即在指定的时间段内获取同步状态，其逻辑如下 主要需要计算出需要睡眠的时间间隔nanosTimeout，公式为：nanosTimeout-=now-lastTime（其中now为当前唤醒时间，lastTime为上次唤醒时间） 如果nanosTimeout大于0则表示超时时间未到，需要重新计算超时间隔nanosTimeout，继续睡眠nanosTimeout纳秒，反之，表示已经超时 12345678910111213141516171819202122232425262728293031323334353637//当前唤醒时间long now = System.nanoTime();private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; //上次唤醒时间 long lastTime = System.nanoTime(); final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; //-----------------重点----------------------------- if (nanosTimeout &lt;= 0) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); long now = System.nanoTime(); //计算时间，当前时间now减去睡眠之前的时间lastTime得到已经睡眠的时间delta，然后被原有超时时间nanosTimeout减去，得到了还应该睡眠的时间 nanosTimeout -= now - lastTime; lastTime = now; if (Thread.interrupted()) throw new InterruptedException(); &#125; //----------------------------------------------------------- &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 》 如果nanosTimeout小于等于spinForTimeoutThreshold（1000纳秒）时，将不会使该线程进行超时等待，而是进入快速的自旋过程(非常短的超时等待无法做到十分精确) Java中的锁Lock 接口》 Java SE 5之后，并发包中新增了Lock接口,在使用时需要显式地获取和释放锁。 》 不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放 》 Lock接口提供的synchronized关键字不具备的主要特性 》 Lock的API 重入锁(ReentrantLock)》 支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。 》 为什么要用到重入锁，如下场景 线程A通过aLock.lock()获取了锁 锁未被释放，线程A再次aLock.lock()获取锁，此时将无法获取，导致自己被自己阻塞 》 除此之外，该锁的还支持获取锁时的公平和非公平性选择 公平性：锁获取是顺序的，先请求锁的先获取锁 非公平性: 效率比公平性锁高 实现重进入》 线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞,需要解决两个问题 线程再次获取锁,判断当前线程是否为锁的占有者，是，则获取成功 锁的最终释放,利用计数器记录锁获取的次数，每次释放时计数器自减，当为0时表示锁成功释放 》 ReentrantLock默认为以非公平性实现 1234567891011121314151617181920212223242526272829303132333435//获取锁//判断当前线程是否为获取锁的线程来决定获取操作是否成功//重复获取只是添加了同步状态值final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123;//通过判断当前线程是否跟获取锁的线程是同一个线程 int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); //则将同步状态值进行增加并返回true,表示获取成功,相当于成功获取锁的线程再次获取锁，只是增加了同步状态值 setState(nextc); return true; &#125; return false;&#125;//释放锁//前n-1次方法必定返回false，只有同步状态为0时，才返回trueprotected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; 》 ReentrantLock公平性实现 1234567891011121314151617181920212223242526272829303132//区别在于判断条件多了hasQueuedPredecessors(),判断出当前线程所对应的节点是否有前驱节点，如果有，则返回true//也就是说，只有前驱线程获取并释放锁之后才能继续获取锁protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125;//AQS中的方法public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; //判断头节点和尾节点是否是同一节点，如果h == t,说明同步队列没有节点，肯定没有前驱节点 // 第二步判断，如果头节点的后继节点为空(只有一个节点，自然没有前驱节点) 或者 有后继节点但判断后继节点对应的线程是否是当前线程 //通过三个判断来判断出当前线程的是否是下一个需要执行的 return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); &#125; 》 非公平性锁的一个线程连续获取锁的情况 原因为刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待,可能造成线程饥饿（使得其他线程只能在同步队列中等待） 》 为什么非公平锁为默认？ 公平锁锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。 读写锁》 读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞;读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升 》 java 5.0之前是如何做的? 使用Java的等待通知机制 写操作开始，其他读操作等待，直到通知(防止幻读) 》 有了读写锁后怎么做？ 读操作，获取读锁，允许多个线程获取读锁进行访问，后继无法获取写锁 写操作，获取写锁,后续其他线程读写操作均被阻塞 ReentrantReadWriteLock》 Java并发包提供读写锁的实现是ReentrantReadWriteLock，它实现于ReadWriteLock,其特性如下 》 ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方法，而ReentrantReadWriteLock，还提供了一些便于外界监控其内部工作状态的方法 读写锁的实现分析》 ReentrantReadWriteLock的实现，主要包括： 读写状态的设计 写锁的获取与释放 读锁的获取与释放 锁降级 读写状态的设计》 读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态.写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态 》 如何在一个变量上维护多种状态？ 使用“按位切割” 高16位表示读，低16位表示写 》 如何确定状态? 通过位运算 写状态：status_value&amp;0x0000FFFF(高16位全部抹去) 写状态+1：status_value +1 读状态：status_value&gt;&gt;&gt;16(无符号补0右移16位) 读状态+1：status_value+(1&lt;&lt;16)，也就是status_value+0x00010000 写锁的获取与释放》 写锁是一个支持重进入的排它锁 如果当前线程已经获取了写锁，则增加写状态 如果当前线程在获取写锁时，读锁已经被获取其他或当前线程获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态 12345678910111213141516171819202122//写锁获取protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); int c = getState(); //获取写锁状态 int w = exclusiveCount(c); if (c != 0) &#123; //从c != 0-&gt;当前线程存在锁，w == 0,没有写锁，说明存在的是读锁 // 存在读锁或者当前获取线程不是已经获取写锁的线程 if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error("Maximum lock count exceeded"); setState(c + acquires); return true; &#125; if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123; return false; &#125; setExclusiveOwnerThread(current); return true;&#125; 》 写锁释放与ReentrantLock类似 读锁的获取与释放》 读锁是一个支持重进入的共享锁，它能够被多个线程同时获取,在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取;如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态 》 逻辑如下： 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态 如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁 1234567891011121314protected final int tryAcquireShared(int unused) &#123; for (;;) &#123; int c = getState(); int nextc = c + (1 &lt;&lt; 16); if (nextc &lt; c) throw new Error("Maximum lock count exceeded"); //如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态 if (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread()) return -1; //增加读状态，成功获取读锁 if (compareAndSetState(c, nextc)) return 1; &#125; &#125; 》 读锁释放，每次减少读状态(线程安全的，可能有多个读线程同时释放读锁)，减少的值是（1&lt;&lt;16） 锁降级》 锁降级指的是写锁降级成为读锁,步骤为 持有写锁(不释放,当前拥有的) 获取读锁 释放（先前拥有的）写锁 》 为什么要使用锁降级?从以下示例来解释,逻辑如下 数据发生变更后，update变为false(布尔类型且volatile修饰) 所有访问该方法的线程，感知变化，但只有一个线程能获取到写锁 写锁修改完数据后，释放锁（注意在写锁是释放前，又获取了读锁） 123456789101112131415161718192021222324252627public void processData() &#123; //读锁会被写锁阻塞 readLock.lock(); if (!update) &#123; // 必须先释放读锁 readLock.unlock(); // 锁降级从写锁获取到开始 writeLock.lock(); try &#123; if (!update) &#123; // 准备数据的流程（略） update = true; &#125; //再次获取读锁 readLock.lock(); &#125; finally &#123; writeLock.unlock(); &#125; // 锁降级完成，写锁降级为读锁 &#125; //step_join try &#123; // 使用数据的流程（略） &#125; finally &#123; readLock.unlock(); &#125;&#125; 》 为什么要再次获取读锁? 假设线程A释放写锁后不获取读锁 此时线程B在step_join 位置获取到了获取了写锁并修改了数据，但线程A无法获取到线程B更新的数据,继续使用数据就会不一致（注意此时setp_join位置线程A是没有任何锁的） 但如果加了读锁呢，线程A拥有读锁，线程B因为线程A持有读锁，导致其进入等待状态，直到线程A释放读锁，才能进行数据修改 》 问题：其实不用锁降级，单单依靠volatile和写锁，也能保证数据的安全性，那么为什么要用锁降级呢？ 》》 个人猜想：写锁会导致其他线程完全堵塞，而读锁是可以多线程访问的。比方说除了写锁锁定的代码外，其他代码是可以线程共享的，那么写锁降级读锁可以充分利用读锁的共享机制。 等待/通知机制》相关方法： 》等待/通知机制: 线程A调用对象O的wait()进入等待状态 线程B执行完程序后，调用对象O的notify()/notifyAll()方法 线程A收到通知从wait()方法返回，执行它的操作 》调用wait()、notify()以及notifyAll()时需要注意的细节 使用wait()、notify()和notifyAll()时需要先对调用对象加锁。 调用wait()方法后,线程状态由RUNNING变为WAITING,并将当前线程放置到对象的等待队列。 notify()或notifyAll()方法调用后,等待线程依旧不会从wait()返回,需要调用notify()或notifAll()的线程释放锁之后,等待线程才有机会从wait()返回。 notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中,而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列,被移动的线程状态由WAITING变为BLOCKED。 从wait()方法返回的前提是获得了调用对象的锁 等待/通知经典范式》将线程分为 等待方（消费者线程,感知变化，进行相应的操作） 通知方(生产者线程,修改某个对象的值) 》等待方规则: 获取锁对象 如果条件不满足,那么调用对象的wait()方法,被通知后仍要检查条件。 条件满足则执行对应的逻辑。 》伪代码: 123456synchronized(aObject.class) &#123; while(condition) &#123; aObject.wait(); &#125; doSomething;&#125; 》通知方规则： 获取所对象 改变条件 通知所有等待在对象上的线程。 》伪代码： 1234synchronized(aObject.class) &#123; change condition to true; aObject.notifyAll();`&#125; Condition接口》 任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式；而Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式 》 Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁,Condition依赖Lock对象 Condition的（部分）方法以及描述 condition对比Object Condition的实现分析》 ConditionObject是同步器AbstractQueuedSynchronizer的 内部类,每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。 》 Condition的实现，主要包括： 等待队列 等待 通知 等待队列》 等待队列 FIFO的队列 节点包含了一个线程引用（在Condition对象上等待的线程），复用了同步器中节点的定义 拥有首节点（firstWaiter）和尾节点（lastWaiter） 节点更新无需CAS,因为await()方法必然是获取了锁的线程 》 同步器拥有一个同步队列和多个等待队列 等待》 调用了Condition.await()方法，该线程将会释放锁、构造成节点加入等待队列并进入等待状态 》 逻辑如下 当前线程必定是获取到锁的线程,即同步队列的首节点 该方法会将当前线程构造成节点并加入等待队列 释放同步状态,也就是释放锁 阻塞当前队列 调用acquireQueued()方法加入到获取同步状态的竞争中，为的是唤醒后重写抢回锁，并从await()返回 12345678910111213141516171819202122public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); // 当前线程加入等待队列 Node node = addConditionWaiter(); // 释放同步状态，也就是释放锁 int savedState = fullyRelease(node); int interruptMode = 0; // 被唤醒的程序将从循环中退出，isOnSyncQueue(node)判断当前节点是否已经在同步队列 while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; //调用同步器的acquireQueued()方法加入到获取同步状态的竞争中 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; 》 注意: 释放锁之后，线程只有被唤醒才能从LockSupport.park(this)返回 返回之后，只有抢到锁才能从await()方法中返回,所以需要通过acquireQueued()来重写抢回锁 通知》 调用Condition的signal()方法,将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中 》 逻辑如下 当前线程必须是获取了到锁的线程（通过isHeldExclusively()检查） 移动等待队列首节点到同步队列并使用LockSupport唤醒节点中的线程 12345678910public final void signal() &#123; // 判断当前线程获取到了锁的线程 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); // 获取等待队列的首节点 Node first = firstWaiter; if (first != null) // 移动到同步队列并使用LockSupport唤醒节点中的线程 doSignal(first);&#125; 》 Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。 管道输入/输出流》 主要用于线程之间的数据传输,而传输的媒介为内存,管道输入/输出流主要包括了如下4种具体实现: PipedOutputStream PipedInputStream、 PipedReader PipedWriter 》 输入/输出流必须绑定起来,也就是调用connect()方法,否则会抛出异常 12//将输出流和输入流进行连接,否则在使用时会抛出IOExceptionaPipedWriter.connect(aPipedReader); java并发中的集合ConcurrentHashMap》 为什么要使用ConcurrentHashMap？ 线程不安全的HashMap会引起死循环 用线程安全的HashTable效率又非常低下（线程都竞争同一把锁） java 1.8中的CurrentHashMap有了较大的不同（以下介绍的是java 7 的版本） 》 HashMap会引起死循环 》 ConcurrentHashMap的锁分段技术 数据分段存储，并为每段数据配锁 当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 》 concurrentHashMap类图 由Segment数组结构和HashEntry数组结构组成 Segment是一种可重入锁（ReentrantLock）,包含一个HashEntry数组 HashEntry则用于存储键值对数据 当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁 ConcurrentHashMap的初始化》 ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的 初始化segments数组、segmentShift和segmentMask1234567891011121314if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS;int sshift = 0;//segments长度int ssize = 1;//计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度 (为了能通过按位与的散列算法来定位segments数组的索引)while (ssize &lt; concurrencyLevel) &#123; ++sshift;//ssize从1向左移位的次数 ssize &lt;&lt;= 1;&#125;//初始化segmentShift = 32 - sshift;//用于定位参与散列运算的位数（之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的）segmentMask = ssize - 1;//散列运算的掩码（掩码的二进制各个位的值都是1）this.segments = Segment.newArray(ssize); 》 concurrencyLevel的最大值是65535，这意味着segments数组的长度最大为65536，对应的二进制是16位;所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1 初始化每个segment》 segment的容量 threshold = （int）cap*loadFactor 1234567891011//initialCapacity是ConcurrentHashMap的初始化容量,默认16 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY;int c = initialCapacity / ssize;if (c * ssize &lt; initialCapacity) ++c;int cap = 1;//变量cap就是segment里HashEntry数组的长度,大小为2^c [c∈(0,n)]while (cap &lt; c) cap &lt;&lt;= 1;for (int i = 0; i &lt; this.segments.length; ++i) this.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);//，loadfactor是每个segment的负载因子，默认0.75 定位Segment》 虽然ConcurrentHashMap在插入和获取元素的时候，必须先通过散列算法定位到Segment,才能使用不同段的数据。ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再散列 12345678private static int hash(int h) &#123; h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16);&#125; 》 ConcurrentHashMap通过以下散列算法定位segment 1234//默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到散列运算中final Segment&lt;K,V&gt; segmentFor(int hash) &#123; return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];&#125; 》 此外，定位HashEntry所使用的hash算法如下 1int index = hash &amp; (tab.length - 1); ConcurrentHashMap的操作》 ConcurrentHashMap的3种操作 get操作 put操作 size操作 get操作》 get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读 123456public V get(Object key) &#123; //先进行一次再散列 int hash = hash(key.hashCode()); //再使用使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素 return segmentFor(hash).get(key, hash);&#125; 》 为什么get方法不用加锁？ 是它的get方法里将要使用的共享变量都定义成了volatile类型 根据ava内存模型的happen before原则，对volatile字段的写入操作先于读操作 put 操作》 put方法里需要对共享变量进行写入操作，在操作共享变量时必须加锁，其逻辑如下 首先定位到Segment，然后在Segment里进行插入操作 第一步判断是否需要对Segment里的HashEntry数组进行扩容(在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold）) 第二步定位添加元素的位置，然后将其放在HashEntry数组里 》 如何扩容? 创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里(对Segment的扩容) size操作》 要计算CurrentHashMap的大小，需要将Segment里的全局变量count累计相加，count是一个volatile变量，在获取时将得到最新的数据，但在计算相加前可能发生改变。 》 ConcurrentHashMap的做法如下 先尝试2次通过不锁住Segment的方式来统计各个Segment大小 如果果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小 通过使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化 Java并发中的队列》 实现一个线程安全的队列有两种方式： 使用阻塞算法（可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现） 使用非阻塞算法(用循环CAS的方式来实现) 非阻塞队列ConcurrentLinkedQueue》 ConcurrentLinkedQueue 基于链接节点的无界线程安全队列 FIFO规则排序 采用了“wait-free”算法（即CAS算法）来实现 》 concurrentLinkedQueue类图 由head节点和tail节点组成 每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成 默认情况下head节点存储的元素为空，tail节点等于head节点 入队列》 首先要理解入队操作(java入队操作与数据结构算法中的有些不同) 一个空的队列，插入节点A，Head.next设置为节点A，tail默认与head节点相同，也指向A 添加第二个节点B,节点A.next设置为节点B，同时更新tail指向节点B 添加第三个节点C，节点B.next设置为节点C 添加第四个节点D，节点C.next设置为节点D，同时更新tail指向节点D 可以看出，tail节点有可能不是尾节点(重点) 》 个入队过程逻辑如下 定位出尾节点(tail节点或者tail.next是尾节点) 使用CAS算法将入队节点设置成尾节点的next节点，如不成功则重试 1234567891011121314151617181920212223242526272829303132333435public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); // 入队前，创建一个入队节点 Node&lt;E&gt; n = new Node&lt;E&gt;(e); retry: // 死循环，入队不成功反复入队。 for (;;) &#123; // 创建一个指向tail节点的引用 Node&lt;E&gt; t = tail; // p用来表示队列的尾节点，默认情况下等于tail节点。 Node&lt;E&gt; p = t; for (int hops = 0; ; hops++) &#123; // 获得p节点的下一个节点。 Node&lt;E&gt; next = succ(p); // next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点 if (next != null) &#123; // 循环了两次及其以上，并且当前节点还是不等于尾节点 if (hops &gt; HOPS &amp;&amp; t != tail) continue retry; p = next; &#125; // 如果p是尾节点，则设置p节点的next节点为入队节点。 else if (p.casNext(null, n)) &#123; /*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/ if (hops &gt;= HOPS) casTail(t, n); // 更新tail节点，允许失败 return true; &#125; // p有next节点,表示p的next节点是尾节点，则重新设置p节点 else &#123; p = succ(p); &#125; &#125; &#125; &#125; 》 为什么ConcurrentLinkedQueue入队不是每次都变化tail节点? 减少CAS更新tail节点的次数，能提高入队的效率 ConcurrentLinkedQueue使用hops变量来控制并减少tail节点的更新频率 hops变量相当于tail与尾节点的长度，如果大于等于HOPS(默认1)，才更新节点 tail与尾节点越长，那么更新tail节点操作就越少，但是相对的每次定位到尾节点需要读取更多的节点（相当于通过添加对volatile变量的读操作减少写操作，而读操作开销要远远小于写操作，从而得到提升） 》 入队方法永远返回true，所以不能靠返回值判断是否入队成功 出队列》 逻辑如下 与入队列相同，通过hops来减少更新head节点操作 head 节点内有元素，则弹出元素 head节点为空，弹出head.next,更新head节点 12345678910111213141516171819202122232425262728293031 public E poll() &#123; Node&lt;E&gt; h = head;// p表示头节点，需要出队的节点 Node&lt;E&gt; p = h; for (int hops = 0; ; hops++) &#123;// 获取p节点的元素 E item = p.getItem();// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,// 如果成功则返回p节点的元素。 if (item != null &amp;&amp; p.casItem(item, null)) &#123; if (hops &gt;= HOPS) &#123;// 将p节点下一个节点设置成head节点 Node&lt;E&gt; q = p.getNext(); updateHead(h, (q != null)q :p); &#125; return item; &#125;// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外// 一个线程修改了。那么获取p节点的下一个节点 Node&lt;E&gt; next = succ(p);// 如果p的下一个节点也为空，说明这个队列已经空了 if (next == null) &#123;// 更新头节点。 updateHead(h, p); break; &#125;// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点 p = next; &#125; return null; &#125; 阻塞队列（BlockingQueue）》 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。 支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空 常用于生产者和消费者的场景 》 在阻塞队列不可用时，这两个附加操作提供了4种处理方式 抛出异常：队列满，再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常；队列空，当队列空时，从队列里获取元素会抛出NoSuchElementException异常 返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null 一直阻塞：队列满，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空 ·超时退出：队列满，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出；队列空，抛出元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出 》 如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true。 》 JDK 7提供了7个阻塞队列 ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。 DelayQueue：一个使用优先级队列实现的无界阻塞队列。 SynchronousQueue：一个不存储元素的阻塞队列。 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 ArrayBlockingQueue》 ArrayBlockingQueue: 由数组结构组成的有界阻塞队列 此队列按照先进先出（FIFO）的原则对元素进行排序 默认不保证线程公平的访问队列 》 创建一个公平的阻塞队列(即先阻塞先访问) 1ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true); 》 访问者的公平性是使用可重入锁实现的 12345678public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; LinkedBlockingQueue》 LinkedBlockingQueue 用链表实现的有界阻塞队列 默认和最大长度为Integer.MAX_VALUE FIFO PriorityBlockingQueue 》 PriorityBlockingQueue 支持优先级的无界阻塞队列 默认情况下元素采取自然顺序升序排列 可以自定义类实现compareTo()方法来指定元素排序规则;也可以初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序 但不能保证同优先级元素的顺序 DelayQueue》 DelayQueue 支持延时获取元素的无界阻塞队列 使用PriorityQueue来实现， 队列中的元素必须实现Delayed接口 在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。 》 应用场景 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。 定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。 实现Delayed接口》 第一步，在对象创建的时候，初始化基本数据 1234567private static final AtomicLong sequencer = new AtomicLong(0);ScheduledFutureTask(Runnable r, V result, long ns, long period) &#123; super(r, result); this.time = ns;//time记录当前对象延迟到什么时候可以使用 this.period = period; this.sequenceNumber = sequencer.getAndIncrement();//sequenceNumber来标识元素在队列中的先后顺序&#125; 》 第二步，实现getDelay方法 1234//该方法返回当前元素还需要延时多长时间，单位是纳秒(注意当time小于当前时间时，getDelay会返回负数)public long getDelay(TimeUnit unit) &#123; return unit.convert(time - now(), TimeUnit.NANOSECONDS);&#125; 》 第三步，实现compareTo方法来指定元素的顺序 12345678910111213141516171819public int compareTo(Delayed other) &#123; if (other == this) // compare zero ONLY if same object return 0; if (other instanceof ScheduledFutureTask) &#123; ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other; long diff = time - x.time; if (diff &lt; 0) return -1; else if (diff &gt; 0) return 1; else if (sequenceNumber &lt; x.sequenceNumber) return -1; else return 1; &#125; long d = (getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS)); return (d == 0) 0 : ((d &lt; 0) -1 : 1); &#125; 实现延时阻塞队列1234567891011121314151617181920//从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程long delay = first.getDelay(TimeUnit.NANOSECONDS);if (delay &lt;= 0) return q.poll();//leader：等待获取队列头部元素的线程//如果leader不等于空，表示已经有线程在等待获取队列的头元素,使用await()方法让当前线程等待信号else if (leader != null) available.await();else &#123; //leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间 Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; available.awaitNanos(delay); &#125; finally &#123; if (leader == thisThread) leader = null; &#125;&#125; SynchronousQueue》 SynchronousQueue 不存储元素的阻塞队列 每一个put操作必须等待一个take操作，否则不能继续添加元素 支持公平访问队列,默认非公平访问 非常适合传递性场景 吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue 》 创建公平性访问的SynchronousQueue 1234//fair == true -&gt; 公平访问public SynchronousQueue(boolean fair) &#123; transferer = fair ? new TransferQueue() : new TransferStack();&#125; LinkedTransferQueue》 LinkedTransferQueue 由链表结构组成的无界阻塞TransferQueue队列 相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。 transfer方法》 transfer方法 如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者;。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回 1234//尝试把存放当前元素的s节点作为tail节点Node pred = tryAppend(s, haveData);//让CPU自旋等待消费者消费元素（自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。）return awaitMatch(s, pred, e, (how == TIMED), nanos); tryTransfer方法》 用来试探生产者传入的元素是否能直接传给消费者 如果没有消费者等待接收元素，则返回false 如果消费了元素，则返回true 该方法无论消费者是否接收，方法立即返回；，而transfer方法是必须等到消费者消费了才返回 》 此外还有带有时间限制的tryTransfer（E e，long timeout，TimeUnit unit）方法 试图把生产者传入的元素直接传给消费者 如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false 如果在超时时间内消费了元素，则返回true。 LinkedBlockingDeque》 LinkedBlockingDeque 由链表结构组成的双向阻塞队列 因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争 相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法 在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。 双向阻塞队列可以 运用在“工作窃取”模式中。 阻塞队列的实现原理》 在JDK中，使用通知模式实现;所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用 todo Java中的13个原子操作类》 Java从JDK 1.5开始提供了java.util.concurrent.atomic包,一共包含13个类，属于4种类型的原子更新方式，分别是 原子更新基本类型 原子更新数组 原子更新引用 原子更新属性（字段） 》 Atomic包里的类基本都是使用Unsafe实现的包装类 原子更新基本类型类》 Atomic包提供了以下3个类 AtomicBoolean：原子更新布尔类型。 AtomicInteger：原子更新整型。 AtomicLong：原子更新长整 》 以AtomicIntege为例,常用方法如下 12345678910//以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。int addAndGet（int delta）//update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。boolean compareAndSet（int expect，int update）//以原子方式将当前值加1，注意，这里返回的是自增前的值int getAndIncrement()//最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值void lazySet（int newValue）//以原子方式设置为newValue的值，并返回旧值int getAndSet（int newValue） 原子更新数组》 Atomic包提供了以下3个类 AtomicIntegerArray：原子更新整型数组里的元素。 AtomicLongArray：原子更新长整型数组里的元素。 AtomicReferenceArray：原子更新引用类型数组里的元素。 》 以AtomicIntegerArray为例，其主要是提供原子的方式更新数组里的整型，常用方法如下 1234//以原子方式将输入值与数组中索引i的元素相加。int addAndGet（int i，int delta）：//如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。boolean compareAndSet（int i，int expect，int update） 原子更新引用类型》 Atomic包提供了以下3个类 AtomicReference：原子更新引用类型。 AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 AtomicMarkableReference：原子更新带有标记位的引用类型 原子更新字段类》 Atomic包提供了以下3个类 AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 AtomicLongFieldUpdater：原子更新长整型字段的更新器。 AtomicStampedReference：原子更新带有版本号的引用类 Java并发中的工具类并发工具类》在JDK的并发包里提供了几个非常有用的并发工具类 CountDownLatch CyclicBarrier Semaphore Exchanger CountDownLatch》CountDownLatch允许一个或多个线程等待其他线程完成操作。 todo LockSupport工具类》当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作;LockSupport定义了一组静态方法，以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程 》LockSupport提供的阻塞和唤醒方法 》java6 添加 park(Object blocker) parkNanos(Object blocker,long nanos) parkUn til(Object blocker,long deadline) 用于实现阻塞当前线程的功能,blocker是用来标识当前线程在等待的对象(阻塞对象),该对象主要用于问题排查和系统监控(能传递更多的信息)，可以通过dump 线程来对比 Java中的线程池》线程池能够带来3个好处 降低资源消耗 提高响应速度 提高线程的可管理性 线程池的初始化》ThreadPoolExecutor是Java提供的一个核心的线程池,通过它来创建一个线程池 1234567new ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 》其参数定义如下 》corePoolSize 线程池的基本大小 任务数在小于它时每提交一个任务就会创建一个新的线程（无论其他线程是否空闲） 当任务数大于它时，不会再创建线程 可以使用prestartAllCoreThreads()方法提前创建并开启所有基本线程 》maximumPoolSize 线程池最大数量 如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务 使用了无界的任务队列此参数失效 》keepAliveTime 线程活动保持时间 线程池的工作线程空闲后，保持存活的时间 任务多时且执行时间短，可以调大它提高线程利用率 》TimeUnit 线程活动保持时间的单位 可选单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒） 》BlockingQueue 任务队列 用于保存等待执行的任务的阻塞队列 可以选择阻塞队列的有：ArrayBlockingQueue、SynchronousQueue、LinkedBlockingQueue、PriorityBlockingQueue 》ThreadFactory 创建线程的工厂 可以通过线程工厂给每个创建出来的线程设 置更有意义的名字 (使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字) 》RejectedExecutionHandler 饱和策略 在队列和线程池都满情况下使用，可选策略有 AbortPolicy，表示无法处理新任务时抛出异常,默认 CallerRunsPolicy：只用调用者所在线程来运行任务 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务 DiscardPolicy：不处理，丢弃掉 也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略 向线程池提交任务》可以使用两个方法向线程池提交任务 execute()：提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功 submit()：提交需要返回值的任务，线程池会返回一个Future类型的对象， 》Future： 通过该对象可以判断任务是否执行成功 可以通过future的get()方法来获取返回值，get()方法造成阻塞 可以使用超时方法get（long timeout，TimeUnit unit） 关闭线程池》可以通过调用线程池提供的两个方法来关闭线程池 shutdown：只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程（通常使用） shutdownNow：将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表（如果任务无需执行完成，则可以使用） 原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程(无法响应中断的任务可能永远无法终止) 》判断是否关闭 1234//执行shutdown()和shutdownNow后就会返回trueaThreadPoolExecutor.isShutdown()//执行shutdown()和shutdownNow后,且任务全部关闭才返回trueaThreadPoolExecutor.isTerminaed() 合理地配置线程池》要想合理地配置线程池，就必须首先分析任务特性 任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 任务的优先级：高、中和低。 任务的执行时间：长、中和短。 任务的依赖性：是否依赖其他系统资源，如数据库连接 》建议使用有界队列 线程池的监控》监控线程池的时候可以使用以下属性 taskCount：线程池需要执行的任务数量。 completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。 largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。 getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。 getActiveCount：获取活动的线程数。 线程池的实现原理》线程池的处理逻辑 判断核心线程池里的线程是否都在执行任务；否，则创建新的线程来执行任务；是，则进入2 判断工作队列是否已经满；否，则将新提交的任务存储在这个工作队列里；是，则进入3 判断线程池的线程是否都处于工作状态;否，则创建一个新的工作线程来执行任务；是，则交给饱和策略来处理这个任务 》执行过程(ThreadPoolExecutor为例) 判断：如果当前运行的线程数n与corePoolSize如果n &lt; corePoolSize 则创建新线程来执行任务（执行这一步骤需要获取全局锁）;结束；如果n &gt;= corePoolSize,则将任务加入BlockingQueue,进行下一步判断 判断：BlockingQueue是否已满否则，则将任务加入队列中;结束；如果队列已满，则需要创建新的线程来处理任务（需要获取全局锁）;继续判断 判断：创建新进程后进程数是否超出maximumPoolSize是，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法否，则创建线程，结束 123456789101112131415public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); // 如果线程数小于基本线程数，则创建线程并执行当前任务 if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; // 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。 if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); &#125; else if (!addIfUnderMaximumPoolSize(command)) // 抛出RejectedExecutionException异常 reject(command); // is shutdown or saturated &#125;&#125; 》线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行 12345678910111213//Woker类的run方法 public void run() &#123; try &#123; Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) &#123; runTask(task); task = null; &#125; &#125; finally &#123; workerDone(this); &#125; &#125; 》线程池中的线程执行任务分两种情况 在execute()方法中创建一个线程时，会让这个线程执行当前任务 线程执行完任务后，会反复从BlockingQueue获取任务来执行。 Java框架Fork/Join框架》 Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。 工作窃取算法》 工作窃取（work-stealing）算法 指某个线程从其他队列里窃取任务来执行. 通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行 窃取任务的线程永远从双端队列的尾部拿任务执行 优点:充分利用线程进行并行计算，减少了线程间的竞争 缺点:在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列 Fork/Join框架的设计》 步骤 分割任务，通过fork类将任务切割成足够小的子任务 执行任务并合并结果，子任务放入双端队列中，多个线程从队列中获取；子任务执行结果放在同一个队列里，启动一个线程合并结果 》 Fork/Join使用两个类完成任务 ForkJoinTask,创建ForkJoin任务，提供fork()和join()方法,一般继承它的子类RecursiveAction：用于没有返回结果的任务。RecursiveTask：用于有返回结果的任 ForkJoinPool,ForkJoinTask需要通过ForkJoinPool来执行 》 任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。 使用Fork/Join框架》 以计算1+2+3+4的结果为例 假设每个子任务最多执行两个数的相加，则设置分割的阈值是2 因为是有结果的任务，所以必须继承RecursiveTask 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class CountTask extends RecursiveTask&lt;Integer&gt; &#123; private static final int THRESHOLD = 2; // 阈值 private int start; private int end; public CountTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0;// 如果任务足够小就计算任务 boolean canCompute = (end - start) &lt;= THRESHOLD; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123;// 如果任务大于阈值，就分裂成两个子任务计算 int middle = (start + end) / 2; CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle + 1, end);// 执行子任务 leftTask.fork(); rightTask.fork();// 等待子任务执行完，并得到其结果 int leftResult=leftTask.join(); int rightResult=rightTask.join();// 合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125; public static void main(String[] args) &#123; ForkJoinPool forkJoinPool = new ForkJoinPool();// 生成一个计算任务，负责计算1+2+3+4 CountTask task = new CountTask(1, 4);// 执行一个任务 Future&lt;Integer&gt; result = forkJoinPool.submit(task); try &#123; System.out.println(result.get()); &#125; catch (InterruptedException e) &#123; &#125; catch (ExecutionException e) &#123; &#125; &#125;&#125; Fork/Join框架的异常处理》 检查任务是否已经抛出异常或已经被取消 1aForkJoinTask.isCompletedAbnormally() 》 获取异常 12//返回Throwable对象，如果任务被取消了则返回CancellationException;任务没有完成或者没有抛出异常则返回nullaForkJoinTask.getException() Fork/Join框架的实现原理Executor框架》 在JDK 5之前，java线程既是工作单元，也是执行机制，JDK 5之后把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供,其内部使用了线程池机制,通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作 Executor框架的两级调度模型》 在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。 》 如图所示 上层：ava多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程 底层：操作系统内核将这些线程映射到硬件处理器CPU上 Executor框架的成员ThreadPoolExecutor》 ThreadPoolExecutor： 线程池的核心实现类 用来执行被提交的任务。 通常使用工厂类Executors来创建 》 ThreadPoolExecutor主要由下列4个组件构成。 corePool：核心线程池的大小。 maximumPool：最大线程池的大小。 BlockingQueue：用来暂时保存任务的工作队列 RejectedExecutionHandler：当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已经饱和时（达到了最大线程池大小且工作队列已满），execute()方法将要调用的Handler 》 Executors可以创建3种类型的ThreadPoolExecutor FixedThreadPool：创建使用固定线程数的FixedThreadPool(适用于负载比较重的服务器) SingleThreadExecutor：创建使用单个线程的SingleThreadExecutor（适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。） CachedThreadPoo：创建一个会根据需要创建新线程的CachedThreadPool（大小无界线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。） FixedThreadPool12345678public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor( nThreads, nThreads, 0L, //keepAliveTime设置为0L，意味着多余的空闲线程会被立即终止 TimeUnit.MILLISECONDS, new inkedBlockingQueue&lt;Runnable&gt;());&#125; SingleThreadExecutorCachedThreadPoolScheduledThreadPoolExecutor》 ScheduledThreadPoolExecutor 线程池实现类 可以在给定的延迟后运行命令，或者定期执行命令 通常使用工厂类Executors来创建 》 Executors可以创建2种类型的ScheduledThreadPoolExecutor ScheduledThreadPoolExecutor：，创建固定个数线程的ScheduledThreadPoolExecutor(适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景) SingleThreadScheduledExecutor：创建单个线程的ScheduledThreadPoolExecutor(适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。) Future接口和实现Future接口的FutureTask类》 Future接口和实现Future接口的FutureTask类 表示异步计算的结果 通过sumbit()提交给线程池后返回该类型的数据 Runnable接口和Callable接口》 Runnable接口和Callable接口 可以被ThreadPoolExecutor或Scheduled-ThreadPoolExecutor执行 Runnable不会返回结果 Callable可以返回结果 工具类Executors可以把一个Runnable对象封装为一个Callable对象 12345//Runnable-&gt;Callable// sumbit后返回nullExecutors.callable（Runnable task）// sumbit 后返回resultExecutors.callable（Runnable task，Object result） 任务的执行： Executor框架的使用示意图 》 执行流程 主线程创建实现Runnable或者Callable接口的任务对象 Runnable对象直接交给ExecutorService执行;或者把Runnable对象或Callable对象提交给ExecutorService执行 123456//直接执行ExecutorService.execute（Runnablecommand）;//提交,会返回实现Future接口的对象（一般是FutureTask对象）//FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。Executor-Service.submit（Runnable task）ExecutorService.submit（Callable&lt;T&gt;task） 主线程可以执行FutureTask.get()方法来等待任务执行完成。主也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java 并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 基础]]></title>
    <url>%2Fblog%2F2018%2F02%2F02%2Fjava.all%2F</url>
    <content type="text"><![CDATA[java 基本数据类型八大基础数据类型 java一共有8个基本数据类型 数据类型 存储需求 取值范围 前/后缀 int 4字节 -2^32~ 2^32-1 short 2字节 -2^16~ 2^16 -1 long 8字节 -2^64~2^64 -1 后缀：L或l,如40000L byte 1字节 -2^8 ~ 2^8 -1 float 4字节 后缀F或f double 8字节 默认，后缀可以是D或d char 1个字符 \u0000~\Uffff boolean true/false JAVA范围与j运行ava代码机器无关,因为Java程序必须保证在所有机器上都能够得到相同的结果，所以各种数据类型的取值范围必须固定。 浮点类型的特殊常量 特殊值 对应常量 正无穷大 Double.POSITIVE_INFINITY 、 Float.POSITIVE_INFINITY 负无穷大 Double.NEGATIVE_INFINITY、Float.NEGATIVE_INFINITY NaN(不是一个数) Double.NaN、Float.NaN 浮点类型不适用于无法接受舍入误差的金融计算中，如2.0 -1.1 会输出0.8999999999999999，而不是0.9 原因：浮点数值采用二进制系统表示法（二进制无法精确表示分数1/10） 如果不允许输入误差，需要使用 BigDecimal类 数值类型转换 分为自动类型转换和强制类型转换。 自动类型转换 满足以下条件将自动转换 这2种类型是兼容的。 目的类型数的范围比来源类型的大。 当以上2个条件都满足时,拓宽转换(widening conversion)发生数字类型和字符类型(char)或布尔类型(bollean)是不兼容的。字符类型(char)和布尔类型(bollean)也是互相不兼容的。 虚线表示数据可能丢失,如果对图中箭头反向转换，会报错，需要强制转换 强制转换1(target-type)value 截断(truncation):把浮点值赋给整数类型时一种不同的类型转换,小数部分会被舍去。 java 257强制转换赋值给byte会怎么样？323呢? 答：byte范围是256,所以257赋值后，值为1(257/256)。323为67(323/256) 表达式中的类型提升 所有byte型和short型的值在表达式中会被提升到int类型 好处：避免了计算过程中中间结果超出范围 缺点，需要强转 类型提升规则： 如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。 否则， 如果其中一个操作数是 float 类型， 另一个操作数将会转换为 float 类型。 否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 否则， 两个操作数都将被转换为 int 类型 12345byte a = 50;byte b = 20;int i = b * a; //okb = b * 2;//error,b * 2 会提升到int,b 是一个byte b = (byte)b; //ok 对象包装器和自动装箱 基本类型对应的类，被称为包装器。 包装器 原始 Integer int Long long Float float Double double Short short Byte byte Character char Void void Boolean boolean Number类 Integer、Long、Float、Double、Short、Short均继承于Number类 123456789101112131415161718192021222324//Number类源码package java.lang;public abstract class Number implements java.io.Serializable &#123; public abstract int intValue(); public abstract long longValue(); public abstract float floatValue(); public abstract double doubleValue(); public byte byteValue() &#123; return (byte)intValue(); &#125; public short shortValue() &#123; return (short)intValue(); &#125; private static final long serialVersionUID = -8742448824652078965L;&#125; 装箱和拆箱是编译器认可的，而不是虚拟机（编译器在生成类的字节码的时候，插入必要的方法调用，而虚拟机这是执行这些字节码） 自动装箱 将基本数据赋值给包装器123list.add(3);//自动装箱成list.add(Integer.valueOf(3)); 自动拆箱 将包装器对象赋值给基本数据 123int n = list.get(i);//自动拆箱int n = list.get(i).intValue(); 数组数组初始化1234//自动初始化值new type[size];//自定义初始化值int[] smallPrimes = &#123; 2, 3, 5, 7, 11, 13 &#125;; 初始化匿名数组1new int[] &#123; 17, 19, 23, 29, 31, 37 &#125; 多维数组1234567int twoD[][] = new int[4][5];// 也可以,第二维手工分配 int twoD[][] = new int[4][];twoD[0] = new int[5];twoD[1] = new int[5];twoD[2] = new int[5];twoD[3] = new int[5]; 运算符 运算符 结果 ~ 按位非(NOT)(一元运算) &amp; 按位与(AND), a &amp; b, 都为1时为1，其余为0；如果是布尔运算，则为 两者为true时为true &#124; 按位或(OR), a \&#124; b, 其中一个为1则为1 ^ 按位异或(XOR)，a ^b, 两值相同为1,（ a 异或两次b,还是a） &gt;&gt; 右移,被移走的最高位(最左边的位)由原来最高位的数字补充 &gt;&gt;&gt; 右移,左边空出的位以0填充 &lt;&lt; 左移,高阶位都被移出(并且丢弃),并用0填充右边 ?: 三元运算符(IF-THEN-ELSE)，condition ? expression1 : expression2; &amp;&amp; 短路与，a &amp;&amp; b, a为false，则不再考虑b,即使b报错 &#124;&#124; 短路或， a &#124;&#124; b,a为true，则不考虑b，即使b报错 流程控制语句选择语句if语句12if (condition) statement1;else statement2; switch语句 需满足: 表达式expression必须为byte,short,int或char类型。 每个case语句后的值value必须是与表达式类型兼容的特定的一个常量(它必须为一个常量,而不是变量)。 重复的case值是不允许的。 如果没有break语句,程序将继续执行下面的每一个case语句,直到遇到break语句(或switch语句的末尾) 12345678910111213141516switch (expression) &#123; case value1: // statement sequence break; case value2: // statement sequence break; . . . case valueN: // statement sequence break; default: // default statement sequence&#125; 循环语句while语句 while语句在循环一开始就计算条件表达式,若开始时条件为假,则循环体一次也不会执行 123while(condition) &#123;// body of loop&#125; do-while循环 do-while循环总是先执行循环体,然后再计算条件表达式，所以至少一次 123do &#123;// body of loop&#125; while (condition); for循环123for(initialization; condition; iteration) &#123;// body&#125; Java允许你在for循环的初始化部分和反复部分声明多个变量1234for(a=1, b=4; a&lt;b; a++, b--) &#123; System.out.println("a = " + a); System.out.println("b = " + b);&#125; 跳转语句break语句 作用： 在switch语句中,它被用来终止一个语句序列 能被用来退出一个循环 能作为一种“先进”的goto 语句来使用 break不是被设计来提供一种正常的循环终止的方法!!! 把 break 当作 goto 的一种形式来用,标签break语句的通用格式12345label:&#123; ... break label//直接跳出循环，调到label块的尾部执行some code..&#125;// some code.. continue语句 跳出当前循环，开始新的一次循环 return语句 return语句用来明确地从一个方法返回 对象与类 类： 对象的模板(template) 对象：类的一个实例(instance) 实例变量(instance variables)：定义在类中的数据或变量 类的成员: 定义在类中的方法和实例变量 类的组成方法参数数量可变的方法1public static double max(int aint, double... values) 方法重载 方法重载（overloaded）：同一个类中的2个或2个以上的方法可以有同一个名字,只要它们的参数声明不同即可 在一些情况下,Java的自动类型转换也适用于重载方法的自变量 123456//当只有double类型的方法时，会把int扩大到double void test(double a) &#123;System.out.println("Inside test(double) a: " + a);&#125;test(10);// print 10; 域 默认初始化域 类型 值 基本数值类型 0 布尔值 false 对象引用 null 块初始化块 在一个类的声明中， 可以包含多个代码块；只要构造类的对象，这些块就会被执行 静态初始化块 对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块 123static&#123; some code&#125; 构造器无参构造器 没有编写构造器，系统就会提供一个无参数构造器，并将值默认初始化 可以 使用 this 关键字调用其他构造器,this放在第一行 ，这么做可以对公共的构造器代码部分只编写一次 构造器调用处理步骤 具体顺序如下 父类静态代码块 子类静态代码块 父类构造代码块 父类构造函数 子类构造代码块 子类构造函数 类的参数传递 计算机语言给子程序传递参数的方法有两种: 值传递：当一个简单类型传递给一个方法时,使用按值传递。将一个参数值(value)复制成为子程序的正式参数 引用传递：对象传递使用引用传递。参数的引用(而不是参数值)被传递给子程序参数 类之间的关系 关系 描述 依赖 uses-a 聚合 has-a 继承 is-a 嵌套类和内部类 嵌套类(nested classes): 在另一个类中定义的类,嵌套类可以访问嵌套它的类的成员,包括private成员。但是,包围类不能访问嵌套类的成员。 嵌套类一般有2种类型,前面加static标识符的和不加static标识符的 static的嵌套类：只能通过对象来访问它外部类的成员 非static的嵌套类：又称内部类，可以访问它的外部类的所有变量和方法 为什么使用内部类? 内部类方法可以访问该类定义所在的作用域中的数据, 包括私有的数据 内部类可以对同一个包中的其他类隐藏起来 当想要定义一个回调函数且不想编写大量代码时,使用匿名内部类比较便捷 内部类的特殊语法规则 内部类中引用外围类 12// 如OuterlCLass.this.name就是引用外围类的name变量OuterCLass.this 更明确地编写内部类构造器 12// 如，this.new Node();编写一个内部Node类的构造器outerObject.new InnerCLass(...); 外围类中引用内部类 1OuterClass.InnerClass; 局部内部类 局部内部类： 在方法中定义的类 通常类只使用一次时可以将其定义为局部内部类 局部类不能用 public 或 private 访问说明符进行声明.它的作用域被限定在声明这个局部类的块中 局部类有一个优势, 即对外部世界可以完全地隐藏起来 123456789// 这里的InnerClass,只有start方法知道它的存在public void start()&#123; class InnerClass&#123; public void method ( ActionEvent event)&#123; ... &#125; InnerClass aInnerCLass = new InnerClass(); ....&#125; 局部内部类访问不仅可以访问外部类，还可以访问局部变量,但那些局部变量必须为 final。 匿名内部类 匿名内部类：只需要创建一次,无需为类命名 1234// 直接通过父接口来创建，方法实现直接写在&#123;&#125;SuperType aClass = new SuperType(construction parameters)&#123; .....&#125; 静态内部类 只是为了把一个类隐藏在另外一个类的内部 , 并不需要内部类引用外围类对象,此时可以将内部类声明为static 在内部类不需要访问外围类对象的时候, 应该使用静态内部类 与常规内部类不同 , 静态内部类可以有静态域和方法 声明在接口中的内部类自动成为 static 和 public 类(即接口中的都是静态公有内部类) 抽象类 关键字：abstract 抽象类介绍 可以包含具抽象方法、具体数据、具体方法 类即使不含抽象方法，也可以将类声明为抽象类。 抽象类不能被实例化。 抽象类是被继承的。 可以定义一个抽象类的对象变量，但只能引用非抽象子类的对象。 1234567public abstract Clss person&#123; private String name; public Person(String name)&#123; this.name = name; &#125; public abstract String geDescrption();&#125; 枚举类 如下枚举类Size，其中SMALL, MEDIUM, LARGE, EXTRA ,LARCE是它的实例 1Enum Size &#123; SMALL, MEDIUM, LARGE, EXTRA .LARCE &#125;; 因为直接存在实例，所以比较两个枚举类时，直接使用==（不需要构造新对象） 如果需要，可以添加构造器，方法，域 123456789//SMALL("s"),, MEDIUM("x")就相当于使用构造器进行了实例化public enum Size &#123; SMALL("s"), MEDIUM("x"); private String name; private Size(String name)&#123; this.name = name; &#125; public String getName()&#123;return name;&#125;&#125; 调用实例 1Size.SMALL.toString() 逆方法，指向枚举实例 1234//可以通过字符串数据来获取实例Size f = Enum.valueOf(Size.class, "SMALL");//实际上与下面方法效果一样，但无法使用字符串来获取相应的实例Size e = Size.SMALL; 获取枚举类的所有实例,返回一个数组 1Size[]values = Size.values(); 字符串字符串的构造函数 当创建一个String对象时，被创建的字符串是不能被改变的 123456789//创建空字符串String s = new String();// 通过字符数组创建字符串String(char chars[ ]);//指定字符数组一个子区域创建字符串String(char chars[ ], int startIndex, int numChars);//指定字节数组来创建字符串String(byte asciiChars[ ])String(byte asciiChars[ ], int startIndex, int numChars) 对于程序中的每一个字符串常量，Java会自动创建String对象 12//会创建一个字符串对象，且该对象将会被任何地方使用String s2 = "abc"; 字符串操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//返回指定位置的字符;char charAt(int where);//一次截取多个字符.包头不包尾，target[ ]为存放截取字符的数组，targetStart表示从什么位置开始存放void getChars(int sourceStart, int sourceEnd, char target[ ], int targetStart)；//字符串-&gt; 字节数组byte[ ] getBytes( )；//字符串-&gt;字符数组,可使用getChars()达到相同的效果char[ ] toCharArray( );//字符串比较,String重写equals方法，比较字符串的长度和字符boolean equals(Object str);boolean equalsIgnoreCase(String str)；//字符串区域比较，startIndex，str2StartIndex表示两字符串的起始位置，numChars表示比较的字符数boolean regionMatches(int startIndex, String str2,int str2StartIndex, int numChars)；boolean regionMatches(boolean ignoreCase,int startIndex, String str2,int str2StartIndex, int numChars)；//开头/结尾比较boolean startsWith(String str);boolean endsWith(String str);//字符串大小比较,默认比较的是ASCII码值// 大于0表示字符串大于str//等于0 表示字符串等于str// 小于0表示字符串小于strint compareTo(String str)；int compareToIgnoreCase(String str)；//查找ASCII码对应的字符出现的位置,ch为值,没有返回-1int indexOf(int ch); //第一次出现int lastIndexOf(int ch)；//最后一次出现//startIndex:起始搜索位置int indexOf(int ch, int startIndex);int lastIndexOf(int ch, int startIndex);//查找字符串出现的位置int indexOf(String str)；int lastIndexOf(String str)；int indexOf(String str, int startIndex);int lastIndexOf(String str, int startIndex);//从 startIndex 截取子字符串.(在endIndex结束，不包尾)String substring(int startIndex);String substring(int startIndex, int endIndex);//链接两个字符串,与+效果相同String concat(String str);//original 字符 被replacement 取代String replace(char original, char replacement);//去空格String trim( );//字符串大小写String toLowerCase( )String toUpperCase( ) 利用valueOf( )实现数据转换 valueOf()是String的静态方法，可以酱任何类转换成String类 12345static String valueOf(double num)static String valueOf(long num)static String valueOf(Object obj)//返回的是null或Obj.toString()static String valueOf(char chars[ ]) //返回字符数组所有字符的字符串static String valueOf(char chars[ ], int startIndex, int numChars) StringBuffer StringBuffer是可变长的和可写的字符序列,可以自动地增加空间，但通常还有比实际需要更多的预留字符 构造函数 12345678910111213//无参，默认可以存储16个字符public StringBuffer() &#123; super(16);&#125;// 自定义大小public StringBuffer(int capacity) &#123; super(capacity);&#125;//通过str初始化，且大小+16public StringBuffer(String str) &#123; super(str.length() + 16); append(str);&#125; 长度获取 12345678//得到当前StringBuffer的长度public int length() &#123; return count;&#125;//得到总的分配容量public int capacity() &#123; return value.length;&#125; 为某些字符预分配空间，添加缓冲区容量 1void ensureCapacity(int capacity) 设置缓冲区的大小,可用于缩短StringBuffer 1void setLength(int len) 获取/设置字符 12char charAt(int where)void setCharAt(int where, char ch) 将StringBuffer的子字符串复制给数组 12void getChars(int sourceStart, int sourceEnd, char target[ ],int targetStart) 将任一其他类型数据的字符串形式连接到调用StringBuffer对象的后面 123StringBuffer append(String str)StringBuffer append(int num)StringBuffer append(Object obj) 将一个字符串插入另一个字符串中 123456/***index: 插入位置**/StringBuffer insert(int index, String str)StringBuffer insert(int index, char ch)StringBuffer insert(int index, Object obj) 字符串翻转 1StringBuffer reverse( ) 删除字符串 12StringBuffer delete(int startIndex, int endIndex)StringBuffer deleteCharAt(int loc) 替换字符串 1StringBuffer replace(int startIndex, int endIndex, String str) 子串 12String substring(int startIndex)String substring(int startIndex, int endIndex) 继承 关键字 extends 表示继承 成员的访问与继承 子类方法不能够直接地访问超类的私有域。需要通过super调用父类的getter方法。 子类继承了父类的所有属性和方法，只不过父类的私有属性和方法子类是无法直接访问到的 super用法一：调用超类中定义的构造函数方法 子类可以通过spuer调用超类中定义的构造函数方法 1super(parameter-list); super( )必须是在子类构造函数中的第一个执行语句。 super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编 译器调用超类方法的特殊关键字。 用法二：类似于this的用法12//member既可以是1个方法也可以是1个实例变量super.member 方法重写(override） 如果子类中的一个方法与它超类中的方法有相同的方法名和类型声明,称子类中的方法重写(override)超类中的方法 方法重写应遵循“三同一小一大”原则： “三同”：即方法名相同，形参列表相同，返回值类型相同； “一小”：子类方法声明抛出的异常比父类方法声明抛出的异常更小或者相等； “一大”:子类方法的访问修饰符应比父类方法更大或相等 子类构造器 如果需要对对父类私有属性的初始化，必须通过 super 实现对超类构造器的调用，且在第一句 子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类的无参构造器。 如果超类没有不带参数的构造器， 并子类的构造器中必须显示地调用超类 的其他构造器,否则报错 多态 一个对象可以指示多种实际类型的现象被成为多态。 当一个子类对象的引用被赋给一个超类引用变量时,你只能访问超类定义的对象的那一部分(即由父类引用子类对象，无法调用子类的特有方法。)子类引用父类对象，需要强转。 动态绑定 动态方法调度是一种在运行时而不是编译时调用重载方法的机制,即在运行时能够自动地选择调用哪个方法的现象被称为动态绑定，这是Java实现运行时多态性的基础 理解方法调用 当一个重载方法通过超类引用被调用,Java根据当前被引用对象的类型来决定执行哪个版本的方法 调用过程的详细描述： 编译器査看对象的声明类型和方法名。【编译器已获得所有可能被调用的候选方法，同名不同参数的方法】 接下来，编译器将査看调用方法时提供的参数类型【编译器已获得需要调用的方法名字和参数类型。】。编译器没有找到与参数类型匹配的方法， 或者发现经过类型转换后 有多个方法与之匹配， 就会报告一个错误。 如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定（ static binding )。 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实 际类型最合适的那个类的方法。。假设 x 的实际类型是 D，它是 C 类的子类。如果 D 类定义了 方法 f(String，) 就直接调用它；否则， 将在 D 类的超类中寻找 f(String，) 以此类推。每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个 方法表（ method table), 其中列出了所有方法的签名和实际调用的方法。这样一来，在真正 调用方法的时候， 虚拟机仅查找这个表就行了 修饰符static 声明为static的变量实质上就是全局变量 声明为static的方法有以下几条限制 它们仅能调用其他的static方法。 它们只能访问static数据。 它们不能以任何方式引用this或super 静态域和静态方法 静态域（类域）：属于类，而不属于任何独立的对象，所有对象共享。 静态方法：一种不能向对象实施操作的方法，没有隐式参数 静态常量: static final修饰 使用静态方法的情况 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow（）） 一个方法只需要访问类的静态域 final作用一：定义常量 变量可以声明为final,这样做的目的是阻止它的内容被修改 final域：构建对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改 作用二：使用final阻止重写 声明成final的方法不能被重载 作用三：使用final阻止继承 声明成final的类不能被继承 访问控制（作用域） 作用域 当前类 同一package 子孙类 其他package 描述 public √ √ √ √ 对所有类可见 protected √ √ √ × 对本包和所有子类可见 default √ √ × × 对本包可见,默认 private √ × × × 仅对本类可见 对于类来说，只有默认和public两种访问级别 Object类 Object 类是 Java 中所有类的始祖， 在 Java 中每个类都是由它扩展而来的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package java.lang;public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; public final native Class&lt;?&gt; getClass(); public native int hashCode(); public boolean equals(Object obj) &#123; return (this == obj); &#125; protected native Object clone() throws CloneNotSupportedException; public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0); &#125; protected void finalize() throws Throwable &#123; &#125;&#125; 在 Java 中，只有基本类型 （ primitive types) 不是对象， 例如，数值、 字符和布尔类型的 值都不是对象。 equals 方法 Object 类的equals()方法判断两个对象是否具有相同的引用,其本质等同于”==”,但有些类已经重写了 equals(),如String类 Java语言规范下的equals 自反性：对于任何非空引用x，x.equals(x)应该返回true 对称性：对于任何引用x和y，当且仅当y.equals(x)返回true，x.equals(y)也应该返回true 传递性：对于任何引用x、y、z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true 一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果 对于任何非空引用x，x.equals(null)应该返回true 完美equals建议 123456789101112131415public class E&#123; public boolean equals(Object otherObject)&#123; //先判断地址相同 if(this == otherObject) return true; //如果传入参数为null，无需比较 if(otherObject == null) return false; //类不同，肯定不同 if(getClass() != otherObject.getClass()) return false //此时可知参数是非null 的E类了 E other = (E)otherObject; //比较直，对象用equals比较，防止null值;数值用==比较 return Objects.equals(name, other.name) &amp;&amp; phone == other.phone &#125;&#125; hashCode方法 散列码（ hash code ) 是由对象导出的一个整型值，其值为对象的 存储地址 如果重新定义 equals方法，就必须重新定义 hashCode 方法， 以便用户可以将对象插入到散列表中 1234//这是一个由name、salary、hireDay组成的hashCode编码。public int hashCode()&#123; return Objects.hash(name, salary, hireDay)&#125; 反射 大量应用于JavaBeans中，是Java组件的体系结构,反射可以用来: 在运行时分析类的能力 在运行时查看对象，如编写一个toSring方法供所有类使用 实现通用的数组操作代码 利用Method对象 Class 类 Class类：Java运行时系统始终为所有的对象维护一个运行时的类型标识。这个信息跟踪每个对象所属的类，保存这些信息的类被称为Class。 获取Class对象：1234567//方法1：静态方法(应该提供一个异常处理器)Class.forName(className);//方法2：Object的getClass()方法e.getClass();//方法3：Class cl1 = int.class;//int不是类，但int.class是一个类Class cl2 = Double[].class 获取类名：1aClass.getName(); 获取元素类型 1aClass.getComponentType() Class类比较： 虚拟机为每个类型管理一个Class对象。所以class比较只需要用==即可 创建实例：12345//方式一：e.getClass().newInstance();//方式二：forName()配合使用String s = "java.util.Random";Object m = Class.forName(s).newInstance(); 类的结构，java.lang.reflect中的三各类 类 描述 Field 类的域 Method 类的方法 Constructor 类的构造器 Field 类Field类：类的域对象 获取域对象 1Field aField = aClass.getDeclareField("fieldName"); 查看数据域的实际内容 123//Object obj 是一个包含该域的对象//对于get()方法如果域是一个String,那么返回成Object是没有问题的。但如果是一个基本数据类型，get()方法会自动将值打包成对象。aField.get(Object obj) 设置域12// obj: 设置的对象aFiled.set(obj, "newName"); 实例: 123456Employee maorl = new Employee("maorl", 39999, 10, 1, 1994);Class aClass = maorl.getClass();// 在这里，name是一个私有域，因为反射机制的默认是受Java访问控制的，所以get()方法会抛出一个IllegalAccessException。 Field aField = aClass.getDeclareField("name");//获取具体值Object value = aField.get(masorl); 覆盖访问控制（即访问无妨访问的域，破坏了封装性）。为了达到这个目的，可以使用Field、Method、Constructor对象的 setAccessible12// 此时，我们可以访问得到name域的值了。 aFiled.setAcessible(true) Method类 类的方法对象 获取方法对象 1Method aMethod = aClass.getMethod("methodName"); 执行方法 123456//obj: 执行改方法的对象aMethod.invoke(obj);// obj: 隐式参数(静态方法就传null,有点类似于feild.get()方法) //args: 显式参数//返回Object，所以可能需要进行类型转换（返回值是基本数据类型，会自动包装）public Object invoke(Object obj, Object... args)&#123;...&#125; 反射示例通用数组拷贝的的方法1234567891011121314151617181920212223//Arrays.copyOf()源码 public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125; public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") //判断原始数据是否属于Object[]数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] //Array.newInstance(): 创建一个新的指定数组元素类型的数组 : (T[]) Array.newInstance(newType.getComponentType(), newLength); // 复制数组：System.arraycopy(src,srcPos,dest, destPos,length) /* * Object src：需要复制的源数组 * int srcPos：源数组复制起始位置 * Object dest：复制的目标数组 * int destPos：复制的目标数组的起始位置 * int length: 复制长度 */ System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 通过反射打印类的信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.util.Scanner;public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; if (args.length &gt; 0 ) name = args[0]; else &#123; Scanner in = new Scanner(System.in); System.out.println("输入Class名"); name = in.next(); &#125; /** * 通过Class.forName获取类 * 通过Class.getSuperclass()获取父类 * 通过Modifier.toString(aClass.getModifiers()) 获取类的修饰符 */ try &#123;// 打印类名、修饰符 Class&lt;?&gt; aClass = Class.forName(name); Class&lt;?&gt; superclass = aClass.getSuperclass(); String modifiers = Modifier.toString(aClass.getModifiers()); if (modifiers.length() &gt; 0) System.out.print( modifiers + ""); System.out.print(" class " + name);// 打印父类 if (superclass != null &amp;&amp; superclass != Object.class) System.out.print(" extends " + superclass.getName());// 打印构造器、方法、域 System.out.print("\n&#123;\n"); printConstructors(aClass); System.out.println(); printMethods(aClass); System.out.println(); printFields(aClass); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; System.exit(0); &#125; /** * 打印类的所有构造器 * * 通过Class.getConstructors方法获取构造器数组 * 通过Modifier.toString(Constructor.getModifiers()) 方法获取构造器的修饰符 * 通过Constructor.getParameterTypes() 方法获取构造器参数 * @param aClass */ public static void printConstructors(Class aClass) &#123; Constructor[] constructors = aClass.getConstructors();// 打印构造器名和修饰符 for (Constructor constructor : constructors) &#123; String name = constructor.getName(); System.out.print(" "); String modifiers = Modifier.toString(constructor.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(name + "(");// 打印参数类型 Class[] parameterTypes = constructor.getParameterTypes(); for (int j = 0; j &lt; parameterTypes.length; j++) &#123; if (j &gt; 0) System.out.print(","); System.out.print(parameterTypes[j].getName()); &#125; System.out.println(");"); &#125; &#125; /** * 打印类的所有方法 * * 通过Class.getDeclaredMethods()获取类的所有方法 * 通过Method.getReturnType(); 获取方法的返回类型 * 通过Modifier.toString(Method.getModifiers()) 方法获取方法的修饰符 * 通过Method.getParameterTypes() 方法获取构造器参数 * @param aClass */ public static void printMethods(Class aClass)&#123; Method[] methods = aClass.getDeclaredMethods();// 打印类方法名、修饰符、返回类型 for(Method method : methods)&#123; Class&lt;?&gt; type = method.getReturnType(); String name = method.getName(); System.out.print(" "); int modifiers1 = method.getModifiers(); String modifiers = Modifier.toString(modifiers1); if (modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(type.getName() + " " + name + "("); //打印参数类型 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); for (int j = 0; j &lt; parameterTypes.length; j++)&#123; if (j &gt; 0) System.out.print(","); System.out.print(parameterTypes[j].getName()); &#125; System.out.println(")"); &#125; &#125; /** * 通过Class.getDeclaredFields()获取类的所有域 * 通过Field.getType()获取域的类型 * 通过Modifier.toString(field.getModifiers()) 获取域的修饰符 * @param aClass */ public static void printFields(Class aClass)&#123; Field[] fields = aClass.getDeclaredFields(); for (Field field : fields)&#123; Class&lt;?&gt; type = field.getType(); String name = field.getName(); System.out.print(" "); String modifiers = Modifier.toString(field.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + ""); System.out.println(type.getName() + " " + name + ";"); &#125; &#125;&#125; 利用反射编写通用toString，打印对象的域值 ObjectAnalyzer类:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.lang.reflect.AccessibleObject;import java.lang.reflect.Array;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.ArrayList;public class ObjectAnalyzer &#123; private ArrayList&lt;Object&gt; visited = new ArrayList&lt;&gt;(); /** * 打印对象域的值 * 1. Null 值：直接返回"null" * 2. ArrayList visited：防止无限递归 * 3. 获取对象的类 * 4. 如果是String类，直接返回数值即可 * 5. 如果是数组类 * 获取数组的组件类：Class.getComponentType()方(如 int[]对象，返回int.class, Integer[] 返回 Integer.class) * 遍历数组，分两种情况 * 1）对于基本类型数组：Class.isPrimitive()判断是否属于基本类型的类,可以直接处理值 * 2) 对于对象数组：则需要递归使用toString()来处理其中的域值 * 6. 如果是对象类，先要获取它的域值： * 1）获取所有域：Class.getDeclaredFields()； * 2）要获取值，使用AccessibleObject.setAccessible(Field[] field, true); 来批量接解除的访问控制 * 3）遍历域： * I：获取域的类型，对于基础类型，可以直接处理值；对于对象类型，需要再次toString来递归处理域值 * II：除了当前对象的域值外，还需要处理它的父类，Class.getSuperclass() * * * @param obj * @return */ public String toString(Object obj)&#123; if(obj == null) return "null"; if (visited.contains((obj))) return "..."; visited.add(obj); Class&lt;?&gt; aClass = obj.getClass(); //处理String类 if(aClass == String.class) return (String) obj; //处理数组 if (aClass.isArray())&#123; String result = aClass.getComponentType() + "[]&#123;"; for (int i = 0; i &lt; Array.getLength(obj); i++)&#123; if (i &gt; 0) result += ","; Object val = Array.get(obj, i); //isPrimitive 判断该类是否是一个基本类型(即int、double...) if (aClass.getComponentType().isPrimitive()) result += val; else result += toString(val); //不是基础类型还需要再次调用toString方法进行转换 &#125; return result + "&#125;"; &#125; String result = aClass.getName(); do&#123; Field[] fields = aClass.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field field : fields)&#123; if (!Modifier.isStatic(field.getModifiers()))&#123; if (!result.endsWith("[")) result += ","; result += field.getName() + "="; try &#123; Class&lt;?&gt; type = field.getType(); Object val = field.get(obj); if (type.isPrimitive()) result += val; else result += toString(val); &#125;catch (Exception e)&#123; e.printStackTrace();; &#125; &#125; &#125; result += "]"; aClass = aClass.getSuperclass(); &#125; while (aClass != null); return result; &#125;&#125; 测试类:1234567891011import java.util.ArrayList;public class ObjectAnalyzerTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; squares = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 5; i++) squares.add(i * i); int[] ints = &#123;1, 2, 4, 5&#125;; System.out.println(new ObjectAnalyzer().toString(squares)); System.out.println(new ObjectAnalyzer().toString(ints)); &#125;&#125; 接口 接口方法都是public,可以不写。但是实现接口的时候必须写（实现类不写是default） 接口特性 接口的特性如下 无法实例化 能声明接口的变量 可以使用 instanceof 检查类是否属于某个特定的接口 接口可以继承接口 接口不能包含实例域和静态方法(java 8.0后可以添加静态方法) 接口可以包含常量（共享，因为是public static final） 接口方法自动设置为public abstract,接口域自动设置为public static final 默认方法 可以为接口方法提供一个默认方法,使用default 修饰符标记 123public interface Comparable&lt;T&gt;&#123; default int compareTo(T other)&#123;return 0;&#125;&#125; 应用一12345678//把所有方法都设置为默认，程序员只需覆盖关心的方法即可public interface Demo()&#123; default void method1()&#123;&#125; default void method2()&#123;&#125; default void method3()&#123;&#125; default void method4()&#123;&#125; default void method5()&#123;&#125;&#125; 应用二：接口演化 假设我们现在有一个接口 A, Mas是其的一个实现类 12public interface A&#123;...&#125;publiic Class Max implements A&#123;...&#125; 后来，我们为A添加了一个新方法 newMethod 123public interface A&#123; void newMethod()&#123;&#125;&#125; 可能会出现以下情况 Mas类编译将会失败（没有重写newMethod） 不重新编译Mas类，在Mas调用newMethod时抛出AbstractMethodError 如果变为defalut方法，以上两个问题都会解决 Mas成功编译 不重新编译Mas,调用时会向上调用A接口的newMethod 解决默认方法冲突情况一：接口与父类冲突 父类优先 如接口定义了默认方法getName(),而父类中也定义了getName()方法，默认方法被忽略 情况二：接口与接口冲突： 手动覆盖。如接口A、Ｂ同时定义了默认的getName()方法，必需覆盖解决冲突。也可以在类中选择二者其一 12345Class Choose implements A,B&#123; public String getName()&#123; return A.super.getName(); &#125;&#125; 情况三：非默认 如果接口Ａ、Ｂ的方法是非默认方法，无论是否另一个有同名默认方法，必需重写 异常Error/Exception 异常对象都是派生于 Throwable 类的一个实例,但在下一层立即分解为两个分支 : Error 和 Exception Error Java 运行时系统的内部错误和资源耗尽错误 Exception 真正需要关心的异常，分解为两个分支 : RuntimeException :程序错误导致的异常属于 RuntimeException 其他异常 :程序本身没有问题,但由于像I/O错误这类问题导致的异常属于其他异常（IOException） RuntimeException包含情况 错误的类型转换 数组访问越界 访问到null指针 其他异常包含情况 试图在文件尾部后面读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找 Class 对象, 而这个字符串表示的类并不存在 受查异常和非受查异常 非受查异常: 派生于Error类或RuntimeException类的所有异常 受查异常：除了非受查异常其他的异常 声明受查异常（throws） 受查异常需要在方法首部声明所有可能抛出的异常(通过关键字throws) 如下是Java类库中的一个类的构造器方法的声明1public FilelnputStream ( String name ) throws FileNotFoundException 子类异常和父类异常 在子类中覆盖了父类的一个方法 ,子类方法中声明的受查异常不能比父类方法中声明的异常更通用(子类方法中可以抛出更特定的异常, 或者根本不抛出任何异常) 父类类方法没有抛出任何受查异常, 子类也不能抛出任何受查异常 抛出异常(throw)1throw EOFException(); 再次抛出异常与异常链 在catch中抛出异常,目的是为了改变异常类型 方式一：123456try&#123;access the database&#125;catch ( SQLException e )&#123; throw new ServletException (" database error: " + e.getMessage());&#125; 方式二：更好的处理，并将原始异常设置成新异常的原因（推荐） 123456789101112131415//Throwable.initCause(Throwable cause) : 将Throwable的cause初始化为指定的值（不能是它本身） //Throwable.getCause():获取cause值try&#123; ...&#125;catch ( SQLException e )&#123; Throwable se = new ServletException("database error"); // Throwable.initCause(Throwable cause) se.initCause(e); throw se;&#125;// 获取原始异常Throwable.getCause() Throwabl e = se.getCasue(); 捕获异常(try/catch)块1234567891011121314151617try&#123; ...&#125;catch ( FileNotFoundException e )&#123; ...&#125;catch ( UnknownHostException e )&#123; ...&#125;catch ( IOException e )&#123; ...&#125;// catch 也可以进行合并（此时的异常变量e 变为 final 变量。即不能为e赋值不同的值）catch ( FileNotFoundException | nknownHostException e )&#123; ...&#125; finally子句 可以这样使用,有异常抛出就直接执行finally中的语句 12345try&#123;&#125;finally&#123;&#125; finally 中包含return,会覆盖原始方法中的return值 123456789//执行f(2),将会返回0public static int f (int n )&#123; try&#123; int r = n * n; return r; &#125;finally&#123; if ( n == 2) return 0 ; &#125;&#125; finally抛出异常带来的麻烦，假设在try中抛出了一些非IOException, 而finally中的closed()方法也有可能抛出异常，这时，原始异常丢失，抛出closed方法的异常 12345 try&#123; ...&#125;finally&#123; in.closed();&#125; 解决也十分繁琐 12345678910111213141516InputStream in = ...;Exception ex = null ;try&#123; try&#123; code that might throw exceptions &#125;catch (Exception e)&#123; ex = e; throw e; &#125;&#125;finally&#123; try&#123; in.closed(); &#125;catch(Exception e)&#123; if(ex == null) throw e; &#125;&#125; 更好的解决办法: Java SE 7 新增的资源关闭处理. 带资源的try语句(Java SE 7) 当try块退出时，自动执行res.closed()。 对于colosed()可能抛出的异常，原来的异常会被抛出，而closed()异常会被自动捕获,并由Throwable.addSuppressed()添加到原来的异常中。（可以使用Throwableget.Suppressed()获取。） 123try (Resource res = ...；Ｒesource res2 = ...)&#123; ...&#125; 自定义异常 继承Exception 或其子类 ,一般异常有两个构造函数： 一个无参构造器 一个记录详细描述信息(超类Throwable.toString可以打印这些信息) 123456public MyExcpetion extends IOexception&#123; public MyExcpetion()&#123;&#125; public MyExcpetion(String message)&#123; super(message) &#125;&#125; Throwable 定义的方法 Exception类自己没有定义任何方法。,它继承了Throwable提供的一些方法 方法 描述 Throwable fillInStackTrace( ) 返回一个包含完整堆栈轨迹的Throwable对象,该对象可能被再次引发 String getLocalizedMessage( ) 返回一个异常的局部描述 String getMessage( ) 返回一个异常的描述 void printStackTrace( ) 显示堆栈轨迹 void printStackTrace(PrintStreamstream) 把堆栈轨迹送到指定的流 void printStackTrace(PrintWriterstream) 把堆栈轨迹送到指定的流 String toString( ) 返回一个包含异常描述的String对象。当输出一个Throwable对象时,该方法被println( )调用 Java的内置异常 Java 的 java.lang 中定义的非受查异常子类: 异常 说明 ArithmeticException 算术错误,如被0除 ArrayIndexOutOfBoundsException 数组下标出界 ArrayStoreException 数组元素赋值类型不兼容 ClassCastException 非法强制转换类型 IllegalArgumentException 调用方法的参数非法 IllegalMonitorStateException 非法监控操作,如等待一个未锁定线程 IllegalStateException 环境或应用状态不正确 IllegalThreadStateException 请求操作与当前线程状态不兼容 IndexOutOfBoundsException 某些类型索引越界 NullPointerException 非法使用空引用 NumberFormatException 字符串到数字格式非法转换 SecurityException 试图违反安全性 StringIndexOutOfBounds 试图在字符串边界之外索引 UnsupportedOperationException 遇到不支持的操作 java.lang 中定义的受查异常: 异常 说明 ClassNotFoundException 找不到类 CloneNotSupportedException 试图克隆一个不能实现Cloneable接口的对象 IllegalAccessException 对一个类的访问被拒绝 InstantiationException 试图创建一个抽象类或者抽象接口的对象 InterruptedException 一个线程被另一个线程中断 NoSuchFieldException 请求的字段不存在 NoSuchMethodException 请求的方法不存在 使用异常机制技巧 技巧如下 异常处理不能代替简单的测试 不要过分地细化异常 利用异常层次结构 不要只抛出 RuntimeException 异常 。 应该寻找更加适当的子类或创建自己的异常类 。 不要只捕获 Thowable 异常 不要压制异常 在检测错误时, “ 苛刻 ” 要比放任更好 在用无效的参数调用一个方法时 , 返回一个虚拟的数值, 还是抛出一个异常 , 哪种处理方式更好 如,当栈空时, Stack.pop() 是返回一个 null , 还是抛出一个异常? 在出错的地方抛出一个 EmptyStackException异常要比在后面抛出一g个NullPointerException 异常更好 不要羞于传递异常 建议解耦try/catch和try/finally 如下：12345678910InputStrean in = ...;try&#123; try&#123; ... &#125;finally&#123; in.closed(); &#125;&#125;catch(IOExcpetion o)&#123; ...&#125; 好处： 内层try/finally只有一个职责，确保关闭流 外层try/catch也只有一个职责，报告异常 这样设计不仅清楚，还能报告finally中的异常 lambda表达式 lambda表达式：可传递的代码块 12(param [, param, ...]) -&gt; &#123;表达式&#125; Lambda表达式省略 没有参数时：123()-&gt; &#123; ...&#125; 可以推导出参数类型时，可省略参数类型123(first, second)-&gt;&#123; first.length() - second.length()&#125; 只有一个参数，且可以推导类型，可省略 ()12event -&gt; System.out.print("This time is" + new Date()) 函数式接口 函数式接口 只有一个抽象方法的接口,需要这种接口的对象时，可以提供lambda表达式 函数式接口还可以定义Object的方法，即equals属于Object方法，所以Comparator属于函数式接口 1234567891011//如 Arrays.sort()这个方法，它的第二个参数是一个Comparator接口,Comparator接口就是一个函数式接口Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) ​```java@FunctionalInterface //表明其为函数式接口public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); //equals属于object方法 boolean equals(Object obj); ...&#125; 实例：123//在底层，Arrays.sort接受的是Comparator&lt; String &gt;这个对象,在这个对象调用compare方法时会执行lambda表达式。Arrays.sort(words, (first, second)-&gt;first.length() - second.length()); 函数式接口设计： 设计一个接口，其中只有一个抽象方法 可以用 @ FunctionalInterface 注解来标记这个接口，有两点好处 a. 如果不小心添加了一个抽象方法，编译器会产生错误消息 b. javadoc会指出该接口是函数接口 方法引用所谓的方法引用，即将现成的方法传递到其他代码中 12345Timer t = new Timer(1000, event -&gt; System.out.println(event));//可以直接将println方法传递到Timer构造器//System.out::println等同于 x -&gt; System.out.println(x)Timer t = new Timer(1000,System.out::println); 对于使用 :: ，一共有三种情况 1234567object::instanceMethodClass::staticMethod// 前2种情况中,方法引用等价于提供方法参数的lambda 表达式//如 Math::pow等价于(x,y)-&gt;Math.pow(x,y)) Class::instanceMethod//第3种情况，第1个参数会成为方法的目标 //如(String::compareTolgnoreCase等价于(x,y)-&gt;x.compareTOlgnoreCase(y)) 如果出现重载方法。则通过方法参数选择版本（如Math.max有两个版本，一个用于整数，一个用于double。选择哪一个版本取决于Math::max转换成哪一个函数式接口的方法参数） 可以在方法中引用this和super123this::equals//等同于x -&gt; this.equals(x) 构造器引用 构造器引用： 类似于方法引用，但方法名为new(可以理解为特殊的方法引用)，调用的构造器取决于上下文 123int[]::new //等价于x -&gt; new int[x] lambda变量作用域12345678910// ActionListener 是一个函数是接口，所以lambda表达式可以赋值给它pubic static void repeatMessage(String text, int delay)&#123; ActionListener aListener = event -&gt;&#123; System.out.println(text); &#125; new Timer(delay, aListener).start();&#125;//调用repeatMessage("hello", 1000);//print hello 如上代码，lambda表达式使用了外部的变量text,而真正执行lambda，可能要等到定时器运行为止，此时：text变量可能已经不存在了。 lambda是如何保存变量的,首先看lambda表达式的组成 一个代码块 参数 自有变量（即非参数且不在代码块中定义的，这里就是text） (自有变量的值，可以被lambda表达式捕获。具体细节为：lambda表达式最终会变为一个包含方法的实例对象，而自由变量的值会复制到这个对象的实例变量中) lambda捕获的限制限制一 不能在lambda表达式中改变捕获的自由变量的值 1234567public void static countDonw(int start, int end)&#123; ActionListener aListener = event -&gt;&#123; start--; System.out.println(start);//Error，不能改变捕获的变量 &#125; new Timer(delay, aListener).start();&#125; 限制二 不能捕获一个改变的变量 1234567public void static repeat(String text, int count)&#123; for(int i = 0; i &lt;= count; i++)&#123; ActionListener aListener = event -&gt;&#123; System.out.println(i);//Error，不能引用一个改变的变量 &#125; &#125;&#125; 在lambda中使用this 在一个 lambda 表达式中使用 this 关键字时, 是指创建这个 lambda 表达式的方法的 this参数 12345678public class Application()&#123; public void init()&#123; ACtionListener aLinstener = event -&gt; &#123; //调用的toString 会是Application的toString方法 System.out.println(this.toString); &#125; &#125;&#125; 处理Lambda表达式使用 lambda 表达式的重点是延迟执行,如果想耍立即执行代码 , 完全可以直接执行 , 而无需把它包装在一个lambda 表达式中 需要延迟执行的情况 在一个单独的线程中运行代码 多次运行代码 在算法的适当位置运行代码 (例如,排序中的比较操作） 发生某种情况时执行代码 (如,点击了一个按钮,数据到达,等等;） 只在必要时才运行代码 。 例：重复n遍动作 123456// Runnable是一个JAVA Api中提供的接口public static void repeat(int n, Runnable action)&#123; for(int i = 0; i &lt; n; i++) action.run();&#125;//当执行action.run()时，就会执行lambda主体repeat(10, () -&gt; System.out.println("Hellp world")); 泛型泛型类类型变量使用大写形式，在Java中 E表示集合的元素类型 K和V表示关键字与值类型 T(需要时还可以使用临近字母U,S)表示任意类型 123public class MyCLass&lt;T,U&gt;&#123; ...&#125; 泛型方法写法1： 12345//类型变量放在修饰符后面，返回值前面//可以在调用方法时指定Ｔ的类型，如MyClass.&lt;String&gt; get()，获取的返回值就是String类 public static &lt;T&gt; T get(T... a)&#123;...&#125; 写法2： 1234//只能使用普通的MyClass.get()，根据ＭyClass&lt;T&gt;类型变量决定public T get(T... a()&#123;&#125; 类型变量限定Ｔ本身可以是任何类型，但可以通过实现extends关键字来限制Ｔ 123456//限制T 类型必须实现Comparable接口public static &lt;T extends Comparable&gt; T min(T[] a)&#123; ...&#125;//多个限定，使用 &amp; 来分隔限定类型,使用 "," 来分隔类型变量&lt;T extends Comparable &amp; Serializable, U&gt; 注意: ​ 即使是限制接口，也是使用extends，而不是implement。T extends Comparable应理解为是Comparable的子类型，而不是实现或者继承Comparable 泛型与虚拟机类型擦除虚拟机只有普通类，没有泛型类这个概念。在虚拟机中，泛型类都会被还原成一个原始类型 没有限定类型的泛型类替换方式 123456789public class Pair&lt;T&gt;&#123; private T first; ...&#125;//类型擦除后,T没有限定类型，会被替换成 Objectpublic class pair&#123; private Object first; ....&#125; 有限定类型的话的替换方式 123456789101112131415public class pair&lt;T extends Comparable &amp; Serializable&gt;&#123; private T first; ...&#125; //擦除后,会替换为第一个限定类型public class pair&#123; private Comparable first; ....&#125;//如果是 &lt;T extends Serializable&amp; Comparable&gt;public class pair&#123; private Serializable first; ....&#125; 泛型方法替换方式 123public static &lt;T extends Comparable 〉 T min ( T[] a )//擦除类型后public static Comparable min(Comparable a) 泛型表达式替换方式 第一步：对原始getFirst()的调用((T 擦除后替换成Object，方法返回Object)) 第二步：将Object强制转换为Employee 123456789101112//泛型类public class Pair&lt;T&gt;&#123; private T first; public Pair(T first)&#123; this.first = first; &#125; public &lt;T&gt; T getFirst()&#123;return first&#125;&#125;//泛型表达式Pair&lt;Employee&gt; buddies = ...;Employee buddy = buddies.getFirst(); 即getFirst()方法会变成 1234567//执行Employee buddy = buddies.getFirst();//第一步：get方法擦除public Object getFirst()&#123; return first;&#125;//第二步：再进行强转(Employee)buddies.getFirst(); 类型擦除带来的问题通配符类型语法： 12//表示MyClass的类型参数是SomeClass的子类MyClass &lt; ? extends SomeClass &gt; 通配符的超类型限定通配符可以指定一个超类型限定 （ supertypebound ) ，语法如下 12//限制该类必须是SomeClass的超类? super SomeClass 集合Java中提供的集合接口 接口 描述 Collection 能使你操作对象组，它位于类集层次结构的顶层 List 扩展Collection去处理序列（对象的列表） Set 扩展Collection去处理集合，集合必须包含唯一元素 SortedSet 扩展Set去处理排序集合 其他相关的集合接口 接口 描述 Comparator 定义了两个对象如何比较 Iterator 枚举类集中的对象 ListIterator 扩展Iterator，允许双向遍历列表，并可以修改单元 Java为开发者提供的抽象类 抽象类 描述 AbstractCollection 实现大多数Collection接口 AbstractList 扩展AbstractCollection并实现大多数List接口 AbstractSequentialList 为了被类集使用而扩展AbstractList，该类集使用连续而不是随机方式访问其元素 AbstractMap 实现大多数的Map接口 通配符类型 Collection接口Collection接口是构造类集框架的基础。它声明所有类集都将拥有的核心方法 方法 描述 boolean add(Object obj) 将obj加入到调用类集中。如果obj被加入到类集中了，则返回true；如果obj已经是类集中的一个成员或类集不能被复制时，则返回false boolean addAll(Collection c) 将c中的所有元素都加入到调用类集中，如果操作成功（也就是说元素被加入了），则返回true；否则返回false void clear( ) 从调用类集中删除所有元素 boolean contains(Object obj) 如果obj是调用类集的一个元素，则返回true，否则，返回false boolean containsAll(Collection c) 如果调用类集包含了c中的所有元素，则返回true；否则，返回false boolean equals(Object obj) 如果调用类集与obj相等，则返回true；否则返回false int hashCode( ) 返回调用类集的散列码 boolean isEmpty( ) 如果调用类集是空的，则返回true；否则返回false Iterator iterator( ) 返回调用类集的迭代程序 Boolean remove(Object obj) 从调用类集中删除obj的一个实例。如果这个元素被删除了，则返回true；否则返回false Boolean removeAll(Collection c) 从调用类集中删除c的所有元素。如果类集被改变了（也就是说元素被删除了），则返回true；否则返回false Boolean retainAll(Collection c) 删除调用类集中除了包含在c中的元素之外的全部元素。如果类集被改变了（也就是说元素被删除了），则返回true，否则返回false int size( ) 返回调用类集中元素的个数 Object[ ] toArray( ) 返回一个数组，该数组包含了所有存储在调用类集中的元素。数组元素是类集元素的拷贝 Object[ ] toArray(Object array[ ]) 返回一个数组，该数组仅仅包含了那些类型与数组元素类型匹配的类集元素。数组元素是类集元素的拷贝。如果array的大小与匹配元素的个数相等，它们被返回到array。如果array的大小比匹配元素的个数小，将分配并返回一个所需大小的新数组，如果array的大小比匹配元素的个数大，在数组中，在类集元素之后的单元被置为null。如果任一类集元素的 类 型 都 不 是 array 的 子 类 型 ， 则 引 发 一 个ArrayStoreException异常 List接口List接口扩展了Collection,使用一个基于零的下标，元素可以通过它们在列表中的位置被插入和访问。 方法 描述 void add(int index, Object obj) 将obj插入调用列表，插入位置的下标由index传递。任何已存在的，在插入点以及插入点之后的元素将前移。因此，没有元素被覆盖 boolean addAll(int index, Collection c) 将c中的所有元素插入到调用列表中，插入点的下标由index传递。在插入点以及插入点之后的元素将前移。因此，没有元素被覆盖。如果调用列表改变了，则返回true；否则返回false Object get(int index) 返回存储在调用类集内指定下标处的对象 int indexOf(Object obj) 返回调用列表中obj的第一个实例的下标。如果obj不是列表中的元素，则返回-1 int lastIndexOf(Object obj) 返回调用列表中obj的最后一个实例的下标。如果obj不是列表中的元素，则返回-1 ListIterator listIterator( ) 返回调用列表开始的迭代程序 ListIterator listIterator(int index) 返回调用列表在指定下标处开始的迭代程序 Object remove(int index) 删除调用列表中index位置的元素并返回删除的元素。删除后，列表被压缩。也就是说，被删除元素后面的元素的下标减一 Object set(int index, Object obj) 用obj对调用列表内由index指定的位置进行赋值 List subList(int start, int end) 返回一个列表，该列表包括了调用列表中从start到end–1的元素。返回列表中的元素也被调用对象引用 ArrayList类ArrayList类扩展于AbstractList，支持可随需要而增长的动态数组 构造函数 123ArrayList( )ArrayList(Collection c)ArrayList(int capacity) LinkedList类LinkedList类扩展于AbstractSequentialList,提供了一个链接列表数据结构 构造函数 12LinkedList( )LinkedList(Collection c) 列表操作 123456789101112//在列表头添加元素void addFirst(Object obj)//在列表尾添加元素 void addLast(Object obj)//获取Object getFirst( )Object getLast( )//删除Object removeFirst( )Object removeLast( ) Set接口Set接口类似与Connection,但是对方法的行为更为严谨。容器不能添加重复元素，需要定义equals*()方法和hashCode()方法 SortedSet接口SortedSet接口扩展了Set并说明了按升序排列的集合的特性 方法 描述 Comparator comparator( ) 返回调用被排序集合的比较函数，如果对该集合使用自然顺序，则返回null Object first( ) 返回调用被排序集合的第一个元素 SortedSet headSet(Object end) 返回一个包含那些小于end的元素的SortedSet，那些元素包含在调用被排序集合中。返回被排序集合中的元素也被调用被排序集合所引用 Object last( ) 返回调用被排序集合的最后一个元素 SortedSet subSet(Object start, Object end) 返回一个SortedSet，它包括了从start到end–1的元素。返回类集中的元素也被调用对象所引用 SortedSet tailSet(Object start) 返回一个SortedSet，它包含了那些包含在分类集合中的大于等于start的元素。返回集合中的元素也被调用对象所引用 HashSet类HashSet扩展于AbstractSet,使用散列表进行存储 构造函数 12345HashSet( )HashSet(Collection c)HashSet(int capacity)//fillRatio : 负载因子,默认0.75,值在0.0~1.0之间HashSet(int capacity, float fillRatio) TreeSet类TreeSet扩展于AbstractSet，使用树来进行存储，对象按升序存储 构造函数 1234TreeSet( )TreeSet(Collection c)TreeSet(Comparator comp)TreeSet(SortedSet ss) Iterator接口 方法 描述 boolean hasNext( ) 如果存在更多的元素，则返回true，否则返回false Object next( ) 返回下一个元素。如果没有下一个元素，则引发NoSuchElementException异常 void remove( ) 删除当前元素，如果试图在调用next( )方法之后，调用remove( )方法，则引发IllegalStateException异常 ListIterator接口ListIterator接口扩展Iterator，允许双向遍历列表，并可以修改单元 方法 描述 void add(Object obj) 将obj插入列表中的一个元素之前，该元素在下一次调用next( )方法时，被返回 boolean hasNext( ) 如果存在下一个元素，则返回true；否则返回false boolean hasPrevious( ) 如果存在前一个元素，则返回true；否则返回false Object next( ) 返回下一个元素，如果不存在下一个元素，则引发一个NoSuchElementException异常 int nextIndex( ) 返回下一个元素的下标，如果不存在下一个元素，则返回列表的大小 Object previous( ) 返回前一个元素，如果前一个元素不存在，则引发一个NoSuchElementException异常 int previousIndex( ) 返回前一个元素的下标，如果前一个元素不存在，则返回-1 void remove( ) 从列表中删除当前元素。如果remove( )方法在next( )方法或previous( )方法调用之前被调用，则引发一个IllegalStateException异常 void set(Object obj) 将obj赋给当前元素。这是上一次调用next( )方法或previous( )方法最后返回的元素 使用迭代器遍历一个元素，可以使用迭代器来完成,有两种使用方式 通过hasnext()和next()方法进行遍历 通过for-earch循环来完成 1234567891011Collection&lt;String&gt; aCollection = ...;Iterator&lt;String&gt; iter = aCollection.iterator();// 遍历迭代器，逐个访问元素while(iter.hasnext())&#123; String element = iter.next(); //do something with element&#125;// 使用for-each循环遍历for(String element : aCollection)&#123; //do something with element&#125; for-each 循环可以与任何实现了 Iterable 接口的对象一起工作，而 Collction 接口扩展了 Iterable 接口，这就意味着所有集合都可以使用 for-each 循环 此外，在Java SE 8,可以通过调用 forEachRemaining() 方法来完成查看所有元素,它将会对迭代器里的每个元素调用lambda表达式，直到没有为止。 1iter.forEachRemaining(element -&gt; do something with element) Map接口Map是一个存储关键字(key)/值(value)对的对象 接口 描述 void clear( ) 从调用映射中删除所有的关键字/值对 boolean containsKey(Object k) 如果调用映射中包含了作为关键字的k，则返回true；否则返回false boolean containsValue(Object v) 如果映射中包含了作为值的v，则返回true；否则返回false Set entrySet( ) 返回包含了映射中的项的集合（Set）。该集合包含了类型Map.Entry的对象。这个方法为调用映射提供了一个集合“视图” Boolean equals(Object obj) 如果obj是一个Map并包含相同的输入，则返回true；否则返回false Object get(Object k) 返回与关键字k相关联的值 int hashCode( ) 返回调用映射的散列码 boolean isEmpty( ) 如果调用映射是空的，则返回true；否则返回false Set keySet( ) 返回一个包含调用映射中关键字的集合（Set）。这个方法为调用映射的关键字提供了一个集合“视图” Object put(Object k, Object v) 将一个输入加入调用映射，覆盖原先与该关键字相关联的值。关键字和值分别为k和v。如果关键字已经不存在了，则返回null；否则，返回原先与关键字相关联的值 void putAll(Map m) 将所有来自m的输入加入调用映射 Object remove(Object k) 删除关键字等于k的输入 int size( ) 返回映射中关键字/值对的个数 Collection values( ) 返回一个包含了映射中的值的类集。这个方法为映射中的值提供了一个类集“视图” SortedMap 接口SortedMap接口扩展了Map，它确保了各项按关键字升序排序 方法 描述 Comparator comparator( ) 返回调用排序映射的比较函数。如果调用映射使用的是自然顺序的话，则返回null Object firstKey( ) 返回调用映射的第一个关键字 SortedMap headMap(Object end) 返回一个排序映射，该映射包含了那些关键字小于end的映射输入 Object lastKey( ) 返回调用映射的最后一个关键字 SortedMap subMap(Object start, Object end) 返回一个映射，该映射包含了那些关键字大于等于start同时小于end的输入 SortedMap tailMap(Object start) 返回一个映射，该映射包含了那些关键字大于等于start的输入 Map.Entry 接口Map.Entry描述映射中的元素（关键字/值对）。这是Map的一个内部接口，可以操作映射的输入 方法 描述 boolean equals(Object obj) 如果obj是一个关键字和值都与调用对象相等的Map.Entry，则返回true Object getKey( ) 返回该映射项的关键字 Object getValue( ) 返回该映射项的值 int hashCode( ) 返回该映射项的散列值 Object setValue(Object v) 将这个映射输入的值赋给v。如果v不是映射的正确类型，则引发一个lassCastException 异 常 。 如 果 v 存 在 问 题 ， 则 引 发 一 个IllegalArgumentException异常。如果v是null而映射又不允许null关键字，则引发一个NullPointerException异常。如果映射不能被改变，则引发一个UnsupportedOperationException异常 HashMap 类HashMap类使用散列表实现Map接口。这允许一些基本操作如get( )和put( )的运行时间保持恒定 构造函数 12345HashMap( )HashMap(Map m)HashMap(int capacity)//fillRatio : 负载因子,默认0.75,值在0.0~1.0之间HashMap(int capacity, float fillRatio) TreeMap 类TreeMap实现SortedMap并且扩展AbstractMap。TreeMap提供了按排序顺序存储关键字/值对的有效手段，同时允许快速检索;树映射保证它的元素按照关键字升序排序 构造函数 1234TreeMap( )TreeMap(Comparator comp)TreeMap(Map m)TreeMap(SortedMap sm) Comparator接口构造集合或映射时，可以指定一个Comparator对象，使用不同的方法对元素进行排序。Comparator接口定义了两个方法 12int compare(Object obj1, Object obj2)boolean equals(Object obj) 版本遗留下来的类和接口遗留下来的类都是同步的，jave util 遗留下的类有：Dictionary 、Hashtable、 Properties、 Stack 、Vector、Enumeration Enumeration接口Enumeration接口定义了可以对一个对象的类集中的元素进行枚举（一次获得一个）的方法，被Iterator所替代 Vector与ArrayList相似，但Vector是同步的，该类被重新设计来扩展AbstractList和实现List接口，因此现在它与类集是完全兼容的 构造函数 12345Vector( )Vector(int size)//incr: 扩容时的增量，默认增长一倍Vector(int size, int incr)Vector(Collection c) 成员属性 123int capacityIncrement; //增量值int elementCount; //当前元素的个数Object elementData[ ]; //保存元素的数组 StackStack是Vector的一个子类，它实现标准的后进先出堆栈 HashtableDictionary的一个具体实现，与HashMap相似，但它是同步的 构造函数 1234Hashtable( )Hashtable(int size)Hashtable(int size, float fillRatio)Hashtable(Map m) Properties属性（Properties）是Hashtable的一个子类.用来保持值的列表，在其中关键字和值都是字符串（String） 构造函数 12Properties( )Properties(Properties propDefault) 使用store( )和load( )Properties的一个最有用的方面是可以利用store( )和load( )方法包含在Properties对象中的信息进行存储或从盘中装入信息 123void store(OutputStream streamOut, String description)void load(InputStream streamIn) throws IOException Java工具类集合工具类Collections类集框架定义了几种能用于类集和映射的算法。在Collections类中（注意Collections是一个工具类，不是接口），这些算法被定义为静态方法 synchronized*方法被用来获得各种类集的同步（安全线程）拷贝 unmodifiable*方法返回不能被改变的各种类集“视图”。这些方法当将一些进程对类集设为只读形式时很有用的 Collections定义了三个静态变量：EMPTY_SET，EMPTY_LIST和EMPTY_MAP 数组工具类Arrays返回List集合 1static List asList(Object[ ] array) 使用二进制搜索寻找指定的值,以下只是示例，Arrays根据不同数据类型重载了多个binarySearch() 12static int binarySearch(byte[ ] array, byte value) static int binarySearch(Object[ ] array, Object value, Comparator c) 比较方法 1static boolean equals(boolean array1[ ], boolean array2[ ]) 填充数组 1234// 将value值赋值给array[ ]的每一个元素static void fill(Object array[ ], Object value)//将value值赋值给array[ ]的一个子集static void fill(Object array[ ], int start, int end, Object value) 排序 1234567// 对整个数组进行排序static void sort(Object array[ ])static void sort(Object array[ ], Comparator c)//对数组子集进行排序 static void sort(Object array[ ], int start, int end)static void sort(Object array[ ], int start, int end, Comparator c) 字符串标记类StringTokenizer日期类Date构造函数 123Date( )//millisec : 该参数等于从1970年1月1日午夜起至今的毫秒数的大小Date(long millisec) 其他方法 方法 描述 boolean after(Date date) 如果调用Date对象所包含的日期迟于由date指定的日期，则返回true；否则返回false boolean before(Date date) 如果调用Date对象所包含的日期早于由date指定的日期，则返回true；否则返回false Object clone( ) 复制调用Date对象 int compareTo(Date date) 将调用对象的值与date的值进行比较。如果这两者数值相等，则返回0；如果调用对象的值早于date的值，则返回一个负值；如果调用对象的值晚于date的值，则返回一个正值（在Java 2中新增加的） int compareTo(Object obj) 如果obj属于类Date，其操作与compareTo(Date)相同；否则，引发一个ClassCastException异常（在Java 2中新增加的） boolean equals(Object date) 如果调用Date对象包含的时间和日期与由date指定的时间和日期相同，则返回true；否则，返回false long getTime( ) 返回自1970年1月1日起至今的毫秒数的大小 int hashCode( ) 返回调用对象的散列值 void setTime(long time) 按time的指定，设置时间和日期，表示自1970年1月1日午夜至今的以毫秒为单位的时间值 String toString( ) 将调用Date对象转换成字符串并且返回结果 日历类Calendar抽象Calendar类提供了一组方法，这些方法允许将以毫秒为单位的时间转换为一组有用的分量 GregorianCalendar（标准阳历）Calendar的实现类 构造函数 123456789101112//year: 从1900年起的年数//month: 以0表示一月GregorianCalendar(int year, int month, int dayOfMonth)GregorianCalendar(int year, int month, int dayOfMonth, int hours,int minutes)GregorianCalendar(int year, int month, int dayOfMonth, int hours,int minutes, int seconds) //用指定的时区和/或地区的当前日期和当前时间来初始化的对象GregorianCalendar(Locale locale)GregorianCalendar(TimeZone timeZone)GregorianCalendar(TimeZone timeZone, Locale locale) 时区类TimeZoneTimeZone类允许给出相对于格林威治时间（GMT），也称为世界时间（UTC）的时区差 SimpleTimeZoneSimpleTimeZone类是TimeZone的一个子类，允许对公历进行时区操作。它也计算夏令时 构造函数 12345678910111213141516171819202122232425//与格林威治标准时间（GMT）的偏移量SimpleTimeZone(int timeDelta, String tzName) SimpleTimeZone(int timeDelta , String tzId , int dstMonth0 //-----夏令时的开始参数 START----- , int dstDayInMonth0 , int dstDay0 , int time0 //-----夏令时的开始参数 END----- , int dstMonth1 //-----夏令时的结束参数 START----- , int dstDayInMonth1 , int dstDay1 , int time1) //-----夏令时的结束参数 END----- SimpleTimeZone(int timeDelta , String tzId , int dstMonth0 , int dstDayInMonth0 , int dstDay0 , int time0 , int dstMonth1 , int dstDayInMonth1 , int dstDay1 , int time1 , int dstDelta) //在夏令时期间保存的毫秒数 地区类 LocaleLocale类被实例化以生成其中每一个描述一个地理或文化区域的对象。它是提供了编写在不同的国际环境下都能运行的程序的几个类之一 Locale类定义的常数，用于处理最常见的地区 1234567CANADA GERMAN KOREANCANADA_FRENCH GERMANY PRCCHINA ITALIAN SIMPLIFIED_CHINESECHINESE ITALY TAIWANENGLISH JAPAN TRADITIONAL_CHINESEFRANCE JAPANESE UKFRENCH KOREA US 构造函数 12Locale(String language, String country)Locale(String language, String country, String data) 随机函数类Random构造函数 123Random( )//seed : 人为指定一个初值Random(long seed) Timer和TimerTask提供了提前安排将来某时间要执行任务的能力。使用这些类可以创建一个工作于后台的线程，该线程等待一段指定的时间。当指定的时间到来时，与该线程相连的任务被执行 TimerTimer是一个用于安排一个将来执行的任务的类。被安排的任务必须是TimerTask的一个实例 构造函数 12Timer( )Timer(boolean DThread) 方法 描述 void cancel( ) 终止定时器线程 void schedule(TimerTask TTask, long wait) TTask被安排在由参数wait传递的周期之后执行wait参数的单位是毫秒 void schedule(TimerTask TTask, long wait,long repeat) void schedule(TimerTask TTask, long wait,long repeat) void schedule(TimerTask TTask, Date targetTime) TTask被安排在由targetTime指定的时间执行 void schedule(TimerTask TTask,Date targetTime, long repeat) TTask被安排在由targetTime指定的时间执行。接&gt;着任务在由repeat传递的时间间隔重复执行。repeat参数的单位是毫秒 void scheduleAtFixedRate(TimerTask TTask,long wait, long repeat) TTask被安排在经过由参数wait传递的周期之后执行。任务随后在由repeat指定的时间间隔重复执行。参数wait和repeat的单位都是毫秒。每一次重复的时间是和第一次执行，而不是和前一次执行的时间有关。因此执行的总速度是固定的 void scheduleAtFixedRate(TimerTask TTask,Date targetTime, long repeat) TTask被安排在由targetTime指定的时间执行。任务随后在由repeat指定的时间间隔重复执行。参数repeat的单位是毫秒。每一次重复的时间是和第一次执行，而不是和前一次执行的时间有关。因此执行的总速度是固定的 TimerTaskTimerTask实现了Runnable接口；因此它可以被用于创建一个执行线程 构造函数 1TimerTask( ) 方法 描述 boolean cancel( ) 终止任务。如果任务的执行被阻止了，则返回true；否则返回false abstract void run( ) 包含了定时器任务的代码 long scheduledExecutionTime( ) 返回被安排最后执行的任务的时间 数学函数类Math 函数 说明 Math.sin sin Math.cos Math.tan Math.atan(x) 返回一个 - π/2 到 π/2 弧度之间的数值 Math.atan2(y,x) 返回一个 -π 到 π 之间的数值，表示点 (x, y) 对应的偏移角度 Math.exp Math.log Math.log10 Math.PI π Math.E e Math.sqrt 算数平方根 Math.pow(x,a) 幂运算，计算x^a(double参数，返回double类型) Math.round(x) 四舍五入,返回long类型 Java IO]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
