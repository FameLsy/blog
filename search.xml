<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Http学习]]></title>
    <url>%2Fblog%2F2019%2F05%2F17%2F%EF%BC%A8ttp%2F</url>
    <content type="text"><![CDATA[基础协议（protocol）所谓的协议，指的是不同的硬件、操作系统之间的通信需要一种的规则 OSI标准OSI提出了一个标准，并非真正的实现。 7层模型主要包括： 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。 数据链路层：主要将从物理层接收的数据进行MAC地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。 网络层：主要将从下层接收到的数据进行IP地址（例192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。 传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） 表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）） 应用层 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用 TCP/IP协议族TCP/IP 是互联网相关的各类协议族的总称，其中最重要的一点是分层。TCP/IP是遵循OSI标准的一个具体实现 TCP/IP 的分层管理TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层 应用层应用层决定了向用户提供应用服务时通信的活动，在CP/IP 协议族内预存了各类通用的应用服务。如FTP（FileTransfer Protocol，文件传输协议）、 DNS（Domain Name System，域名系统）、HTTP 传输层传输层提供处于网络连接中的两台计算机之间的数据传输，存在两个不同性值的协议：TCP（Transmission ControlProtocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议） 网络层网络层又名网络互连层，用来处理在网络上流动的数据包（数据包是网络传输的最小数据单位），通过该层决定传输线路，如IP协议就位于网络层 链路层链路层又名数据链路层，网络接口层，用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介） TCP/IP通信传输过程TCP/IP通信，采用封装（encapsulate）方式将数据信息包装起来进行传输。 以HTTP为例，结合图 在应用层（HTTP 协议），发出一个HTTP请求 在传输层（TCP 协议），把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层 到服务器端，在依次去掉首部，获得真正的HTTP数据 IP协议IP（Internet Protocol）网际协议位于网络层，几乎所有使用网络的系统都会用到 IP 协议。其作用是把各种数据包传送给对方，为了保证数据传送到目的地，需要满足两个重要的条件 IP地址：指明了节点被分配到的地址（可变换） MAC （Media Access Control Address）地址：指网卡所属的固定地址（基本不变） IP间的通信依赖于MAC地址。除局域网外，往往需要经过多台计算机和网络设备中转才会连接到目的地，主要是利用了MAC地址进行搜索下一个中转目标。此时，需要采用ARP协议（AddressResolution Protocol），该协议可以根通信方的 IP 地址反查出对应的 MAC 地址 数据包 源端口号（ 16 位）：它（连同源主机 IP 地址）标识源主机的一个应用进程。 目的端口号（ 16 位）：它（连同目的主机 IP 地址）标识目的主机的一个应用进程。这两个值加上 IP 报头中的源主机 IP 地址和目的主机 IP 地址唯一确定一个 TCP 连接。 顺序号seq（ 32 位）：用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则 TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数，序号到达 2 的32次方 － 1 后又从 0 开始。当建立一个新的连接时， SYN 标志变 1 ，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ）。 确认号ack（ 32 位）：包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效。 TCP 为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。 TCP 报头长度（ 4 位）：给出报头中 32bit 字的数目，它实际上指明数据从哪里开始。需要这个值是因为任选字段的长度是可变的。这个字段占 4bit ，因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节。 保留位（ 6 位）：保留给将来使用，目前必须置为 0 。 控制位（ control flags ， 6 位）：在 TCP 报头中有 6 个标志比特，它们中的多个可同时被设置为 1 。依次为： a. URG ：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。 b. ACK ：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。 c. PSH ：为 1 表示是带有 PUSH 标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。 d. RST ：用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。 e. SYN ：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步（ synchronize ）。 f. FIN ：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。 窗口大小（ 16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535字节。 校验和（ 16 位）：此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。 紧急指针（ 16 位）：只有当 URG 标志置 1 时紧急指针才有效。TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。 选项：最常见的可选字段是最长报文大小，又称为 MSS(Maximum Segment Size) 。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项，它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍，所以要加填充位，使得报头长度成为整字数。 数据： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。 TCP协议三次握手TCP 位于传输层，可以提供可靠的字节流服务。为了确保可靠性，即保证数据传送给目标，TCP协议采用了三次握手策略 第一次握手：客户端首先发送SYN=1标志,并随机产生seq的数据包给服务器，根据SYN=1，服务器知道客户端要求建立联机 第二次握手：服务器接收到数据包后，回传一个 ack(值为客户端seq+1) 标志,SYN=1,ACK标志=1，随机产生服务器seq的数据包以示传达确认信息 第三次握手：客户端确认ack是否正确，即确认seq+1和ACK标志=1，若正确，再回传一个ack（值为服务器端的seq+1）,ACK标志=1的数据包，服务器确认ack和ACK标志=1，正确则建立成功 TCP协议四次挥手TCP断开连接要进行四次，这是由于TCP的半关闭造成的。因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个方向的连接。 第一次： 关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。随后客户端进入终止等待状态。 第二次： 服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。服务器进入关闭等待状态。（此时客户端不能发送信息服务器，而服务器还可以发送信息给客户端，即半关闭状态） 第三次： 关闭服务器到客户端的连接：也是发送一个FIN给客户端，等待客户端确认 第四次： 客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。随后服务器端关闭，而客户端需要经过时间等待计时器设置的2MSL后，才关闭 为什么需要等待2MSL？ 当客户端发送ACK后，服务器端确认完毕，可以直接关闭。但对于客户端来说，存在以下两种情况 服务器没有接收到ACK 服务器接收到ACK 而2MSL，正是去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。等待2MSL时间，客户端可以放心地关闭。 DNS服务DNS（Domain Name System）服务位于应用层，提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务 URI和URLURI：统一资源标识符，用字符串标识某一互联网资源 URL：统一资源定位符，表示资源的地点（互联网上所处的位置） URL和URI区别URI可被视为定位符（URL）和名称（URN）的组合，URN定义某个资源的身份，而URL提供查找资源的方法。所以可以说，URL是URI的子集。实际上，可以近似认为URL就是URI URI完整格式完整格式如下： 信息 描述 协议方案名 可以是http、https、file等协议，获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:） 登录信息 （可选）指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证） 服务器地址 指定待访问的服务器地址，可以是域名、IPv4(192.167.2.2)、IPv6([0:0:0:0:0:0:0:1]) 服务器端口号 （可选）指定服务器连接的网络端口号，浏览器默认一般是80 带层次的文件路径 指定服务器上的文件路径来定位特指的资源 查询字符串 （可选）针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数 片段标识符 （可选）使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法 RFC（Request for Comments，征求修正意见书）：互联网的设计文档，要是不按照 RFC 标准执行，就有可能导致无法通信的状况 Http协议HTTP 通常被译为超文本传输协议，严谨的译名应该为超文本转移协议。HTTP是一种无状态的协议，也就是说它不会保留之前一切的请求或响应报文的信息，这样做是为了更快地处理大量事务，确保协议的可伸缩性。如果需要保存状态，可以使用Cooike技术 HTTP报文HTTP报文大致可分为报文首部和报文主体两块，使用空行划分，且报文主体并不一定有 报文 请求报文客户端发送给服务器端请求报文，其由方法、URI、协议版本、请求首部字段、内容实体五部分组成 响应报文服务器端会返回给客户端响应报文，其由协议版本、状态码、状态码的原因短语、相应首部字段、主主体组成。 报文主体和实体主体报文：是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，用于传输请求或响应的实体主体 实体：作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成 传输速率提升HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。 压缩传输的内容编码内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。常见内容编码有 gzip(GNU zip) compress(UNIX系统标准压缩) deflate(zlib) identity(不进行编码) 分块传输编码在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面，但传输大容量数据时，可以采用分块传输编码的方式，把实体主体分给成多块，使浏览器逐步显示页面。 分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主。 发送多种数据在发送邮件时，在邮件里写入文字并添加多份附件，原因时其采用了MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。 在HTTP通信中，在报文主体内可能含有多类型实体，需要在首部字段里加上Content-type 多部分对象集合包含的对象如下 multipart/form-data： 在 Web 表单文件上传时使用 multipart/byteranges： 状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用 multipart/form-data 1234567891011121314//boundary 通过指定的字符串，来划分多部分对象集合指明的各类实体//利用--XX 来表示实体的开始，在这里是--AaB03x//利用--XX-- 来表示多部分对象集合最后，在这里是--AaB03x--Content-Type: multipart/form-data; boundary=AaB03x --AaB03xContent-Disposition: form-data; name="field1" Joe Blow--AaB03xContent-Disposition: form-data; name="pics"; filename="file1.txt"Content-Type: text/plain ...（file1.txt的数据）...--AaB03x-- multipart/byteranges 123456789101112HTTP/1.1 206 Partial ContentDate: Fri, 13 Jul 2012 02:45:26 GMTLast-Modified: Fri, 31 Aug 2007 02:02:20 GMTContent-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES--THIS_STRING_SEPARATESContent-Type: application/pdfContent-Range: bytes 500-999/8000--THIS_STRING_SEPARATESContent-Type: application/pdfContent-Range: bytes 7000-7999/8000...（范围指定的数据）...--THIS_STRING_SEPARATES-- 范围请求即可以请求一个资源的部分部分内容。执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文；另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容 123456//请求5001~10 000 字节Range: bytes=5001-10000//请求从 5001 字节之后全部的Range: bytes=5001-//请求从一开始到 3000 字节和 5000~7000 字节的多重范围Range: bytes=-3000, 5000-7000 内容协商内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。如对相同内容的资源，请求中文版而不是英文版。 内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。在报文中为以下首部字段 Accept Accept-Charset Accept-Encoding Accept-Language Content-Language 此外还有三种内容协商技术 服务器驱动协商：以请求的首部字段为参考，在服务器端自动处理 客户端驱动协商：用户从浏览器显示的可选项列表中手动选择或使用JS脚本在Web 页面上自动进行上述选择 透明协商：由服务器端和客户端各自进行内容协商的 请求方法请求方法用于告知服务器意图，主要有以下几种 方法 描述 GET 用来请求访问已被 URI 识别的资源 POST 传输实体主体 PUT 传输文件（无验证机制，任何人都可以上传文件，不安全） HEAD 获得报文首部，与GET方式类似，只是不返回报文主体部分 DELETE 删除文件（无验证机制，任何人都可以删除文件，不安全） OPTIONS 用来查询针对请求 URI 指定的资源支持的方法 TRACE 让 Web 服务器端将之前的请求通信环回给客户端的方法 CONNECT 要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要的隧道协议有SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全） 持久连接在HTTP协议初始版本，每一次HTTP通信就要断开一次TCP协议，这样做无疑会导致通信量的增加。而HTTP/1.1支持持久协议（HTTP Persistent Connections),，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态,从而减少开销 管线化由于持久连接，使得一个TCP可以接受多个请求，而管线化技术，可以并行发送多个请求，而不是发一个请求，响应之后才可以发送下一个 CookieHTTP协议是无状态协议，由于不必保存状态，自然可减少服务器的 CPU 及内存资源的消耗。Cookie技术可以再保留状态的同时，同时只为服务器带来极少的负担，它通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态，具体为 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。 当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息 第一次请求报文 12GET /reader/ HTTP/1.1Host: hackr.jp 响应报文 123456HTTP/1.1 200 OKDate: Thu, 12 Jul 2012 07:12:20 GMTServer: Apache＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞//生成Cookie信息Content-Type: text/plain; charset=UTF-8 再次请求的请求报文 123GET /image/ HTTP/1.1Host: hackr.jpCookie: sid=1342077140226724// 发送保存的Cookie信息 HTTP状态码状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果，由3个数字和原因短语组成，其中第一个数字指定了相应类别 状态码 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error （服务器错误状态码） 服务器处理请求出错 常见状态码 数字 原因短语 描述 200 OK 客户端发来的请求在服务器端被正常处理 204 No Content 服务器接收的请求已成功处理，但不返回任何实体的主体 206 Partial Content 状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容 301 Moved Permanently 永久性重定向。表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI 302 Found 临时性重定向。表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。禁止将POST变成GET，但可以不遵守 303 See Other 表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源 304 Not Modified 表示客户端发送附带条件的请时，服务器端允许请求访问资源，但未满足条件。 307 Temporary Redirect 临时重定向，与302相同，但会遵从标准，不会讲POST变成GET 400 Bad Request 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求 401 Unauthorized 表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。若之前已进行过 1 次请求，则表示用 户认证失败 403 Forbidden 表明对请求资源的访问被服务器拒绝 404 Not Found 表明服务器上无法找到请求的资源 500 Internal Server Error 表明服务器端在执行请求时发生了错误 503 Service Unavailable 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求 HTTP 首部HTTP首部字段根据实际用途被分为以下 4 种类型 通用首部字段：请求报文和响应报文两方都会使用的首部。 请求首部字段：从客户端向服务器端发送请求报文时使用的首部 响应首部字段：从服务器端向客户端返回响应报文时使用的首 实体首部字段：针对请求报文和响应报文的实体部分使用的首部 此外还存在一些非HTTP/1.1的首部字段，如Cookie、Set-Cookie等 WEB安全HTTP缺点： 通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 加密TCP/IP 是可能被窃听的网络，就算是加密过的通信，也会被窃听，只是窃听的是加密后的报文信息。为了防止被窃听，可以进行的加密处理有 通信加密：即HTTPS 内容的加密：对内容本身进行加密 通信加密HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。它会在服务器和客户端之间，建立一个安全的通信线路。与SSL 组合使用的 HTTP 被称为 HTTPS（HTTPSecure，超文本传输安全协议） 内容加密对内容本身进行加密，要求客户端和服务器同时具备加密和解密机制。但内容还是存在被篡改的可能 身份验证HTTP 协议中的请求和响应不会对通信方进行确认，也就是说服务器不管是谁的请求都会返回一个响应，那么就可能存在以下隐患 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器，可能是伪装的WEB服务器 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端，可能是伪装的客户端 无法确定正在通信的对方是否具备访问权限 无法判定请求是来自何方、出自谁手 即使是无意义的请求也会照单全收（DOS攻击，发送海量请求） SSL除了提供加密处理外，还提供了证书，证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的，且证书伪造极为困难。通过持有的证书，来进行认证。 防止篡改由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，请求或响应的内容可能遭到篡改却无法得知。 对于防止篡改，较为常用的是MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法（可以查看《哈希算法》数据校验 一小节） HTTPSHTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。与HTTP的区别在于，HTTP是直接和TCP进行通信，而HTTPS是先和SSL通信，再由SSL和TCP进行通信，从而获得加密、证书、完整性保护等功能 密钥技术SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式，在加密和解密都会用到密钥。没有密钥就无法对密码解密。 如何将密钥安全的发送公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。私有密钥不能让任何人知道，公开密钥任何人都可以获取 对于发送密文的一方，使用对方的公开密钥进行加密处理，而它本身也不知道如何解密。也就是说，公开密钥只负责加密 收到密文的一方，通过私钥进行解密。也就是说，私钥只负责解密 利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。而且根据密文和公开密钥，恢复信息原文是极为困难的。 如何保证公钥的正确性公开密钥本身也有可能被篡改。解决的方式为，可以使用由数字证书认证机构（CA，CertificateAuthority）和其相关机关颁发的公开密钥证书。数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上，业务流程如下 由服务器向认证机构提出公开密钥的申请 认证机构对申请的企业进行审核，审核通过后会对已申请的公钥进行数字签名（用于验证企业），并将该公钥放入公钥证书 服务器将公钥证书发送给客户端 客户端利用对应 CA 的公钥解密签名数据，进行验证，验证通过说明 a. 公开密钥的是真实有效的数字证书认证机构 b. 服务器的公开密钥是值得信赖的 每个浏览器都内置了信赖的CA，如果CA不被信任，则找不到对应 CA 的证书，证书也会被判定非法。也就是说光篡改公钥不行，还得搞定CA的认证。伪造数字签名显然不可能，但如果客户端乱加CA认证，还是不能保证公钥的正确性。 HTTPS的安全通信机制HTTPS 的通信步骤如下 客户端通过发送Client Hello报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等） 服务器可进行 SSL 通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。 服务器发送 Certificate（证书） 报文。报文中包含公开密钥证书 最后服务器发送Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束 SSL 第一次握手结束之后，客户端以 Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密 接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密 客户端发送 Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准 服务器同样发送 Change Cipher Spec 报文。 服务器同样发送 Finished 报文。 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。 最后由客户端断开连接。断开连接时，发送 close_notify 报文。这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。 WEB攻击Web的攻击模式有以下两种 主动攻击：直接针对服务器上的资源进行攻击，具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击。 被动攻击：利用圈套策略执行攻击代码的攻击模式，步骤如下 a. 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的 HTTP 请求 b. 当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱 c. 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码 d. 执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。 输出转义存在的安全漏洞实施 Web 应用的安全对策可大致分为以下两部分 客户端的验证 Web端的验证：包括输入值验证和输出值转义 XSS攻击跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击 如下是一个页面的代码，用于输入ID 12345678&lt;div class="logo"&gt; &lt;img src="/img/logo.gif" alt="E! 拍卖会" /&gt;&lt;/div&gt; &lt;form action="http://example.jp/login" method="post" id="login"&gt; &lt;div class="input_id"&gt; ID &lt;input type="text" name="ID" value="yama" /&gt; &lt;/div&gt;&lt;/form&gt; 如下URI可以自动注入ID的值 1http://example.jp/login?ID=xxx" 如果此时URI变成 1http://example.jp/login?ID=&quot;&gt;&lt;script&gt;alert(&quot;你被攻击了&quot;);&lt;/script&gt;&lt;span+s=&quot; 那么整个页面就会被注入JS脚本(如果是恶意的话，你的某些信息就会被获取了) 123456789101112&lt;div class="logo"&gt; &lt;img src="/img/logo.gif" alt="E! 拍卖会" /&gt;&lt;/div&gt; &lt;form action="http://example.jp/login" method="post" id="login"&gt; &lt;div class="input_id"&gt; ID &lt;input type="text" name="ID" value=" "&gt; &lt;script&gt;alert("你被攻击了");&lt;/script&gt;&lt;span+s=""/&gt; &lt;/div&gt;&lt;/form&gt; &lt;!--比方说调用远程的js文件进行攻击 --&gt;&lt;script src=http://hackr.jp/xss.js&gt;&lt;/script&gt; SQL注入源代码 1SELECT title,text FROM newsTbl WHERE id="" and passwd="" 注入 12-- 表示注释，如下注入后就无需密码就可以获取到资源了SELECT title,text FROM newsTbl WHERE id="" or 1 = 1 -- and passwd=? todo]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap详解]]></title>
    <url>%2Fblog%2F2018%2F03%2F23%2FHashMap%2F</url>
    <content type="text"><![CDATA[Java7中的HashMapHashMap的结构HashMap的结构使用数组+链表的方式实现。它的内部包含了一个单向链表Entry静态内部类和一个以Entry[]数组 123456789// 内部静态类，是一个单项链表 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; &#125;// 类型为 Entry&lt;K,V&gt;的一个数组transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; 其结构图如下，可以看出，该结构借鉴了桶排序算法 HashMap相关变量介绍 变量 描述 DEFAULT_INITIAL_CAPACITY 默认初始化容量，值为1 &lt;&lt; 4(16) MAXIMUM_CAPACITY HashMap容器允许的最大容量，值为1 &lt;&lt; 30(2 ^ 30) DEFAULT_LOAD_FACTOR 默认加载因子，值为0.75f EMPTY_TABLE 一个空的Entry[] size HashMap所包含键值对的数量，可以理解为HashMap的大小 loadFactor 加载因子 threshold 扩容的阈值，计算方式为 capacity * loadFactor modCount HashMap结构修改次数，结构修改指的是该百年HashMap中映射数量(如插入、删除)或修改其内部结构（如重散列） hashSeed 该值应用于键的哈希码以使哈希冲突更难找到。 如果为0，则禁用备用散列 HashMap构造函数HashMap有三个重载方法，构造实例后仅初始化了loadFactor和threshold的值 12345678910111213141516171819202122232425262728293031323334//无参构造函数,创建一个初始容量为16，加载因子0.75的HashMappublic HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&#125;// 指定初始容量，加载因子0.75的HashMappublic HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//前两个都是调用这个构造函数/***创建指定容量和指定加载因子的HashMap*@param initialCapacity 容量*@param loadFactor 因子**/public HashMap(int initialCapacity, float loadFactor) &#123; //容量负值，抛出异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); // 容量是否超出最大值 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 加载因子负值或未定义，抛出异常 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); //设置阈值和加载因子 this.loadFactor = loadFactor; threshold = initialCapacity; //初始化（实际上该方法是空的，从注释看与子类有关，暂时不管） init(); &#125; 此外还有一个构造函数，该方法时基于传入的Map来构造HashMap 1234567891011public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; //Math.max(...)方法用来比较传入的Map容量与默认容量的大小 this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); //初始化内部的Entry数组 inflateTable(threshold); //复制值 putAllForCreate(m);&#125; HashMap.put()1234567891011121314151617181920212223242526272829public V put(K key, V value) &#123; // 当第一次插入元素时，需要初始化一个Entry[]数组 if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // key的值可以为null，map数组下表为0的位置用于存放key为null的数据 if (key == null) return putForNullKey(value); //计算K的hash值 int hash = hash(key); // 通过hash值和数组长度，计算出在数组中的插入位置 int i = indexFor(hash, table.length); //检查key是否存在，循环遍历table[i]出的链表，如果key存在，则覆盖并返回旧值 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++;//结构修改次数+1 addEntry(hash, key, value, i);//key没有重复，则添加到链表中 return null;&#125; HashMap.inflateTable()初始化数组 1234567891011121314/***@param toSize： 数组的容量**/private void inflateTable(int toSize) &#123; // roundUpToPowerOf2用于保证当前的数组容量为2的n次方,如传入20,则返回32 int capacity = roundUpToPowerOf2(toSize); //计算扩容阈值：capacity * loadFactory threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); //初始化一个数组 table = new Entry[capacity]; //用于初始化散列掩码值，会延迟初始化知道真正需要它的时候，(暂时不需要理解它) initHashSeedAsNeeded(capacity); &#125; HashMap.indexFor()通过hash值和数组长度，计算Entry在数组中的位置 12345678910/****@param h 数组的哈希值*@param length 数组的长度*@return 返回key在数组的具体位置**/static int indexFor(int h, int length) &#123; // length的长度必须是2的n次，这样length-1转换成二进制即为数个1，如length=32,那么二进制就是11111,整个计算过程就是取hash值的低5位 return h &amp; (length-1);&#125; HashMap.addEntry()12345678910111213/** * 添加数据到链表 **/ void addEntry(int hash, K key, V value, int bucketIndex) &#123; //如果数组达到阈值且新值插入的位置有元素，则需要扩容 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//数组扩容到原来的两倍 hash = (null != key) ? hash(key) : 0;//重新计算hash值 bucketIndex = indexFor(hash, table.length);//重新计算新的下标 &#125; createEntry(hash, key, value, bucketIndex);//创建Entry并插入新值 &#125; HashMap.createEntry()12345678910/** * 加数据封装成Entry并添加 */void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 获取到bucketIndex位置的链表 Entry&lt;K,V&gt; e = table[bucketIndex]; // 将新值设置为链表表头 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;//数组大小+1&#125; HashMap.get()123456789101112131415161718192021222324252627282930public V get(Object key) &#123; //null的情况 if (key == null) return getForNullKey(); //通过Key来得到节点 Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125;//通过key获取节点final Entry&lt;K,V&gt; getEntry(Object key) &#123; //数组大小为0，则直接返回null if (size == 0) &#123; return null; &#125; //计算出hash值，null对应数组下标0的位置 int hash = (key == null) ? 0 : hash(key); //循环遍历链表，直到找到对应的值 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; //== 用于判断基础类型的key，equals用于判断对象类型的key ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; HashMap.remove()123456789101112131415161718192021222324252627282930313233343536373839public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value);&#125;/** * Removes and returns the entry associated with the specified key * in the HashMap. Returns null if the HashMap contains no mapping * for this key. */final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e;&#125; HashMap扩容对于数组扩容，需要考虑 是否已经是最大容量，如果是，那么不能再扩容了 可以扩容，则需要创建一个新的数组，并把旧的数据复制过去 再复制的时候，应该考虑到因为数组长度的变化，原数据中的节点的在位置会发生改变 123456789101112131415161718192021/***@newCapacity 新的数组大小，一般传入的时当前数组的两倍**/void resize(int newCapacity) &#123; Entry[] oldTable = table; //旧数组 int oldCapacity = oldTable.length;//旧数组长度 //如果旧数组容量已经达到最大限制，旧把阈值设置到最大值，这样旧无法扩容给了 if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE;//将扩容阈值提升到Integer的最大值(2^31)，即无法再扩容（再扩容就超出int范围了） return; &#125; //没有达到最大限制 //新建一个数组 Entry[] newTable = new Entry[newCapacity]; //数组迁移,迁移方式为：如table[1]处的Entry链表，它的所有节点，会被拆分并分配到table[1]~table[1+oldLength]的位置 transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; HashMap.initHashSeedAsNeeded()该方法实现数据迁移，迁移会导致链表逆序，即扩容器A-&gt;B-&gt;C,扩容后C-&gt;B-&gt;A，如果是多线程的情况下，容易出现环形链表（当然，如果是多线程，建议使用ConcurrentHashMap） 123456789101112131415161718192021void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; //循环遍历旧table for (Entry&lt;K,V&gt; e : table) &#123; //开始循环处理链表上的每一个元素 while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; //如果rehash为true，说明需要重新计算hash值 if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; //重新计算位置 int i = indexFor(e.hash, newCapacity); //数据放到新的bin中的第一个节点（导致链表逆序） e.next = newTable[i]; newTable[i] = e; //处理链表的下一个Entry e = next; &#125; &#125;&#125; hash函数 HashMap是通过key来计算哈希值，hash函数应该尽量减少hash冲突 12345678910111213141516/***hash值的计算***/final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); //此函数确保在每个位位置仅由常数倍数相差的hashCodes具有有限的冲突数（默认负载系数约为8） h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; java8中的HashMapHashMap的结构Java8 于java7最大的不同指出，在于底层采用了数组+链表+红黑树组成，时间复杂度从O(n)降为O(logn) 123456789101112131415161718//java 8中的table为Node数组transient Node&lt;K,V&gt;[] table;//Node节点属性与Java 7 中的Entry并无区别static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;&#125;// Java 8独有的用于红黑树的节点 static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; &#125; HashMap相关变量介绍除了Java7的变量外，还新增了 变量 描述 TREEIFY_THRESHOLD 这是一个计数阈值，当桶中bin(箱)的元素数量到达该阈值时，会将bin的结构改为红黑树，值为8 UNTREEIFY_THRESHOLD 计数阈值，当桶中bin(箱)的元素数量到达该阈值时，会将bin的结构改为链表，值为8 MIN_TREEIFY_CAPACITY 桶中bin最小hash容量，如果大于这个值会进行resize扩容操作，此值至少是TREEIFY_THRESHOLD的4倍，值为64 HashMap构造函数依旧是有三个方法, 对threshold变量的赋值方法发生了变化 123456789101112131415161718192021222324//java 7 的赋值方法threshold = initialCapacity;//java 8的赋值方法，直接在构造是就计算出了真实的容量this.threshold = tableSizeFor(initialCapacity);// 这是一种计算获取cap就近二次幂的高效算法,假设传入一个129static final int tableSizeFor(int cap) &#123; int n = cap - 1; //256,二进制 1000_0000 n |= n &gt;&gt;&gt; 1; // 结果：1100_0000 n |= n &gt;&gt;&gt; 2; // 结果: 1111_0000 n |= n &gt;&gt;&gt; 4; // 结果：1111_1111 n |= n &gt;&gt;&gt; 8; // 结果：1111_1111 n |= n &gt;&gt;&gt; 16;// 结果：1111_1111 //规律 //第一次运算，会使...1...-&gt;...11... //第二次运算，会使...11...-&gt;...1111... //第三次运算，会使...1111...-&gt;...11111111... //... //最后一次 ,会使 1111111111111111-&gt; 11111111111111111111111111111111 //至于cap - 1,如果cap恰好为2的倍数，则应该不需要变化，如果没有-1，比方说传入8，那么会得到16，显然不行 return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 因为会计算容量，所以对于无参的构造函数，也进行了修改，因为其不需要计算真实的容量 123public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; 基于传入的Map来构造HashMap的方法，因为数据复制会牵扯到数组-&gt;红黑树，所以该部分方法进行了重写 12345// todopublic HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; HashMap.put()Java7和Java8 put的不同点在于 Java8 需要考虑链表转红黑树的过程 对于扩容，Java7是先扩容后，在插值；而Java8直接插值，然后预判下一次插值是否会超过阈值，是的话就扩容 1234//调用了putVal方法public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; HashMap.putVal()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 /** * * @param hash * @param key * @param value * @param onlyIfAbsent 如果为true，则只有在不存在该 key 时才会进行 put 操作 * @param evict 如果为false，则表处于创建模式。（暂时不用管） * @return */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //当第一次put时，触发resize()方法扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //寻找节点，如果没有该节点，则直接创建一个节点并赋值即可 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123;//如果有节点 Node&lt;K,V&gt; e; K k; // 判断第一个节点是否相等，是的话直接覆盖 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断是否是红黑树节点，是的话调用红黑树节点的插入法 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 前面两部判断出桶的bin是链表 else &#123; //开始循环遍历链表并插入 // 如果p的下一节点为空，就之间创建并赋值即可（考虑链表转红黑树）,此时e == null // 如果p的下一个节点不为空，那么有两种情况 // 1. 这个节点与插入的key、hash相等，保留这个节点e，退出循环,此时e != null // 2. 不相等，那么将p设置成p.next,进行下一次循环 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 判断插入的节点是否是链表中的第8个,如果是，需要将链表转换成红黑树 // 要注意binCount只的是插入节点的前一个节点位置， if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 如果存在相等的情况，则什么都不做，保留这个节点e，并退出 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //将p设置为p.next,进行下一次循环 p = e; &#125; &#125; //经过前面的循环，如果e ！= null，说明存在相同key、hash值的节点，需要覆盖 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 如果插入后超出了阈值，则扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); // 空方法，不用管 return null; &#125; HashMap.get()12345//调用了getNode()方法public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; HashMap.getNode()12345678910111213141516171819202122232425262728293031/** * Implements Map.get and related methods. * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 判断table是否为Null，长度是否为0，对应位置的是否存在节点 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 判断第一个节点是不是需要的 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 如果有下一个节点 if ((e = first.next) != null) &#123; //如果是红黑树节点，则使用红黑树的方法获取 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123;//如果是链表，则循环判断 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; HashMap.remove()123456//调用了removeNode()方法public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; HashMap. removeNode()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Implements Map.remove and related methods. * * @param hash hash for key * @param key the key * @param value the value to match if matchValue, else ignored * @param matchValue if true only remove if value is equal * @param movable if false do not move other nodes while removing * @return the node, or null if none */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; // 先判空，如果table为空或者对应位置的bin为空的话，就不需要删除了 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; //node 用来存储要删的节点 Node&lt;K,V&gt; node = null, e; K k; V v; // 这一层if-eles 类似于get过程，用于找到要删除的节点 (不再赘述) if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; //这一层if-else通过上一层获取到的节点，进行删除 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; //如果是红黑树节点，使用红黑树节点的方式删除 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p)// 相等，说明时第一个节点，直接将node的下一个节点提上来 tab[index] = node.next; else // 非第一个节点时的删除情况 p.next = node.next; ++modCount; --size; afterNodeRemoval(node);// 空方法 return node; &#125; &#125; return null;&#125; HashMap扩容HashMap在第一次put时，就会进行扩容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length;// 旧table 容量 int oldThr = threshold;//旧table 扩容阈值 int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 容量是否超出最大限定 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 扩容一倍容量 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 复制阈值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; //oldCap、oldThr均小于等于0，说明是第一次put，赋值默认值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //计算新的扩容上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; // 初始化一个新的Node数组 @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 如果有旧数据，则需要复制到新的数组中 if (oldTab != null) &#123; //循环遍历旧表 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode)// 如果红黑树树节点则按照红黑树的方式转移 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; Hash函数精简了哈希函数 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 其他问题为什么加载因子的默认值为.75查看HashMap开头的注释，有这么一段话 As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put ) 作为一般规则，默认加载因子（.75）在时间和空间成本之间提供了良好的权衡。 较高的值会减少空间开销，但会增加查找成本（反映在HashMap类的大多数操作中，包括get和put）]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2Fblog%2F2018%2F03%2F22%2FMyBatis.all%2F</url>
    <content type="text"><![CDATA[MyBatis相关包Mybatis 123456789101112&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.25&lt;/version&gt;&lt;/dependency&gt; MyBatis 基本构成 组件 说明 SqlSessionFactoryBuilder 根据配置信息或者代码生成SqlSessionFactory SqlSessionFactory 依靠工厂来生成SqlSession SqlSession 可以发送Sql去执行返回结果，也可以获取Mapper的接口 SQL Mapper MyBatis新设计组件，由一个Java接口和XML文件（或注解）构成，需要给出对应的SQL和映射规则。负责发送SQL去执行，并返回结果 关系图： SqlSessionFactoryBuilderSqlSessionFactoryBuilder 用于构建 SqlSessionFactory 的实例，提供了两种方式 从 XML 配置文件构建 通过 Configuration 的实例构建 生命周期： 其作用是构建一个或多个SqlSessionFactory 只存在于方法的局部，一旦完成了构建SqlSessionFacory，它的作用就已经结束 XML方式构建SqlSessionFactory（推荐）构建方式： 创建一个XML输入流 MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易 使用SqlSessionFactroyBuilder读取XML信息来创建SqlSessionFactory对象 其中，XML的配置信息会解析到Configuration类对象里面，SqlSessionFactroyBuilder就是通过读取改对象创建的SessionFactory 1234String resource = "mybatis-config.xml";Inputstream inpoutStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = null;sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 代码方式构建SqlSessionFactory（了解）构建方式、 创建了一个Configuration类对象，通过该对象添加各种配置 通过SqlSessionFactoryBuilder读取Configuration对象创建SqlSessionFactory 1234567891011121314151617181920212223// package com.masorl.code2_3;public class MyBaitsDemo &#123; public static void main(String[] args) &#123;// 构建数据库环境 PooledDataSource dataSource = new PooledDataSource(); dataSource.setDriver("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql：//localhost:3306/mybatis"); dataSource.setUsername("root"); dataSource.setPassword("123456");// 构建数据库事务方式 TransactionFactory transactionFactory = new JdbcTransactionFactory();// 构建数据库运行环境 Environment environment = new Environment("development",transactionFactory,dataSource);// 构建Configuration对象 Configuration configuration = new Configuration(environment);// 注册一个Mybatis上下文别名 configuration.getTypeAliasRegistry().registerAlias("role",Role.class);// 加入映射器 configuration.addMapper(RoleMapper.class);// 使用SqlSessionFactoryBuilder构建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); &#125;&#125; SqlSessionFactorySqlSessionFactory是一个工厂接口，任务是创建SqlSession（创建方式为单例），有两个实现 DefaultSqlSessionFactory SqlSessionManager(较少用) 生命周期 其作用是创建SqlSession 因为SqlSession是一个会话，所以每次访问数据库时都需要SqlSessionFactory创建 因此SqlSessionFacory存在于MyBayis的整个生命周期内 获取SqlSession方法 1sqlSession = sqlSessionFactroy.openSession(); SqlSessionSqlSession: 完全包含了面向数据库执行 SQL 命令所需的所有方法。可以通过 SqlSession 实例来直接执行已映射的 SQL 语句(但不推荐)，或者获取Mapper类 类似于一个JDBC的Conneciton的接口，需要保证每次用完都会关闭Sqlsession，线程不安全，有两个实现类 DefaultSqlSession SlqSessionManger 生命周期： 会话，相当于一个JDBC的Connection对象。每个线程都应该有它的SqlSession实例 最佳作用域式请求或者方法作用域 因此生命周期应该在请求数据库处理事务中 存活于一个应用的请求和操作 标准SqlSession用法12345678910111213141516171819// package com.masorl.code2_4;public class SqlSessionDemo &#123; public static void main(String[] args) &#123;// 伪代码 SqlSession sqlSession = null; try&#123; sqlSession = sqlSessionFactroy.openSession();// some code sqlSession.commit(); &#125;catch (Exception e)&#123; System.out.println(e.getMessage()); sqlSession.rollback(); &#125;finally &#123; if (sqlSession != null)&#123; sqlSession.close(); &#125; &#125; &#125;&#125; SqlSession直接执行SQL（不推荐） SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法可以通过 SqlSession 实例来直接执行已映射的 SQL 语句 123456 SqlSession session = sqlSessionFactory.openSession();try &#123; Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);&#125; finally &#123; session.close();&#125; SqlSession通过Mapper执行SQL（推荐）1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; finally &#123; session.close();&#125; 用途1，2对比之下，2可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。 Mapper, 映射器映射器： 由Java接口和XML文件（或注解）共同组成 映射器作用： 定义参数类型 描述缓存 描述Sql语句 定义查询结果和POJO的映射关系 映射器的实现： XML方式 代码方式 生命周期： 其作用是发送SQL，返回我们需要的结果，或执行SQL语句修改数据库 因此属于方法级别，存在于一个SqlSession事务方法之内 最佳作用域为方法作用域 Configuration,配置信息Configuration: 全限定名：rog.apache.ibatis.seeion.Configuration，用于保存配置信息，可以主动创建或者通过SqlSessionFactoryBuilder .build()方法自动创建 在Mybatis中以对象的形式存在于整个应用的生命周期,以便重复读取和云用 单例 XML配置文件XML配置文件元素 配置 说明 properties 属性,主要是定义一些字符常量等属性共Mybatis上下文使用 settings 设置 typeAliases 类型别名,主要时用来减少完全限定名的冗余 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 databaseIdProvider 数据库厂商标识 mappers 映射器 xml 通用格式文件名： mybatis-config.xml 1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; ...&lt;/configuration&gt; properties 属性properties 配置的属性可用于整个配置文件，有三种配置方式： 直接在property 子元素中配置 通过外部的properties配置文件 通过程序参数传递 property 子元素配置方式1234&lt;properties resource="org/mybatis/example/config.properties"&gt; &lt;property name="username" value="dev_user"/&gt; &lt;property name="password" value="F2Fa3!33TYyg"/&gt;&lt;/properties&gt; properties配置文件（推荐）123//xxx.properties文件username=dev_userpassword=F2Fa3!33TYyg 在XML配置中引入properties文件 1&lt;properties resource="../xxx.properties"&gt; 程序参数传递即通过参数的形式，将properties和xml配置作为参数传入SqlSessionFactoryBuilder构造方法中，以此直接构造一个SqlSessionFactory对象. 12345SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);// ... or ...SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props); 三种配置方式的优先级properties 属性的读取顺序为 &lt; property &gt;元素体内的属性先被读取（所以优先级最低，会被覆盖） 再读取&lt; properties &gt;元素体中resource引入的.properties文件 最后读取方法参数引入的属性(所以优先级最高) 因此，建议首选properties文件引入方式，不要混淆使用 属性的使用通过${name}的方式来整个配置文件中进行动态配置属性 123456&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/dataSource&gt; 从MyBatis 3.4.2开始，你可以为占位符指定一个默认值(默认这个特性是关闭的，需要手动添加一个指定的属性来开启这个特性) 1234567891011&lt;!-- 开启特效 --&gt;&lt;properties resource="org/mybatis/example/config.properties"&gt; &lt;!-- ... --&gt; &lt;property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/&gt; &lt;!-- Enable this feature --&gt;&lt;/properties&gt;&lt;!-- 使用该特性 --&gt;&lt;dataSource type="POOLED"&gt; &lt;!--username没有定义时会用ut_user代替 --&gt; &lt;property name="username" value="$&#123;username:ut_user&#125;"/&gt; &lt;/dataSource&gt; Setting 属性Setting属性式用来改变Mybaits的默认配置，它会改变Mybaits的运行时行为，可以不用配置 Setting属性表 设置名 描述 有效值 默认值 cacheEnabled 全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。 true &#124; false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType属性来覆盖该项的开关状态。 true &#124; false false aggressiveLazyLoading 当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载（参考 lazyLoadTriggerMethods)。 true &#124; false false （在 3.4.1 及之前的版本默认值为 true） multipleResultSetsEnabled 是否允许单一语句返回多结果集（需要驱动支持）。 true &#124; false true useColumnLabel 使用列标签代替列名。不同的驱动在这方面会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。 true &#124; false true useGeneratedKeys 允许 JDBC 支持自动生成主键，需要驱动支持。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能支持但仍可正常工作（比如 Derby）。 true &#124; false False autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。 NONE, PARTIAL, FULL PARTIAL autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或者未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出提醒日志 (&#39;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#39;的日志等级必须设置为 WARN)FAILING: 映射失败 (抛出 SqlSessionException) NONE, WARNING, FAILING NONE defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数。 任意正整数 未设置 (null) defaultFetchSize 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 任意正整数 未设置 (null) safeRowBoundsEnabled 允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 true &#124; false False safeResultHandlerEnabled 允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为 false。 true &#124; false True mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 true &#124; false False localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 SESSION &#124; STATEMENT SESSION jdbcTypeForNull 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 JdbcType 常量，常用值：NULL, VARCHAR 或 OTHER。 OTHER lazyLoadTriggerMethods 指定哪个对象的方法触发一次延迟加载。 用逗号分隔的方法列表。 equals,clone,hashCode,toString defaultScriptingLanguage 指定动态 SQL 生成的默认语言。 一个类型别名或完全限定类名。 org.apache.ibatis.scripting.xmltags.XMLLanguageDriver defaultEnumTypeHandler 指定 Enum 使用的默认 TypeHandler 。（新增于 3.4.5） 一个类型别名或完全限定类名。 org.apache.ibatis.type.EnumTypeHandler callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值初始化的时候比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。 true &#124; false false returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回 null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 （如集合或关联）。（新增于 3.4.2） true &#124; false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 任何字符串 未设置 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J &#124; LOG4J \&#124;LOG4J2 &#124; JDK_LOGGING &#124; COMMONS_LOGGING &#124; STDOUT_LOGGING &#124; NO_LOGGING 未设置 proxyFactory 指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。 CGLIB &#124; JAVASSIST JAVASSIST （MyBatis 3.3 以上） vfsImpl 指定 VFS 的实现 自定义 VFS 的实现的类全限定名，以逗号分隔。 未设置 useActualParamName 允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 -parameters 选项。（新增于 3.4.1） true &#124; false true configurationFactory 指定一个提供 Configuration 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为static Configuration getConfiguration() 的方法。（新增于 3.2.3） 类型别名或者全类名. 未设置 一个完整的setting配置1234567891011121314151617&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt; &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt; &lt;setting name="defaultStatementTimeout" value="25"/&gt; &lt;setting name="defaultFetchSize" value="100"/&gt; &lt;setting name="safeRowBoundsEnabled" value="false"/&gt; &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt; &lt;setting name="localCacheScope" value="SESSION"/&gt; &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt;&lt;/settings&gt; typeAliases属性(别名)typeAliases用来为java类型设置一个短的名称，它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余 Mybatis内置的别名 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 自定义别名XML方式12345&lt;typeAliases&gt;&lt;!-- Author和Blog在其他敌方使用，就相当于后面的全称 --&gt; &lt;typeAlias alias="Author" type="com.masorl.blog.Author"/&gt; &lt;typeAlias alias="Blog" type="com.masorl..blog.Blog"/&gt;&lt;/typeAliases&gt; 扫描注解方式应用场景，当POJO对象过多时，一个个定义别名未免太过于繁琐 MyBatis可以通过扫描包的形式定义别名 123&lt;typeAliases&gt; &lt;package name="com.masorl.blog"/&gt;&lt;/typeAliases&gt; 那么他将会扫描com.masorl.blog下的所有Java bean 在没有注解的情况下，会使用bean的首字母小写作为别名,如com.masorl.blog.Author的别名就是”author” 也可以通过@Alias注解方式命名 12@Alias("author")public class Author()&#123;...&#125; typeHandlers类型处理器无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。 作用： 将javaType转换成jdbcType 将jdbcType转换成javaType Mybatis内置的类型处理器 类型处理器 Java 类型 JDBC 类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的 BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的 NUMERIC 或 BYTE ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或 SMALLINT IntegerTypeHandler java.lang.Integer, int 数据库兼容的 NUMERIC 或 INTEGER LongTypeHandler java.lang.Long, long 数据库兼容的 NUMERIC 或 BIGINT FloatTypeHandler java.lang.Float, float 数据库兼容的 NUMERIC 或 FLOAT DoubleTypeHandler java.lang.Double, double 数据库兼容的 NUMERIC 或 DOUBLE BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的 NUMERIC 或 DECIMAL StringTypeHandler java.lang.String CHAR, VARCHAR ClobReaderTypeHandler java.io.Reader - ClobTypeHandler java.lang.String CLOB, LONGVARCHAR NStringTypeHandler java.lang.String NVARCHAR, NCHAR NClobTypeHandler java.lang.String NCLOB BlobInputStreamTypeHandler java.io.InputStream - ByteArrayTypeHandler byte[] 数据库兼容的字节流类型 BlobTypeHandler byte[] BLOB, LONGVARBINARY DateTypeHandler java.util.Date TIMESTAMP DateOnlyTypeHandler java.util.Date DATE TimeOnlyTypeHandler java.util.Date TIME SqlTimestampTypeHandler java.sql.Timestamp TIMESTAMP SqlDateTypeHandler java.sql.Date DATE SqlTimeTypeHandler java.sql.Time TIME ObjectTypeHandler Any OTHER 或未指定类型 EnumTypeHandler Enumeration Type VARCHAR 或任何兼容的字符串类型，用以存储枚举的名称（而不是索引值） EnumOrdinalTypeHandler Enumeration Type 任何兼容的 NUMERIC 或 DOUBLE 类型，存储枚举的序数值（而不是名称）。 SqlxmlTypeHandler java.lang.String SQLXML InstantTypeHandler java.time.Instant TIMESTAMP LocalDateTimeTypeHandler java.time.LocalDateTime TIMESTAMP LocalDateTypeHandler java.time.LocalDate DATE LocalTimeTypeHandler java.time.LocalTime TIME OffsetDateTimeTypeHandler java.time.OffsetDateTime TIMESTAMP OffsetTimeTypeHandler java.time.OffsetTime TIME ZonedDateTimeTypeHandler java.time.ZonedDateTime TIMESTAMP YearTypeHandler java.time.Year INTEGER MonthTypeHandler java.time.Month INTEGER YearMonthTypeHandler java.time.YearMonth VARCHAR 或 LONGVARCHAR JapaneseDateTypeHandler java.time.chrono.JapaneseDate DATE 注册TypeHandler的方式指定类型处理器 1234&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt; &lt;typeHandler handler="org.mybatis.example.ExampleTypeHandler"/&gt;&lt;/typeHandlers&gt; 查找类型处理器 1234&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt; &lt;package name="org.mybatis.example"/&gt;&lt;/typeHandlers&gt; 自定义类型处理器自定义处理器可以通过实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler TypeHandler接口1234567891011public interface TypeHandler&lt;T&gt; &#123; //setParameter方法用于对PreparedStatement参数的设置 void setParameter(PreparedStatement var1, int var2, T var3, JdbcType var4) throws SQLException; //getResult: 可以通过下标，列名，或者存储过程（CallableStatement）来获取结果 T getResult(ResultSet var1, String var2) throws SQLException; T getResult(ResultSet var1, int var2) throws SQLException; T getResult(CallableStatement var1, int var2) throws SQLException;&#125; 自定义一个类型处理器如下定义的类型处理器将会覆盖已经存在的处理 Java 的 String 类型属性和 VARCHAR 参数及结果的类型处理器 123456789101112131415161718192021222324// ExampleTypeHandler.java@MappedJdbcTypes(JdbcType.VARCHAR)public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123; ps.setString(i, parameter); &#125; @Override public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return rs.getString(columnName); &#125; @Override public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return rs.getString(columnIndex); &#125; @Override public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return cs.getString(columnIndex); &#125;&#125; 类型处理器是如何确定java类型的 通过泛型处理器的泛型（本例就是这种方式确定Java类型为String) 在类型处理器的配置元素（typeHandler element）上增加一个 javaType 属性（比如：javaType=”String”）； 在类型处理器的类上（TypeHandler class）增加一个 @MappedTypes 注解来指定与其关联的 Java 类型列表(比如：@MappedTypes{String.class})。 如果在 javaType 属性中也同时指定，则注解方式将被忽略。 通过泛型 1public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; 通过Mybaits配置文件 123&lt;typeHandlers&gt; &lt;typeHandler handler="com.learn.chapter2.typeHandler.StringTypeHandler" javaType="string" jdbcType="VARCHAR"/&gt;&lt;/typeHandlers&gt; 通过MappedTypes 123@MappedTypes(&#123;String.class&#125;)@MappedJdbcTypes(JdbcType.VARCHAR)public class StringTypeHandler extends BaseTypeHandler&#123; 类型处理器是如何确定jdbc类型的 在类型处理器的类上（TypeHandler class）增加一个 @MappedJdbcTypes 注解来指定与其关联的 JDBC 类型列表。 如果在 jdbcType 属性中也同时指定，则注解方式将被忽略。 在类型处理器的配置元素上增加一个 jdbcType 属性（比如：jdbcType=”VARCHAR”）； 通过MapperTypes 123@MappedTypes(&#123;String.class&#125;)@MappedJdbcTypes(JdbcType.VARCHAR)public class StringTypeHandler extends BaseTypeHandler&#123; 通过配置文件 12345&lt;typeHandlers&gt; &lt;typeHandler handler="com.learn.chapter2.typeHandler StringTypeHandler" javaType="string" jdbcType="VARCHAR"/&gt;&lt;/typeHandlers&gt; 自定义泛型处理器12345678910//GenericTypeHandler.javapublic class GenericTypeHandler&lt;E extends MyObject&gt; extends BaseTypeHandler&lt;E&gt; &#123; private Class&lt;E&gt; type; public GenericTypeHandler(Class&lt;E&gt; type) &#123; if (type == null) throw new IllegalArgumentException("Type argument cannot be null"); this.type = type; &#125; ... EnumTypeHandler 和 EnumOrdinalTypeHandler 都是泛型类型处理器（generic TypeHandlers） 特殊的TypeHandler,枚举类型若想映射枚举类型 Enum，则从以下TypeHandler中选择 EnumTypeHandler(使用字符串名称作为参数传递) EnumOrdinalTypeHandler(使用整数下标作为参数传递，默认枚举处理器) 在ResultMap中使用TypeHandler在ResultMap中使用TypeHandler java类型可以从结果类型中获得 Jdbc类型未知 因此Mybatis使用javaType=[ TheJavaType ], jdbcType=null的组合来选择一个TypeHandler 非显示设置的话，TypeHandler在ResultMap中无效 希望在ResultMap中使用TypeHandler，那么设置@MappedJdbcTypes注解的includeNullJdbcType=true即可 当只有一个TypeHandler，就算没有includeNullJdbcType=true，它也会是ResultMap使用Java类型时的默认。 objectFactory对象工厂objectFactory对象工厂: MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂（org.apache.ibatis.reflection.factory.DefaultObjectFactory） 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化 自定义工厂对象ObjectFactory接口： 两个创建用的方法 一个setProperties方法（xml文件中的元素体定义的属性会被传递给 setProperties 方法） 一个判断方法 123456789public interface ObjectFactory &#123; void setProperties(Properties var1);// &lt;T&gt; T create(Class&lt;T&gt; var1);//处理默认构造函数 &lt;T&gt; T create(Class&lt;T&gt; var1, List&lt;Class&lt;?&gt;&gt; var2, List&lt;Object&gt; var3);//处理带参数的构造函数 &lt;T&gt; boolean isCollection(Class&lt;T&gt; var1);&#125; 继承DefaultObjectFactory或实现ObjectFactory接口 1234567891011121314// ExampleObjectFactory.javapublic class ExampleObjectFactory extends DefaultObjectFactory &#123; public Object create(Class type) &#123; return super.create(type); &#125; public Object create(Class type, List&lt;Class&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) &#123; return super.create(type, constructorArgTypes, constructorArgs); &#125; public void setProperties(Properties properties) &#123; super.setProperties(properties); &#125; public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type) &#123; return Collection.class.isAssignableFrom(type); &#125;&#125; 配置文件引入自定义工厂对象 1234 &lt;!-- mybatis-config.xml --&gt;&lt;objectFactory type="org.mybatis.example.ExampleObjectFactory"&gt; &lt;property name="someProperty" value="100"/&gt;&lt;/objectFactory&gt; plugins 插件插件引用 123456&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt; &lt;plugin interceptor="org.mybatis.example.ExamplePlugin"&gt; &lt;property name="someProperty" value="100"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 过于复杂，单独开出一章 environments 环境MyBatis可以设置多种环境，但是虽然可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。例如，如果想要链接多个数据库，那就要创建多个SqlSessionFactory 实例 12345678910111213141516171819202122232425262728293031&lt;!-- default属性：表示在默认情况下，使用哪个数据源配置--&gt;&lt;environments default="development"&gt;&lt;!--environment:一个数据源的配置开始 --&gt; &lt;environment id="development"&gt; &lt;!-- transactionManager :事务配置 type属性：事务管理方式 1. JDBC: 采用JDBC方式管理事务 2. MANAGED,采用容器方式管理事务，JNDI常用 3. 自定义 --&gt; &lt;transactionManager type="JDBC"&gt; &lt;!-- property 元素：配置数据事务属性，例如autoCommit=false,不自动提交--&gt; &lt;property name="autoCommit" value="false"/&gt; &lt;/transactionManager&gt; &lt;!-- dataSource:数据库连接信息配置 tpye属性:提供对数据库连接方式的配置,可以选择以下几种 1. UNPOOLED：非数据库连接池配置 2. POOLED,数据库连接池方式 3. JNDI,JDNI数据源 4. 自定义数据源 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 注意：如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置 数据库事务的控制MyBaits将数据库事务交给SqlSession去控制，可以通过SqlSession来提交或回滚。 12aSqlSession.commit();aSqlSession.rollback(); databaseIdProvider,数据库厂商标识作用：MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性 12345&lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="SQL Server" value="sqlserver"/&gt; &lt;property name="DB2" value="db2"/&gt; &lt;property name="Oracle" value="oracle" /&gt;&lt;/databaseIdProvider&gt; type=”DB_VENDOR”,启动MyBaits内部注册的策略器获取数据库ID 1sqlSessionFactory.getConfigureation().getDatabaseId(); 指定SQL语句执行厂商 1&lt;select databaseId="mysql"&gt; 有databaseId属性的Mybatis规则 如果没有配置databaseIdProvider标签，databaseId返回Null 配置了databaseIdProvider标签，MyBaits会用配置的name去匹配数据库信息，配置成功设置databaseId,否则返回Null Comfiguration的databaseId不为空，只会找到配置的databaseID的SQL语句 MyBaits加载不带databaseId属性和带有匹配当前数据库databaseId属性的所有语句。同时找到，会舍弃不带databaseId的语句。 mapper映射器用于注册映射文件，即告诉MyBatis去哪里找映射文件 使用相对于类路径的资源引用12345&lt;mappers&gt; &lt;mapper resource="org/mybatis/builder/AuthorMapper.xml"/&gt; &lt;mapper resource="org/mybatis/builder/BlogMapper.xml"/&gt; &lt;mapper resource="org/mybatis/builder/PostMapper.xml"/&gt;&lt;/mappers&gt; 使用完全限定资源定位符（URL）12345&lt;mappers&gt; &lt;mapper url="file:///var/mappers/AuthorMapper.xml"/&gt; &lt;mapper url="file:///var/mappers/BlogMapper.xml"/&gt; &lt;mapper url="file:///var/mappers/PostMapper.xml"/&gt;&lt;/mappers&gt; 使用映射器接口实现类的完全限定类名12345&lt;mappers&gt; &lt;mapper class="org.mybatis.builder.AuthorMapper"/&gt; &lt;mapper class="org.mybatis.builder.BlogMapper"/&gt; &lt;mapper class="org.mybatis.builder.PostMapper"/&gt;&lt;/mappers&gt; 将包内的映射器接口实现全部注册为映射器123&lt;mappers&gt; &lt;package name="org.mybatis.builder"/&gt;&lt;/mappers&gt; XML映射文件SQL映射文件元素 元素 描述 cache 给定命名空间的缓存配置 cache-ref 其他命名空间缓存配置的引用 resultMap 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象 sql 可被其他语句引用的可重用语句块 insert 映射插入语句 update 映射更新语句 delete 映射删除语句 select 映射查询语句 映射文件通用格式namespace: 为mapper指定一个唯一的namespace，习惯上使用包名+SQL映射文件名形式 1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.liisyu.example.UserMapper"&gt; ...&lt;/mapper&gt; select 元素select 元素具体属性 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。 useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。 insert, update 和 delete数据变更语句 insert，update 和 delete 的实现非常接近，它们执行完后会返回一个整数，标出执行后影响的记录条数 示例1234567891011121314151617&lt;insert id="insertAuthor"&gt; insert into Author (id,username,password,email,bio) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt;&lt;update id="updateAuthor"&gt; update Author set username = #&#123;username&#125;, password = #&#123;password&#125;, email = #&#123;email&#125;, bio = #&#123;bio&#125; where id = #&#123;id&#125;&lt;/update&gt;&lt;delete id="deleteAuthor"&gt; delete from Author where id = #&#123;id&#125;&lt;/delete&gt; 具体属性三者的属性非常相似 1234567891011121314151617181920212223&lt;insert id="insertAuthor" parameterType="domain.blog.Author" flushCache="true" statementType="PREPARED" keyProperty="" keyColumn="" useGeneratedKeys="" timeout="20"&gt;&lt;update id="updateAuthor" parameterType="domain.blog.Author" flushCache="true" statementType="PREPARED" timeout="20"&gt;&lt;delete id="deleteAuthor" parameterType="domain.blog.Author" flushCache="true" statementType="PREPARED" timeout="20"&gt; 属性表 属性 描述 id 命名空间中的唯一标识符，可被用来代表这条语句。 parameterType 将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 主键自动生成123456789&lt;!-- useGeneratedKeys="true" 设置开启自动生成主键 keyProperty="id" 设置需要自动生成的目标主键--&gt;&lt;insert id="insertAuthor" useGeneratedKeys="true" keyProperty="id"&gt; insert into Author (username,password,email,bio) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt; 如果你的数据库还支持多行插入, 你也可以传入一个 Author 数组或集合，并返回自动生成的主键 1234567&lt;insert id="insertAuthor" useGeneratedKeys="true" keyProperty="id"&gt; insert into Author (username, password, email, bio) values &lt;foreach item="item" collection="list" separator=","&gt; (#&#123;item.username&#125;, #&#123;item.password&#125;, #&#123;item.email&#125;, #&#123;item.bio&#125;) &lt;/foreach&gt;&lt;/insert&gt; sql 元素这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中 示例12345678910111213141516171819202122232425&lt;sql id="sometable"&gt; $&#123;prefix&#125;Table &lt;/sql&gt;&lt;sql id="someinclude"&gt; from &lt;include refid="$&#123;include_target&#125;"/&gt; &lt;/sql&gt;&lt;select id="select" resultType="map"&gt; select field1, field2, field3 &lt;include refid="someinclude"&gt; &lt;property name="prefix" value="Some"/&gt; &lt;property name="include_target" value="sometable"/&gt; &lt;/include&gt;&lt;/select&gt;&lt;!-- 语句相当于SELECT field1, field2, field3FROM SomeTable--&gt; resultMap元素在简单的场景下，MyBatis 可以为你自动映射查询结果。但如果遇到复杂的场景，则需要构建一个结果映射 自动映射select元素在简单的场景下，可以自动映射 映射到HashMap：那么，HashMap中的键值就是列名，值即为行对应的值 映射到JavaBean：MyBatis会根据属性名，进行精确匹配，如果没有精确匹配，可以在SELECT语句中使用别名（实际上，MyBatis会在后台创建一个ResultMap,然后再基于属性名进行映射） 123456789101112131415161718192021222324&lt;!-- 查询结果会返回到一个HashMap类型的对象--&gt;&lt;select id="selectPerson" parameterType="int" resultType="java.util.HashMap"&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;!-- 使用别名减少输入完全限定名--&gt;&lt;typeAlias type="com.someapp.model.User" alias="User"/&gt;&lt;select id="selectUsers" resultType="User"&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt;&lt;!-- 没有精确匹配，在SELECT中使用别名--&gt;&lt;select id="selectUsers" resultType="User"&gt; select user_id as "id", user_name as "userName", hashed_password as "hashedPassword" from some_table where id = #&#123;id&#125;&lt;/select&gt; 注意#{id}，表示 MyBatis 创建一个预处理语句参数，相当于 1234// Similar JDBC code, NOT MyBatis…String selectPerson = "SELECT * FROM PERSON WHERE ID=?";PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id); 驼峰命名法的自动映射可以在&lt; setting &gt;中打开mapUnderscoreToCamelCase 配置,可以按照如下方式自动映射 12user_id -&gt; userIDuser_name -&gt; userName 自动映射等级一共由三种自动映射等级 NONE - 禁用自动映射。仅对手动映射的属性进行映射。 PARTIAL - 对除在内部定义了嵌套结果映射（也就是连接的属性）以外的属性进行映射，默认 FULL - 自动映射所有属性 可以使用autoMapping属性 来控制启用/禁用自动映射 123&lt;resultMap id="userResultMap" type="User" autoMapping="false"&gt; ...&lt;/resultMap&gt; FULL 级别自动映射的风险1234567891011121314151617181920&lt;!-- 可以发现B和A都有一个id属性使用FULL会将A的id填入到B的id--&gt;&lt;select id="selectBlog" resultMap="blogResult"&gt; select B.id, B.title, A.username, from Blog B left outer join Author A on B.author_id = A.id where B.id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id="blogResult" type="Blog"&gt; &lt;association property="author" resultMap="authorResult"/&gt;&lt;/resultMap&gt;&lt;resultMap id="authorResult" type="Author"&gt; &lt;result property="username" column="author_username"/&gt;&lt;/resultMap&gt; &lt; resultMap &gt;resultMap元素是MyBatis中最强大的元素，它包含很多子元素 元素 描述 constructor 用于在实例化类时，注入结果到构造方法中 id 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 result 注入到字段或 JavaBean 属性的普通结果 association 一个复杂类型的关联；许多结果将包装成这种类型 嵌套结果映射，关联本身可以是一个 resultMap元素，或者从别处引用一个 collection 一个复杂类型的集合 嵌套结果映射，集合本身可以是一个 resultMap元素，或者从别处引用一个 discriminator 使用结果值来决定使用哪个 resultMap &lt; constructor &gt;用于在实例化类时，注入结果到构造方法中 12345&lt;constructor&gt; &lt;idArg column="id" javaType="int" name="id" /&gt; &lt;arg column="age" javaType="_int" name="age" /&gt; &lt;arg column="username" javaType="String" name="username" /&gt;&lt;/constructor&gt; 相关属性 属性 描述 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 javaType 一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之前的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。 select 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性中指定的列检索数据，作为参数传递给此 select 语句。具体请参考关联元素。 resultMap 结果映射的 ID，可以将嵌套的结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 ResultSet。这样的 ResultSet 将会将包含重复或部分数据重复的结果集。为了将结果集正确地映射到嵌套的对象树中，MyBatis 允许你 “串联”结果映射，以便解决嵌套结果集的问题。想了解更多内容，请参考下面的关联元素。 name 构造方法形参的名字。从 3.4.3 版本开始，通过指定具体的参数名，你可以以任意顺序写入 arg 元素。参看上面的解释。 &lt; id &gt; &amp; &lt; result&gt;id*和 result 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段 12&lt;id property="id" column="post_id"/&gt;&lt;result property="subject" column="post_subject"/&gt; 相关属性 属性 描述 property 映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 javaType 一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。 &lt; association &gt;关联加载方式一：直接在内部进行加载关联（association）元素用于处理类中的依赖其他对象的成员变量,其本身也是个resultMap 1234&lt;association property="author" column="blog_author_id" javaType="Author"&gt; &lt;id property="id" column="author_id"/&gt; &lt;result property="username" column="author_username"/&gt;&lt;/association&gt; 相关属性,这些属性，与resultMap相同（但多出了嵌套select、resultMap的属性） 属性 描述 property 映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 javaType 一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之前的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。 关联的加载方式二：嵌套 Select 查询1234567891011&lt;resultMap id="blogResult" type="Blog"&gt; &lt;association property="author" column="author_id" javaType="Author" select="selectAuthor"/&gt;&lt;/resultMap&gt;&lt;select id="selectBlog" resultMap="blogResult"&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;select id="selectAuthor" resultType="Author"&gt; SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;&lt;/select&gt; 嵌套 Select 查询带来的N+1问题，即 首先会执行selectBlog来获取整个Blog列表(1) 为了加载关联，selectBlog返回了N个id,那么就需要进行N次selectAuthor,获取对应的行(也就是N) 可以看出，非常浪费性能。MyBatis 能够对这样的查询进行延迟加载，因此可以将大量语句同时运行的开销分散开来。当然，还可以使用其他加载方式 相关属性 属性 描述 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 column=&quot;{prop1=col1,prop2=col2}&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 select 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 column=&quot;{prop1=col1,prop2=col2}&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 fetchType 可选的。有效值为 lazy 和 eager。 指定属性后，将在映射中忽略全局配置参数 lazyLoadingEnabled，使用属性的值。 关联的加载方式三：嵌套结果映射12345678910111213&lt;resultMap id="blogResult" type="Blog"&gt; &lt;id property="id" column="blog_id" /&gt; &lt;result property="title" column="blog_title"/&gt; &lt;association property="author" column="blog_author_id" javaType="Author" resultMap="authorResult"/&gt;&lt;/resultMap&gt;&lt;resultMap id="authorResult" type="Author"&gt; &lt;id property="id" column="author_id"/&gt; &lt;result property="username" column="author_username"/&gt; &lt;result property="password" column="author_password"/&gt; &lt;result property="email" column="author_email"/&gt; &lt;result property="bio" column="author_bio"/&gt;&lt;/resultMap&gt; 通过该方法加载关联，使得Author的结果映射可以重用，也就没有N+1的问题了 相关属性 属性 描述 resultMap 结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 ResultSet。这样的 ResultSet 有部分数据是重复的。 为了将结果集正确地映射到嵌套的对象树中, MyBatis 允许你“串联”结果映射，以便解决嵌套结果集的问题。使用嵌套结果映射的一个例子在表格以后。 columnPrefix 当连接多个表时，你可能会不得不使用列别名来避免在 ResultSet 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。 notNullColumn 默认情况下，在至少一个被映射到属性的列不为空时，子对象才会被创建。 你可以在这个属性上指定非空的列来改变默认行为，指定后，Mybatis 将只在这些列非空时才创建一个子对象。可以使用逗号分隔来指定多个列。默认值：未设置（unset）。 autoMapping 如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。注意，本属性对外部的结果映射无效，所以不能搭配 select 或 resultMap 元素使用。默认值：未设置（unset）。 关联加载方式四：多结果集这是MyBatis从版本 3.2.3 开始提供的解决N+1查询问题的方法 某些数据库允许存储过程返回多个结果集，或一次性执行多个语句，每个语句返回一个结果集 123SELECT * FROM BLOG WHERE ID = #&#123;id&#125;SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125; 利用这一个特性,我们可以一次性获得多个结果集（通过 resultSets 属性为每个结果集指定一个名字，多个名字使用逗号隔开） 123&lt;select id="selectBlog" resultSets="blogs,authors" resultMap="blogResult" statementType="CALLABLE"&gt; &#123;call getBlogsAndAuthors(#&#123;id,jdbcType=INTEGER,mode=IN&#125;)&#125;&lt;/select&gt; 现在可以指定使用 “authors” 结果集的数据来填充 “author” 关联 1234567891011&lt;resultMap id="blogResult" type="Blog"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="title" column="title"/&gt; &lt;association property="author" javaType="Author" resultSet="authors" column="author_id" foreignColumn="id"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="username" column="username"/&gt; &lt;result property="password" column="password"/&gt; &lt;result property="email" column="email"/&gt; &lt;result property="bio" column="bio"/&gt; &lt;/association&gt;&lt;/resultMap&gt; &lt; collection &gt;集合与关联非常相似，只不过处理的是一对多的关系 集合加载方式一：直接在内部进行加载123456789&lt;!-- ofType属性表示的是集合的具体类型javaType指明集合类型，一般可以由MyBatis推断出来，可以省略--&gt;&lt;collection property="posts" javaType="ArrayList" ofType="domain.blog.Post"&gt; &lt;id property="id" column="post_id"/&gt; &lt;result property="subject" column="post_subject"/&gt; &lt;result property="body" column="post_body"/&gt;&lt;/collection&gt; 集合加载方式二：、嵌套SELECT查询1234567891011&lt;resultMap id="blogResult" type="Blog"&gt; &lt;collection property="posts" javaType="ArrayList" column="id" ofType="Post" select="selectPostsForBlog"/&gt;&lt;/resultMap&gt;&lt;select id="selectBlog" resultMap="blogResult"&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;select id="selectPostsForBlog" resultType="Post"&gt; SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;&lt;/select&gt; 集合的加载方式三：嵌套结果映射1234567891011&lt;resultMap id="blogResult" type="Blog"&gt; &lt;id property="id" column="blog_id" /&gt; &lt;result property="title" column="blog_title"/&gt; &lt;collection property="posts" ofType="Post" resultMap="blogPostResult" columnPrefix="post_"/&gt;&lt;/resultMap&gt;&lt;resultMap id="blogPostResult" type="Post"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="subject" column="subject"/&gt; &lt;result property="body" column="body"/&gt;&lt;/resultMap&gt; 集合加载方式四：多结果集某些数据库允许存储过程返回多个结果集，或一次性执行多个语句，每个语句返回一个结果集 123SELECT * FROM BLOG WHERE ID = #&#123;id&#125;SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125; 利用这一个特性,我们可以一次性获得多个结果集（通过 resultSets 属性为每个结果集指定一个名字，多个名字使用逗号隔开） 123&lt;select id="selectBlog" resultSets="blogs,posts" resultMap="blogResult"&gt; &#123;call getBlogsAndPosts(#&#123;id,jdbcType=INTEGER,mode=IN&#125;)&#125;&lt;/select&gt; 指定 “posts” 集合将会使用存储在 “posts” 结果集中的数据进行填充 123456789&lt;resultMap id="blogResult" type="Blog"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="title" column="title"/&gt; &lt;collection property="posts" ofType="Post" resultSet="posts" column="id" foreignColumn="blog_id"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="subject" column="subject"/&gt; &lt;result property="body" column="body"/&gt; &lt;/collection&gt;&lt;/resultMap&gt; &lt; discriminator &gt; 鉴别器，通过结果值来决定使用哪个 resultMap，类似于java中的switch语句 鉴别器的定义需要指定 column 和 javaType 属性 一旦匹配到结果映射，其余的结果映射就会被忽略（包括外部的！！但可以通过扩展来加载外部结果映射）。如果一个都匹配不到,那么就会使用鉴别器外的结果映射 123456789101112131415161718192021222324&lt;!-- 如果vehicle_type的值在&#123;1,2,3,4&#125;中，就会使用第一个对应的resultMap，其他的结果映射集都会被忽略，包括外部的vehicleResult 但如果一个都没匹配，将会使用外部的resultMap,即以下代码中的vehicleResult--&gt;&lt;resultMap id="vehicleResult" type="Vehicle"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="vin" column="vin"/&gt; &lt;result property="year" column="year"/&gt; &lt;result property="make" column="make"/&gt; &lt;result property="model" column="model"/&gt; &lt;result property="color" column="color"/&gt; &lt;discriminator javaType="int" column="vehicle_type"&gt; &lt;!-- 引用其他结果映射--&gt; &lt;case value="1" resultMap="carResult"/&gt; &lt;case value="2" resultMap="truckResult"/&gt; &lt;!-- 直接内部定义--&gt; &lt;case value="3" resultType="vanResult"&gt; &lt;result property="powerSlidingDoor" column="power_sliding_door" /&gt; &lt;/case&gt; &lt;case value="4" resultType="suvResult"&gt; &lt;result property="allWheelDrive" column="all_wheel_drive" /&gt; &lt;/case&gt; &lt;/discriminator&gt;&lt;/resultMap&gt; 如果carResult声明如下 123&lt;resultMap id="carResult" type="Car"&gt; &lt;result property="doorCount" column="door_count" /&gt;&lt;/resultMap&gt; 为了加载外部的属性，可以通过扩展,改动如下 1234&lt;!-- 扩展了vehicleResult后，carResult和vehicleResult属性都会被加载--&gt;&lt;resultMap id="carResult" type="Car" extends="vehicleResult"&gt; &lt;result property="doorCount" column="door_count" /&gt;&lt;/resultMap&gt; &lt; resultMap &gt;相关属性解释 属性 描述 id 当前命名空间中的一个唯一标识，用于标识一个结果映射。 type 类的完全限定名, 或者一个类型别名（关于内置的类型别名，可以参考上面的表格）。 autoMapping 如果设置这个属性，MyBatis将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。默认值：未设置（unset）。 利用resultMap进行简单映射利用resultMap进行映射分为两步 配置一个&lt; resultMap&gt; 通过&lt; select resultMap=“”&gt; 引用外部的resultMap 以下只是一个简单的示例，其实完全可以使用自动映射 12345678910111213&lt;!-- 配置一个resultMap--&gt;&lt;resultMap id="userResultMap" type="User"&gt; &lt;id property="id" column="user_id" /&gt; &lt;result property="username" column="user_name"/&gt; &lt;result property="password" column="hashed_password"/&gt;&lt;/resultMap&gt; &lt;!-- select 引用外部的resultMap--&gt;&lt;select id="selectUsers" resultMap="userResultMap"&gt; select user_id, user_name, hashed_password from some_table where id = #&#123;id&#125;&lt;/select&gt; 高级映射resultMap整体结构 123456789&lt;resultmap id="" type="" autoMapping="" &gt; &lt;constructor&gt; &lt;idArg column="" javaType=""/&gt; &lt;arg column="" javaType=""/&gt; &lt;/constructor&gt; &lt;id property="id" column="post_id"/&gt; &lt;result property="subject" column="post_subject"/&gt;&lt;/resultmap&gt; 如下时一个几位复杂的结果映射，从中可以看出resultMap的强大之处 1234567891011121314151617181920212223242526272829&lt;!-- 非常复杂的结果映射 --&gt;&lt;resultMap id="detailedBlogResultMap" type="Blog"&gt; &lt;constructor&gt; &lt;idArg column="blog_id" javaType="int"/&gt; &lt;/constructor&gt; &lt;result property="title" column="blog_title"/&gt; &lt;association property="author" javaType="Author"&gt; &lt;id property="id" column="author_id"/&gt; &lt;result property="username" column="author_username"/&gt; &lt;result property="password" column="author_password"/&gt; &lt;result property="email" column="author_email"/&gt; &lt;result property="bio" column="author_bio"/&gt; &lt;result property="favouriteSection" column="author_favourite_section"/&gt; &lt;/association&gt; &lt;collection property="posts" ofType="Post"&gt; &lt;id property="id" column="post_id"/&gt; &lt;result property="subject" column="post_subject"/&gt; &lt;association property="author" javaType="Author"/&gt; &lt;collection property="comments" ofType="Comment"&gt; &lt;id property="id" column="comment_id"/&gt; &lt;/collection&gt; &lt;collection property="tags" ofType="Tag" &gt; &lt;id property="id" column="tag_id"/&gt; &lt;/collection&gt; &lt;discriminator javaType="int" column="draft"&gt; &lt;case value="1" resultType="DraftPost"/&gt; &lt;/discriminator&gt; &lt;/collection&gt;&lt;/resultMap&gt; resultMap 整体结构12 12345678910111213&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt; &lt;constructor&gt; &lt;arg/&gt; &lt;idArg/&gt; &lt;/constructor&gt; &lt;association property=&quot;&quot;/&gt; &lt;collection property=&quot;&quot;/&gt; &lt;id/&gt; &lt;result/&gt; &lt;discriminator javaType=&quot;&quot;&gt; &lt;case value=&quot;&quot;&gt;&lt;/case&gt; &lt;/discriminator&gt;&lt;/resultMap&gt; &lt; Constructor &gt;该元素用于配置POJO的构造方法 &lt; id&gt;表示那个列是主键，允许多个（联合主键） &lt; reslut&gt;配置POJI到SQL列名的映射关系 &lt; id&gt; &amp; &lt; result&gt; 元素属性 元素名称 说明 property 映射到列结果的字段或属性 column SQL列 javaType 配置java类型 jdbcType 配置数据库类型 typeHandler 类型处理器 级联Mybatis级联分三种 association，一对一关系 collection，一对多 discriminator，鉴别器，根据条件关联不同的结果集 对应3个标签 cache 元素MyBatis 内置了一个强大的事务性查询缓存机制，默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存 二级缓存开启二级缓存如果要开启二级缓存，只需要添加一行 1&lt;cache/&gt; 二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新 二级缓存效果 映射语句文件中的所有 select 语句的结果将会被缓存。 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。 缓存不会定时进行刷新（也就是说，没有刷新间隔）。 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改 缓冲的作用域缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域 缓存配置1234567891011&lt;!--FIFO清除策略每60s刷新最多存储结果对象或列表的512个引用返回对象只读--&gt;&lt;cache eviction="FIFO" flushInterval="60000" size="512" readOnly="true"/&gt; 相关属性 属性 描述 flushInterval （刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新 size （引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024 readOnly （只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false 可用的缓存策略 LRU – 最近最少使用：移除最长时间不被使用的对象,默认 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象 自定义缓存12&lt;!-- type 属性指定的类必须实现 org.mybatis.cache.Cache 接口 --&gt;&lt;cache type="com.domain.something.MyCustomCache"/&gt; 自定义缓存接口如下 123456789public interface Cache &#123; String getId(); int getSize(); void putObject(Object key, Object value); Object getObject(Object key); boolean hasKey(Object key); Object removeObject(Object key); void clear();&#125; 参数原始类型或简单数据类型参数对于原始类型或简单数据类型参数，MyBaits可以直接传入，无需设置参数类型 12345&lt;select id="selectUsers" resultType="User"&gt; select id, username, password from users where id = #&#123;id&#125;&lt;/select&gt; JavaBean参数对于JavaBean参数，需要通过parameterType指定参数类型，如下代码，如果 User 类型的参数对象传递到了语句中，id、username 和 password 属性将会被查找，然后将它们的值传入预处理语句的参数中 1234&lt;insert id="insertUser" parameterType="User"&gt; insert into users (id, username, password) values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)&lt;/insert&gt; 参数可以指定数据类型 1#&#123;property,javaType=int,jdbcType=NUMERIC&#125; 或者指定类型处理器(或别名) 1#&#123;age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler&#125; 设置可以指定小数点后保留的位数 1#&#123;height,javaType=double,jdbcType=NUMERIC,numericScale=2&#125; mode 属性允许你指定 IN，OUT 或 INOUT 参数。如果参数的 mode 为 OUT 或 INOUT，就像你在指定输出参数时所期望的行为那样，参数对象的属性实际值将会被改变。 如果 mode 为 OUT（或 INOUT），而且 jdbcType 为 CURSOR（也就是 Oracle 的 REFCURSOR），你必须指定一个 resultMap 引用来将结果集 ResultMap 映射到参数的类型上。要注意这里的 javaType 属性是可选的，如果留空并且 jdbcType 是 CURSOR，它会被自动地被设为 ResultMap 1#&#123;department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap&#125; MyBatis 也支持很多高级的数据类型，比如结构体（structs），但是当使用 out 参数时，你必须显式设置类型的名称 1#&#123;middleInitial, mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE, resultMap=departmentResultMap&#125; 存储过程的支持通过mode属性来确定存储过程的参数:IN、OUT、INOUT 如果 mode 为 OUT（或 INOUT），而且 jdbcType 为 CURSOR(也就是 Oracle 的 REFCURSOR)，必须指定一个 resultMap 来映射结果集 ResultMap 到参数类型。 1#&#123;department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap&#125; MyBatis 也支持很多高级的数据类型，比如结构体，但是当注册 out 参数时你必须告诉它语句类型名称 1#&#123;middleInitial, mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE, resultMap=departmentResultMap&#125; 字符串替换#{}: 会创建预编译语句，然后赋值 ${}: 不转义的字符串,即直接插入字符（不应该将其用于接收用户的输入，并将其用于语句中的参数是不安全的，会导致潜在的 SQL 注入攻击 ） 传递多个参数对于参数，最简单就是传递一个参数,可能传入一个int类型，当然，也可以传入javabean 对于多个参数，有几种方式 使用Map进行传递(弊端，可读性不强,不推荐用) 注解方式传递(参数少时使用) 使用JavaBean传递参数（参数多于5个使用） 动态SQLMybaits包含以下几种动态Sql元素 元素 描述 if 判断语句 choose(when,otherwise) 相当于java中的case，when trim(where,set) 辅助元素 foreach 循环语句 &lt; if &gt;元素12345678&lt;select id="findActiveBlogWithTitleLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; 两个以上的参数12345678910&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; &lt;choose, when, otherwise &gt;多个条件选一个123456789101112131415&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test="title != null"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; &lt;where, set &gt;where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除。 123456789101112131415&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test="state != null"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; &lt; trim &gt;prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它的作用是移除所有指定在 prefixOverrides 属性中的内容，并且插入 prefix 属性中指定的内容。 以下语句等价于&lt; where&gt;123&lt;trim prefix="WHERE" prefixOverrides="AND |OR "&gt; ... &lt;/trim&gt; &lt; set &gt;类似的用于动态更新语句的解决方案叫做 set。set 元素可以用于动态包含需要更新的列，而舍去其它的 12345678910&lt;update id="updateAuthorIfNecessary"&gt; update Author &lt;set&gt; &lt;if test="username != null"&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test="password != null"&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test="email != null"&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test="bio != null"&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号，因为用了条件语句之后很可能就会在生成的 SQL 语句的后面留下这些逗号 等价于123&lt;trim prefix="SET" suffixOverrides=","&gt; ...&lt;/trim&gt; &lt; foreach&gt;123456789&lt;select id="selectPostIn" resultType="domain.blog.Post"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item="item" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 属性 描述 collection 表示传递进来的参数，可以是List，Set等集合 item 循环中的当前元素 index 当前元素索引 open/close 以什么符号元素包裹起来 separator 元素主键的间隔符号 &lt; bind &gt;bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文 _parameter.getTitle()表示的是传进来的参数12345&lt;select id="selectBlogsLike" resultType="Blog"&gt; &lt;bind name="pattern" value="'%' + _parameter.getTitle() + '%'" /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt; bind的使用定义接口1public List&lt;T&gt; findRole(@Param("name")String name, @Param("note") String note); 定义bind123456&lt;select id="selectBlogsLike" resultType="Blog"&gt; &lt;bind name="pattern_name" value="'%' + name + '%'" /&gt; &lt;bind name="pattern_note" value="'%' + note + '%'" /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern_name&#125; and note LIKE #&#123;pattern_note&#125;&lt;/select&gt; Mybaits逆向工程MyBaits Generator是由Mybatis官方提供的一种逆向代码生成器，会根据数据库表生成相关代码 POJO Mapper接口 SQL Mapper XML MyBatis提供了多种实现方式 命令行 Maven Plugin Java 程序 Maven Plugin方式使用逆向工程依赖: mybatis依赖 mybatis-generator-maven插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.liisyu&lt;/groupId&gt; &lt;artifactId&gt;mybaits-generator&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.plugin.version&gt;3.8.0&lt;/maven.compiler.plugin.version&gt; &lt;mysql.connector.version&gt;5.1.6&lt;/mysql.connector.version&gt; &lt;mybatis.generator.version&gt;1.3.7&lt;/mybatis.generator.version&gt; &lt;mybatis.version&gt;3.4.6&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!--maven的JDK编译级别--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;maven.compiler.plugin.version&#125;&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--mybatis-generator-maven插件--&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.generator.version&#125;&lt;/version&gt; &lt;dependencies&gt; &lt;!--如果出现找不到jdbc.driver,需要添加该依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.connector.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置文件: mybaits generator 会自动寻找目录下的resources/generatorConfig.xml mybatis配置文件提供的标签 commentGenerator: 用于生成的各种元素生成注释 jdbcConnection： 用于连接数据库 javaTypeResolver：用于定义Java类型解析器的属性 javaModelGenerator：定义Java模型生成器的属性 sqlMapGenerator：用于定义SQL映射生成器的属性 javaClientGenerator：用于定义Java客户端生成器的属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="testTables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mydb?serverTimezone=GMT%2B8" userId="masorl" password="314512321lsy"&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage="com.liisyu.po" targetProject=".\src\main\java"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage="com.liisyu.mapper" targetProject=".\src\main\java"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.liisyu.mapper" targetProject=".\src\main\java"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;!-- domainObjectRenamingRule通过正则表达式，去除签所有*_开头的前缀 --&gt; &lt;table tableName="t_account"&gt; &lt;domainObjectRenamingRule searchString="^[^_]" replaceString=""/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 通过maven插件方式运行生成 1mybatis-generator:generate MyBatis支持的JDBC类型 BIT FLOAT CHAR TIMESTAMP OTHER UNDEFINED TINYINT REAL VARCHAR BINARY BLOB NVARCHAR SMALLINT DOUBLE LONGVARCHAR VARBINARY CLOB NCHAR INTEGER NUMERIC DATE LONGVARBINARY BOOLEAN NCLOB BIGINT DECIMAL TIME NULL CURSOR ARRAY]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2Fblog%2F2018%2F02%2F19%2Fgit.all%2F</url>
    <content type="text"><![CDATA[起步GIt相关概念了解Git存储数据的方式：对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git保证数据完整性：所有数据在存储前都计算校验和，然后以校验和来引用Git 计算校验和的机制：SHA-1 散列，这由 40 个十六进制字符（0-9 和 a-f）组成字符串Git的三种状态：已提交（committed）、已修改（modified）和已暂存（staged）Git的三种工作区域： Git 仓库（.git directory）：Git 用来保存项目的元数据和对象数据库的地方 工作目录(Working Directory)：对项目的某个版本独立提取出来的内容 暂存区域(Stagign Area)：保存了下次将提交的文件列表信息 基本的 Git 工作流程 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 安装centos:1sudo yum install git unbuntu1sudo apt-get install git 初次运行前的git配置git config 工具Git自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 /etc/gitconfig文件：包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。 ~/.gitconfig或 ~/.config/git/config文件：只针对当前用户。 可以传递 --global 选项让 Git读写此文件。 .git/config文件：针对该仓库。 每一个级别覆盖上一级别的配置，所以 .git/config的配置变量会覆盖/etc/gitconfig中的配置变量。也就是说 .git/config &gt; /etc/gitconfig &gt; /etc/gitconfig 用户信息当安装完 Git 应该做的第一件事就是设置用户名称与邮件地址。每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：123456#针对当前用户的操作git config --global user.name &quot;Fame Lee&quot;git config --global user.email famelee@example.com#如果对特定项目使用不同的用户名称与邮件地址，可以在哪个项目下执行不带--global的操作git config user.name &quot;Fame Lee&quot;git config user.email famelee@example.com 检查用户配置信息如果需要检查配置，则输入1git config --list 可能会看到重复变量名，因为有3个配置文件。如果想要查看某一个指定的变量，则输入git config &lt; key &gt;1git config user.name 文本编辑器配置默认编辑器，在 git 输入信息时会掉用。没有配置的话会使用系统默认的文本编辑器（通常是 vim ）,如果想要设置，例如 Emacs 编辑器，则输入以下命令1git config --global core.editor emacs 获取帮助git 有三种方式获取帮助1234#git help &lt;verb&gt;#git &lt;verb&gt; --help#man git -&lt;verb&gt;git help config 获取Git仓库一共有两种方法获取git项目的仓库。 在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库 在现有目录中初始化仓库初始化操作1git init 该命令会创建一个 .git 子目录(存放 git 核心文件)。 克隆现有仓库克隆仓库的命令为 git clone [url] [name]123456# 克隆仓库到当前目录，仓库名默认git clone https://github.com/demo/demo# 自定义本地仓库名字git clone https://github.com/demo/demo mydemo# 不带工作区git clone --bare 执行完后有当前目录会有两个文件夹 demo文件夹：项目文件都会在这 .git文件夹：存放远程仓库的数据，从中读取最新版本的文件的拷贝 文件更新文件的状态在 git 工作目录下的文件一共有两种状态： 已跟踪：指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 未跟踪：除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态 查看文件状态1git status 紧凑输出文件状态123git status -s#或者git status --short 紧凑输出结果如下12345 M README #右M：文件被修改了但是还没放入暂存区MM Rakefile #MM:在工作区被修改并提交到暂存区后又在工作区中被修改A lib/git.rb #A 新添加到缓存区的文件M lib/simplegit.rb #左M：文件被修改了并放入了暂存区?? LICENSE.txt #??：新添加但为加入缓存区的文件 git的生命周期如下图，可以看到 处于 Untrcked(未跟踪) 的文件经过添Add the file(追加文件), 追加的文件状态变为 staged(暂存) 处于 Unmodeifed(未更改) 的文件经过 Edit the file(修改文件) 后，状态变为 Modeified(已修改) 处于Modeified(已修改),经过stage the file(暂存操作)，会存入到暂存区，此时文件状态变为 staged(暂存) 文件经过 commit(提交后)，变为Unmodeifed(未更改) 暂存文件添加内容到下一次提交中 : git add1234# 参数为filegit add README# 参数为pathgit add /home/git/ 经过该命令后，文件将会被跟踪且放入暂存区。所以该命令使用的效果有 将单个文件变为跟踪状态，并放入暂存区 将路径下所有文件递归设置成跟踪状态，并放入暂存区 对于已经是跟踪状态的已经修改文件，放入暂存区 查看未暂存的文件与暂存区比较123git diff#只查看某个文件git diff -- 文件1 文件2 暂存区与上一次提交(HEAD指向)比较123git diff --cached#或者，git16.1版本后适用git diff --staged 注意，git diff比较的是工作目录文件的内容和暂存区文件的内容。 忽略文件如日志文件之类的文件，无需纳入git管理。这种情况下，创建一个名为 .gitignore 的文件,列出要忽略的文件模式.1234# 忽略以.a或.o为结尾的文件*.[oa]# 忽略以～结尾的文件x~ 文件 .gitignore 的格式规范： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以(/)开头防止递归。 匹配模式可以以(/)结尾指定目录。 要忽略指定模式以外的文件或目录,可以在模式前加上惊叹号(!)取反。 glob模式： 星号(*)匹配零个或多个任意字符; [abc] 匹配任何一个列在方括号中的字符(这个例子要么匹配一个 a,要么匹配一个 b,要么匹配一个 c); 问号(?)只匹配一个任意字符; 如果在方括号中使用短划线分隔两个字符,表示所有在这两个字符范围内的都可以匹配(比如 [0-9] 表示匹配所有 0 到 9 的数字)。 使用两个星号(*) 表示匹配任意中间目录,比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。 官方针对各种语言的忽略文件 提交更新所谓的提交，实际上相当于本地的保存记录。在提交更新前，最好先运行一下 git status命令，查看是不是还有没暂存的文件1git status 提交命令git commit之后，会启动文本编辑器以便输入本次提交的说明。1git commit 提交命令，显示修改信息git commit之后，会启动文本编辑器以便输入本次提交的说明。1git commit -v 将提交信息与命令放在同一行1git commit -m &quot;提交信息&quot; 自动暂存追踪文件并提交有时候使用暂存区域的方式有些繁琐，使用以下命令， Git 就会自动把所有已经跟踪过的文件暂存起来一并提交,从而跳过 git add 步骤1git commit -a 移除文件删除跟踪状态，且同时删除工作区的的文件（未暂存）。1git rm &lt; file-name&gt; 强制删除已暂存的文件1git rm -f file 删除暂存区中的文件，不删除工作区的文件1git rm --cached file 删除目录，使用blog模式1234#删除 log/ 目录下扩展名为 .log 的所有文件(注意&quot;/&quot;)git rm log/\*.log#删除以 ~ 结尾的所有文件git rm \*~ 移动文件移动文件1git mv file path 重命名12#对文件进行重命名git mv README.md README 实际上相当于运行了123mv README.md READMEgit rm README.mdgit add README 注意：如果出现了not under version control,只是因为你的文件不是追踪文件而已，执行 git add file就能用了 查看提交历史基本信息：每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明查看提交历史适用命令（显示基本信息）,该命令会按提交时间列出所有的更新,最近的更新排在最上面。1git log git log 的常用选项 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 如，使用 -p 来显示每次提交的内容差异（基本信息+diff）。12#显示最近的两次提交的内容差异 git log -p 适用 –stat查看每次提交的简略统计信息（基本信息+简略改动,如插入几行，几个文件修改，删除几行）1git log --stat 不同格式显示历史 使用不同于默认格式的方式展示提交历史 git log –pretty=[ option ]12345678910# oneline显示一行，包含SHA-1校验值和提交说明git log --pretty=oneline# short 包含SHA-1校验值、作者名字和邮件、提交说明git log --pretty=short# full 包含SHA-1校验值、作者名字和邮件、提交说明、提交者名字和邮件git log --pretty=full# fuller 包含SHA-1校验值、作者名字和邮件、提交说明、提交者名字和邮件、提交时间git log --pretty=fuller# format 自定义输出格式git log --pretty=format:&quot;%h - %an, %ar : %s&quot; 自定义输出格式|选项|说明||–|–||%H|提交对象（commit）的完整哈希字串||%h|提交对象的简短哈希字串||%T|树对象（tree）的完整哈希字串||%t|树对象的简短哈希字串||%P|父对象（parent）的完整哈希字串||%p|父对象的简短哈希字串||%an|作者（author）的名字||%ae|作者的电子邮件地址||%ad|作者修订日期（可以用 –date= 选项定制格式）||%ar|作者修订日期，按多久以前的方式显示||%cn|提交者（committer）的名字||%ce|交者的电子邮件地址||%cd|提交日期||%cr|提交日期，按多久以前的方式显示||%s|提交说明| 限制输出长度 选项 说明 -(n) 仅显示最近的 n 条提交 –since, –after 仅显示指定时间之后的提交。 –until, –before 仅显示指定时间之前的提交。 –author 仅显示指定作者相关的提交。 –committer 仅显示指定提交者相关的提交。 –grep 仅显示含指定关键字的提交 -S 仅显示添加或移除了某个关键字的提交 如，列出最佳两周提交1git log --since=2.weeks 图形化方式查看git提交1234#当前分支gitk #所有分支gitk --all 变更操作重新提交实为再次提交暂存区的文件，并重写覆盖上一次的提交信息(commit对象会变)1git commit --amend 修改老旧commit如果要更改老旧commit的提交信息，请看变基操作 整合多个commit提交也看变基操作 取消暂存的文件1234# 取消所有暂存区内容git reset HEAD# 取消指定文件git reset HEAD &lt;file-name&gt; 从暂存区恢复文件1git checkout -- &lt;file-name&gt; 恢复到某个commit恢复后暂存区、工作区都会变化，然后之后的commit全部丢失，very 恐怖1git reset --hard hashcode 远程仓库的使用远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 查看远程仓库查看已经配置的远程仓库简写对于使用 git clone过来的仓库，默认名为origin1git remote 查看已经配置的远程仓库简写与其对应的 URL1git remote -v 列出远程仓库的 URL 与跟踪分支的信息1# git remote show [remote-name] 添加远程仓库添加远程仓库，同时指定简写1git remote add &lt;remote-name&gt; &lt;url&gt; 现在，可以用 &lt; remote-name &gt; 来代替整个URL. 从远程仓库抓取拉取远程仓库数据拉取远程仓库中有而本地仓库没有的信息.执行完成后，将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。12#git fetch &lt;remote-name&gt;git fetch pb 抓取之后，，本地不会自动生成一份可编辑的副本，需要进行合并操作克隆远程仓库对于 git clone命令添加的远程仓库会以 orgin 为简写。它自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支1git clone [url] 自动的抓取然后合并远程分支到当前分支1git pull &lt;remote-name&gt; 推送到远程仓库推送到远程仓库1# git push [remote-name] [branch-name] git push命令生效，还需要两个条件 拥有所克隆服务器的写入权限 之前没有人推送过 如果在推送之前，有人已经推送过。那必须先进行抓取操作，合并后才能推送。 远程仓库的移除与重命名重命名远程仓库修改远程仓库的简写名,同时也会改变远程分支名1# git remote rename &lt;old-remote-name&gt; &lt;new-remote-name&gt; 移除远程仓库1# git remote rm &lt;remote-name&gt; 标签Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。 轻量标签：很像一个不会改变的分支 - 它只是一个特定提交的引用 附注标签：存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 查看标签在git中列出已有标签1git tag 特定模式列出标签1# git tag -l &apos;关键字&apos; 查看标签信息与对应的提交信息1# git show &lt;tag-name&gt; 附注标签创建附注标签1# git tag -a &lt;tag-name&gt; 创建附注标签并指定存储在标签中的信息1# git tag -a &lt;tag-name&gt; -m &apos;标签中的信息&apos; 轻量标签创建轻量标签创建轻量标签，只需要提供标签名字1$ git tag &lt;tag-name&gt; 后期打标签后期打标签对过去的提交打标签(在命令的末尾指定提交的校验和（或部分校验和）)12# git tag -a &lt;tag-name&gt; 校验和,校验和可以通过git log 命令查看git tag -a v1.2 9fceb02 共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上显示推送标签1# git push &lt;remote-name&gt; [tagname] 一次性推送很多标签这将会把所有不在远程仓库服务器上的标签全部传送到那里1git push origin --tags 检出标签标签并不会像分支一样完全移动，但想要工作目录与仓库中特定的标签版本完全一样，可以在特定的标签上创建一个新分支1#git checkout -b [branchname] [tagname] 不过当该分支提交后，标签和分支又会稍微有些不一样了 Git 别名通过 git config 文件来轻松地为每一个命令设置一个别名1234$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status 如，想要输入 git commit 时，只需要输入 git ci又如12# 向 Git 中添加取消暂存别名git config --global alias.unstage &apos;reset HEAD --&apos; 下面两个命令等价12git unstage fileAgit reset HEAD -- fileA 想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号1git config --global alias.visual &apos;!gitk&apos; Git分支分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线 Git数据保存的方式在进行提交操作时，Git 会保存一个提交对象（commit object）。且该提交对象会保存 包含一个指向暂存内容快照的指针 包含了作者的姓名和邮箱、提交时输入的信息 指向它的父对象的指针 一个保存校验和的树对象的指针 从下图（3个文件的提交）可以看出，对于一个提交对象，里面保存了一个tree的指针,而tree中有保存了文件的校验和 而对于每一个的提交，除第一次外都有指向父对象的指针) 创建分支master分支 Git 的默认分支（注意：Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别，只是默认创建了这个分支而已）创建分支 ： git branch &lt; branch-name &gt;12#创建了testing分支git branch testing 创建一个分支(实际上只是在当前所在的提交对象上创建一个指针)，相当于如图所示 特殊指针HEAD作用：指向当前所在的本地分支，即Git用它来确定当前所在的分支。 分支切换切换分支其实相当于改变HEAD的指针，同时会改变你工作目录中的文件 切换到分支1git checkout &lt; branch-name &gt; 新建分支同时切换到该分支： 123git checkout -b testing# 基于远程分支建立新分支git checkout -b &lt;branch-name&gt; &lt;remote-branch-name&gt; 相当于执行了如下两条命令12git branch testinggit checkout testing 查看分支查看各个分支所指的提交对象 提供该功能的选项是 –decorate1git log --oneline --decorate 查看项目分叉历史1git log --oneline --decorate --graph --all 查看当前所有分支12#输出结果前*表示当前所在分支git branch 要查看每一个分支的最后一次提交1234# 查看当前分支的最后一次提交git branch -v# 查看所有分支的最后一次提交git branch -av 查看哪些分支已经合并/未合并到当前分支1234#合并的分支git branch --merged#未合并的分支git branch --no-merged 比较两个分支不同1234# 比较两个不同分支的所有文件git diff &lt; branch1&gt; &lt;branch2&gt;# 比较两个不同分支指定文件git diff &lt; branch1&gt; &lt;branch2&gt; -- &lt; file-name &gt; 合并分支合并分支 : git merge &lt; branch-name &gt;1git merge hotfix 合并冲突遇到冲突时的分支合并在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，需要手动去处理冲突。 解决内容冲突12345678# 先将远程分支的拉下来合并,合并过程会告知你那个文件合并必败git pull # 修改该文件,该文件内容可以看到冲突的地方vim README# 修改完后再次提交git commit -am&apos;解决冲突&apos;# 再pushgit push 同时修改文件名和文件内容一方变更了文件名另一方变更了文件内容无需解决，git会自动改文件名和文件内容 解决文件名冲突 拉下来后,工作区改名后的两个文件都存在 解决：12345678# 先删除暂存区的原文件git rm index.html# 把想要保留的加入到暂存区git add index1.html# 删除另一个git rm index2.html# 提交git commit -am&quot;修改冲突&quot; 使用 git status查看那些因包含合并冲突而处于未合并（unmerged）状态的文件 解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决 使用图形化工具解决冲突运行图形化工具1git mergetoo 删除分支删除分支 ： git branch -d &lt; branch-name &gt; 1git branch -d hotfix 该命令无法删除当前分支未合并的分支，如果一定要删除，需要适用强制删除 强制删除 1git branch -D &lt; branch-name &gt; 远程分支远程引用的完整列表 : git ls-remote &lt; remote-name &gt; 1git ls-remote htofix 获得远程分支信息 : git remote show &lt; remote-name &gt; 1git remote show origin 远程跟踪分支 远程分支状态的引用，上次连接到远程仓库时，那些分支所处状态的书签. 以 (remote)/(branch) 形式命名 无法移动的本地引用，当你做任何网络通信操作时，它们会自动移动 其实就相当于一个记录远程仓库分支位置的书签 跟踪分支 从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。 变基1git rebase -i 提交的hashcode 在编辑之后，会弹出一个文本,里面告诉你该如何用命令123456789101112131415161718pick 5e358bb [添加]添加了MyBaits相关笔记pick 9c77fd9 [.]# Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec &lt;command&gt; = run command (the rest of the line) using shell# b, break = stop here (continue rebase later with &apos;git rebase --continue&apos;)# d, drop &lt;commit&gt; = remove commit# l, label &lt;label&gt; = label current HEAD with a name# t, reset &lt;label&gt; = reset HEAD to a label# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]# . create a merge commit using the original merge commit&apos;s# . message (or the oneline, if no original merge commit was# . specified). Use -c &lt;commit&gt; to reword the commit message. 想要修改提交信息，就使用r这个命令1234pick 5e358bb [添加]添加了MyBaits相关笔记pick 9c77fd9 [.]# 修改5e358bb的提交信息r 5e358bb [添加]添加了MyBaits相关笔记 想要合成多个commit，则要使用s命令1234567891011pick 5e358bb [添加]添加了MyBaits相关笔记pick 9c77fd9 [.]pick 7gsdh96 [sd]pick asdas323 [sd]pcik asdsad [22]# 合并前4个，则pick 5e358bb [添加]添加了MyBaits相关笔记s 9c77fd9 [.]s 7gsdh96 [sd]s asdas323 [sd]pcik asdsad [22] 所有的变基操作，在变基的位置开始，所有的commit对象都改变了其地址。所以，当项目已经push上了，千万别用，在本地用用就可以了。 服务器上的Git裸仓库（bare repository）即为一个没有当前工作目录的仓库。 因为该仓库仅仅作为合作媒介，不需要从磁碟检查快照；存放的只有 Git 的资料协议Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。 本地协议其中的远程版本库就是硬盘内的另一个目录,常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。克隆一个本地版本库123git clone /opt/git/project.git# 或者,file://传输效率较低git clone file:///opt/git/project.git 增加一个本地版本库到现有的 Git 项目1git remote add local_proj /opt/git/project.git HTTP 协议Git 通过 HTTP 通信有两种模式:“智能” HTTP 协议和“哑” HTTP 协议智能（Smart） HTTP 协议运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制哑（Dumb） HTTP 协议web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 哑 HTTP 协议的优美之处在于设置起来简单。 基本上，只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 post-update 的挂钩就可以了12345cd /var/www/htdocs/git clone --bare /path/to/git_project gitproject.gitcd gitproject.gitmv hooks/post-update.sample hooks/post-updatechmod a+x hooks/post-update SSH 协议用 SSH 协议作为传输协议通过 SSH 协议克隆版本库，你可以指定一个 ssh:// 的 URL：1git clone ssh://user@server/project.git 或者使用一个简短的 scp 式的写法：1git clone user@server:project.git Git 协议包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权要让版本库支持 Git 协议，需要先创建一个 git-daemon-export-ok 文件 在服务器上搭建 Git在开始架设 Git 服务器前，需要把现有仓库导出为裸仓库1$ git clone --bare my_project my_project.git 把裸仓库放到服务器上并设置协议1scp -r my_project.git user@git.example.com:/opt/git 生成SSH公钥查看是否有密钥执行以下命令查看是否拥有12cd ~/.sshls 如果没有这个目录,或者有目录，但没有id_dsa和id_rsa文件，说明你没有公钥。 创建123ssh-keygen# 官方给的设置方式，管理email ssh-keygen -t rsa -b 4096 -C &quot;xx.@xx.com&quot; (创建过程中会让你输入密钥口令，可以直接按空格不输入)现在，在目录下，起码有两个文件存在了12-rw------- 1 famel famel 1675 12月 17 11:48 id_rsa-rw-r--r-- 1 famel famel 409 12月 17 11:48 id_rsa.pub 以 .pub 为扩展名则为公钥，另一个则为私钥。(github上输入公钥) 紧急任务加塞当在开发过程中，需要处理其他紧急任务，可使用1git stash 这样将当前状态保存到一个堆栈中,查看堆栈如下12git stash list# 显示stash@&#123;2&#125;: WIP on master: 0cb0a4b [修改] 任务完成后，可以使用如下命令继续刚才停止的任务123456# 弹出最顶的stash，但不删除git stash apply# 弹出最顶的stash，但删除git stash pop# 弹出制定的某个栈值，上面两个相当于stash@&#123;0&#125;git stash apply/pop stash@&#123;n&#125; git备份常用协议： 哑协议 /path/to/repo.git(传输进度不可见) 智能协议 file:///psth/to/repo.git（传输可见，速度比哑协议快） http/https协议 ssh协议 如果是本地仓库的备份12# 使用--bare不备份工作区，更干净git clone --bare 协议(推荐智能协议) 如果是远程仓库备份1234# 关联原创仓库git remote add &lt;remote-name&gt; 协议# 然后pushgit push [branch-name] git 18R!(禁止命令)禁止一：强制更新1234# 如果本地使用了,那么之后的commit就会消失git reset --hard &lt;hashcode&gt;# 如果使用了强制更新，那么远程仓库也会小时一大堆commit！！！git push -f 禁止二：不要对集成分支变基对公共commit改变后，之后历史的commit全部改变。对于其他人可能还需要一个个对新的commit进行merge等操作。 git ssh代理设置创建配置文件 1vim ~/.ssh/config 架设了bwg + v2ray,走的SOCKS,配置github代理如下 12345Host github.com HostName github.com User git # connect是git安装后自动装的 ProxyCommand "C:\Program Files\Git\mingw64\bin\connect.exe" -S localhost:1080 %h %p]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DesignPatterns]]></title>
    <url>%2Fblog%2F2018%2F02%2F18%2FDesignPatterns.all%2F</url>
    <content type="text"><![CDATA[设计模式7大原则单一原则单一原则SRP（Single Responsibility Principle） 将类的职责划进行划分，比如数据职责（通过其属性来体现）和行为职责（过其方法来体现），当然也可以根据实际情况来划分职责 一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中，换句话说，就是只能有一个使类变更的原因 示例： User 包含了数据职责和行为职责 使用单一原则重构后，将数据职责和行为职责分开 优点： 降低类的复杂性，类的职责清晰明确。比如数据职责和行为职责清晰明确。 提高类的可读性和维护性 变更引起的风险减低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的类有影响，对其他接口无影响，这对系统的扩展性、维护性都有非常大的帮助 开闭原则开闭原则OCP( Open - ClosedPrinciple )： 对扩展开放，对修改关闭：当软件实体因需求要变化时, 尽量通过扩展已有软件实体，提供新的行为，以满足对软件的新的需求，而不是修改已有的代码。特别是抽象层模块不能修改 实现开闭原则的关键：抽象化 找到系统的可变因素,将它封装起来 示例：模板方法模式、观察者模式 里氏代换原则里氏代换原则LSP ( Liskov Substitution Principle )： 继承关系应满足里氏代换原则：在父类出现的地方，也可以使用子类替代；（但子类出现的地方，父类不一定可以代替） 在定义时使用父类类型，在运行时确定其子类类型 示例 123456789101112131415161718192021222324252627282930313233343536// 长方形类Rectangleclass Rectangle &#123; double length; double width; public double getLength() &#123; return length; &#125; public void setLength(double height) &#123; this.length = length; &#125; public double getWidth() &#123; return width; &#125; public void setWidth(double width) &#123; this.width = width; &#125; &#125;// 正方形类Square:class Square extends Rectangle &#123; public void setWidth(double width) &#123; super.setLength(width); super.setWidth(width); &#125; public void setLength(double length) &#123; super.setLength(length); super.setWidth(length); &#125; &#125;/***测试类，对于resize()方法* 1. 如果传入的是长方形，最终会在宽大于长时结束循环* 2. 如果传入的是正方形，就会变成永远的循环* Rectangle与Square 之类的继承关系违反了里氏代换原则（必须是子类和父类关系），而正方形并不是长方形，所以* 并不是父子关系*/class TestRectangle &#123; public void resize(Rectangle objRect) &#123; while(objRect.getWidth() &lt;= objRect.getLength() ) &#123; objRect.setWidth( objRect.getWidth () + 1 ); &#125; &#125;&#125; 里氏代换原则优点： 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性； 提高代码的重用性； 提高代码的可扩展性 提高产品或项目的开放性 依赖倒转原则依赖倒转原则DIP（ Dependence Inversion Principle） 高层模块不应该依赖底层模块，应该都依赖于抽象 针对接口编程，不针对实现变成 依赖倒转原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件中 依赖倒转原则的关键：抽象耦合关系 示例： 指挥中心可以指示驾驶员开高达，现在是没有问题的 12345678910111213141516171819202122// 驾驶员public class Driver &#123; // 开高达 public void driveGundam(Gundam gundam)&#123; gundam.go(); &#125;&#125;//高达类public class Gundam &#123; public void go()&#123; System.out.println("高达出击"); &#125;&#125;// 指挥中心public class Center &#123; public static void main(String[] args) &#123; Gundam gundam = new Gundam(); new Driver().driveGundam(gundam); &#125;&#125; 但是，指挥中心新进一批扎古，现在想让驾驶员开扎古，他做不到 123456//扎古类public class Zaku &#123; public void go()&#123; System.out.println("扎古出击"); &#125;&#125; 按照依赖倒转原则，进行以下修改（Driver属于高层模块，不应该被修改） 1234567891011121314151617181920212223242526272829303132333435//无论是扎古还是高达，都属于机器人public interface Robot &#123; void go();&#125;//扎古类、高达类 均实现Robot几口public class Zaku implements Robot &#123; public void go()&#123; System.out.println("扎古出击"); &#125;&#125;public class Gundam implements Robot &#123; public void go()&#123; System.out.println("高达出击"); &#125;&#125;//Dirve 不依赖于细节，只要知道是开机器人这个动作就行了public class Driver &#123; // 开高达 public void drive(Robot robot)&#123; robot.go(); &#125;&#125;// 指挥中心public class Center &#123; public static void main(String[] args) &#123; //再增加再多的类，只要实现Robot,Dirver就可以使用 Dirver driver = new Driver(); driver.drive(new Gundam()); driver.driver(new Zaku()); &#125;&#125; 事实上，依赖的注入方式，有以下三种（Spring 采用） 构造器注入：通过构造器注入 设置注入：通过Setter方法注入 接口注入：通过接口方法注入，即示例中的注入方式 优点：采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性 倒置了什么？ 正置情况下，就是面向实现编程，开高达即依赖高达实例，开扎古即依赖扎古实例 而倒置，是将现实倒置成了抽象，系统依赖的是抽象类或者接口 合成/聚合复用原则合成/聚合复用原则CARP（Composite/Aggregate Reuse Principle） 尽量使用对象组合，而不是继承来达到复用的目的。即在一个新的对象中使用已有的对象，使其成为新对象的一部分，新对象通过委派这些对象达到代码复用 复用一般有两种方式：合成合成/复用或继承复用 a. 相对于继承，合成复用是系统更加灵活，类鱼类直接耦合度更低。可在运行时动态进行。 b. 合成/聚合表示为整体和部分关系,而继承表示父子关系 c. 要尽量使用合成/聚合复用，而少用继承 示例： 123456789101112//汽车和引擎关系public class Car&#123; private Engine engine; public Car(Engine engine) &#123; this.engine = engine; &#125; public void setEngine(Engine engine) &#123; this.engine = engine; &#125;&#125;public class Engine&#123;&#125; 迪米特法则迪米特法则LoD(Law of Demeter) 又叫最少知识原则LKP（Least Knowledge Principle） 系统中的类,尽量不要与其他类互相作用,减少类之间的耦合度，或者说只有朋友类进行通信，陌生的类不应该作为局部变量出现在类内部，朋友类包括以下几类 a. 当前对象本身(this)； b. 以参数形式传入到当前对象方法中的对象； c. 当前对象的成员对象； d. 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； e. 当前对象所创建的对象 狭义迪米特法则 a. 如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 b. 优点：会降低耦合度 c. 缺点：可能造成系统大量的第三方中介类；不同模块间不容易协调 广义迪米特法则 a. 优先考虑将一个类设置成不变类； b. 尽量降低一个类的访问权限； c. 尽量降低成员的访问权限 d. 谨慎使用Serializable 示例：外观模式（门面模式）和中介者模式（调停者模式） 接口隔离法则接口隔离法则ISL(Interface Segregation Principle) 将接口分割成更小的接口，客户端只需要它需要的方法，将不需要的方法隐藏起来 用多个专门的接口，而不使用单一的总接口 拆分接口时应满足单一原则，将相关操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好 可以采用定制服务方式，即为不同的客户端提供宽窄不同的接口 示例： 对于客户端A，它只需要操作方法1、2、5 对于客户端B，它只需要操作方法3、4 然后客户端A、B都拥有它们不需要的操作方法 在满足单一原则和接口隔离法则后的设计 接口细分职责 客户端A、B只包含它们需要的方法 继承继承优点： 实现简单 易于扩展 有效利用继承有助于对问题的理解，降低复杂度 继承有以下缺点： 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法； 降低代码的灵活性，无法在运行时发生改变 子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束； 增强了耦合性。当父类的常量、变量和方法被修改时，必需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大片的代码需要重构 建议：要避免在系统设计中出现，一个类的继承层次超过3次 UML图关系泛化关系(generalization) 使用空心箭头的实线表示 在代码中表现为继承 实现关系(realize) 使用空心箭头的虚线表示 在代码中表现为接口的实现，个人认为抽象类与类的关系也属于实现 聚合关系(aggregation) 使用空心菱形箭头的实线表示，聚合关系表现为has-a，部分和整体都有各自的声明周期，部分可以脱离整体存在； 在代码中表现为成员变量，与关联不同是，聚合更强调整体和部分 组合关系(composition) 使用实心菱形箭头的实线表示，组合关系表现为contains-a，部分不能脱离整体 在代码中表示为成员变量，强调整体性和不能分离 关联关系(association) 使用带箭头的实线表示 关联关系表示的是结构上的关系，强调相互之间是平等的，可以是双向或者单项，如学校和学生； 在代码中，关联对象通常是以成员变量的形式实现的 依赖关系(dependency) 使用带箭头的虚线表示 依赖关系表示一个对象在运行期间会使用到另一个对象，与关联关系不同处在于其是一种临时性的关系，会随着运行发生变化，并且依赖关系也有可能发生变化； 在代码中，依赖主要体现为类的某个成员函数的返回值、形参、局部变量或静态方法的调用 可以单向或者双向，但双向依赖是一种极差的设计 访问权限 Character Visibility - private # protected ~ package private + public 创建型模式特点： 将对象的创建与使用分离 可以降低系统的耦合度，使用者不需要关注对象的创建细节 分为类创建型和对象创建型模式,前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为 简单工模式和工厂方法模式属于类创建型模式，其余属于对象创建型模式 简单工厂模式（Simple Factory Pattern）简单工厂模式又称，静态工厂方法模式（Static Factory Method) 核心思想 定义一个工厂类，由其完成对产品的创建 客户端只需要通过不同的参数来获取不同的产品实例 应用场景 需要获取同接口/抽象类的对象，且获取的对象较少 结构 Factory：工厂角色，负责创建所有实例（静态方法创建） Product：抽象产品角色，负责描述所有实例 ConcreteProduct：具体产品角色 UML图 优点 隐藏了实例化的细节: 客户端只需要知道具体工厂的名称和对应的参数就可得到所要的产品，无须知道产品的具体创建过程。 静态化创建方法使得创建产品更加方便 缺点 创建产品的逻辑全部集中在了工厂类中，一旦工程类不能工作，整个系统都会受到影响 不满足开闭原则（根据产品变动需要改变工厂类） 实例现在基地准备开战，需要从工厂造几台机器人。任务员去工厂，她并不需要知道到底怎么造机器人，她只要告诉工厂，要高达，还是扎古。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//机器人接口，Productpublic interface Robot &#123; /** * 机器人出击方法描述 */ void go();java&#125;//机器人实现类1（扎古）public class zaku implements Robot &#123; public zaku() &#123; System.out.println("扎古，出击！"); &#125; @Override public void go() &#123; System.out.println("时速500公里/小时"); &#125;&#125;//机器人实现类(高达Zero)public class GaodaZero implements Robot &#123; public GaodaZero() &#123; System.out.println("高达，出击！"); &#125; @Override public void go() &#123; System.out.println("时速1500公里/小时，瞬移100米"); &#125;&#125;//-------------------------------------------------------------------------------------------//机器人工厂public class RobotFactory &#123; /** * 获取机器人 * @param robotType 机器人类型 * @return 机器人实例 */ public static Robot getRobot(String robotType)&#123; if (robotType == null || robotType.length() == 0)&#123; return null; &#125; if ("zaku".equalsIgnoreCase(robotType)) &#123; return new zaku(); &#125;else if("gaoda".equalsIgnoreCase(robotType))&#123; return new GaodaZero(); &#125; return null; &#125; /** * 反射方式获取机器人 * @param robotType 机器人类型 * @return 机器人实例 */ public static Robot getRobot2(String robotType) &#123; Robot robot = null; try &#123; robot = (Robot) Class.forName("com.liisyu.factory.simple." + robotType).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return robot; &#125;&#125;//-------------------------------------------------------------------------------------------//使用public class Client &#123; public static void main(String[] args) &#123; //根据传入的参数不同，创建不同的实例 Robot robot = RobotFactory.getRobot("gaoda"); robot.go(); robot = RobotFactory.getRobot2("zaku"); robot.go(); &#125;&#125;//print高达，出击！时速1500公里/小时，瞬移100米扎古，出击！时速500公里/小时 工厂方法模式(Factory Method Pattern)工厂方法模式(又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式 核心思想在简单工厂模式的进出上，进一步抽象 定义一个工厂抽象类或接口，将具体的实例创建交给其子类 客户端只需要知道创建产品的工厂名 应用场景 创建对象的任务可以由多个具体子工厂中的某一个完成 结构 Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂 UML图 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//机器人接口public interface Robot &#123; /** * 机器人出击方法描述 */ void go();&#125;//机器人实现类（扎古）public class zaku implements Robot &#123; public zaku() &#123; System.out.println("扎古，出击！"); &#125; @Override public void go() &#123; System.out.println("时速500公里/小时"); &#125;&#125;//机器人实现类(高达Zero)public class GaodaZero implements Robot &#123; public GaodaZero() &#123; System.out.println("高达，出击！"); &#125; @Override public void go() &#123; System.out.println("时速1500公里/小时，瞬移100米"); &#125;&#125;//-------------------------------------------------------------------------------------------// 工厂接口public interface Factory &#123; /** * 工厂方法,所有子类必须继承 */ Robot factoryMethod();&#125;// 高达Zero工厂public class GaodaFactory implements Factory&#123; @Override public Robot factoryMethod() &#123; return new GaodaZero(); &#125;&#125;// 扎古工厂public class zakuFactory implements Factory &#123; @Override public Robot factoryMethod() &#123; return new zaku(); &#125;&#125;//-------------------------------------------------------------------------------------------/** * Test Class * @author liisyu * @date 2019/02/22 */public class TestMain &#123; public static void main(String[] args) &#123; Robot robot = new GaodaFactory().factoryMethod(); robot.go(); robot = new zakuFactory().factoryMethod(); robot.go(); &#125;&#125;//print高达，出击！时速1500公里/小时，瞬移100米扎古，出击！时速500公里/小时 优点 隐藏了实例化的细节**: 客户端只需要知道具体工厂的名称和对应的参数就可得到所要的产品，无须知道产品的具体创建过程。 符合开闭原则，在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改 扩展性更好 缺点 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类（即一个产品一个工厂），这增加了系统的复杂度。 实际应用 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方 数据库访问：数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时 设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口 抽象工厂模式(Abstract Factory)核心思想 工厂可以创建一组相关或相互依赖的对象 客户端只需要知道工厂名，并不需要指定索要产品的具体类 应用场景 系统中包含多个产品族，而每次只使用其中的一种产品组 结构 AbstractFactory：抽象工厂，提供了创建产品的接口，它包含多个创建产品的方法 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 UML图 实例小汪需要买电脑、显示器、耳机，他家附近有戴尔和联想两家厂家。为了防止两家的插口之间不匹配，所以小汪决定从中选一家购买 12 优点 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象 缺点 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象中增加代码代码，又要在具体的里面加代码 实际应用 手机主题等，不同主题下都有图标、壁纸等产品组成，每次都使用一个主题的所有产品 生成不同操作系统的程序 单例模式(Singleton pattern)核心思想 一个类只有一个实例，且该类能自行创建这个实例 单例对外提供一个可以访问该单例的方法 应用场景 需要控制实例数目，节省系统资源的时候 结构 单例类（Singleton）：包含一个实例且能自行创建这个实例的类。 UML图 优点 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例 避免对资源的多重占用（IO） 缺点 没有接口，不能继承，与单一职责原则冲突 实际应用 Windows 的回收站 操作系统中的文件系统 多线程中的线程池 显卡的驱动程序对象 打印机的后台处理服务 应用程序的日志对象 数据库的连接池 网站的计数器 Web 应用的配置对象 应用程序中的对话框 系统中的缓存 实例单例模式的实现分两种 懒汉式：类加载时不创建，在第一次调用时创建单例 饿汉式：类一旦加载就创建一个单例 饿汉式（线程安全）123456789101112131415161718192021222324/** * 饿汉式线程安全 * @author liisyu * @date 2019/02/22 */public class Hungry &#123; /** * 静态初始化变量，保证单例且线程安全 */ private static Hungry hungry = new Hungry(); /** * 私有化构造器，防止创建 */ private Hungry()&#123;&#125;; public static Hungry getHungry() &#123; return hungry; &#125; public void doMethod()&#123; System.out.println("do something"); &#125;&#125; 饿汉式（枚举实现）123456789101112131415/** * 饿汉式枚举 * @author liisyu * @date 2019/02/22 */public enum HungryEnum &#123; /** * 唯一实体类 */ HUNGRY_INSTANCE; public void doMethod()&#123; System.out.println("do something"); &#125;&#125; 懒汉式（非线程安全)123456789101112131415161718/** * 懒汉式非线程安全 * @author liisyu * @date 2019/02/22 */public class Lazy &#123; private static Lazy lazy; private Lazy()&#123;&#125;; public static Lazy getLazy()&#123; if (lazy == null)&#123; //这里有可能出现线程问题 lazy = new Lazy(); &#125; return lazy; &#125;&#125; 懒汉式（线程安全）如果想要线程安全，可以使用synchronized,不过每次获取都需要经过一遍锁，不推荐 1234567public static synchronized Lazy getLazy()&#123; if (lazy == null)&#123; //这里有可能出现线程问题 lazy = new Lazy(); &#125; return lazy; &#125; 懒汉式(双重检查加锁版本) 第一次先检查是否为null，再进入同步 第二次检查是否为Null，null才创建实例。 12345678910111213141516171819202122232425262728/** * 懒汉式(双重检查加锁版本) * @author liisyu * @date 2019/02/22 */public class LazyDoubleLock &#123; /** * volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量 */ private volatile static LazyDoubleLock lazy; private LazyDoubleLock() &#123; &#125; public static LazyDoubleLock getInstance() &#123; //检查实例，如果不存在，就进入同步代码块 if (lazy == null) &#123; //只有第一次才彻底执行这里的代码 synchronized(LazyDoubleLock.class) &#123; //进入同步代码块后，再检查一次，如果仍是null，才创建实例 if (lazy == null) &#123; lazy = new LazyDoubleLock(); &#125; &#125; &#125; return lazy; &#125;&#125; 懒汉式（登记式/静态内部类方式）只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类(只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题) 123456789101112131415/** * 懒汉式(静态内部类方式) * @author liisyu * @date 2019/02/22 */public class LazyInnerClass &#123; private static class SingletonHolder &#123; private static final LazyInnerClass LZAY = new LazyInnerClass(); &#125; private LazyInnerClass ()&#123;&#125; public static final LazyInnerClass getInstance() &#123; return SingletonHolder.LZAY; &#125;&#125; 原型模式(Prototype pattern)核心思想 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象 原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节 应用场景 需要多个创建多个对象，且对象之间相同或相似，可能仅仅只是个别的几个属性不同 对象的创建过程比较麻烦，但复制比较简单的时候 结构 抽象原型类（AbstractPrototype）：规定了具体原型对象必须实现的接口。 具体原型类（Realizetype）：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类（Client）：使用具体原型类中的 clone() 方法来复制新的对象 UML图 优点 性能提高，越是复杂的对象，复制比创建的速度越快 逃避构造函数的约束 缺点 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候 必须实现 Cloneable 接口 实际应用 资源优化场景 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等 性能和安全要求的场景 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式 一个对象多个修改者的场景 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者 实例三好学生奖状，每张奖状几乎一模一样，只需要改个名字即可。所以可以使用原型模式来复制奖状对象 建造者模式（Builder Pattern）核心思想 复杂对象：由对各子部件组合成一起的对象 创建一个复杂对象，则将一个复杂对象的构造与它的部件的创建细节分开 可以和工厂方法模式结合使用 应用场景 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但对象本身的结构和装配方式不变 结构 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息 UML图 优点 各个具体的建造者相互独立，有利于系统的扩展 客户端不必知道产品内部组成的细节，便于控制细节风险 缺点 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，该模式会增加很多的建造者类 实际应用实例客厅装修：用户（Client）需要装修客厅（Product）,装修的内容包括墙体的装修、电视机的选择、沙发的购买与布局等，装修工知道怎么去装修，当然用户不可能自己装修，所以需要通过一个项目经理指挥装修工人来完成 结构型模式特点： 将类或对象按照某种布局组成更大的结构 分为两类 a. 结构型模式，采用继承机制来组织接口和类 b. 对象结构型模式,釆用组合或聚合来组合对象 除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式 适配器模式(Adapter pattern)核心思想 利用一个适配器，将一个类的接口转换成另一个类的接口，使原本由于接口不兼容而不能一起工作的那些类能一起工作 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些 应用场景 两个对象因接口不兼容而不能在一起工作时使用 结构 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口 UML图类适配器模式 对象配器模式 代码类适配器代码 1234567891011121314151617181920212223242526272829303132package adapter;//目标接口interface Target&#123; public void request();&#125;//适配者接口class Adaptee&#123; public void specificRequest() &#123; System.out.println("适配者中的业务代码被调用！"); &#125;&#125;//类适配器类class ClassAdapter extends Adaptee implements Target&#123; public void request() &#123; specificRequest(); &#125;&#125;//客户端代码public class ClassAdapterTest&#123; public static void main(String[] args) &#123; System.out.println("类适配器模式测试："); Target target = new ClassAdapter(); target.request(); &#125;&#125; 对象适配器代码 1234567891011121314151617181920212223242526272829303132333435363738394041package adapter;//目标接口interface Target&#123; public void request();&#125;//适配者接口class Adaptee&#123; public void specificRequest() &#123; System.out.println("适配者中的业务代码被调用！"); &#125;&#125;//对象适配器类class ObjectAdapter implements Target&#123; private Adaptee adaptee; public ObjectAdapter(Adaptee adaptee) &#123; this.adaptee=adaptee; &#125; public void request() &#123; adaptee.specificRequest(); &#125;&#125;//客户端代码public class ObjectAdapterTest&#123; public static void main(String[] args) &#123; System.out.println("对象适配器模式测试："); Adaptee adaptee = new Adaptee(); Target target = new ObjectAdapter(adaptee); target.request(); &#125;&#125; 优点 可以让任何两个没有关联的类一起运行 提高了类的复用 增加了类的透明度 灵活性好 缺点 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构 实际应用 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同 实例桥接模式((Bridge pattern)核心思想 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替抽象与实现的继承关系 ，从而降低了抽象和实现这两个可变维度的耦合度 应用场景 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。 结构 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现 UML图 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//实现化角色interface Implementor&#123; public void OperationImpl();&#125;//具体实现化角色class ConcreteImplementorA implements Implementor&#123; public void OperationImpl() &#123; System.out.println("具体实现化(Concrete Implementor)角色被访问" ); &#125;&#125;//抽象化角色abstract class Abstraction&#123; protected Implementor imple; protected Abstraction(Implementor imple) &#123; this.imple=imple; &#125; public abstract void Operation(); &#125;//扩展抽象化角色class RefinedAbstraction extends Abstraction&#123; protected RefinedAbstraction(Implementor imple) &#123; super(imple); &#125; public void Operation() &#123; System.out.println("扩展抽象化(Refined Abstraction)角色被访问" ); imple.OperationImpl(); &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; Implementor imple=new ConcreteImplementorA(); Abstraction abs=new RefinedAbstraction(imple); abs.Operation(); &#125;&#125; 优点 由于抽象与实现分离，所以扩展能力强； 其实现细节对客户透明 缺点 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度 实际应用实例女士皮包有很多种，可以按用途分、按皮质分、按品牌分、按颜色分、按大小分等，存在多个维度的变化，所以采用桥接模式来实现女士皮包的选购比较合适 代理模式(Proxy pattern)核心思想 通过一个代理对象，作为访问者和目标对象的中介 应用场景 需要要访问的远程对象或者需要屏蔽真实对象 结构 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能 UML图 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445//抽象主题interface Subject&#123; void Request();&#125;//真实主题class RealSubject implements Subject&#123; public void Request() &#123; System.out.println("访问真实主题方法..."); &#125;&#125;//代理class Proxy implements Subject&#123; private RealSubject realSubject; public void Request() &#123; if (realSubject==null) &#123; realSubject=new RealSubject(); &#125; preRequest();//真实方法前可以插入的动作 realSubject.Request(); postRequest();//真实方法后可以插入的动作 &#125; public void preRequest() &#123; System.out.println("访问真实主题之前的预处理。"); &#125; public void postRequest() &#123; System.out.println("访问真实主题之后的后续处理。"); &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; Proxy proxy=new Proxy(); proxy.Request(); &#125;&#125; 优点 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 缺点 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢； 多了代理类，增加了系统的复杂度 实际应用 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。 智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载 静态代理前面介绍的即为静态代理。指的是代理类在编译器就已经确定 动态代理动态代理，是在运行时期生成，相比静态代理，动态代理可以很方便的对委托类的方法进行统一处理，如添加方法调用次数、添加日志功能等等，动态代理分为jdk动态代理和cglib动态代理 JDK动态代理JDK动态代理主要由一个接口和一个类来完成 InvocationHandler接口：用于管理代理类 Proxy类：用于生产实际的代理类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface Service &#123; //目标方法 public abstract void add(); &#125; public class UserServiceImpl implements Service &#123; public void add() &#123; System.out.println("This is add service"); &#125; &#125; //实现java.lang.reflect.InvocationHandler接口，并提供一个生产代理类的方法class MyInvocationHandler implements InvocationHandler &#123; private Object target; public MyInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("-----before-----"); Object result = method.invoke(target, args); System.out.println("-----end-----"); return result; &#125; // 返回代理对象的方法 public Object getProxy() &#123; //获取类加载器 ClassLoader loader = Thread.currentThread().getContextClassLoader(); // 获取目标对象的接口 Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); //生产代理类（newProxyInstance内部使用地方是java反射机制） return Proxy.newProxyInstance(loader, interfaces, this); &#125;&#125; public class Client&#123; public static void main(String[] args) &#123; Service service = new UserServiceImpl(); MyInvocationHandler handler = new MyInvocationHandler(service); Service serviceProxy = (Service)handler.getProxy(); serviceProxy.add(); &#125;&#125; 代理对象生成，即newProxyInstance方法过程 内部由一个ProxyGenerator.generateProxyClass()方法来负责生成代理类的字节码（这个方法是依赖于接口的） Proxy.defineClass0()方法会加载字节码，并返回相应的Class对象 最后利用clazz.newInstance()反射机制来生成代理类对象 JDK动态代理的局限性 从生成代理对象的方法可知，需要传入一个目标对象的接口，如果目标对象没有实现接口的话，则无法使用动态代理。 仅能代理接口定义的方法，如果目标对象拥有自己的方法，则这些方法无法被代理 cglib动态代理使用cglib代理，并不需要目标类实现接口，它的底层采用asm字节码框架生成代理类的字节码,cglib代理核心为 MethodInterceptor接口：用于定义方法的拦截器 Enhancer类：用于生成代理类 12345678910111213141516171819202122232425262728public class UserServiceImpl &#123; public void add() &#123; System.out.println("This is add service"); &#125; public void delete(int id) &#123; System.out.println("This is delete service：delete " + id ); &#125; &#125; public class MyMethodInterceptor implements MethodInterceptor &#123; public Object intercept(Object obj, Method method, Object[] arg, MethodProxy proxy) throws Throwable &#123; System.out.println("Before:" + method); Object object = proxy.invokeSuper(obj, arg); System.out.println("After:" + method); return object; &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(UserServiceImpl.class); enhancer.setCallback(new MyMethodInterceptor()); UserServiceImpl userService = (UserServiceImpl)enhancer.create(); userService。add(); &#125;&#125; cglib代理生成的代理类是委托类的子类，且不能处理被final关键字修饰的方法 参考 https://www.jianshu.com/p/a1d094fc6c00 https://www.jianshu.com/p/13aa63e1ac95 装饰模式(Decorator pattern)核心思想 在不改变现有对象结构的情况下，动态地给对象添加功能的模式 结构 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//抽象构件角色interface Component&#123; public void operation();&#125;//具体构件角色class ConcreteComponent implements Component&#123; public ConcreteComponent() &#123; System.out.println("创建具体构件角色"); &#125; public void operation() &#123; System.out.println("调用具体构件角色的方法operation()"); &#125;&#125;//抽象装饰角色class Decorator implements Component&#123; private Component component; public Decorator(Component component) &#123; this.component=component; &#125; public void operation() &#123; component.operation(); &#125;&#125;//具体装饰角色class ConcreteDecorator extends Decorator&#123; public ConcreteDecorator(Component component) &#123; super(component); &#125; public void operation() &#123; super.operation(); addedFunction(); &#125; public void addedFunction() &#123; System.out.println("为具体构件角色增加额外的功能addedFunction()"); &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; Component p=new ConcreteComponent(); p.operation(); System.out.println("---------------------------------"); Component d=new ConcreteDecorator(p); d.operation(); &#125;&#125; UML图 优点 采用装饰模式扩展对象的功能比采用继承方式更加灵活。 可以设计出多个不同的具体装饰类，创造出多个不同行为的组合 缺点装饰模式增加了许多子类，如果过度使用会使程序变得很复杂 应用场景 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。 当对象的功能要求可以动态地添加，也可以再动态地撤销时 实际应用 Java中的IO流 实例外观模式(Façade pattern)核心思想 通过一个对外的统一窗口，使多个子系统更加容易被访问 迪米特法则典型应用 结构 外观（Facade）角色：为多个子系统对外提供一个共同的窗口。 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。 客户（Client）角色：通过一个外观角色访问各个子系统的功能。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//外观角色class Facade&#123; private SubSystem01 obj1=new SubSystem01(); private SubSystem02 obj2=new SubSystem02(); private SubSystem03 obj3=new SubSystem03(); public void method() &#123; obj1.method1(); obj2.method2(); obj3.method3(); &#125;&#125;//子系统角色class SubSystem01&#123; public void method1() &#123; System.out.println("子系统01的method1()被调用！"); &#125; &#125;//子系统角色class SubSystem02&#123; public void method2() &#123; System.out.println("子系统02的method2()被调用！"); &#125; &#125;//子系统角色class SubSystem03&#123; public void method3() &#123; System.out.println("子系统03的method3()被调用！"); &#125; &#125;public class FacadePattern&#123; public static void main(String[] args) &#123; Facade f=new Facade(); f.method(); &#125;&#125; UML图 优点 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。 缺点 不能很好地限制客户使用子系统类。 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则” 应用场景 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性 实际应用实例享元模式(Flyweight pattern)核心思想 通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率 享元模式中存在以下两种状态： a. 内部状态，即不会随着环境的改变而改变的可共享部分； v. 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。 结构 抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。 具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。 非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//非享元角色class UnsharedConcreteFlyweight&#123; private String info; UnsharedConcreteFlyweight(String info) &#123; this.info=info; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info=info; &#125;&#125;//抽象享元角色interface Flyweight&#123; public void operation(UnsharedConcreteFlyweight state);&#125;//具体享元角色class ConcreteFlyweight implements Flyweight&#123; private String key; ConcreteFlyweight(String key) &#123; this.key=key; System.out.println("具体享元"+key+"被创建！"); &#125; public void operation(UnsharedConcreteFlyweight outState) &#123; System.out.print("具体享元"+key+"被调用，"); System.out.println("非享元信息是:"+outState.getInfo()); &#125;&#125;//享元工厂角色class FlyweightFactory&#123; private HashMap&lt;String, Flyweight&gt; flyweights=new HashMap&lt;String, Flyweight&gt;(); public Flyweight getFlyweight(String key) &#123; Flyweight flyweight=(Flyweight)flyweights.get(key); if(flyweight!=null) &#123; System.out.println("具体享元"+key+"已经存在，被成功获取！"); &#125; else &#123; flyweight=new ConcreteFlyweight(key); flyweights.put(key, flyweight); &#125; return flyweight; &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; FlyweightFactory factory=new FlyweightFactory(); Flyweight f01=factory.getFlyweight("a"); Flyweight f02=factory.getFlyweight("a"); Flyweight f03=factory.getFlyweight("a"); Flyweight f11=factory.getFlyweight("b"); Flyweight f12=factory.getFlyweight("b"); f01.operation(new UnsharedConcreteFlyweight("第1次调用a。")); f02.operation(new UnsharedConcreteFlyweight("第2次调用a。")); f03.operation(new UnsharedConcreteFlyweight("第3次调用a。")); f11.operation(new UnsharedConcreteFlyweight("第1次调用b。")); f12.operation(new UnsharedConcreteFlyweight("第2次调用b。")); &#125;&#125; UML图 优点 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力 分为透明式和安全式 a. 透明式：抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的 b. 将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法 缺点 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。 读取享元模式的外部状态会使得运行时间稍微变长。 应用场景 系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。 大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。 由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。 实际应用实例组合模式(Composite pattern)核心思想 将对象的整体-部分关系以树状的层次结构来表示，使用户对单个对象和组合对象具有一致的访问性 结构 抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。 树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。 树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。 代码透明式的组合模式（安全式只需要稍加修改） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//抽象构件interface Component&#123; public void add(Component c); public void remove(Component c); public Component getChild(int i); public void operation();&#125;//树叶构件class Leaf implements Component&#123; private String name; public Leaf(String name) &#123; this.name=name; &#125; public void add(Component c)&#123; &#125; public void remove(Component c)&#123; &#125; public Component getChild(int i) &#123; return null; &#125; public void operation() &#123; System.out.println("树叶"+name+"：被访问！"); &#125;&#125;//树枝构件class Composite implements Component&#123; private ArrayList&lt;Component&gt; children=new ArrayList&lt;Component&gt;(); public void add(Component c) &#123; children.add(c); &#125; public void remove(Component c) &#123; children.remove(c); &#125; public Component getChild(int i) &#123; return children.get(i); &#125; public void operation() &#123; for(Object obj:children) &#123; ((Component)obj).operation(); &#125; &#125; &#125;public class Client&#123; public static void main(String[] args) &#123; Component c0=new Composite(); Component c1=new Composite(); Component leaf1=new Leaf("1"); Component leaf2=new Leaf("2"); Component leaf3=new Leaf("3"); c0.add(leaf1); c0.add(c1); c1.add(leaf2); c1.add(leaf3); c0.operation(); &#125;&#125; UML图透明式组合模式 安全式组合模式 优点 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码； 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”； 缺点 设计较复杂，客户端需要花更多时间理清类之间的层次关系； 不容易限制容器中的构件； 不容易用继承的方法来增加构件的新功能 透明式缺点：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题 安全式缺点：叶子和分支方法不同，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性 应用场景 在需要表示一个对象整体与部分的层次结构的场合。 要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。 实际应用实例行为型模式 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。 行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。 除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式 模板方法模式(Template method pattern)核心思想 定义一个操作中的算法骨架，而将算法的具体逻辑由子类完成，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤 结构 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。 a. 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 b. 基本方法：是整个算法中的一个步骤，包含以下几种类型 ​ I. 抽象方法：在抽象类中申明，由具体子类实现。 ​ II. 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。 ​ III. 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。 代码12345678910111213141516171819202122232425262728293031323334353637//抽象类abstract class AbstractClass&#123; public void TemplateMethod() //模板方法 &#123; SpecificMethod(); abstractMethod1(); abstractMethod2(); &#125; public void SpecificMethod() //具体方法 &#123; System.out.println("抽象类中的具体方法被调用..."); &#125; public abstract void abstractMethod1(); //抽象方法1 public abstract void abstractMethod2(); //抽象方法2&#125;//具体子类class ConcreteClass extends AbstractClass&#123; public void abstractMethod1() &#123; System.out.println("抽象方法1的实现被调用..."); &#125; public void abstractMethod2() &#123; System.out.println("抽象方法2的实现被调用..."); &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; AbstractClass tm=new ConcreteClass(); tm.TemplateMethod(); &#125;&#125; UML图 优点 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 它在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 缺点 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 应用场景 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。 实际应用实例策略模式(Strategy pattern)核心思想 定义一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户 结构 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。 环境（Context）类：持有一个策略类的引用，最终给客户端调用。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//抽象策略类interface Strategy&#123; public void strategyMethod(); //策略方法&#125;//具体策略类Aclass ConcreteStrategyA implements Strategy&#123; public void strategyMethod() &#123; System.out.println("具体策略A的策略方法被访问！"); &#125;&#125;//具体策略类Bclass ConcreteStrategyB implements Strategy&#123; public void strategyMethod() &#123; System.out.println("具体策略B的策略方法被访问！"); &#125;&#125;//环境类class Context&#123; private Strategy strategy; public Strategy getStrategy() &#123; return strategy; &#125; public void setStrategy(Strategy strategy) &#123; this.strategy=strategy; &#125; public void strategyMethod() &#123; strategy.strategyMethod(); &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; Context c=new Context(); Strategy s=new ConcreteStrategyA(); c.setStrategy(s); c.strategyMethod(); System.out.println("-----------------"); s=new ConcreteStrategyB(); c.setStrategy(s); c.strategyMethod(); &#125;&#125; UML图 优点 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。 缺点 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。 策略模式造成很多的策略类。 应用场景 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。 实际应用实例命令模式(Command pattern)核心思想 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开 结构 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。 具体命令角色（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。 实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//调用者class Invoker&#123; private Command command; public Invoker(Command command) &#123; this.command=command; &#125; public void setCommand(Command command) &#123; this.command=command; &#125; public void call() &#123; System.out.println("调用者执行命令command..."); command.execute(); &#125;&#125;//抽象命令interface Command&#123; public abstract void execute();&#125;//具体命令class ConcreteCommand implements Command&#123; private Receiver receiver; ConcreteCommand() &#123; receiver=new Receiver(); &#125; public void execute() &#123; receiver.action(); &#125;&#125;//接收者class Receiver&#123; public void action() &#123; System.out.println("接收者的action()方法被调用..."); &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; Command cmd=new ConcreteCommand(); Invoker ir=new Invoker(cmd); System.out.println("客户访问调用者的call()方法..."); ir.call(); &#125;&#125; UML图 优点 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。 缺点 可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。 应用场景 当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。 当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。 当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。 当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。 实际应用实例责任链模式(Chain-of-responsibility pattern)责任链模式又被称为职责链模式 核心思想 为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止 结构 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//抽象处理者角色abstract class Handler&#123; private Handler next; public void setNext(Handler next) &#123; this.next=next; &#125; public Handler getNext() &#123; return next; &#125; //处理请求的方法 public abstract void handleRequest(String request); &#125;//具体处理者角色1class ConcreteHandler1 extends Handler&#123; public void handleRequest(String request) &#123; if(request.equals("one")) &#123; System.out.println("具体处理者1负责处理该请求！"); &#125; else &#123; if(getNext()!=null) &#123; getNext().handleRequest(request); &#125; else &#123; System.out.println("没有人处理该请求！"); &#125; &#125; &#125; &#125;//具体处理者角色2class ConcreteHandler2 extends Handler&#123; public void handleRequest(String request) &#123; if(request.equals("two")) &#123; System.out.println("具体处理者2负责处理该请求！"); &#125; else &#123; if(getNext()!=null) &#123; getNext().handleRequest(request); &#125; else &#123; System.out.println("没有人处理该请求！"); &#125; &#125; &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; //组装责任链 Handler handler1=new ConcreteHandler1(); Handler handler2=new ConcreteHandler2(); handler1.setNext(handler2); //提交请求 handler1.handleRequest("two"); &#125;&#125; UML图 优点 降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。 增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。 增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。 责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。 缺点 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。 应用场景 有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。 可动态指定一组对象处理请求，或添加新的处理者。 在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。 实际应用实例状态模式(State pattern)核心思想 对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。 结构 环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。 具体状态（Concrete State）角色：实现抽象状态所对应的行为。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//环境类class Context&#123; private State state; //定义环境类的初始状态 public Context() &#123; this.state=new ConcreteStateA(); &#125; //设置新状态 public void setState(State state) &#123; this.state=state; &#125; //读取状态 public State getState() &#123; return(state); &#125; //对请求做处理 public void Handle() &#123; state.Handle(this); &#125;&#125;//抽象状态类abstract class State&#123; public abstract void Handle(Context context);&#125;//具体状态A类class ConcreteStateA extends State&#123; public void Handle(Context context) &#123; System.out.println("当前状态是 A."); context.setState(new ConcreteStateB()); &#125;&#125;//具体状态B类class ConcreteStateB extends State&#123; public void Handle(Context context) &#123; System.out.println("当前状态是 B."); context.setState(new ConcreteStateA()); &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; Context context=new Context(); //创建环境 // 执行完操作后，可能状态发生改变 context.Handle(); // 当前状态是 A. context.Handle(); //当前状态是 B. context.Handle(); //当前状态是 A. context.Handle();//当前状态是 B. &#125;&#125; UML图 优点 状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。 减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。 有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。 缺点 状态模式的使用必然会增加系统的类与对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱 应用场景 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。 实际应用实例观察者模式(Observer pattern)又被称为发布-订阅模式、模型-视图模式 核心思想 多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新 结构 抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。 具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//抽象目标abstract class Subject&#123; protected List&lt;Observer&gt; observers=new ArrayList&lt;Observer&gt;(); //增加观察者方法 public void add(Observer observer) &#123; observers.add(observer); &#125; //删除观察者方法 public void remove(Observer observer) &#123; observers.remove(observer); &#125; public abstract void notifyObserver(); //通知观察者方法&#125;//具体目标class ConcreteSubject extends Subject&#123; public void notifyObserver() &#123; System.out.println("具体目标发生改变..."); System.out.println("--------------"); for(Object obs:observers) &#123; ((Observer)obs).response(); &#125; &#125; &#125;//抽象观察者interface Observer&#123; void response(); //反应&#125;//具体观察者1class ConcreteObserver1 implements Observer&#123; public void response() &#123; System.out.println("具体观察者1作出反应！"); &#125;&#125;//具体观察者1class ConcreteObserver2 implements Observer&#123; public void response() &#123; System.out.println("具体观察者2作出反应！"); &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; Subject subject=new ConcreteSubject(); Observer obs1=new ConcreteObserver1(); Observer obs2=new ConcreteObserver2(); subject.add(obs1); subject.add(obs2); subject.notifyObserver(); &#125;&#125; UML图 优点 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 目标与观察者之间建立了一套触发机制。 缺点 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 应用场景 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 实际应用实例中介模式(Mediator pattern)中介模式又称为调停模式 核心思想 定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互 迪米特法则典型应用 结构 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。 具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//抽象中介者abstract class Mediator&#123; public abstract void register(Colleague colleague); public abstract void relay(Colleague cl); //转发&#125;//具体中介者class ConcreteMediator extends Mediator&#123; private List&lt;Colleague&gt; colleagues=new ArrayList&lt;Colleague&gt;(); public void register(Colleague colleague) &#123; if(!colleagues.contains(colleague)) &#123; colleagues.add(colleague); colleague.setMedium(this); &#125; &#125; public void relay(Colleague cl) &#123; for(Colleague ob:colleagues) &#123; if(!ob.equals(cl)) &#123; ((Colleague)ob).receive(); &#125; &#125; &#125;&#125;//抽象同事类abstract class Colleague&#123; protected Mediator mediator; public void setMedium(Mediator mediator) &#123; this.mediator=mediator; &#125; public abstract void receive(); public abstract void send();&#125;//具体同事类class ConcreteColleague1 extends Colleague&#123; public void receive() &#123; System.out.println("具体同事类1收到请求。"); &#125; public void send() &#123; System.out.println("具体同事类1发出请求。"); mediator.relay(this); //请中介者转发 &#125;&#125;//具体同事类class ConcreteColleague2 extends Colleague&#123; public void receive() &#123; System.out.println("具体同事类2收到请求。"); &#125; public void send() &#123; System.out.println("具体同事类2发出请求。"); mediator.relay(this); //请中介者转发 &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; Mediator md=new ConcreteMediator(); Colleague c1,c2; c1=new ConcreteColleague1(); c2=new ConcreteColleague2(); md.register(c1); md.register(c2); c1.send(); System.out.println("-------------"); c2.send(); &#125;&#125; UML图 优点 降低了对象之间的耦合性，使得对象易于独立地被复用。 将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。 缺点 当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。 应用场景 当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。 当想创建一个运行于多个类之间的对象，又不想生成新的子类时。 实际应用实例迭代器模式(Iterator pattern)核心思想 提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示 结构 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//抽象聚合interface Aggregate&#123; public void add(Object obj); public void remove(Object obj); public Iterator getIterator(); &#125;//具体聚合class ConcreteAggregate implements Aggregate&#123; private List&lt;Object&gt; list=new ArrayList&lt;Object&gt;(); public void add(Object obj) &#123; list.add(obj); &#125; public void remove(Object obj) &#123; list.remove(obj); &#125; public Iterator getIterator() &#123; return(new ConcreteIterator(list)); &#125; &#125;//抽象迭代器interface Iterator&#123; Object first(); Object next(); boolean hasNext();&#125;//具体迭代器class ConcreteIterator implements Iterator&#123; private List&lt;Object&gt; list=null; private int index=-1; public ConcreteIterator(List&lt;Object&gt; list) &#123; this.list=list; &#125; public boolean hasNext() &#123; if(index&lt;list.size()-1) &#123; return true; &#125; else &#123; return false; &#125; &#125; public Object first() &#123; index=0; Object obj=list.get(index);; return obj; &#125; public Object next() &#123; Object obj=null; if(this.hasNext()) &#123; obj=list.get(++index); &#125; return obj; &#125; &#125;public class Client&#123; public static void main(String[] args) &#123; Aggregate ag=new ConcreteAggregate(); ag.add("中山大学"); ag.add("华南理工"); ag.add("韶关学院"); System.out.print("聚合的内容有："); Iterator it=ag.getIterator(); while(it.hasNext()) &#123; Object ob=it.next(); System.out.print(ob.toString()+"\t"); &#125; Object ob=it.first(); System.out.println("\nFirst："+ob.toString()); &#125;&#125; UML图 优点 访问一个聚合对象的内容而无须暴露它的内部表示。 遍历任务交由迭代器完成，这简化了聚合类。 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。 增加新的聚合类和迭代器类都很方便，无须修改原有代码。 封装性良好，为遍历不同的聚合结构提供一个统一的接口。 缺点 增加了类的个数，这在一定程度上增加了系统的复杂性 应用场景 当需要为聚合对象提供多种遍历方式时。 当需要为遍历不同的聚合结构提供一个统一的接口时。 当访问一个聚合对象的内容而无须暴露其内部细节的表示时。 实际应用实例访问者模式(Visitor)核心思想 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式 它将对数据的操作与数据结构进行分离 结构 抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。 具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。 抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。 具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。 对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//抽象访问者interface Visitor&#123; void visit(ConcreteElementA element); void visit(ConcreteElementB element);&#125;//具体访问者A类class ConcreteVisitorA implements Visitor&#123; public void visit(ConcreteElementA element) &#123; System.out.println("具体访问者A访问--&gt;"+element.operationA()); &#125; public void visit(ConcreteElementB element) &#123; System.out.println("具体访问者A访问--&gt;"+element.operationB()); &#125;&#125;//具体访问者B类class ConcreteVisitorB implements Visitor&#123; public void visit(ConcreteElementA element) &#123; System.out.println("具体访问者B访问--&gt;"+element.operationA()); &#125; public void visit(ConcreteElementB element) &#123; System.out.println("具体访问者B访问--&gt;"+element.operationB()); &#125;&#125;//抽象元素类interface Element&#123; void accept(Visitor visitor);&#125;//具体元素A类class ConcreteElementA implements Element&#123; public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public String operationA() &#123; return "具体元素A的操作。"; &#125;&#125;//具体元素B类class ConcreteElementB implements Element&#123; public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public String operationB() &#123; return "具体元素B的操作。"; &#125;&#125;//对象结构角色class ObjectStructure&#123; private List&lt;Element&gt; list=new ArrayList&lt;Element&gt;(); public void accept(Visitor visitor) &#123; Iterator&lt;Element&gt; i=list.iterator(); while(i.hasNext()) &#123; ((Element) i.next()).accept(visitor); &#125; &#125; public void add(Element element) &#123; list.add(element); &#125; public void remove(Element element) &#123; list.remove(element); &#125;&#125;public class VisitorPattern&#123; public static void main(String[] args) &#123; ObjectStructure os=new ObjectStructure(); os.add(new ConcreteElementA()); os.add(new ConcreteElementB()); Visitor visitor=new ConcreteVisitorA(); os.accept(visitor); System.out.println("------------------------"); visitor=new ConcreteVisitorB(); os.accept(visitor); &#125;&#125; UML图 优点 扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。 复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。 灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。 符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。 缺点 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。 违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。 应用场景 对象结构相对稳定，但其操作算法经常变化的程序。 对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。 对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。 实际应用实例备忘录模式(Memento pattern)核心思想 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态 结构 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//备忘录class Memento&#123; private String state; public Memento(String state) &#123; this.state=state; &#125; public void setState(String state) &#123; this.state=state; &#125; public String getState() &#123; return state; &#125;&#125;//发起人class Originator&#123; private String state; public void setState(String state) &#123; this.state=state; &#125; public String getState() &#123; return state; &#125; public Memento createMemento() &#123; return new Memento(state); &#125; public void restoreMemento(Memento m) &#123; this.setState(m.getState()); &#125; &#125;//管理者class Caretaker&#123; private Memento memento; public void setMemento(Memento m) &#123; memento=m; &#125; public Memento getMemento() &#123; return memento; &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; Originator or=new Originator(); Caretaker cr=new Caretaker(); or.setState("S0"); System.out.println("初始状态:"+or.getState()); cr.setMemento(or.createMemento()); //保存状态 or.setState("S1"); System.out.println("新的状态:"+or.getState()); or.restoreMemento(cr.getMemento()); //恢复状态 System.out.println("恢复状态:"+or.getState()); &#125;&#125; UML图 优点 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。 缺点 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。 应用场景 需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。 需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。 实际应用实例解释器模式(Interpreter pattern)核心思想 给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文 解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 Expression4J 或 Jep 等来设计 编译原理概念文法文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的“句子”的文法如下。 12345678//注：这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。〈句子〉::=〈主语〉〈谓语〉〈宾语〉〈主语〉::=〈代词〉|〈名词〉〈谓语〉::=〈动词〉〈宾语〉::=〈代词〉|〈名词〉〈代词〉你|我|他〈名词〉7大学生I筱霞I英语〈动词〉::=是|学习 句子 句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子 语法树语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。如下图是”我是大学生“的语法树 结构 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。 代码123456789101112131415161718192021222324252627282930313233343536//抽象表达式类interface AbstractExpression&#123; public Object interpret(String info); //解释方法&#125;//终结符表达式类class TerminalExpression implements AbstractExpression&#123; public Object interpret(String info) &#123; //对终结符表达式的处理 &#125;&#125;//非终结符表达式类class NonterminalExpression implements AbstractExpression&#123; private AbstractExpression exp1; private AbstractExpression exp2; public Object interpret(String info) &#123; //非对终结符表达式的处理 &#125;&#125;//环境类class Context&#123; private AbstractExpression exp; public Context() &#123; //数据初始化 &#125; public void operation(String info) &#123; //调用相关表达式类的解释方法 &#125;&#125; UML图 优点 扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。 缺点 执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。 会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。 可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。 应用场景 当语言的文法较为简单，且执行效率不是关键问题时。 当问题重复出现，且可以用一种简单的语言来进行表达时。 当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。 实际应用实例参考https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#id3 http://c.biancheng.net/view/1317.html]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataStructure]]></title>
    <url>%2Fblog%2F2018%2F02%2F17%2FDataStructure.all%2F</url>
    <content type="text"><![CDATA[数组（Array）数组概念数组（Array）：是一种 线性表 数据结构，用一组 连续 的内存空间，来存储一组具有相同类型的数据 数组两大关键概念 线性表：即数据成直线一样的结构，每个线性表上的数据可访问前后两个方向 连续的内存空间和相同的类型数据: 这两个限制使数组具备了“随机访问” 的特性，同时使得数组的部分操作变得低效（删除、更新等） 示例： 1int[] a= new int[10]; 数组的内存地址计算如下 a[i]_addree = base_address + i * data_type_size 假设内存块的首地址base_address = 10; int数据类型，所以data_type_size = 4 由此可以得到a[10]的内存空间为连续的1000~1039 关于“数组适合查找，查找时间复杂度为O(1)”的描述 实际上不够准确,因为即使是排序好的数组，使用二分查找，复杂度也是O(longn) 正确描述应该是：“数组适合查找，且支持随机访问，根绝下表随机访问的时间复杂度为O(1)” 数组的插入数组为了保持内存的连续性，插入和删除操作比较低效 比如我们要将一个数据插入到数组中的第K个位置，需要 把第K个位置腾出来 k~n的元素往后移动一位 如果k是末尾，那时间复杂度就是O(1)；如果是头部时间复杂度就是O(n),平均复杂度就是(1+2+3…+n)/n = O(n) 由此可见，对于插入一个数的操作，非常低效。 但是，对于数组仅仅只是被当作一个存储数据的集合，对于其内的数据没有任何规律的话，可以避免大规模的数据迁移，方法就是 将第K位置的元素放到数组元素最后 新的元素放到k的位置 好处就是插入的复杂度降为O(1) 数组的删除如果我们要将一个数据从第k的位置删除，那么 把第k位置的元素删除 k~n的数据向前一迁移 平均复杂度：O(n) 但是，如果我们对数组数据的连续性并没有要求，为了防止删除一次，就迁移一次数据，而是将多次删除一起执行，可以使用如下方法 并不删除数据，而是标识该数据已经被删除 当数组空间不足时，再执行一次真正的删除操作 好处就是大大减少了删除导致的数据迁移 数组的访问越界众所周知,如下代码会出现访问越界 12int [] a = new int[3];a[3] = 10; 访问数组，其本质时访问一段连续内存，只要数组通过偏移计算得到的内存地址可用，程序可能不会报错(Java自身会做越界检查，越界抛出java.lang.ArrayIndexOutOfBoundsException) 数组和容器选择针对数组类型，Java提供了很多容器，如ArrayList,并且实现很多逻辑，如扩容逻辑。但是，有些时候，使用数组会更加合适 存储基本类型，ArrayList无法存储基本类型，而Autoboxing、Unboxing有一定的性能消耗 数据大小事先已知，且对数据操作非常简单，不需要容器提供的大部分方法，也可以使用数组 多维数组，用数组会更加直观 为什么数组会是从0开始前面看完后，基本上可以了解数组为什么从0开始 从数组内存模型可以看出，所谓的下标其实就是“偏移offset”如,a[0]就是偏移为0的位置，也就是首地址 计算公式如下 1a[k]_address = base_address + k * type_size 但如果从1开始计算，那么计算公式如下 1a[k]_address = base_address + (k-1) * type_size 两个公式相比较，从1开始计算，对于CPU来说，需要多一次减法操作 数组列表(ArrayList)利用数组的连续存储空间顺序存放线性表的各元素 基本构成： 用于存放数据的数组,数组的大小即长度 最后一个数组元素的索引 1234public class ArrayList &#123; private Object[] elementData;//用于存放数据的数组 private int last;//最后一个数组元素的索引&#125; 初始化操作： 123456public List() &#123; //空数组 this.elementData =new Object[0]; //last设为-1 this.last = -1;&#125; 查询元素所在位置： 123456789public int find(Object x)&#123; int i = 0; //从0开始找直到最后或者找到x，停止循环 while (i &lt;= last &amp;&amp; elementData[i] != x) i++; //i 大于last时，表示找到最后一个没找到，返回-1 if (i &gt; last) return -1; //找到的话直接返回i就是x所在的位置 else return i;&#125; 插入操作： 123456789101112131415161718 /*** * @param x 要插入的元素* @param i 要插入的位置，i &gt;= 1,因为0前面是没有索引的*/public void insert(Object x, int i)&#123; // 如果last指向最后一个位置，表示空间已满，不能插入 if (last == elementData.length-1) return; //检查插入位置的合法性 if (i &lt; 1 || i &gt; last + 2) return; for (int j = last; j &gt;= i-1; j--)&#123; elementData[j + 1] = elementData[j];//从最后一个数开始往后存数 elementData[i-1] = x; //将x插入 &#125; last++; //last仍指向最后的元素 return;&#125; 删除操作 1234567891011public void delete(int i)&#123; //检查空表以及删除位置的合法性 if (i &lt;0 || i &gt; last+1) return; for(int j = i; j &lt;= last; j++)&#123; if (j == last) elementData[last] = null; else elementData[j] = elementData[j + 1]; // 从i位置一个一个往前挪 &#125; last--;//last仍指向最后的元素 return;&#125; 链表（linkedList）什么是链表？ 链表是通过将零散的内存块串联起来，该内存块被称为”结点”； 结点除了存储数据之外，还需要记录链上的下一个结点的地址，该地址被称为”后继指针next” 链表与数组的区别区别如下： 数组需要连续的空间，如1000MB的数组，必须要有1000MB的连续空间，否则就算内存有充足的空间但不连续，数组就申请失败;而链表无需连续的内存空间，通过“指针”将零散的内存快串联起来 数组大小固定，而链表没有大小限制 数组使用连续内存空间，可借助CPU缓存机制，预读数组中的数据，访问效率更高；链表没有办法有效预读 时间复杂度 数组 链表 插入/删除 O(n) O(1) 随机访问 0(1) O(n) 常见链表单链表单链表存在两个特殊的结点 第一个结点：称为头结点，用来记录链表的基地址 最后一个结点：尾结点，指针指向NULL 删除和插入操作 只需要改变插入位置相邻结点的指向极客 时间复杂度为O(1) 查询操作 因为链表数据并非连续存储，所以无法想数组一样靠首地址和下标，只能通过遍历结点获取 时间复杂度：O(n) 循环链表属于一种特殊的单链表 循环链表的尾结点指向链表的头结点 优点在于处理数据具有环形结构特点比较方便，如约瑟夫问题 双向链表特点： 每个结点不知有一个后继指针next,还有一个前驱指针prev 因为存储后继结点和前驱结点，需要额外的空间 双向链表查找前驱结点的时间复杂度是O(1) 双向链表再某些情况下插入删除操作比单链表更简单高效 在java中，LinkedHashMap使用了双项链表结构 单链表的插入删除操作已经是O(1),双向链表如何更高效？ 通常开发中的删除数据情况 情况1：给定某个值，删除对应结点 情况2：给定某个指针，删除给定指针指向的结点 对于情况1，具体流程为： 查找需要的结点（需遍历结点，复杂度O(n)） 改变相邻结点指针指向（复杂度O(1)) 总的时间复杂度为O(n) 对于情况2，直接获取到需要删除的结点q，但需要知道该结点的前驱结点 对于单链表，为了找前驱结点p，还是需要遍历链表，直到p.next=q,复杂度为0(n) 对于双向链表，复杂度就是O(1)了 链表的插入同理 双向循环链表 如何写好链表理解指针所谓指针： 将某个标量赋值给指针，就是将变量的地址复制给指针。通过指针保存的内存地址，找到这个变量 对于java，就是引用 常用的代码 1234//p结点中的next针织存储了q结点的地址p-&gt;next = q//p结点next指针存储p结点的下下个结点内存地址（删除了下一个结点）p-&gt;next = p-&gt;next-&gt;next 警惕指针丢失和内存泄露假设想将x插入到p和b之间 如下代码，会导致指针丢失和内存泄漏 123//p指向了自己p-&gt;next = x;x-&gt;next = p-&gt;next; 正确的插入x的做法应该是 1234//先将x指向bx-&gt;next = p-&gt;next;//再将p指向xp-&gt;next = x; 利用哨兵简化实现难度假设在头结点p后插入新结点x 12x-&gt;next = p-&gt;next;p-&gt;next = x; 看似没有问题，但如果该链表其实是空表呢?(需要插入到表头) 对于插入到头结点head，与其他插入逻辑不同 123if(head == null)&#123; head = x;&#125; 再来看删除操作 1p-&gt;next = p-&gt;next-&gt;next 正常来讲没有问题，但如果删除的是链表的最后一个结点，那就出错了,需要进行特殊处理 123if(head-&gt;next == null)&#123; head = null&#125; 可以看出，对于头尾结点，需要特殊处理。哨兵的作用，就是解决这样的“边界问题” 拥有哨兵的结点，被称为带头链表 不管链表是否为空，head结点永远指向哨兵结点 哨兵结点不存储数据 好处就是对于插入第一个结点和其他结点，或者删除最后一个结点和删除其他结点，可以统一为相同的逻辑代码了 留意边界条件处理写完链表后，检查边界条件下是否可以正常允许，通常考虑 链表为空的情况 链表只包含一个结点 链表只包含两个结点 代码逻辑处理头结点和尾结点 画图利用画图，更加清醒插入、删除等操作 比如： 链表应用场景链表经典的应用场景，就是LRU缓存淘汰算法 缓存 一种提高数据读取性能的技术 大小有限，缓存被用满时，需要决定删除那些数据，此时就需要缓存淘汰策略 缓存淘汰策略，常见有三种 先进先出FIFO（First In, First Out） 最少使用策略LFU(Least Frequently Used) 最近最少使用策略LRU(Least Recently Used) LRU缓存淘汰算法思路： 维护一个有序单链表 越靠近链表尾结点，说明是越早之前访问的 一个新的数据被访问，从链表头开始顺序遍历链表 如果此数据已经缓存在链表内，将这个数据对应的结点从原来的位置删除，插入到链表表头 否则，有可以分为两种情况 如果此时缓存未满，则直接将该数据对应的结点插入表头 否则，则删除链表尾结点，数据对应的结点插入表头 栈（Stack）什么是栈？ 栈是一种“操作受限”的线性表，只允许在一端插入和删除数据 栈的操作主要为入栈和出栈 栈的复杂度 在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度为O(1) 入栈、出栈是对栈顶个别数据操作，时间复杂度也是O(1) 简单的栈代码1234567891011121314151617181920212223242526272829303132333435// 基于数组实现的顺序栈public class ArrayStack &#123; private String[] items; // 数组 private int count; // 栈中元素个数 private int n; //栈的大小 // 初始化数组，申请一个大小为n的数组空间 public ArrayStack(int n) &#123; this.items = new String[n]; this.n = n; this.count = 0; &#125; // 入栈操作 public boolean push(String item) &#123;// 数组空间不够了，直接返回false，入栈失败。 if (count == n) &#123; return false; &#125;// 将item放到下标为count的位置，并且count加一 items[count] = item; ++count; return true; &#125; // 出栈操作 public String pop() &#123;// 栈为空，则直接返回null if (count == 0) return null;// 返回下标为count-1的数组元素，并且栈中元素个数count减一 String tmp = items[count - 1]; --count; return tmp; &#125;&#125; 栈的应用栈在函数调用中的应用比较经典的一个应用场景：函数调用栈 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构,用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈 假设如下方法 1234567891011121314int main() &#123; int a = 1; int ret = 0; int res = 0; ret = add(3, 5); res = a + ret; printf("%d", res); reuturn 0;&#125;int add(int x, int y) &#123; int sum = 0; sum = x + y; return sum;&#125; 其内存情况如下图 栈在表达式求值中的应用栈的另一种常见应用场景，编译器通过栈来实现表达式求值 编译器通过两个栈来实现表达式求值 其中一个保存操作数的栈，另一个是保存运算符的栈。 编译器从左向右遍历表达式，当遇到数字，就直接压入操作数栈； 当遇到运算符，就与运算符栈的栈顶元素进行比较。 如果比运算符栈顶元素的优先级高，就将当前运算符压入栈； 如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。 如：3+5*8-6的计算过程图如下 栈在括号匹配中的应用可以借助栈来检查表达式中的括号是否匹配 如表达式中含有:”()”、”{}”、”[]” ({[]}):像这种就是合法的 }){]([)：这样的就是不合法的 那么如何用栈解决 从左到右一次扫描 扫描到左括号时，存入栈中 扫描到右括号时，从栈顶去除一个左括号，如果匹配，则继续扫描；如果不匹配或者没有数据时，说明为非法格式 队列（Queue）什么是队列？ 类似于排队买午饭，先进先出 最基本操作为入队enqueue(): 放一个数据到尾部dequeue(): 从队列头部取一个数据 高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；java.concurrent并发包利用ArrayBlockingQueue实现公平锁 常见队列顺序队列代码特点： 队列需要两个指针：头指针head，指向队头；尾tail，指向队尾 当进行入队操作后，tail指针右移 当进行出队操作后，head指针右移 12345678910111213141516171819202122232425262728293031// 用数组实现的队列public class ArrayQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head表示队头下标，tail表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为capacity的数组 public ArrayQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125;// 入队 public boolean enqueue(String item) &#123; // 如果tail == n 表示队列已经满了 if (tail == n) return false; items[tail] = item; ++tail; return true; &#125; // 出队 public String dequeue() &#123; // 如果head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; ++head;s return ret; &#125;&#125; 如果tail==n时，则无法继续往队列中加数据，但很有可能队列前面还有空间，所以，需要触发一次搬移操作，此时修改enqueue()操作 1234567891011121314151617public boolean enqueue(String item) &#123; // tail == n表示队列末尾没有空间了 if (tail == n) &#123; // tail ==n &amp;&amp; head==0，表示整个队列都占满了 if (head == 0) return false; // 数据搬移 for (int i = head; i &lt; tail; ++i) &#123; items[i-head] = items[i]; &#125; // 搬移完之后重新更新head和tail tail -= head; head = 0; &#125; items[tail] = item; ++tail; return true;&#125; 基础链表的队列实现要想实现基于链表的队列 需要两个指针，head指针和tail指针 入队：tail-&gt;next = new_node,tail = tail-&gt;next 出队：head = head-&gt;next如图 循环队列当tail==n时，前面做法时通过数据搬移来解决，为了避免使用数据搬移，可以使用循环队列，即tail==n时，让它变为tail=0,而不是+1 若要实现循环队列，必须考虑两种情况 队列空：一般判断条件是tail==head 队列满：一般判断条件是tail==n 对于队列空，依旧可以使用tail==head来判断，但对于队列满，tail==n已经不适用了，而是有这样一条规律： 1(tail+1)%n=head 实现代码为 1234567891011121314151617// 入队public boolean enqueue(String item) &#123; // 队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true;&#125;// 出队public String dequeue() &#123; // 如果head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; head = (head + 1) % n; return ret; &#125;&#125; 阻塞队列阻塞队列其实就是在队列基础上加了阻塞操作 队列空时，从对头取数据会被阻塞，知道队列中有了数据才能返回 队列满，插入如数据操作会被阻塞，知道队列有空闲位置再插入数据，然后返回 (典型的生产者-消费者模型) 并发队列并发队列即线程安全的队列 最简单实现方式是直接再enqueue()、dequeue()上枷锁，锁力度大，并发度低 队列相关应用线程池没有空闲线程时，如何处理新的请求线程资源线程池底部数据结构，就是使用了队列 一般解决使用两种策略 非阻塞式：直接拒绝任务请求 阻塞式：将请求排队，等到有空闲线程时，取出排队的请求继续处理 如何来设计存储请求排队？ 第一种：基于链表实现队列，可无限制排队，对响应时间敏感的系统不合适 第二种：基于数组实现队列，比较适合对响应时间敏感的系统，但对队列的大小设计有一定要求 跳表（Skip list）什么是跳表？ 链表的改造，可以实现类似于二分查找的算法 (Redis中的有序集合（Sorted Set）就是用跳表来实现的) 核心思想： 对链表建立“索引” 如，每两个结点提取一个结点到上一级，把抽出来的那一级叫作索引或索引层(当然，可以每n个结点取一个结点，这样可以节省额外空间，不过当存储的对象值比索引大的多少，可以忽略占用额外空间) 结点存在next结点指向下一个结点，down结点指向下一级结点 跳表查找算法 有数据x，首先查询最顶级索引结点y 如果Node[y] &lt; x，再查询next结点z 如果Node[z] &gt; x, 说明该值再[y,z]之间，然后找到y的down结点 重复1-3 如果 Node[y] &gt; x,则表明x不存在(已经是最小的了) 每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是n/2，第二级索引的结点个数大约就是n/4，第三级索引的结点个数大约就是n/8，依次类推，也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那第k级索引结点的个数就是n/(2k)。 假设索引有h级，最高级的索引有2个结点。通过上面的公式，我们可以得到n/(2h)=2，从而求得h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历m个结点，那在跳表中查询一个数据的时间复杂度就是O(m*logn)。 空间复杂度分析 空间复杂度为O(n),非原地排序算法 稳定性分析 是一种数据结构，不存在稳定性 时间复杂度分析 最好情况,时间复杂度O(logn) 最坏情况,时间复杂度O(logn) 平均时间复杂度O(logn) 时间复杂度分析 每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是n/2，第二级索引的结点个数大约就是n/4，第k级的个数就是n/(2k) 假设索引的k级最高级结点数为2，则n/(2k) = 2-&gt; k= logn-1 对于每一层，需要遍历m个结点，那么时间复杂度即为O(m*logn) 因为我们使用的是每两个结点取一个索引，所以，最多也就需要遍历3个结点(y、z以及它们中间的结点)，即m &lt;=3,则整个的时间复杂度为O(logn) 跳表插入删除跳表的插入和删除，只需要通过查找找到位置，然后进行O(1)的插入/删除操作即可，所以时间复杂度为O(logn) 跳表索引动态更新当不停地往跳表中插入数据时，如果不更新索引，就有可能出现某2个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。 跳表通过随机函数来维护“平衡性”,比如随机函数生成了值K，就将这个结点添加到第一级到第K级这K级索引中 跳表示例代码跳表的实现较为复杂，可以查看Redis中关于有序集合的跳表实现。 散列表(HashTable)什么是散列表? key-value形式存储数据 通过散列函数将key转换成value(Hash值) 散列函数把元素的key映射为下标，然后将value存储在数组中对应下标的位置 散列函数散列函数设计的基本要求： 散列函数计算得到的散列值是一个非负整数 如果key1 = key2，那hash(key1) == hash(key2) 如果key1 ≠ key2，那hash(key1) ≠ hash(key2)（不可能实现，无法避免散列冲突） 散列冲突所谓的散列冲突，指的是在同key的情况下，获取到相同的Hash值，并且这是不可避免的。常用的散列冲突解决方法有两类 开放寻址法（open addressing） 链表法（chaining） 其他如平方取中法、折叠法、随机数法 装载因子：用装载因子（load factor）来表示空位的多少 散列表的装载因子=填入表中的元素个数/散列表的长度 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降 开放寻址法核心思想： 出现了散列冲突，就重新探测一个空闲位置，将其插入 线性探测（Linear Probing） 插入：当存储位置被占用，从当前位置开始依次查找，直到找到空闲位置 删除：对于删除一个数据，特殊标记为deleted（为了防止本来应该存在的数据，因为删除后有了空闲位置而不继续查找） 查找：从当前位置开始依次查找，知道空闲位置说明不存在，如果遇到deleted标记，继续向下查找 二次探测（Quadratic probing) 与线性探测类似 区别是线性探测每次探测的步长是1，探测的下标序列就是hash(key)+0，hash(key)+1，hash(key)+2； 而二次探测探测的步长就变成了原来的“二次方”，探测的下标序列就是hash(key)+0，hash(key)+1²，hash(key)+2² 双重散列（Double hashing） 使用一组散列函数hash1(key)，hash2(key)，hash3(key) 第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。 链表法核心思想： 在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中 插入：通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可（O(n)） 查找、删除：通过散列函数计算出对应的槽，然后遍历链表查找或者删除（O(k),k为链表长度） 如何设计散列函数需要考虑的因素有：关键字长度、特点、分布、散列表大小等。 扩容装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。 解决办法： 对于没有频繁插入和删除的静态数据集合（即数据已知），完全可以根据数据特点等设计出散列函数 对于动态散列表，数据集合频繁变动，当装载因子达到一定程度时，需要进行扩容 选择合适的冲突解决办法散列表与链表的结合使用树（Tree）数的基本概念关于“树”，有三个概念：高度（Height）、深度（Depth）、层（Level） 名称 描述 节点 树中的每个元素称为节点 父节点 指向子节点的节点 子节点 被父节点指向的节点 根节点 没有父节点的节点 叶子节点 没有子节点的节点 兄弟节点 具有相同父节点的多个节点称为兄弟节点关系 节点的高度 节点到叶子节点的最长路径（边数） 节点的深度 根节点到节点的路径所经历的边的个数 二叉树基础（Binary Tree）所谓的二叉树，即树有两个节点，分别为左子节点和右子节点。二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点 完全二叉树完全二叉树的特征为： 叶子节点都在最底下两层 最后一层的叶子节点都靠左排列 并且除了最后一层，其他层的节点个数都要达到最大 满二叉树满二叉树特征更为明显，它除了叶子节点之外，每个节点都有左右两个子节点 二叉树的存储有两种方法 基于指针或者引用的二叉链式存储法 基于数组的顺序存储法。 链式存储法核心思想： 每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针 顺序存储法核心思想 把根节点存储在下标1的位置(设为1为根节点，方便计算) 如果节点为i,其左子节点存储在下标2 * i的位置 如果节点为i,其右子节点存储在2 * i 的位置 存储非完全二叉树 存储完全二叉树 两种存储法对比从内存来说，如果存储的是完全二叉树的话，使用顺序存储法不会浪费空间（仅浪费下标为0的存储位置），而链式存储法需要存储额外的左右子节点的指针。但对于非完全二叉树来说，顺序存储法会浪费比较多的数组存储空间 二叉树的遍历二叉树遍历有三种经典的方法 前序遍历（对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。） 中序遍历（对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。） 后序遍历（对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。） 实际上，二叉树的前、中、后序遍历就是一个递归的过程 遍历代码示例 12345678910111213141516171819void preOrder(Node root) &#123; if (root == null) return; print root // 此处为伪代码，表示打印root节点 preOrder(root-&gt;left); preOrder(root-&gt;right);&#125;void inOrder(Node root) &#123; if (root == null) return; inOrder(root-&gt;left); print root // 此处为伪代码，表示打印root节点 inOrder(root-&gt;right);&#125;void postOrder(Node* root) &#123; if (root == null) return; postOrder(root-&gt;left); postOrder(root-&gt;right); print root // 此处为伪代码，表示打印root节点&#125; 二叉查找树特点 支持动态数据集合的快速插入、删除、查找操作 在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值 二叉查找树的查找操作核心思想 先取根节点，如果它等于我们要查找的数据，那就返回 如果要查找的数据比根节点的值小，那就在左子树中递归查找 如果要查找的数据比根节点的值大，那就在右子树中递归查找 示例代码 1234567891011121314151617181920public class BinarySearchTree &#123; private Node tree; public Node find(int data) &#123; Node p = tree; while (p != null) &#123; if (data &lt; p.data) p = p.left; else if (data &gt; p.data) p = p.right; else return p; &#125; return null; &#125; public static class Node &#123; private int data; private Node left; private Node right; public Node(int data) &#123; this.data = data; &#125; &#125;&#125; 二叉查找树的插入操作核心思想 类似查找操作 从根节点开始 如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置 如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置 示例代码 123456789101112131415161718192021222324public class demo &#123; public void insert(int data) &#123; if (tree == null) &#123; tree = new Node(data); return; &#125; Node p = tree; while (p != null) &#123; if (data &gt; p.data) &#123; if (p.right == null) &#123; p.right = new Node(data); return; &#125; p = p.right; &#125; else &#123; // data &lt; p.data if (p.left == null) &#123; p.left = new Node(data); return; &#125; p = p.left; &#125; &#125; &#125;&#125; 二叉查找树的删除操作较为复杂，需要分三种情况处理 如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null(如图删除节点55) 如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。（如图删除节点13） 如果要删除的节点有两个子节点,需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了）（如图删除节点18） 示例代码 123456789101112131415161718192021222324252627282930public void delete(int data) &#123; Node p = tree; // p指向要删除的节点，初始化指向根节点 Node pp = null; // pp记录的是p的父节点 while (p != null &amp;&amp; p.data != data) &#123; pp = p; if (data &gt; p.data) p = p.right; else p = p.left; &#125; if (p == null) return; // 没有找到 // 要删除的节点有两个子节点 if (p.left != null &amp;&amp; p.right != null) &#123; // 查找右子树中最小节点 Node minP = p.right; Node minPP = p; // minPP表示minP的父节点 while (minP.left != null) &#123; minPP = minP; minP = minP.left; &#125; p.data = minP.data; // 将minP的数据替换到p中 p = minP; // 下面就变成了删除minP了 pp = minPP; &#125; // 删除节点是叶子节点或者仅有一个子节点 Node child; // p的子节点 if (p.left != null) child = p.left; else if (p.right != null) child = p.right; else child = null; if (pp == null) tree = child; // 删除的是根节点 else if (pp.left == p) pp.left = child; else pp.right = child;&#125; 二叉查找树的时间复杂度无论是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，在较为想的情况下，树的高度为log2(n),则此时复杂度为O(logn)。当根节点的左右子树即为不平衡时，二叉查找树会退化成链表，时间复杂度变为O(n) 支持重复数据的二叉查找树方法一：二叉查找树中每一个节点不仅会存储一个数据，通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。 方法二：（更优雅）每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理 查找操作遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。 删除操作需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除 平衡二叉查找树平衡二叉查找树，是为了解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。（即尽量让树保存左右平衡，防止链表化） 平衡二叉查找树核心思想 二叉树中任意一个节点的左右子树的高度相差不能大于1 （完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树） 平衡二叉树的种类 AVL树(严格符合平衡二叉查找树的定义) Splay Tree（伸展树） Treap（树堆) 红黑树(使用最多，非严格符合平衡二叉查找树的定义) 红黑树红黑树，英文名Reb-Black Tree或R-B Tree，是一种不严格的平衡二叉查找树,它的特征如下 红黑树中的节点，一类被标记为黑色，一类被标记为红色。根节点是黑色的； 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据； 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的； 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点； 红黑树的近似平衡红黑树的近似平衡，可以分析比较红黑树的高度是否稳定地趋近log2(n)即可 如果将红色节点从红黑树中去掉，这些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树.而这样的四叉树，其高度肯定要小于拥有相同节点数的完全二叉树，也就是高度不会超过log2(n) 如果加入一个红色节点，因为红色节点不能相邻，且规定每个叶子节点都是黑色的空节点，所以事实上有一个红色节点必然有一个黑色子节点，但这样其高度也不会超过2log2(n),也就是红黑树的高度仅仅比AVL树高了一倍，性能下降并不多（更何况实际上红黑树的性能不仅没降低反而更好） 左右旋实际上，在插入、删除节点的过程中，红黑树的第三、第四点核心思想可能会被破坏，所谓的“平衡调整 ”，实际上就是要把被破坏的第三、第四点恢复过来 首先必须掌握两个重要的操作 左旋 右旋 可以看出，无论左旋还是右旋，都会将y提升为x的父节点，且x会继承y的子节点 插入操作，特殊情况的平衡调整红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上 对于特殊情况，操作比较简单 如果插入节点的父节点是黑色的，什么都不用做，它仍然满足红黑树的定义。 如果插入的节点是根节点，直接改变它的颜色，把它变成黑色就可以了 插入操作，其他情况的平衡调整其他情况，需要两种基础的操作 左右旋转 改变颜色 红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫作关注节点。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点 新节点插入之后，如果红黑树的平衡被打破，一般会有下面三种情况，根据不同情况，需要进行不同的调整 CASE 1：如果关注节点是a，它的叔叔节点d是红色 将关注节点a的父节点b、叔叔节点d的颜色都设置成黑色； 将关注节点a的祖父节点c的颜色设置成红色； 关注节点变成a的祖父节点c； 跳到CASE 2或者CASE 3。 CASE 2：如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的右子节点 关注节点变成节点a的父节点b； 围绕新的关注节点 b左旋； 跳到CASE 3。 CASE 3 ：如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的左子节点 围绕关注节点a的祖父节点c右旋； 将关注节点a的父节点b、兄弟节点c的颜色互换。 调整结束。 删除操作的平衡调整删除操作的平衡调整分为两步 第一步是针对删除节点初步调整。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求都包含相同数目的黑色节点； 第二步是针对关注节点进行二次调整，使其满足红黑树的第三条定义 第一次调整CASE 1：如果要删除的节点是a，它只有一个子节点b，就依次进行下面的操作： 删除节点a，并且把节点b替换到节点a的位置，这一部分操作跟普通的二叉查找树的删除操作一样； 节点a只能是黑色，节点b也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点b改为黑色； 调整结束，不需要进行二次调整 CASE 2：如果要删除的节点a有两个非空子节点，并且它的后继节点就是节点a的右子节点c。就依次进行下面的操作： 如果节点a的后继节点就是右子节点c，那右子节点c肯定没有左子树。我们把节点a删除，并且将节点c替换到节点a的位置。这一部分操作跟普通的二叉查找树的删除操作无异； 然后把节点c的颜色设置为跟节点a相同的颜色； 如果节点c是黑色，为了不违反红黑树的最后一条定义，我们给节点c的右子节点d多加一个黑色，这个时候节点d就成了“红-黑”或者“黑-黑”； 这个时候，关注节点变成了节点d，第二步的调整操作就会针对关注节点来做 CASE 3：如果要删除的是节点a，它有两个非空子节点，并且节点a的后继节点不是右子节点，我们就依次进行下面的操作： 找到后继节点d，并将它删除，删除后继节点d的过程参照CASE 1； 将节点a替换成后继节点d 把节点d的颜色设置为跟节点a相同的颜色； 如果节点d是黑色，为了不违反红黑树的最后一条定义，我们给节点d的右子节点c多加一个黑色，这个时候节点c就成了“红-黑”或者“黑-黑”； 这个时候，关注节点变成了节点c，第二步的调整操作就会针对关注节点来做 第二次调整CASE 1：如果关注节点是a，它的兄弟节点c是红色的，我们就依次进行下面的操作： 围绕关注节点a的父节点b左旋； 关注节点a的父节点b和祖父节点c交换颜色； 关注节点不变； 继续从四种情况中选择适合的规则来调整 CASE 2：如果关注节点是a，它的兄弟节点c是黑色的，并且节点c的左右子节点d、e都是黑色的，我们就依次进行下面的操作： 将关注节点a的兄弟节点c的颜色变成红色； 从关注节点a中去掉一个黑色，这个时候节点a就是单纯的红色或者黑色； 给关注节点a的父节点b添加一个黑色，这个时候节点b就变成了“红-黑”或者“黑-黑”； 关注节点从a变成其父节点b； 继续从四种情况中选择符合的规则来调整 CASE 3：如果关注节点是a，它的兄弟节点c是黑色，c的左子节点d是红色，c的右子节点e是黑色，我们就依次进行下面的操作： 围绕关注节点a的兄弟节点c右旋； 节点c和节点d交换颜色； 关注节点不变； 跳转到CASE 4，继续调整 CASE 4：如果关注节点a的兄弟节点c是黑色的，并且c的右子节点是红色的，我们就依次进行下面的操作： 围绕关注节点a的父节点b左旋； 将关注节点a的兄弟节点c的颜色，跟关注节点a的父节点b设置成相同的颜色； 将关注节点a的父节点b的颜色设置为黑色； 从关注节点a中去掉一个黑色，节点a就变成了单纯的红色或者黑色； 将关注节点a的叔叔节点e设置为黑色； 调整结束 递归树B+树MySQL底层使用的是B+ Tree数据结构，而该数据结构，需要满足以下需求 根据某个值查找数据，比如select * from user where id=1234； 根据区间值来查找某些数据，比如select * from user where id &gt; 1234 and id &lt; 2345 支持快速查询、插入等操作 综合以上需求来分析，我们来看一下较为合适的数据结构散列表、平衡二叉查找树、跳表 散列表：查询性能很好，时间复杂度是O(1)；但散列表不能支持按照区间快速查找数据 平衡二叉查找树：查询的性能也很高，时间复杂度是O(logn)，同样不支持按照区间快速查找数据 跳表：支持快速地插入、查找、删除数据，对应的时间复杂度是O(logn)，并且支持区间快速地查找数据 跳表显然是可以解决这个问题，但MySQL使用的B+树，虽然与跳表类似，但是通过改造平衡二叉查找树演化而来的 平衡二叉树到B+ 树改造如下 树中的节点并不存储数据本身，而是只是作为索引 把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的 如下图插入7的话，会插入到6-10之间，会导致10节点有3个字节点，必须进行索引调整(调整方法稍后看到) 如果要求某个区间的值只需要拿区间的起始值，在树中进行查找），当查找到某个叶子节点之后（如查找到少于这个区间的叶子节点，再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。 不过，如此设计，必定会占用太多内存。比方说有1亿数据，每个节点占16字节，那么就是差不多1G的空间占用。解决如此大的空间问题，思路是：内存速度为纳秒级别，但容量小。而硬盘容量大，但速度为毫秒级别。，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘IO操作。树的高度就等于每次查询数据时磁盘IO操作的次数，所以，优化重点是利用硬盘存储节点，并尽量减少IO次数，即减少树的高度。 如何减少树的高度: 从二叉树到M叉树,如下图，16个数据二叉树高度为4，而五叉树高度为2 不难发现，对于相同个数的数据构建m叉树索引，m叉树中的m越大，那树的高度就越小。那么，M该如何取值？不管是内存中的数据，还是磁盘中的数据，操作系统都是按页来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次IO操作。所以，我们在选择m大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘IO操作。 12# linux 获取内存页大小，一般都是4Kgetconf PAGE_SIZE 插入数据往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过m（m值是提前计算号的），这个节点的大小超过了一个页的大小，一旦超过，那必然会进行多次IO了；所以，必须保证该树是个M叉树，必须进行索引调整(会导致导致写入速度降低) 调整思路:将这个节点分裂成两个节点。但是，节点分裂之后，如果上层父节点的子节点个数就有可能超过m个,将父节点也分裂成两个节点，如下图，图中的B+树是一个三叉树。我们限定叶子节点中，数据的个数超过2个就分裂节点；非叶子节点中，子节点的个数超过3个就分裂节点(注意B+树中链表顺序是由大到小，一旦超出就需要进行索引调整) - 删除数据同样的，删除数据也需要重新调整索引，因为频繁的数据删除，就会导致某些结点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率 调整思路：设置一个阈值 在B+树中，这个阈值等于m/2 如果某个节点的子节点个数小于m/2，将它跟相邻的兄弟节点合并 如果合并之后结点的子节点个数超过m，就使用插入时的调整方法，分裂节点 - 堆（Heap）图（Graph）]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataStructure]]></title>
    <url>%2Fblog%2F2018%2F02%2F16%2FAlgorithm.all%2F</url>
    <content type="text"><![CDATA[递归递归满足的三个条件当面满足以下三个条件时，可以考虑使用递归 一个问题的解可以分解为几个子问题的解 .这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 具体递归写法为 分析出递推公式 找出终止条件 整合翻译成代码 递归警惕事项堆栈溢出递归的缺点很明显，就是空间复杂度高，容易出现堆栈溢出 1java.lang.StackOverFlowError 函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险 所以，对于高深度的代码，这种方法并不实用。深度较小时使用较适宜 重复计算拿f(n) = f(n-1) + f(n-2)为例 假设n = 6,那么计算过程为 f(6) = f(5) + f(4) f(5)=f(4) + f(3)=f(3) + f(2) + f(2) + f(1)… f(4) = f(3) + f(2)= f(2) + f(1) + f(2) 可以发现，f(3)重复计算了多次,为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的f(k) 1234567891011public int f(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; // hasSolvedList可以理解成一个Map，key是n，value是f(n) if (hasSolvedList.containsKey(n)) &#123; return hasSovledList.get(n); &#125; int ret = f(n-1) + f(n-2); hasSovledList.put(n, ret); return ret;&#125; 递归相关问题及应用走步问题问题描述：有n个台阶，你可以每次走一步到两步，问有几种走法 根据递归满足的三个条件分析 分解：完全可以分解为接下来走一步还是走两步,即f(n) = f(n-1) + f(n-2)[ 走一步和走两步的情况 ] 子问题：假设走完一步后，依旧是f(n-1) = f(n-2) + f(n-3),除了规模求解思路一致 存在递归终止条件,即当n=1或者n=2时，停止运算 那么利用递归就可以得到 12345678910int f(int n)&#123; if(n == 1) return 1; if(n == 2) return 2; return f(n-1) + f(n-2)&#125;//验证下,n = 3的时候return f(2) + f(1) //renturn 3,正确//n = 4return f(3) + f(2) // = 2f(2) + f(1) = 5,正确 二分查找又被称为折半查找算法 核心思想 每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。 二分查找应用场景的局限性 二分查找依赖的是顺序表结构，简单点说就是数组 二分查找针对的是有序数 二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用 要处理的数据量很小，完全没有必要用二分查找,直接遍历即可 数据之间的比较操作非常耗时，不管数据量大小，推荐使用二分查找(二分查找比较次数大大减少) 数据量太大也不适合二分查找(二分查找依赖数组，且必须是连续空间) 二分查找示例代码算法步骤 令L为0,R为n-1。 如果L&gt;R，则搜索以失败告终。 m（中间值元素）为(L+R)/2。（具体实现中，为防止算术溢出，一般采用L+(R-L)/2代替。） 如果A[m]&lt;T，令L为m+1,并回到步骤二。（T表示需要查找的值） 如果A[m]&gt;T, 令R为m-1并回到步骤二。 当A[m]=T, 搜索结束；回传值m 递归实现：123456789101112public static int binarySearch(int[] arr, int start, int end, int hkey)&#123; if (start &gt; end) return -1; int mid = start + (end - start)/2; //防止溢位 if (arr[mid] &gt; hkey) return binarySearch(arr, start, mid - 1, hkey); if (arr[mid] &lt; hkey) return binarySearch(arr, mid + 1, end, hkey); return mid; &#125; 循环实现1234567891011121314151617181920```Javapublic static int binarySearch(int[] arr, int start, int end, int hkey)&#123; int result = -1; while (start &lt;= end)&#123; int mid = start + (end - start)/2; //防止溢位 if (arr[mid] &gt; hkey) end = mid - 1; else if (arr[mid] &lt; hkey) start = mid + 1; else &#123; result = mid ; break; &#125; &#125; return result;&#125; 二分查找性能分析空间复杂度分析 迭代: O(1) 递归：O(log n) 稳定性分析 不涉及交换，稳定 时间复杂度分析 最好情况,时间复杂度O(1) 最坏情况,时间复杂度O(logn) 平均时间复杂度,O(logn) 冒泡排序(Bubble Sort)核心思想 重复地走访过要排序的数列，一次比较两个元素，如果顺序错误就进行交换 优化： 可以通过一个flag标志进行优化，当没有数据交换时，说明可以提前结束了 冒泡排序示例代码算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 1234function bubbleSort(a[], n) for i ∈ [0, n) do for j ∈ [0,n-i-1) do compare a[j] with a[j+1] and a[j] &lt;-&gt; a[j+1] 冒泡排序性能分析空间复杂度分析 空间复杂度为O(1),原地排序算法 稳定性分析 稳定的排序算法 时间复杂度分析 最好情况,时间复杂度O(n) 最坏情况,时间复杂度O(n²) 平均时间复杂度O(n²) 插入排序（Insertion Sort）核心思想： 将数组分为两个区间，已排序区间和未排区间 已排序区间初始只有数组的第一个元素，其余为未排序区间 核从未排序区间取元素，然后从已排序区间插入，保证已排序区间一直有序，直到未排序区间元素为空 在实现上，通常采用in-place排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 插入排序示例代码算法描述 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描(为了保证稳定性) 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 1234567891011function insertionSort(a[], n) for i ∈ [1, n) do for j := i -1 to 0 do compare a[j] with a[i] and a[j+1] &lt;- a[j] end for a[j+1] &lt;- value end for 插入排序性能分析空间复杂度分析 为O(1), 原地排序算法 (从过程可以看出，无需额外空间) 稳定性分析 稳定的排序算法 时间复杂度分析 最好情况,时间复杂度O(n) 最坏情况,时间复杂度O(n²) 平均时间复杂度(O(n²)) 为什么插入排序比冒泡排序更受欢迎首先，两种排序都是O(n²)的时间复杂度，原地排序算法,且交换次数都是原属数据的逆序度 但是，它们的是现实，存在差异 12345678910111213//冒泡排序中数据的移动操作if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true;&#125;//插入排序中数据的移动操作：if (a[j] &gt; value) &#123; a[j+1] = a[j]; // 数据移动&#125; else &#123;break;&#125; 可以看出，冒泡排序狡猾需要3个赋值操作，而插入排序只需要一个；也就是说，排入排序执行赋值操作只需要冒泡排序的1/3时间 选择排序特点: 将数组分为两个区间，已排序区间和未排区间 已排序区间初始没有元素，数组全为未排序区间 核心思想为从未排序区间取最小元素，然后将其放到已经排序的末尾，保证已排序区间一直有序，直到未排序区间元素为空 插入排序优化：希尔排序 选择排序示例代码算法步骤 一开始，所有数据都处于未排序区间C[i] 设定一个minIndex记录最小值坐标 如果元素小于C[minIndex],就将该元素的坐标赋值给minIndex 完成便利后将C[minIndex]与C[i]的值进行交换 123456789101112131415161718function selectionSort(a[], n) if n &lt;=1 return for i ∈ [0, n-1) do //最小位置 minIndex &lt;- i //遍历出最小值 for j ∈[i+1, n) do if a[j] &lt; a[minIndex] then minIndex = j end if end for //最小值放入尾部 a[i] &lt;-&gt; a[minIndex] end forend function 选择排序性能分析空间复杂度分析 O(1),原地排序算法 稳定性分析 不稳定 时间复杂度分析 最好情况,时间复杂度O(n) 最坏情况,时间复杂度O(n²) 平均时间复杂度,O(n²)归并排序 核心思想： 要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。 归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决,可用递归实现 使用递归来实现 归并排序示例代码递归法（Top-down） 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 迭代法（Bottom-up） 将序列每相邻两个数字进行归并操作，形成ceil(n/2)}个序列，排序后每个序列包含两/一个元素 若此时序列数不是1个则将上述序列再次归并，形成 ceil(n/4)} 个序列，每个序列包含四/三个元素 重复步骤2，直到所有元素排序完毕，即序列数为1 12345//p和r分别为数组起始位置和接属位置,q则为p和r的中间位置merge_sort(p...r)= &#123; merge_sort(merge_sort(p...q), merge_sort(q+1...r)) merge(a[p...q], a[q+1...r])&#125; 终止条件为: p &gt;= r 转换成代码1234567891011121314151617181920function merge_sort(a[], n) merge_sort_c(a[], 0, n-1)end function// p &lt;- 0, r &lt;- n-1function merge_sort_c(a[], p, r) // 递归终止条件 if p &gt;= r then return // 取p到r之间的中间位置q q = (p+r) / 2 //分治 a[p...q] &lt;- merge_sort_c(a[], p, q) a[q+1...r] &lt;- merge_sort_c(a[], q+1, r) //合并(合并时进行排序) merge(a[p...r], a[p...q], a[q+1...r])end function 归并排序的性能分析空间复杂度分析 空间复杂度为O(n),不是原地排序 稳定性分析 稳定排序 时间复杂度分析 最好情况,时间复杂度O(nlongn) 最坏情况,时间复杂度O(nlongn) 平均时间复杂度O(nlongn) (关于复杂度可参考：如何分析递归函数的复杂度) 快速排序核心思想 如果要排序数组下标从p到r之间的一组数据 首先选择p到r之间的任意一个数据作为pivot（分区点） 然后遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间 最后，根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1 快速排序示例代码算法步骤 从数列中挑出一个元素，称为“基准”（pivot）， 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 1234567891011function quick_sort(a[], n) quick_sort_c(a[], p, n-1)end fucntionfunction quick_sort_c(a[], p, r) if p &gt;= r then return // 随机选择一个元素作为pivot（一般情况下，可以选择p到r区间的最后一个元素），然后对A[p…r]分区，函数返回pivot的下标 q &lt;- partition(a[], p, r) quick_sort_c(a[], p, q-1) quick_sort_c(a[], q+1, r) 但是，为了实现原地排序算法，需要如下设计12345678910111213function partition(a[], p, r) pivot &lt;- a[r] i &lt;- p for j &lt;- p to r-1 do if a[j] &lt; pivot then a[i] &lt;-&gt; a[j] i &lt;= i+1 end if a[i] &lt;-&gt; a[r] return i 快速排序性能分析空间复杂度分析 空间复杂度为O(1),原地排序 稳定性分析 不稳定排序 时间复杂度分析 最好情况,时间复杂度O(nlongn) 最坏情况,时间复杂度O(n²) 平均时间复杂度O(nlongn) 桶排序（Bucket sort）核心思想: 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了 桶排序对要排序数据的要求 要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序 数据在各个桶之间的分布是比较均匀的 桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。 划分之后还是比较大的文件，可以继续划分 桶排序示例代码桶排序算法步骤 设置一个定量的数组当作空桶子。 寻访序列，并且把项目一个一个放到对应的桶子去。 对每个不是空的桶子进行排序。 从不是空的桶子里把项目再放回原来的序列中。 123456789101112// n为划分的桶数function bucket-sort(array, n) is//定义多个桶 buckets//数据插入对应的桶 for i = 0 to (length(array)-1) do insert array[i] into buckets//分别排序对应的桶 for i = 0 to n - 1 do next-sort(buckets[i])//整合 return the concatenation of buckets[0], ..., buckets[n-1] 桶排序性能分析空间复杂度分析 空间复杂度为O(n*k),非原地排序 稳定性分析 不确定,取决于桶内算法算法 时间复杂度分析 最好情况,时间复杂度O(n) 最坏情况,时间复杂度O(n*k) 平均时间复杂度O(n+k) 关于O(n)复杂度的分析: 讲n个数插入到桶内，需要O(n)时间复杂度 对每个桶进行排序，假设有m个桶，使用快排的话，复杂度就是O(n/mlog(n/m)) 整体复杂度就是O(n)+O(n/mlog(n/m))-&gt;O(n(1+1/m)*log(n/m)) 省略常数-&gt;O(nlog(n/m))-&gt; 当m接近n的时候，log是一个很小的数，省略，即得O(n)计数排序（Counting sort） 核心思想 使用一个额外的数组 C ，其中第i个元素是待排序数组A中值等于 i的元素的个数。 然后根据数组 C 来将 A中的元素排到正确的位置 计数排序对数据的要求： 计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序 计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。 计数排序示例代码算法步骤： 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将 C[i]减去1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 public static int[] countingSort(int[] A) &#123; int[] B = new int[A.length]; // 假设A中的数据a'有，0&lt;=a' &amp;&amp; a' &lt; k并且k=100 int k = 100; countingSort(A, B, k); return B; &#125; private static void countingSort(int[] A, int[] B, int k) &#123; int[] C = new int[k]; // 计数 for (int j = 0; j &lt; A.length; j++) &#123; int a = A[j]; C[a] += 1; &#125; Utils.print(C); // 求计数和 for (int i = 1; i &lt; k; i++) &#123; C[i] = C[i] + C[i - 1]; &#125; Utils.print(C); // 整理 for (int j = A.length - 1; j &gt;= 0; j--) &#123; int a = A[j]; B[C[a] - 1] = a; C[a] -= 1; &#125; &#125;&#125;//针对c数组的大小，优化过的计数排序public class CountSort&#123; public static void main(String []args)&#123; //排序的数组 int a[] = &#123;100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95&#125;; int b[] = countSort(a); for(int i : b)&#123; System.out.print(i + " "); &#125; System.out.println(); &#125; public static int[] countSort(int []a)&#123; int b[] = new int[a.length]; int max = a[0], min = a[0]; for(int i : a)&#123; if(i &gt; max)&#123; max = i; &#125; if(i &lt; min)&#123; min = i; &#125; &#125; //这里k的大小是要排序的数组中，元素大小的极值差+1 int k = max - min + 1; int c[] = new int[k]; for(int i = 0; i &lt; a.length; ++i)&#123; c[a[i]-min] += 1;//优化过的地方，减小了数组c的大小 &#125; for(int i = 1; i &lt; c.length; ++i)&#123; c[i] = c[i] + c[i-1]; &#125; for(int i = a.length-1; i &gt;= 0; --i)&#123; b[--c[a[i]-min]] = a[i];//按存取的方式取出c的元素 &#125; return b; &#125; 计数排序性能分析空间复杂度分析 空间复杂度为O(n),非原地排序 稳定性分析 稳定算法 时间复杂度分析 最好情况,时间复杂度O(n+k) 最坏情况,时间复杂度O(n+k) 平均时间复杂度O(n+k) 基数排序（Radix sort）核心思想 将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数 将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 基数排序代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243public class RadixSort&#123; public static void sort(int[] number, int d) //d表示最大的数有多少位 &#123; intk = 0; intn = 1; intm = 1; //控制键值排序依据在哪一位 int[][]temp = newint[10][number.length]; //数组的第一维表示可能的余数0-9 int[]order = newint[10]; //数组orderp[i]用来表示该位是i的数的个数 while(m &lt;= d) &#123; for(inti = 0; i &lt; number.length; i++) &#123; intlsd = ((number[i] / n) % 10); temp[lsd][order[lsd]] = number[i]; order[lsd]++; &#125; for(inti = 0; i &lt; 10; i++) &#123; if(order[i] != 0) for(intj = 0; j &lt; order[i]; j++) &#123; number[k] = temp[i][j]; k++; &#125; order[i] = 0; &#125; n *= 10; k = 0; m++; &#125; &#125; public static void main(String[] args) &#123; int[]data = &#123;73, 22, 93, 43, 55, 14, 28, 65, 39, 81, 33, 100&#125;; RadixSort.sort(data, 3); for(inti = 0; i &lt; data.length; i++) &#123; System.out.print(data[i] + ""); &#125; &#125;&#125; 基数排序性能分析空间复杂度分析 空间复杂度为O(n+k),非原地排序 稳定性分析 稳定算法 时间复杂度分析 最好情况,时间复杂度O(kn) 最坏情况,时间复杂度O(kn) 平均时间复杂度O(kn)]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos]]></title>
    <url>%2Fblog%2F2018%2F02%2F15%2FCentos.all%2F</url>
    <content type="text"><![CDATA[用户相关添加用户指令 1useradd [options] LOGIN 可选选项 选项 描述 u 指定uid g 指定主组 d 指定家目录 c 添加秒速信息 s 指定shell信息 G 指定附加组 示例 1useradd -u 1024 -g root -d /test_user/ -c &apos;test&apos; -s /bin/bash test_user 删除用户指令 1userdel [options] LOGIN 选项 选项 描述 r 删除主目录和邮件池 示例 1userdel -r famel 修改用户指令 1usermod [options] LOGIN 选项 选项 描述 修改用户密码指令 1passwd [-k] [-l] [-u [-f]] [-d] [-e] [-n mindays] [-x liisyudays] [-w warndays] [-i inactivedays] [-S] [--stdin] [username] 选项 选项 描述 stdin 允许接受参数作为密码(centos使用) 一次性修改密码方法 echo 123456 &amp;#124; passwd --stdin famel 示例 123456//修改root用户密码sudo passwd// 修改当前用户密码passwd // 修改指定用户密码passwd liisyu 查看用户信息指令 1id [OPTION]... [USER] 选项 选项 描述 示例 12//查看指定用户信息id liisyu 查看所有用户登录情况指令 1who [OPTION]... [ FILE | ARG1 ARG2 ] 示例 12//查看所有用户登录信息who 查看当前用户登录情况指令 1tty 示例 12//查看当前用户登录情况tty 查看当前用户名指令 1whoami 示例 12//查看当前用户名whoami 切换用户指令 1su [options...] [-] [user [args...]] 示例 12//切换用户su - liisyu 退出用户指令 1exit 模拟用户的创建过程第一步：添加新用户信息 1234vim /etc/passwd//加入以下信息liisyu:x:1024:1024:liisyu,,,:/home/liisyu:/bin/bash 第二步：为新用户添加家目录 1mkdir /home/liisyu 第三步：为新用户添加密码 1234vim /etc/shadow//加入以下信息liisyu:*:17855:0:99999:7::: 第四步：为新用户添加主组 1234vim /etc/group//加入以下信息liisyu:x:1024: 第五步：为组添加组密码 1234vim /etc/gshadow//加入以下信息liisyu:!:: 第六步：为用户创建邮箱 1touch /var/spool/mail/liisyu 第七步： 为创建的邮箱未见属主和属组改为liisyu 1chown -R liisyu.liisyu /var/spool/mail/liisyu 第八步：把相关文件复制到家目录下 1cp /etc/skel/.[!.]* /home/liisyu 第九步：将复制的文件属主和属组改为liisyu’ 1chown -R liisyu.liisyu /home/liisyu 第十步：为用户加个密码 1passwd liisyu 组相关添加组指令 1groupadd [options] group 示例 1groupadd anewgroup 删除组指令 1groupdel [options] GROUP 示例 1groupdel anewgroup 修改组指令 1groupmod [options] GROUP 可选选项 选项 描述 n 修改组名 g 修改组id 示例 12345// 修改组名groupmod -n new_name old_name// 修改组idgrioupmod -g 1032 goup_1 权限相关权限相关概念 字母 描述 对于文件 对于目录 r 对应数字4，可读权限 能看内容 浏览目录下的子目录名，子文件名 w 对应数字2，可写权限 修改内容 创建，重命名，删除子目录名、子文件名 x 对应数字1，可执行权限 执行文件 可以cd切换进入 此外： 对于需要删除某一目录下的文件，需要wx权限 想要执行文件，需要rx权限 查看权限1234// 查看当前目录下文件的权限ll// 查看当前目录的权限ls -dl 权限分析12root@famel-virtual-machine:~# ls -dl /home/fameldrwxr-xr-x 16 famel famel 4096 11月 21 13:45 /home/famel 第一段：文件类型12345678910111213141516171819```-```，普通文件```l```，快捷方式```p```，管道文件```c```，字符设备```b```，磁盘文件第二段：```rwx```，属主的权限第三段：```r-x```，属组的权限第四段：```r-x```，除属主和属组之外的其他用户权限第五段：```famel```，属主第六段：```famel```，属组第七段：```4096```，已经占用大小## 修改权限指令 chmod [OPTION]1234567891011121314151617181920212223242526选项| 选项 | 描述 || ---- | -------- || u | 属主 || g | 属组 || o | 其他用户 |示例```java//将a.txt的rw权限赋给属主chmod u=rw a.txt//删除属组的read权限chmod g-r a.txt//属主权限rwx,属组权限rwx,其他用户权限rchmod 774 a.txt//修改多个，o=表示无任何权限chomd u=rw,g=rwx,o= a.txt//对当前目录下所有的文件夹权限开放chmod 777 * 为LINUX用户添加sudo操作权限第一步：进入root 1su - root 第二步:修改12345678``````javavim /etc/sudoers//找到该行## Allow root to run any commands anywhere root ALL=(ALL) ALL``` 第三步：添加 12345678//为单个用户添加sudo操作，需要输入密码liisyu ALL=(ALL) ALL//为单个用户添加sudo操作，不需要输入密码liisyu ALL=(ALL) NOPASSWD: ALL//为用户组添加sudo操作，需要输入密码%mygroup ALL=(ALL) ALL//为用户组添加sudo操作，不需要输入密码%mygroup ALL=(ALL) NOPASSWD: ALL 系统相关查看网络信息1netstat -tunalp 实时系统信息按1可以展开CPU 1234567891011121314151617top//输出如下top - 21:56:49 up(开机时间) 2:48（运行时间）, 3 users（使用人数）, load average: 0.00, 0.00, 0.00（平均负载：1分钟，5分钟，15分钟）Tasks（任务）: 157 total（当前任务）, 1 running（正在运行的任务）, 156 sleeping, 0 stopped（等待）,（暂停） 0 zombie（僵尸进程）Cpu(s): 0.0%us, 0.3%sy, 0.0%ni, 99.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%stMem（内存）: 1003020k total, 852632k used, 150388k free, 72608k buffersSwap: 2097148k total, 0k used, 2097148k free, 472880k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 19344 1572 1244 S 0.0 0.2 0:01.60 init 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 3 root RT 0 0 0 0 S 0.0 0.0 0:00.00 migration/0 4 root 20 0 0 0 0 S 0.0 0.0 0:00.00 ksoftirqd/0 5 root RT 0 0 0 0 S 0.0 0.0 0:00.00 stopper/0 6 root RT 0 0 0 0 S 0.0 0.0 0:00.01 watchdog/0 7 root 20 0 0 0 0 S 0.0 0.0 0:05.11 events/0 查看cpu信息12// cpu信息保存在/proc/cpuinfo文件中cat /proc/cpuinfo 查看指令路径指令 1which [options] [--] programname [...] 示例 12//查看ls指令的路径which ls 命令的执行过程以ls为例，解释命令是如何执行的 首先需知道，执行123452. 可以通过`which ls`来查看命令的路径```linux[root@famel Packages]# which lsalias ls=&apos;ls --color=auto&apos; /bin/ls 当执行ls命令时，该命令会传给shell shell会从PAHT环境变量查找 通过echo $PATH,可以查看环境变量的值 12[root@famel Packages]# echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin 在桌面模式执行时，会发现ls查看的文件有颜色，而/bin/ls没有颜色。此时再看which ls的查询信息alias ls=&#39;ls --color=auto&#39;: 别名，也就说当ls执行时，其实执行的是ls --color=auto也就是说ls真正等同于 /bin/ls --color=auto 别名12//执行`test`命令时,就相当于执行了`ll /dev`alias test='ll /dev' 关机1init 0 立即关机1shutdown -h now 重启1init 6 多用户终端切换1ctrl + alt + f1~f6(文本界面) \F7 (图形界面) 查看日期1date 查看日历1cal 年: 查看某年的日历，如cal 1990 月 年:查看某年的某月的日历,如cal 3 1998 帮助文档12指令 --helpman 指令 分页查看（上下）12//通过键盘上下键翻阅ls --help | less 百分比查看12//百分比查看信息,通过回车翻页ls --help | more 历史查看历史 1history 使用历史 1! 历史编号 查看系统内核信息 1234567uname -a//输出如下Linux famel-virtual-machine 主机名4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 时间 x86_64 x86_64 x86_64 GNU/Linux 目录相关事实上，LInux的思想是一切皆文件，所以应该把目录看出一个特殊的文件 目录结构 目录 描述 boot 启动相关 bin 常用指令相关 etc 配置文件相关 sbin 系统命令相关 media或mnt 挂载相关 home 家目录相关 dev 设备文件相关 进入目录12345678910//需要x权限cd /a/b//进入上级目录cd ..//进入上次所在的目录cd -//进入用户家目录cd ~//进入根目录cd / 添加目录指令 1mkdir 选项 选项 描述 p 递归添加目录 示例 12// 即使a，b目录不存在，也可以mkdir -p /a/b/c 删除目录需要wx权限 指令 1rm 选项 选项 描述 r 递归方式删除 f 无提示 示例 12//不推荐！！rm -rf /a/b 删除目录推荐做法12//将需要删除的目录移动到tmp文件夹，这样可以找回mv /a/b/ /tmp 重命名目录12// 同一目录下，即为重命名mv new_name 文件/目录 查看当前所在目录1pwd 查看目录指令 1ls 选项 选项 描述 d 列出目录本身，而不是查看它的内容 l 查看目录详细信息,可简写成ll a 查看当前目录所有内容(包括隐藏文件) 复制目录1cp from to 更改目录属主和属组1234//将/home/famel目录的属主和属组改为famelchown famel.famel /home/famel//-R：以递归方式操作文件和目录,将/home/famel 下所有的目录的属主和属组都改为famelchown -R famel.famel /home/famel 计算目录大小指令 1du 选项 描述 s 每个参数只显示一个总数 h 输出大小 示例 12//计算/a文件大小du -sh /a 文件相关新建文件1touch 文件名 修改文件名12//同目录下即为重命名mv new_name 文件 删除文件1rm 文件 复制文件1cp from to 查看文件内容查看文件内容1cat 文件 分页查看1less 文件 百分比查看1more 文件 查看文件开头1234//默认10行head 文件// 指定行数head -n 3 a.txt 查看文件尾部123456//默认10行tail// 指定行数tail -n 3 a.txt//文件内容追踪tail -F test.log 修改文件内容1234//覆盖方式改写文件echo 123456 a.txt//追加方式echo 123456 &gt;&gt; a.txt 系统文件详情介绍passwd文件用户信息文件，位于 /etc/passwd 以12345678910111213141516171819第一段：```famel```,用户名第二段：```x```,密码的占位符第三段：```1000```,uid第四段：```1000```,gid第五段：```Famel,,,```,用户描述信息第六段：```/home/famel```,用户家目录第七段：shell命令```/bin/bash```: 用户登录shell（可登录）```/sbin/nologin```: 用户不可登录（ftp可登录）```/bin/false```: 一切服务均不可登录，最严格### shadow文件(用户密码文件)文件，位于 `/ect/shadow` ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181121134744413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01BU09STA==,size_16,color_FFFFFF,t_70)以如下行为例```famel:$6$7Xe...:17855:0:99999:7::: 第一段：12第二段：```$6$7Xe...```,加密后的密码第三段：```17855 第四段：1第五段：```99999 第六段：1234567891011121314151617181920212223242526### group文件组文件，位于： `/etc/group`![在这里插入图片描述](https://img-blog.csdnimg.cn/20181121141006499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01BU09STA==,size_16,color_FFFFFF,t_70)以```famel:X:1000:```为例第一段：```famel```,组名第二段：```x```,组密码占位符第三段：```1000```,组id第四段：组员(famel 用户肯定在famel，所以这里是空的)，这里表示的是附加组### gshadow文件组密码文件,位于 `/etc/gshadow`![在这里插入图片描述](https://img-blog.csdnimg.cn/20181121141809870.png)# 归档/压缩归档指的是将多个文件组合成一个文件，而压缩则会将文件大小压缩为更小的文件## 归档指令 tar [OPTION…] [FILE]1234567891011121314151617181920212223选项| 选项 | 描述 || ---- | ------------------------ || c | 创建文件 || C | 指定解压位置 || f | 指定归档文件 || v | 显示信息 || t | 查看归档文件 || x | 解压归档文件 || z | 归档后使用`gzip`进行压缩 || j | 归档后使用bzip2进行压缩 |## 压缩指令```javagzip //gzip方式压缩,压缩时间短，压缩效率没bzip2好bzip2//bzip方式压缩,压缩时间久，压缩率高 注意：只能压缩单个文件，多个文件需进行归档 选项 选项 描述 d 解压缩 示例 1234//压缩a.txt.得到a.txt.gzgzip a.txt//压缩a.txt.得到a.txt.bz2bzip2 a.txt Vim编辑器用于编辑文，指令 1vim 文件 存在三个模式：命令行模式、编辑模式、扩展模式 命令行模式 键位 描述 a 进入编辑模式,光标会相对原处后移一位 i 进入编辑模式，光标不动 o 进入编辑模式，直接下一行，且新建成空行 O(大o) 光标跑到当前行头部 : 进入扩展模式 $ 光标跑到当前行尾部 dd 剪切当前行 ndd n为数字,如|12345678910111213141516171819202122232425262728293031323334353637| p | 粘贴剪切板内容到光标的下一行（通过dd和yy操作的内容） || P | 粘贴剪切板内容到光标的上一行（通过dd和yy操作的内容） || yy | 复制当前行 || nyy | n为数字,如```3yy```，表示从光标位置开始三行进行复制操作（包括光标位置的行） || u | 撤销操作 || ctrl+r | 重复操作 || G | 光标移动到最后一行 || nG | 光标移动到第n行，从1开始算 || gg | 光标移动到第一行，相当于1G || H | 跳到屏幕的开头 || M | 跳到屏幕的中间 || L | 跳到屏幕的结尾 || /+字符串 | 查找关键字 || n | 查找下一个，与查找关键字一起用 || N | 查找上一个，与查找关键字一起用 |## 编辑模式| 键位 | m描述 || ---- | -------------- || ESC | 进入命令行模式 |## 扩展模式| 键位模式 | 描述 || -------- | -------- || w | 保存 || q | 退出 || ！ | 强制操作 |# 磁盘相关## 查看I/O信息 iostat123456## 测试磁盘速度指令 dd12345678910111213141516171819202122选项| 选项 | 描述 || ----- | ------------ || if= | 读取文件 || of= | 写入文件 || bs= | 读写大小 || count | 执行读写次数 |示例```java//从/dev/sbd1读数据写到a.txt,大小为500M每次，次数为2次famel@famel-virtual-machine:~$ sudo dd if=/dev/sdb1 of=/a.txt bs=500M count=22+0 records in2+0 records out1048576000 bytes (1.0 GB, 1000 MiB) copied, 19.2122 s, 54.6 MB/s 查看磁盘信息指令 1df 选项 选项 描述 T 查看磁盘系统信息 h 查看磁盘大小和使用情况 i 查看磁盘inode相关信息 磁盘分区指令 1fdisk 选项 选项 描述 l 查看分区信息 示例 1234//为sdb这个磁盘进行分区fdisk /dev/sdb//查看sda的分区信息fdisk -l /dev/sda 磁盘分区信息解读part1: 123456//Disk /dev/sda：表明 /dev/sda是一个磁盘//25 GiB：磁盘大小为25GB//26843545600 bytes,磁盘大小字节为26843545600//52428800 sectors：有52428800 个扇区Disk /dev/sda: 25 GiB, 26843545600 bytes, 52428800 sectors part2: 12//每一个扇区单位是512字节Units: sectors of 1 * 512 = 512 bytes part3: 12//扇区大小(逻辑/物理):512字节/512字节Sector size (logical/physical): 512 bytes / 512 bytes part4: 12//I/O大小(最小/最佳):512字节/512字节I/O size (minimum/optimal): 512 bytes / 512 bytes part5: 12//磁盘标签类型:dos,dos的分区方式磁盘必须&lt; 2TDisklabel type: dos part6: 12//磁盘标识符:0x60356c74Disk identifier: 0x60356c74 part7: 123456//磁盘分区大小等Device Boot Start End Sectors Size Id Type/dev/sda1 * 2048 3999743 3997696 1.9G 82 Linux swap / Solaris/dev/sda2 4001790 52426751 48424962 23.1G 5 Extended/dev/sda5 4001792 4976639 974848 476M 83 Linux/dev/sda6 4978688 52426751 47448064 22.6G 83 Linux 格式化磁盘文件系统1234//格式化为ext4系统（日志文件系统(写数据，先缓存，再写入到硬盘)）mkfs.ext4 /dev/sdb1//格式化为xfs系统mkfs.xfs /dev/sdb1 分区操作磁盘主要分为 主分区：只能创建4个，且一旦创建了4个主分区后无法创建扩展分区（即使磁盘有剩余） 扩展分区:一般分完主分区后剩下的容量来创建扩展分区,创建完扩展分区后，可以创建数个逻辑分区（非无限制建，跟磁盘有关） 逻辑分区：对扩展分区再次分区就是逻辑分区 &emsp;&emsp; 磁盘分区操作第一步：执行命令fdisk /dev/sdb，进行分区操作 第二步：输入命令,如果不知道命令，可以输入m查看命令 可输入命令p,可查看分区表信息 可输入命令n,新建分区 0 primary, 0 extended,4free:表名该磁盘有0个主分区，0个扩展分区，可以创建4个主分区 第三步：输入p创建主分区,或输入l创建逻辑分区或输入e创建扩展分区 1234Partition number (1-4, default 1): 设置分区编号（默认1）First sector (2048-41943039, default 2048): 设置起始扇区（默认从2048开始）Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-41943039, default 41943039): +2G （设置扇区末尾，+2G表示2G大小的分区）Created a new partition 1 of type &apos;Linux&apos; and of size 2 GiB. 创建了一个2G大小的分区 第四步可选选项 输入q,退出分区操作且不保存 输入d.删除分区 1Partition number (1,2, default 2): 通过分区编号进行删除，输入p可以查看分区编号 输入w,保存分区操作 第五步：为磁盘添加挂载点 创建一个/sdb1文件夹 对/dev/sdb1进行格式化系统 挂载：mount /dev/sdb1 /sdb1 挂载点挂载点：磁盘的入口，对磁盘进行存储删除等操作的通道 指令 12345678//挂载mount 磁盘 挂载文件夹//卸载挂载点umount 磁盘//强制卸载挂载点umount -l 磁盘 内存查看内存信息指令 1free 选项 选项 描述 m 以兆为单位输出信息 k 以kb为单位输出信息 w 以宽屏的方式显示数据，此模式下buffer和cache会独立显示 信息解析tota:总内存used:已使用内存free: 剩余内存shared：共享内存buffer:内核缓冲区使用的内存(Buffers in /proc/meminfo),用于存放要写入disk(块设备)的数据cache:页面缓存和slabs使用的内存(Cached and Slab in /proc/meminfo)，用于存放从disk读出的数据avaliable:预计还可以使用的内存 swap分区启动swap分区指令 1swapon 选项 选项 描述 s 显示交换设备相关信息 a 激活swap分区 示例 12//假设sdb7已经制作成swap分区swapon -a /dev/sdb7 禁用swap分区指令 1swapoff 示例 12//禁用sdb7分区swapoff /dev/sdb7 制作swap分区指令 1mkswap 示例 12//将磁盘sdb7制作成swap分区mkswap /dev/sdb7 进程管理查找进程12//查找与mysql相关的进程ps aux | grep mysql 杀死进程1kill -9 pid 后台运行12//后台运行firefoxfirefox &amp; 查询后台运行进程1jobs 包管理相关安装二进制软件包指令 1rpm 选项 选项 描述 i 安装rpm包 v 显示详细信息 h 显示安装进度条 q 显示安装软件的信息 e 卸载安装的软件 YUMyum源位置：/etc/yum.repos.d/ 指令 1yum 选项 选项 描述 clean all 清除缓存，yum clean all -y install 安装软件包 -y earse 卸载软件包 -y makecache 建立缓存,提高装软件包速度（不用检索源） -y reinstall 重新覆盖安装 -y update 更新源 list 查看安装的软件 YUM回滚操作比如,安装了软件gitlab-ee 第一步：查看操作 1234567// 查看软件的yum操作sudo yum history list gitlab-ee//显示如下ID | Login user | Date and time | Action(s) | Altered-------------------------------------------------------------------------------5 | famelee &lt;famel&gt; | 2018-11-30 22:27 | Install | 1 ** 第二步：进行回滚(通过id) 1sudo yum history undo 5 注意：回滚操作会删除依赖 yum源文件位置：/etc/yum.repos.d/xxx.repo 12345name= :源名baseurl=：源URl本地：file:// + url,如file:///dev表示本地的/dev为源路径enable=1; 1表示开启yum源gpgcheck=0；不检测 yum 配置文件位置：/etc/yum.conf 123456789101112[main]cachedir=/var/cache/yum/$basearch/$releasever 缓存路径keepcache=0 1表示保存缓存debuglevel=2logfile=/var/log/yum.logexactarch=1obsoletes=1gpgcheck=1plugins=1installonly_limit=5bugtracker_url=http://bugs.centos.org/set_project.php?project_id=19&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yumdistroverpkg=centos-release]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2Fblog%2F2018%2F02%2F14%2FHexo.all%2F</url>
    <content type="text"><![CDATA[hexo官网文档 安装Hexo安装前提安装hexo前，还需还装Node.js和Git*两个程序 安装 Gitgit官网Linux (Ubuntu, Debian) 1sudo apt-get install git Linux (Fedora, Red Hat, CentOS) 1sudo yum install git 安装Node.jsNode.js官网安装Node.js,推荐使用nvm方式安装下载并安装nvmnvm github地址CURL方式 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash Wget方式 1wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 安装完成后,重新打开一个终端.开始安装Node.js 1nvm install stable 安装Hexo使用nmp命令进行安装 1npm install -g hexo-cli 建站建立博客站先初始化一个站，folder为自己填写的站名 1hexo init &lt;folder&gt; 完成后，在用户目录下，多出了一个以folder 为名的文件夹进入该文件夹 1cd &lt;folder&gt; 该文件夹下，有如下文件 文件名 描述 _config.yml 存有网站的配置信息，大部分配置都在这里修改 package.json 应用程序的信息 scaffolds 模版文件夹。当新建文章时，Hexo 会根据 scaffold 来建立文件 source 资源文件夹是存放用户资源的地方。开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 themes 主题 文件夹。Hexo 会根据主题来生成静态页面 安装相关依赖 1npm install 此时基本可以运行，首先生成静态文件 1hexo d 然后运行 1hexo s 运行正确的话，系统会输出 1Hexo is running at http://localhost:4000 在自己的浏览器打开访问,就可以浏览到一个什么都没有的博客了。 配置网站配置打开配置文件,接下来我将以blog为设置的站文件夹 1sudo vim ~/blog/_config.yml 配置网站,关键字Site 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York,Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址配置关键字，Url 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的永久链接格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 配置目录关键字，Directory 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 配置未完待续 更新博客文件1234# 进入博客文件文件夹cd ~/blog/source/_posts# 更新博客hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 挂载到Github安装依赖 1npm install hexo-deployer-git --save 修改站点配置文件仓库名必须是 famelsy.github.io 1234deploy: type: git repo : git@github.com:FameLsy/famelsy.github.io.git branch: master 个性化Hexo自定义CSS样式创建一个.styl文件 12# 内容就放css的内容即可vim ~/blog/themes/next/source/css/_custom/mystyle.styl 打开custom.styl文件，并将刚刚创建的.styl文件导入 12#输入@impolt &quot;mystyle.styl&quot;导入sudo vim ~/blog/themes/next/source/css/_custom/custom.styl 自定义JS代码首先,如果根目录没有scripts目录，就创建一个。然后，创建js文件 12# 直接创建并打开vim ~/blog/scripts/myjs.js hexo会自动加载该目录下的js文件 修改代码块首先,如果根目录没有scripts目录，就创建一个。然后，创建js文件 12# 直接创建并打开vim ~/blog/scripts/codeblock.js 复制以下内容进去 123456789101112131415161718192021var attributes = [ 'autocomplete="off"', 'autocorrect="off"', 'autocapitalize="off"', 'spellcheck="false"', 'contenteditable="true"']var attributesStr = attributes.join(' ')hexo.extend.filter.register('after_post_render', function (data) &#123; while (/&lt;figure class="highlight ([a-zA-Z]+)"&gt;.*?&lt;\/figure&gt;/.test(data.content)) &#123; data.content = data.content.replace(/&lt;figure class="highlight ([a-zA-Z]+)"&gt;.*?&lt;\/figure&gt;/, function () &#123; var language = RegExp.$1 || 'plain' var lastMatch = RegExp.lastMatch lastMatch = lastMatch.replace(/&lt;figure class="highlight /, '&lt;figure class="iseeu highlight /') return '&lt;div class="highlight-wrap"' + attributesStr + 'data-rel="' + language.toUpperCase() + '"&gt;' + lastMatch + '&lt;/div&gt;' &#125;) &#125; return data&#125;) 然后，创建一个.style文件 1vim ~/blog/themes/next/source/css/_custom/mystyle.styl 加入内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.highlight &#123; margin: 38px 0 0 0 !important;&#125;.highlight-wrap[data-rel] &#123; position: relative; overflow: hidden; border-radius: 5px; box-shadow: 0 10px 30px 0px rgba(0, 0, 0, 0.4); margin: 35px 0; ::-webkit-scrollbar &#123; height: 10px; &#125; ::-webkit-scrollbar-track &#123; -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3); border-radius: 10px; &#125; ::-webkit-scrollbar-thumb &#123; border-radius: 10px; -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.5); &#125; &amp;::before &#123; color: white; content: attr(data-rel); height: 38px; line-height: 38px; background: #21252b; color: #fff; font-size: 16px; position: absolute; top: 0; left: 0; width: 100%; font-family: 'Source Sans Pro', sans-serif; font-weight: bold; padding: 0px 80px; text-indent: 15px; float: left; &#125; &amp;::after &#123; content: ' '; position: absolute; -webkit-border-radius: 50%; border-radius: 50%; background: #fc625d; width: 12px; height: 12px; top: 0; left: 20px; margin-top: 13px; -webkit-box-shadow: 20px 0px #fdbc40, 40px 0px #35cd4b; box-shadow: 20px 0px #fdbc40, 40px 0px #35cd4b; z-index: 3; &#125;&#125; 打开custom.styl文件，并将刚刚创建的.styl文件导入 12#输入@import &quot;mystyle.styl&quot;导入sudo vim ~/blog/themes/next/source/css/_custom/custom.styl 主题下载next主题 1234 git clone https://github.com/theme-next/hexo-theme-next themes/next# 站点配置文件theme: next 不展开全部内容主题配置文件搜索关键字auto_excerpt,enable改为true 123auto_excerpt: enable: true length: 150 添加「标签/分类」页面新建页面 123cd ~/bloghexo new page tagshexo new page tags categories 编辑刚刚新建的页面 12vim source/tags/index.mdvim source/categories/index.md 添加 type: “tags” 12345678910---title: tagstype: &quot;tags&quot;date: 2018-12-20 21:00:02---# 对于分类页面就是title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;--- 修改主题配置文件 12345menu: home: / archives: /archives tags: /tags categories: /categories 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 以下所有终端执行的命令都在你的Hexo根目录下 基本信息配置打开 站点配置文件 ，找到Site模块 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 关于 站点配置文件 中的其他配置可参考站点配置 菜单设置菜单包括：首页、归档、分类、标签、关于等等 我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 主题配置文件 找到Menu Settings 看看你需要哪个菜单就把哪个取消注释打开就行了； 关于后面的格式，以archives: /archives/ || archive为例： || 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改 ||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 主题配置文件 找到Scheme Settings 12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 4种风格大同小异，本人用的是Gemini风格，你们可以选择自己喜欢的风格 侧栏设置开启侧边栏社交链接1234567891011# Social linkssocial: GitHub: https://github.com/hydcoder Weibo: https://weibo.com/3180967953/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo # 等等social_icons: enable: true # Icon Mappings. GitHub: github Weibo: weibo 开启打赏功能123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: 你的微信收款码链接alipay: 你的支付宝收款码链接 开启友情链接1234links_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 开启订阅微信公众号1234wechat_subscriber:enabled: trueqcode: /uploads/wechat-qcode.jpgdescription: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 头像设置打开 主题配置文件 找到Sidebar Avatar字段 12# Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 设置侧边栏设置圆形可旋转头像 找到生成的Hexo目录\themes\next\source\css_common\components\sidebar下的sidebar-author.styl，将里面的css样式内容全部替换为： 123456789101112131415161718192021222324252627282930313233.site-author-image &#123; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; transition: 1.4s all;&#125;.site-author-image:hover &#123; -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg);&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 设置首页不显示全文(只显示预览)打开主题配置文件_config.yml，ctrl + F搜索找到”auto_excerpt”，可以看见 12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt:enable: falselength: 150 把enable改为对应的false改为true，length就是预览显示的文字长度，你可以根据你的需要进行更改，然后重新部署，再进主页，你就发现你首页的文章多了一个阅读全文的按钮。 添加动态背景先上张图 打开生成的Hexo目录\themes\next/layout/_layout.swig文件，在 &lt; head&gt;中的添加代码 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，搜索canvas_nest，将其改成true 1canvas_nest: true 什么？线条太多了？没事，来看看怎么让线条变少点 在上一步修改的主题配置文件中，把刚才的那些代码改成下面这样： 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% e 配置项说明 color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 分类和标签设置这里主要说的是在编写文章的时候，怎么给文章设置标签和分类。 首先通过hexo n &quot;name&quot;命令来新建一个页面，在source/_posts目录下找到刚才新建的name.md文件，用Typora或者notepad++t打开(推荐Typora) 1234title: namedate: 2014-08-05 11:15:00 tags: --- 页面默认就是长这样的，可以编辑标题、日期、标签和内容，但是没有分类的选项。我们可以手动加入categories:项,但是下次创建新的页面的时候还是没有，所以我们直接打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，重新执行hexo n ‘name’命令，会发现新建的页面里有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 设置分类列表在我们编辑文章的时候，直接在categories:项填写属于哪个分类，但如果分类是中文的时候，路径也会包含中文。 比如分类我们设置的是： 1categories: 开车 那在生成页面后，分类列表就会出现开车这个选项，他的访问路径是： 1*/categories/开车 我们都知道，有时候中文路径可能会出现一些奇奇怪怪的问题，所以我们需要路径名和分类名分别设置。 打开站点配置文件_config.yml，找到如下位置做更改： 1234567# Category &amp; Tagdefault_category: uncategorizedcategory_map: 开车: drive 生活: life 其他: othertag_map: 在这里category_map:是设置分类的地方，每行一个分类，冒号前面是分类名称，后面是访问路径。可以提前在这里设置好一些分类，当编辑的文章填写了对应的分类名时，就会自动的按照对应的路径来访问。 设置标签在编辑文章的时候，tags:后面是设置标签的地方，如果有多个标签的话，可以用下面两种办法来设置： 第一种： 1tages: [标签1,标签2,...标签n] 第二种： 12345 tages: - 标签1- 标签2...- 标签n 添加文章更新时间修改（博客主目录）/themes/next/layout/_macro/post.swig 文件，在&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;标签后添加 12345678&#123;%if post.updated and post.updated &gt; post.date%&#125; &lt;span class=&quot;post-updated&quot;&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123; __(&apos;post.updated&apos;) &#125;&#125; &lt;time itemprop=&quot;dateUpdated&quot; datetime=&quot;&#123;&#123; moment(post.updated).format() &#125;&#125;&quot; content=&quot;&#123;&#123; date(post.updated, config.date_format) &#125;&#125;&quot;&gt; &#123;&#123; date(post.updated, config.date_format) &#125;&#125; &lt;/time&gt; &lt;/span&gt;&#123;% endif %&#125; 根据博客配置文件中的 language 参数修改对应的语言配置文件（博客主目录）/themes/next/languages/zh_Hans.yml 12post: updated: 更新于 修改主题配置文件（博客主目录）/themes/next/_config.yml，增加一行 1display_updated: true 或者写文章的时候可以直接在文章开头设置更新时间，没有这参数的话将会显示md文件的修改日期 1updated: 2018-01-01 12:00:00 添加搜索功能 安装 hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 打开 站点配置文件 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 添加阅读全文按钮因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加 1&lt;!--more--&gt; 其后面的部分就不会显示了，只能点击阅读全文才能看 修改文章内链接文本样式 打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加 12345678910.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 设置网站缩略图标从网上看了很多设置方法都是说把favicon.ico放到站点目录的source目录下就可以了，可是我试了好多遍，并不行 我的设置方法是这样的：把你的图片（png或jpg格式，不是favicon.ico）放在themes/next/source/images里，然后打开 主题配置文件 找到favicon，将small、medium、apple_touch_icon三个字段的值都设置成/images/图片名.jpg就可以了，其他字段都注释掉。 设置文章字体的颜色、大小 如果想设置某一句的颜色或大小，只需用html语法写出来就行了 1234接下来就是见证奇迹的时刻&lt;font color="#FF0000"&gt; 我可以设置这一句的颜色哈哈 &lt;/font&gt; &lt;font size=6&gt; 我还可以设置这一句的大小嘻嘻 &lt;/font&gt; &lt;font size=5 color="#FF0000"&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;/font&gt; 设置文字居中1&lt;center&gt;这一行需要居中&lt;/center&gt; 添加评论系统目前国内比较有名的多说、网易云跟帖评论系统都已停止服务了，国外的Disqus评论系统还得需要翻墙，所以不推荐使用，剩下的还有搜狐畅言、友言、来必力等。本来想使用畅言的，结果注册完之后还得要求备案，我只想说F开头的那个单词，果断放弃。后来选择了友言 1、进入友言官网注册、登录步骤我就不介绍了2、登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的uid=12345673、打开 主题配置文件 找到youyan_uid将值设置为上面的uid就可以了 添加站点访问计数站点访问计数有名的就是不蒜子，使用起来非常方便1、安装脚本打开 themes/next/layout/_partial/footer.swig，将下面这段代码添加到里面 12345678910&lt;div&gt;&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot; style=&apos;display:none&apos;&gt; 本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次 &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot; style=&apos;display:none&apos;&gt; 有&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人看过我的博客啦&lt;/span&gt;&lt;/div&gt; 添加的位置如下图，可自行根据个人喜好更换位置 以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 themes/next/layout/_macro/post.swig，在第一行增加is_pv字段 1&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125; 然后将这段代码插入到里面 1234&#123;% if is_pv %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&#123;% endif %&#125; 插入的位置 然后再打开 themes/next/layout/post.swig，这个文件是文章的模板，给render方法传入参数（对应刚才添加的is_pv字段） 最后再打开 themes/next/layout/index.swig，这个文件是首页的模板，给render方法传入参数（对应刚才添加的is_pv字段） OK！设置完毕 去掉文章目录标题的自动编号我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？打开主题配置文件，找到 123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 将number改为false即可 自定义样式 引用需加入custom.styl的代码 文件位置：~/blog/themes/next/source/css/_custom/custom.styl 123456789// 自定义的引用样式blockquote.question &#123; color: #555; border-left: 4px solid rgb(16, 152, 173); background-color: rgb(227, 242, 253); border-top-right-radius: 3px; border-bottom-right-radius: 3px; margin-bottom: 20px;&#125; 文字颜色改color的值 背景色改background-color的值 边框颜色和粗细改border-left的值 效果： 内容 使用方法： 1内容 修改hexo的主题nexT中的Pisces主题宽度在source/css/_schemes/Picses/_layout.styl文件末尾添加如下代码 12345678910111213141516171819202122232425262728293031323334// 以下为新增代码！！header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125; 更多主题和插件还有其他更多的主题配置，请查看主题配置 还有其他更多的插件，请查看Hexo插件]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2Fblog%2F2018%2F02%2F13%2FSpringBoot.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2Fblog%2F2018%2F02%2F12%2FSpring.all%2F</url>
    <content type="text"><![CDATA[Spring 简介Spring特性Spring主要以下特性 轻量： a. 从大小和开销方面，Spring都是轻量级的 b. Spring是非侵入式的 控制反转(IOC)： a. 利用该特性，Spring使代码之间进一步低耦合； b. 对象的依赖会以被动方式加载进来，而不是去创建或查找 面向切面（AOP）: 将应用业务逻辑和系统服务器分开 容器：用于管理所有对象的配置和生命周期 框架： a. 将简单的组件配置组合成复杂的应用 b. 提供了大量的基础功能 Spring核心模块 Spring主要包 包名 描述 org.springframework.core Spring核心工具包，其他包都依赖此包 org.springframework.beans Spring IOC的基础实现，包含访问配置文件、创建和管理bean等 org.springframework.aop 提供AOP的实现 org.springframework.context 在基础IOC功能上提供扩展服务，此外还提供许多企业级服务的支持，有邮件服务、任务调度、JNDI定位，EJB集成、远程访问、缓存以及多种视图层框架的支持。 org.springframework.context.support Spring context的扩展支持，用于MVC方面。 org.springframework.tranaction 为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理 org.springframework.aspects Spring提供的对AspectJ框架的整合 org.springframework.test 对JUNIT等测试框架的简单封装 org.springframework.asm Spring3.0开始提供的独立asm jar包 org.springframework.expression Spring表达式语言 org.springframework.instrument.tomcat Spring对tomcat连接池的集成 org.springframework.instrument Spring对服务器的代理接口 org.springframework.jdbc 对JDBC 的简单封装 org.springframework.jms 为简化jms api的使用而做的简单封装 org.springframework.orm 整合第三方的orm实现，如hibernate，ibatis，jdo以及spring 的jpa实现 org.springframework.oxm Spring对于object/xml映射的支持，可以让JAVA与XML之间来回切换 org.springframework.web 包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类 org.springframework.web.mvc 包含SpringMVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类 org.springframework.web.portlet Spring MVC的增强 org.springframework.web.servlet d对J2EE6.0 servlet3.0的支持 org.springframework.web.struts 整合对struts框架的支持 Spring-IOCSpring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务 SpringIOC容器IOC容器是Spring最基础也是最重要的部分，用于获取bean的实例对象 ApplicationContext接口：实现了BeanFactory接口，在日常开发中基本上使用它，有三个实现类 a. ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件(推荐使用这种) b. FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 c. AnnotationConfigApplicationContext:当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解 BeanFactory接口：属于面向Spring本身的接口，一般不适用（是Spring早期的创建容器的接口） 无论是BeanFactory还是ApplicationContext，其实最终的底层BeanFactory都是DefaultListableBeanFactory。需要注意的式，BeanFactory采取延迟加载，第一次getBean时才会初始化Bean；ApplicationContext是加载完applicationContext.xml时，就创建具体的Bean对象的实例(（只对BeanDefition中描述为是单例的bean，才进行饿汉式加载）) 容器的创建容器创建有两种方式，一种是在java应用中进行创建，而另一种则是在web应用中的创建 在java应用中创建123456//通过xml文件加载配置，实例化ClassPathXmlApplicationContext对象即可ApplicationContext context = new ClassPathXmlApplicationContext("xxx/xxx/xx.xml");//通过配置类加载配置， 使用AnnotationConfigApplicationContext类获取容器ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfiguration.class); 在java web应用中创建需要在web.xml中配置ContextLoaderListener监听器，并配置ContextConfigLocation参数,传入配置类或配置文件 执行流程如下: web容器启动之后加载web.xml，此时加载ContextLoaderListener监听器(该监听器实现了ServletContextListener接口) 监听器会在web容器启动的时候，触发contextInitialized()方法 contextInitialized()方法会调用initWebApplicationContext()方法，该方法负责创建Spring容器 通过xml文件加载配置 12345678910111213141516171819&lt;!-- 通过配置类获取IOC容器 --&gt;&lt;web-app&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context. support.ClassPathXmlApplicationContext &lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com/liisyu/main/resource/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 通过配置类加载配置 123456789101112131415161718192021&lt;!-- 通过配置类获取IOC容器 --&gt;&lt;web-app&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context. support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; com.liisyu.spring.test.SpringConfiguration &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 关于监听器，可参考Servlet章节 bean实例化的三种方式Spring主要是通过配置文件的&lt; bean &gt;标签来进行对对象的给创建和管理，也就是所谓的控制反转，将对象的创建交给Spring。 &lt; bean &gt;的相关属性 属性 描述 id 唯一标识 class 指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数 scope 指定对象的作用范围，可选范围有singleton :默认值，单例的（在整个容器中只有一个对象）.prototype :多例 request:Web 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中 session:Web 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中 global session:Web 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session. init-method 指定类中的初始化方法名称 destroy-method 指定类中销毁方法名称。比如DataSource的配置中一般需要指定destroy-method=“close” factory-method 指定生产对象的静态方法(用于通过静态工厂实现bean的实例化) primary true/false，表示首选bean，当出现多个相同类型的bean时，优先选择首选bean Spring bean要对对象进行实例化的，总共有三种 使用默认无参构造函数(重点) 静态工厂(了解) 实例工厂(了解) 使用默认无参构造函数当我们配置完&lt; bean &gt;后，Spring 可以自动的通过class的无参构造器来创建实例，但需要注意以下两点 如果class没有无参构造函数，就会报错 class 不能是接口 1&lt;bean id="" class=""/&gt; 静态工厂自定义一个静态工厂 12345public class StaticFactory &#123; public static UserService createUserService()&#123; return new UserServiceImpl(); &#125;&#125; 通过factory-method属性指定生产对象的静态方法，需要注意的是，class指向的是静态工厂，而不是具体的实现类了 1&lt;bean id="" class="com.kkb.spring.factory.StaticFactory" factory-method="createUserService"&gt;&lt;/bean&gt; 实例工厂自定义一个实例工厂 12345public class InstanceFactory &#123; public UserService createUserService()&#123; return new UserServiceImpl(); &#125;&#125; 先为实例工厂创建bean，实力工厂需要交给Spring管理 1&lt;bean id="instancFactory" class="com.kkb.factory.InstanceFactory"&gt;&lt;/bean&gt; 再调用实例工厂的获取方法 1&lt;bean id="" factory-bean="instancFactory" factory-method="createUserService"&gt;&lt;/bean&gt; 依赖注入大多数情况下，Spring管理的对象都会依赖于其他属性，如简单类型、POJO类、集合类等。而这些属性，Spring会通过依赖注入的方式实现注入。具体来讲，Spring提供了两种方式 构造器注入：利用构造器来将属性值注入到对象中 setter方法注入：利用setter方法将属性值注入到对象中 通过构造器来注入使用&lt; constructor-arg &gt;标签 123&lt;bean id="" class=""&gt; &lt;constructor-arg/&gt;&lt;/bean&gt; &lt; constructor-arg &gt;相关属性 属性 描述 index 指定参数在构造函数参数列表的索引位置 name 指定参数在构造函数中的名称 value 它能赋的值是基本数据类型和 String 类型 ref 它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean 注入简单类型 12&lt;constructor-arg name="name" value="liisyu"/&gt;&lt;constructor-arg name="number" value="123"/&gt; 注入bean类型 1&lt;constructor-arg name="user" ref="user"/&gt; 注入集合类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 &lt;!--List&lt;String&gt; stringList;--&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;b&lt;/value&gt; &lt;value&gt;c&lt;/value&gt; &lt;value&gt;d&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;!--List&lt;CompactDisc&gt; compactDiscList;--&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;ref bean="sgtPeppers"/&gt; &lt;ref bean="sgtPeppers"/&gt; &lt;ref bean="sgtPeppers"/&gt; &lt;ref bean="sgtPeppers"/&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;!--Set&lt;String&gt; compactDiscs;--&gt; &lt;constructor-arg&gt; &lt;set&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;b&lt;/value&gt; &lt;value&gt;c&lt;/value&gt; &lt;value&gt;d&lt;/value&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;!--Set&lt;CompactDisc&gt; compactDiscSet;--&gt; &lt;constructor-arg&gt; &lt;set&gt; &lt;ref bean="sgtPeppers"/&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="map"&gt; &lt;map&gt; &lt;entry key="number" value="38"/&gt; &lt;entry key="number2" value="38"/&gt; &lt;entry key="number3" value="29"/&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="map"&gt; &lt;map&gt; &lt;entry key="user" value-ref="user"/&gt; &lt;entry key="user2" value-ref="user"/&gt; &lt;entry key="user3" value-ref="user"/&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;!-- Properties集合 --&gt; &lt;constructor-arg name="pro"&gt; &lt;props&gt; &lt;prop key="uname"&gt;root&lt;/prop&gt; &lt;prop key="pass"&gt;123&lt;/prop&gt; &lt;/props&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 此外，构造函数还有一种简写方式，C命名空间索引(无法注入集合，也不推荐使用) 123456&lt;!-- 按属性的顺序传入参数 --&gt; &lt;bean id="cdPlayer" class="com.spring.action.xmlconfig2.CDPlayer" c:_0="字符串数据" c:_1="123" c:_2-ref="user"&gt; &lt;/bean&gt; 通过setter方法注入setter注入方式 手动装配方式注入(XML方式) a. 需要用到&lt; bean&gt;标签的子标签&lt; property &gt; b. 需要在类中指定setter方法 自动装配方式注入(注解方式,再基于注解的文章说明) &lt; property &gt;的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;bean id="" class=""&gt; &lt;!-- 注入简单类型 --&gt; &lt;property name="name" value="name"/&gt; &lt;property name="number" value="123"/&gt; &lt;!-- 注入bean类型 --&gt; &lt;property name="user" ref="user"/&gt; &lt;!-- 注入集合 --&gt; &lt;!--List&lt;String&gt; stringList;--&gt; &lt;property name="stringList"&gt; &lt;list&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;b&lt;/value&gt; &lt;value&gt;c&lt;/value&gt; &lt;value&gt;d&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--List&lt;CompactDisc&gt; compactDiscList;--&gt; &lt;property name="compactDiscList" &gt; &lt;list&gt; &lt;ref bean="sgtPeppers"/&gt; &lt;ref bean="sgtPeppers"/&gt; &lt;ref bean="sgtPeppers"/&gt; &lt;ref bean="sgtPeppers"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Set&lt;String&gt; compactDiscs;--&gt; &lt;property name="compactDiscs"&gt; &lt;set&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;b&lt;/value&gt; &lt;value&gt;c&lt;/value&gt; &lt;value&gt;d&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--Set&lt;CompactDisc&gt; compactDiscSet;--&gt; &lt;property name="compactDiscSet"&gt; &lt;set&gt; &lt;ref bean="sgtPeppers"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="number" value="38"/&gt; &lt;entry key="number2" value="38"/&gt; &lt;entry key="number3" value="29"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="user" value-ref="user"/&gt; &lt;entry key="user2" value-ref="user"/&gt; &lt;entry key="user3" value-ref="user"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- Properties集合 --&gt; &lt;property name="pro"&gt; &lt;props&gt; &lt;prop key="uname"&gt;root&lt;/prop&gt; &lt;prop key="pass"&gt;123&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 简化使用，p命名空间(无法注入集合) 12345&lt;bean id="" class="" p:name="name" p:number="123" p:compactDisc-ref="user"/&gt; 解决命名空间无法注入集合的方式使用&lt; util &gt;标签(需要加约束),如 1234567创建了一个集合的对象 &lt;util:list id="stringList"&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;b&lt;/value&gt; &lt;value&gt;c&lt;/value&gt; &lt;value&gt;d&lt;/value&gt; &lt;/util:list&gt; Spring util-命名空间中的元素 元素 描 述 util:constant 引用某个类型的public static域，并将其暴露为bean util:list 创建一个java.util.List类型的bean，其中包含值或引用 util:map 创建一个java.util.Map类型的bean，其中包含值或引用 util:properties 创建一个java.util.Properties类型的bean util:property-path 引用一个bean的属性（或内嵌属性），并将其暴露为bean util:set 创建一个java.util.Set类型的bean，其中包含值或引用 加载properties文件Spring 可以加载Properties文件方式，供配置文件使用 1&lt;context:property-placeholder location="classpath:foo.properties" /&gt; 获取值则使用 1$&#123;key&#125; 开启注解扫描想使用注解，首先需要开启注解扫描,开启可以使用xml方式，也可以使用注解方式 使用xml方式开启注解 12&lt;!-- base-package传入如，com.liisyu.spring.service,那么它就会扫描该类所在的包 --&gt;&lt;context:component-scan base-package="" /&gt; 使用java方式开启注解 123456//通过@ComponentScan来开启,一般配合@Configuration注解使用，以便在配置类被加载时直接开启注解扫描@Configuration@ComponentScan(basePackages="com.liisyu.spring.service")public class SpringConfiguration()&#123; ...&#125; 常用注解注解方式是Spring提供的另一种实现方式，它更适用于自己开发Bean的场景 @Configuration从Spring3.0开始使用，用于定义配置类，可替换xml文件，效果相当于&lt; beans &gt;根标签。当配置类内部包含一个或多个@Bean注解的方法时，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean，初始化Spring容器。 1234@Configurationpublic class SpringConfiguration()&#123; ...&#125; @ComponentScan效果相当于&lt; context:component-scan &gt;标签,扫描@Component、@Controller、@Service、@Repository注解的类。 相关属性: 属性 描述 basePackages 用于指定要扫描的包 value 和basePackages作用一样，可省略 以下时不同方式的@ComponentScan扫描路径 方式一：类所在的包就是基础包 1@ComponentScan 方式二：指定基础包（String 形式） 1@ComponentScan(“packageName”) 方式三：指定基础包更清晰版（String形式） 1@ComponentScan(basePackages = “packageName”) 方式四：指定多个基础包（String 形式） 1@ComponentScan(backPackages = &#123;“packageName1”, ”packageName2”&#125;) 方式五：通过类来设置类的所在的包为基础包 1@ComponentScan(basePackageClasses=&#123;DemoClass.class, DemoClass2.class&#125;) 推荐使用第五种方式，因为2、3、4是string 形式，而String是类型不安全的（not type-safe）,而5更加安全。通常情况下，可以添加一个空标记接口，只用来设置基础包，这是有利于代码重构的 @Bean效果相当于&lt; bean &gt;标签,标注在返回实例的方法上，将返回的实例注册为bean(主要用于注册第三方的bean)。 可以通过name属性为bean指定名称； 不指定name，默认名称与方法名相同（也就是示例中的userService） 可以与@Scope()配合使用，默认为单例singleton作用域 12345@Bean(name= "")@Scope("prototype")public UserService userService()&#123; return new UserServiceImpl();&#125; @Component及其语义化注解效果相当于&lt; bean &gt;标签,标注在类上 可以使用value属性为bean命名，默认为当前注解类名（首字母小写） 除了@Component，Spring还提供了3个语义化的注解（效果相同） a. @Controller:一般用于表现层的注解 b. @Service:一般用于业务层的注解 c. @Repository:一般用于持久层的注解 1234@Component(value="")public class UserService&#123; ...&#125; todo : 验证是否可以使用@Scope @Scope效果相当于&lt; bean &gt;标签的scope属性,可以与@Bean联合使用 1@Scope(value="singleton") @Autowired用于DI注入 默认按类型装配（byType） 这个注解是spring自身的 默认情况下必须要求依赖对象必须存在,如果要允许null值，可以设置@Autowired(required=false) 可以结合@Qualifier注解进行名称装配 @Resource用于DI注入 按照名称（byName）进行装配，名称可以通过name属性进行指定 注解属于J2EE 如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，当找不到与名称匹配的bean时才按照类型进行装配(先byName,再byType) 注意:如果name属性一旦指定，就 只会 按照名称进行装配 @Value 给基本类型和String类型注入值 可以使用占位符获取属性文件中的值 1@Value("$&#123;name&#125;") @Qualifier与@Autowire连用，在自动按照类型注入的基础之上，再按照 Bean 的 id 注入 12@Autowire@Qualifier("bean_id") 可以通过@Qualifier和@Compontent联合使用，达到自定义bean的名称 123@Component@Qualifier("bean_id")... 当然，也可以通过@Qualifier和@Bean协同使用 123@Bean@Qualifier("bean_id")... 当需要为一个bean定义多个限定符时，又不能使用多个@Qulifier(同名注解只能存在一个)，所以自定义一个注解并使其拥有@Qulifier功能，完美解决这个问题 自定义方式如下 1234567891011121314package com.spring.ambiguity.quaifier;import org.springframework.beans.factory.annotation.Qualifier;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Okss &#123;&#125; 使用这个注解 1234567891011/** * CompactDisc实现类 */@Component//@Qualifier("oks")@Oksspublic class AnotherSgtPeppers implements CompactDisc &#123; public void sing() &#123; System.out.println("AnotherSgtPeppers的sing方法"); &#125;&#125; @PostConstruct与@PreDestroy效果相当于 1&lt;bean id="" class="" init-method="" destroy-method="" /&gt; 使用如下 12345678@PostConstructpublic void init()&#123; ...&#125;@PreDestroypublic void dostory()&#123; ...&#125; 流程图如下 @Primary用于标示首选的bean，效果相当于 1&lt;bean id="" class="" primary="true"/&gt; 使用 @Primary标签 1234567@Component@Primarypublic class xxx//或者@Bean@Primarypublic XXX getXXX()&#123;&#125; @PropertySource用于加载properties配置文件，效果相当于 1&lt; context:property-placeholder &gt; 使用 12345678@Configuration//如果在类路径下，需要写上classpath@PropertySource(“classpath:jdbc.properties”)public class JdbcConfig &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; 配置的混合导入配置类种导入其他配置类通过@Import导入 123@Configuration@Import(CDConfig.class)public class CDPlayerConfig &#123; 配置类中导入xml配置文件通过@ImportResource 123@Configuration@ImportResource("classpath:xxx/xxx/cd-config.xml")public class CDPlayerConfig &#123;&#125; xml配置文件导入配置类直接使用&lt; bean &gt;标签即可 1&lt;bean class="com.spring.action.mixedconfig.CDConfig"/&gt; xml配置文件导入其他xml配置文件使用&lt; import &gt;标签导入即可 1&lt;import resource="cd-config.xml"/&gt; 条件化的bean利用@Conditional注解来配合@Bean使用，满足@Conditional并返回true时才会创建bean 使用@Conditional(XXX.class),使用XXX.class来设置@Conditional 12345@Bean @Conditional(MagciExistsCondition.class) public Magic magic() &#123; return new MagicBean(); &#125; 设置@Conditional的类，需要实现condition接口，重写matches方法 方法return ture,则创建bean 否则，不创建bean 123456public class MagciExistsCondition implements Condition &#123; public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; return true; // return false; &#125;&#125; matches方法的第一个参数ConditionContext源码如下 1234567891011121314151617public interface ConditionContext &#123;//通过返回的BeanDefinitionRegistry检查bean定义 BeanDefinitionRegistry getRegistry();//通过返回的ConfigurableListableBeanFactory检查bean是否存在，甚至探查bean的属性 ConfigurableListableBeanFactory getBeanFactory();//)通过返回的Environment检查环境变量是否存在以及它的值是什么； Environment getEnvironment();//通过返回的ResourceLoader所加载的资源； ResourceLoader getResourceLoader();//通过返回的ClassLoader加载并检查类是否存在。 ClassLoader getClassLoader();&#125; matches方法的第二个参数AnnotatedTypeMetadata源码如下 1234567891011121314public interface AnnotatedTypeMetadata &#123;//检查带有@Bean注解的方法是不是还有其他特定的注解 boolean isAnnotated(String var1);//其余的都是用来获取其他注解的属性 Map&lt;String, Object&gt; getAnnotationAttributes(String var1); Map&lt;String, Object&gt; getAnnotationAttributes(String var1, boolean var2); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1, boolean var2);&#125; 根据不同环境加加载不同beanSpring存在一个profile的概念，设置完profile后，可以通过激活不同的profile，达到加载不同bean的效果 注解方式定义profileSpring 提供了以下两个注解 @Profile: 设置profile，该注解基于@Conditional实现 @ActiveProfiles：激活profile 使用@Profile基于类级别的profile 123456@Profile("dev")public class ClassprofilesConfig &#123; @Bean public CompactDisc compactDisc()&#123; return new SgtPeppers(); &#125; 基于方法级别的profile 12345@Bean @Profile("dev")public CompactDisc compactDisc()&#123; return new SgtPeppers();&#125; 利用@ActiveProfiles注解来激活某个profile 1@ActiveProfiles(&quot;dev&quot;) xml中定义profile只有激活profile才会使用到这个配置文件 12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" profile="dev"&gt; 可以使用嵌套beans的方式，而不是为为每一个环境设置一个profile 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" profile="dev"&gt; &lt;beans profile="xxx"&gt;&lt;/beans&gt; &lt;beans profile ="sdsd"&gt;&lt;/beans&gt; Spring 激活profile主要依赖两个属性 spring.profiles.active spring.profiles.default 有多种方式来设置这两个属性 作为DispatcherServlet的初始化参数； 作为Web应用的上下文参数； 作为JNDI条目； 作为环境变量； 作为JVM的系统属性； 在集成测试类上，使用@ActiveProfiles注解设置。 第一种方式示例 1234567891011121314&lt;!-- web.xml --&gt;&lt;!-- 为上下文设置默认的profile --&gt; &lt;context-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 为servlet设置profile --&gt; &lt;servlet&gt; ... &lt;init-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; Spring-AOP什么是AOP?面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点 – wiki 作用 AOP采取横向抽取机制，补充了传统纵向继承体系（OOP）无法解决的重复性代码优化（性能监视、事务管理、安全检查、缓存） 将业务逻辑和系统处理的代码（关闭连接、事务管理、操作日志记录）解耦。 横向的抽取机制 相对的，我们平常使用的是纵向抽取机制 AOP术语 Joinpoint(连接点) – 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点 Pointcut(切入点) – 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 Advice(通知/增强) – 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Introduction(引介) – 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field Target(目标对象) – 代理的目标对象 Weaving(织入) – 是指把增强应用到目标对象来创建新的代理对象的过程 Proxy（代理） – 一个类被AOP织入增强后，就产生一个结果代理类 Aspect(切面) – 是切入点和通知的结合，以后咱们自己来编写和配置的 Advisor（通知器、顾问） –和Aspect很相似 切入点表达式格式： 1execution([修饰符] 返回类型 包名.类名.方法名(参数) execution:必须 修饰符：可省略 返回类型：必须，可用*代替 包名：多级包之间用 . 分割包名可用代替，多级包使用多个代替生路中间包名可以用..(如...UserDaoImpl.insert()) 类名:可用代替也可以用通配(如,*DaoImpl) 方法名：可以使用代替可以使用通配(如,add*) 参数：可以使用*代替多个参数，可以使用..代替 通知 通知通知类型有五种 前置通知 后置通知 最终通知 环绕通知 异常抛出通知 前置通知： 执行在目标对象方法之前 使用&lt; aop:before &gt;标签 应用于方法开始时校验 后置通知： 执行在目标方法之后，有异常不执行 使用&lt; aop:after-returning &gt; 应用于修改方法的返回值 最终通知： 执行在目标方法完成之后，在后置通知之后，有无异常都会执行 使用&lt; aop:after &gt;标签 应用于如释放资源 异常抛出通知： 执行于异常抛出后 使用&lt; aop:after-throwing &gt;标签 应用于包装异常 环绕通知: 相当于前四个通知的合体 使用&lt; aop:around &gt;标签 应用于事务、统计代码执行时机等 AOP的示例 xml实现 java注解实现 XML方式实现类图 通知类(MyAdvice):定义了处理各种通知的方法，对于环绕通知需要传入ProceedingJoinPoint类 接口: 目标对象接口 接口实现：目标对象 还需要一个xml配置文件 通知类 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author liisyu * @date 2019/2/23 */public class MyAdvice &#123; //演示前置通知 public void log() &#123; System.out.println(&quot;前置...&quot;); &#125; //演示后置通知 public void log2() &#123; System.out.println(&quot;后置...&quot;); &#125; //演示最终通知 public void log3() &#123; System.out.println(&quot;最终...&quot;); &#125; //演示异常抛出通知 public void log4() &#123; System.out.println(&quot;异常...&quot;); &#125; /** * 环绕通知 * @param joinPoint 需要传入的方法 */ public void log5(ProceedingJoinPoint joinPoint) &#123; System.out.println(&quot;前置通知&quot;); //调用目标对象的方法 try &#123; joinPoint.proceed(); System.out.println(&quot;后置通知&quot;); &#125; catch (Throwable e) &#123; //相当于实现异常通知 System.out.println(&quot;异常抛出配置&quot;); e.printStackTrace(); &#125;finally &#123; System.out.println(&quot;最终通知&quot;); &#125; &#125;&#125; 目标对象接口 1234567/** * @author liisyu * @date 2019/2/28 */public interface UserDao &#123; void insert();&#125; 目标对象实例 12345678910111213/** * @author liisyu * @date 2019/2/28 */public class UserDaoImpl implements UserDao &#123; @Override public void insert() &#123; System.out.println("insert()");// 用于手动创造异常// int i = 1/0; &#125;&#125; 配置文件 12345678910111213141516171819202122232425&lt;bean class="com.liisyu.demo1.UserDaoImpl"/&gt;&lt;!--配置通知、增强--&gt;&lt;bean id="myAdvice" class="com.liisyu.demo1.MyAdvice"/&gt;&lt;!--AOP配置--&gt;&lt;aop:config&gt; &lt;aop:aspect ref="myAdvice"&gt; &lt;aop:pointcut id="pointcut" expression="execution(void com.liisyu.demo1.UserDaoImpl.insert())"/&gt; &lt;!--&lt;aop:before method="log"--&gt; &lt;!--pointcut="execution(void com.liisyu.dao.impl.UserDaoImpl.insert())"/&gt;--&gt; &lt;!--&lt;aop:after-returning method="log2"--&gt; &lt;!--pointcut="execution(void com.liisyu.dao.impl.UserDaoImpl.insert())"/&gt;--&gt; &lt;!--&lt;aop:after method="log3"--&gt; &lt;!--pointcut="execution(void com.liisyu.dao.impl.UserDaoImpl.insert())"/&gt;--&gt; &lt;!--&lt;aop:after-throwing method="log4"--&gt; &lt;!--pointcut="execution(void com.liisyu.dao.impl.UserDaoImpl.insert())"/&gt;--&gt; &lt;!--&lt;aop:around method="log5"--&gt; &lt;!--pointcut="execution(void com.liisyu.demo1.UserDaoImpl.insert())"/&gt;--&gt; &lt;aop:around method="log5" pointcut-ref="pointcut"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;/beans&gt; 此外，还可以通过&lt; aop-pointcut &gt;标签来设置切入点 123&lt;aop:pointcut id="pointcut" expression="execution(void com.liisyu.demo1.UserDaoImpl.insert())"/&gt;&lt;aop:around method="log5" pointcut-ref="pointcut"/&gt; 注解方式实现类图 切面类:包含通知和切入点 接口: 目标对象接口 接口实现：目标对象 配置类：需要实现@EnableAspectJAutoProxy自动代理 切面类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 切面类 * @author liisyu * @date 2019/2/28 */@Component("myAspect")@Aspectpublic class MyAspect &#123; //演示前置通知 @Before(value = "execution(void com.liisyu.demo2.UserDaoImpl.insert())") public void log() &#123; System.out.println("前置..."); &#125; @AfterReturning(value = "execution(void com.liisyu.demo2.UserDaoImpl.insert())") //演示后置通知 public void log2() &#123; System.out.println("后置..."); &#125; @After(value = "execution(void com.liisyu.demo2.UserDaoImpl.insert())") //演示最终通知 public void log3() &#123; System.out.println("最终..."); &#125; @AfterThrowing(value = "execution(void com.liisyu.demo2.UserDaoImpl.insert())") //演示异常抛出通知 public void log4() &#123; System.out.println("异常..."); &#125; @Around(value = "execution(void com.liisyu.demo2.UserDaoImpl.insert())") public void log5(ProceedingJoinPoint joinPoint) &#123; System.out.println("前置通知"); //调用目标对象的方法 try &#123; joinPoint.proceed(); System.out.println("后置通知"); &#125; catch (Throwable e) &#123; //相当于实现异常通知 System.out.println("异常抛出配置"); e.printStackTrace(); &#125;finally &#123; System.out.println("最终通知"); &#125; &#125;&#125; 目标对象接口 1234567/** * @author liisyu * @date 2019/2/28 */public interface UserDao &#123; void insert();&#125; 目标对象实例 12345678910111213/** * @author liisyu * @date 2019/2/28 */public class UserDaoImpl implements UserDao &#123; @Override public void insert() &#123; System.out.println("insert()");// 用于手动创造异常// int i = 1/0; &#125;&#125; 配置类 1234567891011/** * 配置类 * @author liisyu * @date 2019/2/28 */@Configuration@ComponentScan(basePackages = "com.liisyu.demo2")@EnableAspectJAutoProxypublic class SpringConfiguration &#123;&#125; 此外，还可以使用@Pointcut提取切入点 12345678@Pointcut(value = "execution(void com.liisyu.demo2.UserDaoImpl.insert())")public void pointcut()&#123;&#125;//演示前置通知@Before(value = "pointcut()")public void log() &#123; System.out.println("前置...");&#125; Spring-JDBCSpring提供的JDBC支持类JdbcTemplate类：模板类DriverManagerDataSource: Spring的内置连接池 手动创建123456789101112131415161718192021/** * 简单的Spring-JDBC测试 * @author liisyu * @date 2019/2/28 */public class TestJdbcTemplate &#123; @Test public void test() &#123; // 创建连接池，先使用Spring框架内置的连接池 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/mydb?serverTimezone=GMT%2B8"); dataSource.setUsername("masorl"); dataSource.setPassword("314512321lsy"); // 创建模板类 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);//我们自己编写原始的JDBC代码，可能需要9步 // 完成数据的添加 jdbcTemplate.update("insert into account values ('liisyu',?,?)", "测试",10000); &#125;&#125; 使用spring来管理1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--导入properties文件--&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!--设置连接池--&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="$&#123;db.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;db.url&#125;"/&gt; &lt;property name="username" value="$&#123;db.username&#125;"/&gt; &lt;property name="password" value="$&#123;db.password&#125;"/&gt; &lt;/bean&gt; &lt;!--设置Spring JdbcTemplate--&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt;&lt;/beans&gt; 基于JdbcTemplate的CURD代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 基于JdbcTemplate的CURD * @author liisyu * @date 2019/2/28 */@RunWith(SpringJUnit4ClassRunner.class )@ContextConfiguration("classpath:jdbctest/jdbc.xml")public class TestJdbcTemplate2 &#123; @Resource(name="jdbcTemplate") private JdbcTemplate jdbcTemplate; //插入 @Test public void test() &#123; jdbcTemplate.update("insert into account values ('liisyu3',?,?)", "测试2",10000); &#125; //更新 @Test public void test2()&#123; jdbcTemplate.update("update account set boy=?,descrption =? where number = ?", "思雨",10000d,10000); &#125; //删除 @Test public void test3()&#123; jdbcTemplate.update("delete from account where number = ?", 10000); &#125; /** * 查询单个 * 需要导入一个映射器 */ @Test public void test4()&#123; Account account = jdbcTemplate.queryForObject("select * from account where number = ?", new BeanMapper(), 10000); System.out.println(account.toString()); &#125; /** * 查询所有 * 需要导入一个映射器 */ @Test public void demo5()&#123; List&lt;Account&gt; list = jdbcTemplate.query("select * from account", new BeanMapper()); for (Account account : list) &#123; System.out.println(account.toString()); &#125; &#125;&#125; 映射器 实现接口RowMapper 重写方法mapRow 主要是将数据库类型转换成Java类型 12345678910111213141516import org.springframework.jdbc.core.RowMapper;/** * 映射器 * @author liisyu * @date 2019/3/1 */public class BeanMapper implements RowMapper&lt;Account&gt; &#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setBoy(rs.getString("boy")); account.setDescrption(rs.getString("descrption")); account.setNumber(rs.getInt("number")); return account; &#125;&#125; 测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class )@ContextConfiguration("classpath:jdbctest/jdbc.xml")public class TestJdbcTemplate &#123; @Resource(name="jdbcTemplate") private JdbcTemplate jdbcTemplate; @Test public void test2() &#123; jdbcTemplate.update("insert into account values ('liisyu2',?,?)", "测试2",10000); &#125;&#125; Spring管理第三方连接池管理DBCPpom: 123456&lt;!--dbcp连接池依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;$&#123;dbcp.version&#125;&lt;/version&gt;&lt;/dependency&gt; 配置 1234567&lt;!--设置DBCP连接池--&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;db.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;db.url&#125;"/&gt; &lt;property name="username" value="$&#123;db.username&#125;"/&gt; &lt;property name="password" value="$&#123;db.password&#125;"/&gt;&lt;/bean&gt; 管理C3P0连接池pom 12345&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;$&#123;c3p0.version&#125;&lt;/version&gt;&lt;/dependency&gt; 配置 1234567&lt;!--设置C3P0连接池--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;db.driverClassName&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;db.url&#125;"/&gt; &lt;property name="user" value="$&#123;db.username&#125;"/&gt; &lt;property name="password" value="$&#123;db.password&#125;"/&gt;&lt;/bean&gt; JdbcDAoSupport工具使用Spring管理JdbcTemplate类后，我们需要写如下一步导入jdbc 12@Resource(name="jdbcTemplate")private JdbcTemplate jdbcTemplate; 并且在xml配置JdbcTemplate,并传入dataSource 123&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt; Spring提供了JdbcDAoSupport，帮我们省去这一步，只需要继承该类 123456789101112/** * @author liisyu * @date 2019/3/1 */public class DemoDao extends JdbcDaoSupport &#123; /** * 继承后，使用this.getJdbcTemplate()获取JdbcTemplate */ public void test()&#123; this.getJdbcTemplate().update("insert into account values ('liisyu3',?,?)", "测试2",100002); &#125;&#125; 并且配置文件，需要为该类注入DataSource 123&lt;bean id="demoDao" class="com.liisyu.Jdbctest.DemoDao"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt; 实际上本质是JdbcDaoSupport帮我们完成了这件事 123456789101112131415161718192021public abstract class JdbcDaoSupport extends DaoSupport &#123; @Nullable private JdbcTemplate jdbcTemplate; /** * Set the JDBC DataSource to be used by this DAO. */ public final void setDataSource(DataSource dataSource) &#123; if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) &#123; this.jdbcTemplate = createJdbcTemplate(dataSource); initTemplateConfig(); &#125; &#125; @Nullable public final JdbcTemplate getJdbcTemplate() &#123; return this.jdbcTemplate; &#125;... Spring-TransactionSpring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给其他相关平台框架的事务来实现。 Spring事务管理器的接口是PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。 Spring框架的事务管理相关的类和API 介绍： PlatformTransactionManager接口:平台事务管理器.(真正管理事务的类)。该接口有具体的实现类，根据不同的持久层框架，需要选择不同的实现类！ TransactionDefinition接口：事务定义信息（包括事务的隔离级别,传播行为,超时,只读等） TransactionStatus接口：事务的状态（包括是否新事务、是否已提交、是否有保存点、是否回滚） 关系：PlatformTransactionManager真正管理事务对象.根据事务定义的信息TransactionDefinition 进行事务管理，在管理事务中产生一些状态.将状态记录到TransactionStatus中 PlatformTransactionManager接口实现类: DataSourceTransactionManager实现类:适用Spring的JDBC模板或者MyBatis（IBatis）框架 HibernateTransactionManager实现类:适用Hibernate的框架 常用方法: void commit(TransactionStatus status) TransactionStatus getTransaction(TransactionDefinition definition) void rollback(TransactionStatus status) TransactionDefinition包含的事务隔离级别的常量： static int ISOLATION_DEFAULT（采用数据库的默认隔离级别） static int ISOLATION_READ_UNCOMMITTED static int ISOLATION_READ_COMMITTED static int ISOLATION_REPEATABLE_READ static int ISOLATION_SERIALIZABLE 事务的传播行为：解决的是业务层之间的方法调用 事务的传播行为常量（不用设置，使用默认值，以A调用B为例）： PROPAGATION_REQUIRED（默认值） – A中有事务,使用A中的事务.如果没有，B就会开启一个新的事务,将A包含进来.(保证A,B在同一个事务中)，默认值！！ PROPAGATION_SUPPORTS – A中有事务,使用A中的事务.如果A中没有事务.那么B也不使用事务. PROPAGATION_MANDATORY – A中有事务,使用A中的事务.如果A没有事务.抛出异常. PROPAGATION_REQUIRES_NEW – A中有事务,将A中的事务挂起.B创建一个新的事务.(保证A,B没有在一个事务中) PROPAGATION_NOT_SUPPORTED – A中有事务,将A中的事务挂起. PROPAGATION_NEVER – A中有事务,抛出异常. PROPAGATION_NESTED – 嵌套事务.当A执行之后,就会在这个位置设置一个保存点.如果B没有问题.执行通过.如果B出现异常,运行客户根据需求回滚(选择回滚到保存点或者是最初始状态) spring框架事务管理的分类spring事务管理分为两类 Spring的编程式事务管理（不推荐使用）：通过手动编写代码的方式完成事务的管理 Spring的声明式事务管理（底层采用AOP的技术）：通过一段配置的方式完成事务的管理 Spring的编程式事务管理（了解）类图 持久层：实现JdbcDaoSupport，使用Spring提供的JdbcTemplate模板类实现JDBC操作 业务层：配置了TransactionTemplate类，该类是Spring用来简化事务管理的模板类 持久层 123456789101112131415161718192021222324252627282930313233343536373839404142public interface AccountDao &#123; void updateMoney(String name, double money); double queryMoney(String name);&#125;/** * 持久层，DAO实现类 * @author liisyu * @date 2019/3/1 */public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123; /** * 更新钱 * @param name * @param money */ @Override public void updateMoney(String name, double money) &#123; this.getJdbcTemplate().update("UPDATE t_account SET money = ? WHERE name = ?", money, name); &#125; /** * 查询钱 * @param name 查询账户 * @return 余额 */ @Override public double queryMoney(String name) &#123; Double aDouble = this.getJdbcTemplate().queryForObject("SELECT money FROM t_account WHERE name = ?", new AccountMapper(), name); return aDouble; &#125; /** * 查询映射器 */ class AccountMapper implements RowMapper&lt;Double&gt;&#123; @Override public Double mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return rs.getDouble("money"); &#125; &#125;&#125; 业务层 . 通过使用transactionTemplate.execute(new TransactionCallbackWithoutResult() {})，内部类方法体内的代码进行事务管理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface AccountService &#123; void transfer(String in, String out, double money);&#125;/** * @author liisyu * @date 2019/3/1 */public class AccountServiceImpl implements AccountService &#123;// 该类是Spring用来简化事务管理的模板类 private TransactionTemplate transactionTemplate; private AccountDao accountDao; public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123; this.transactionTemplate = transactionTemplate; &#125; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; /** * 用于模拟转账 * @param out 转出账户 * @param in 转入账户 * @param money 转移钱数 */ @Override public void transfer(String out, String in, double money) &#123; transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; @Override protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) &#123; //查询钱 double aMoney = accountDao.queryMoney(out); //扣钱 accountDao.updateMoney(out, aMoney - money);// System.out.println(1/0); //查询钱 aMoney = accountDao.queryMoney(in); //加钱 accountDao.updateMoney(in, aMoney + money); &#125; &#125;); &#125;&#125; 配置文件 配置连接池 配置业务层和持久层 配置事务管理器:DataSourceTransactionManager 配置事务管理器模板:TransactionTemplate 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!--设置C3P0连接池--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;db.driverClassName&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;db.url&#125;"/&gt; &lt;property name="user" value="$&#123;db.username&#125;"/&gt; &lt;property name="password" value="$&#123;db.password&#125;"/&gt; &lt;/bean&gt; &lt;!--配置bean--&gt; &lt;bean id="accountDao" class="com.liisyu.dao.impl.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;bean id="accountService" class="com.liisyu.service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;property name="transactionTemplate" ref="transactionTemplate"/&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--配置事务模板--&gt; &lt;bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate"&gt; &lt;property name="transactionManager" ref="transactionManager"/&gt; &lt;/bean&gt;&lt;/beans&gt; 声明式事务管理(重点掌握)声明式事务管理分为两种方式 基于AspectJ的XML方式（重点掌握） 基于AspectJ的注解方式（重点掌握） 基于AspectJ的XML方式实现在Spring的编程式事务管理的基础下，做如下改动 不再使用TransactionTemplate类来管理 利用AspectJ来切入事务通知达到事务管理的目的 具体做法如下 业务层不再需要TransactionTemplate类，只是一个普通的类 1234567891011121314151617181920212223242526272829303132/** * @author liisyu * @date 2019/3/1 */public class AccountServiceImpl2 implements AccountService &#123;// 该类是Spring用来简化事务管理的模板类 private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; /** * 用于模拟转账 * @param out 转出账户 * @param in 转入账户 * @param money 转移钱数 */ @Override public void transfer(String out, String in, double money) &#123; //查询钱 double aMoney = accountDao.queryMoney(out); //扣钱 accountDao.updateMoney(out, aMoney - money);// System.out.println(1/0); //查询钱 aMoney = accountDao.queryMoney(in); //加钱 accountDao.updateMoney(in, aMoney + money); &#125;&#125; 配置文件添加事务通知和AOP 123456789101112131415 &lt;!--事务通知--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;!--设置事务管理信息--&gt; &lt;tx:attributes&gt; &lt;!--查询使用read-only--&gt; &lt;!--&lt;tx:method name="query" read-only="true"/&gt;--&gt; &lt;!--增删改使用propagation="REQUIRED"事务传播行为,隔离级别选择DEFAULT--&gt; &lt;tx:method name="transfer*" propagation="REQUIRED" isolation="DEFAULT"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!--基于AspectJ + XML方式实现声明式事务--&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* *..*.*ServiceImpl2.*(..))"/&gt;&lt;/aop:config&gt; 基于AspectJ的注解方式实现（重点掌握）对于注解模式，在Spring的编程式事务管理的基础下，做如下改动 开启事务注解 12345678&lt;!--配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 使用@Transactional注解使用在类上，类中所有方法开启事务使用在方法上，单一方法开始事务 Spring-MVCSpringMVC是基于MVC设计模式的，MVC模式指的就是Model（业务模型）、View（视图）、Controller（控制器）。SpringMVC处理请求的过程就是通过MVC这三个角色的功能来实现的,且只针对表现层进行设计。 Spring-MVC组件以下组件通常使用框架提供的实现： DispatcherServlet：前端控制器用户请求到达前端控制器，它就相当于mvc模式中的C，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 HandlerMapping：处理器映射器HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 Handler：处理器Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 HandlAdapter：处理器适配器通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 View Resolver：视图解析器View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 View：视图springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp Spring mvc 执行流程 用户发送请求至前端控制器DispatcherServlet DispatcherServlet收到请求调用HandlerMapping处理器映射器。 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 DispatcherServlet通过HandlerAdapter处理器适配器调用处理器 HandlerAdapter执行处理器(handler，也叫后端控制器)。 Controller执行完成返回ModelAndView HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet DispatcherServlet将ModelAndView传给ViewReslover视图解析器 ViewReslover解析后返回具体View对象 DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet响应用户 注册DispatcherServlet方式为在web.xml中配置 设置了初始化参数contextConfigLocation,按指定路径加载配置文件 如果不指定初始化参数，它会默认加载/WEB-INF/${servlet-name}-servlet.xml(本例就是/WEB-INF/springmvc-servlet.xml) 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 注册HandlerMappingRequestMappingHandlerMapping(注解式处理器映射器): 对类中标记@ResquestMapping的方法进行映射 根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method 配置 123456&lt;!--注解映射器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;另一种配置功能更加强大,除了配置了方式一的RequestMappingHandlerMapping bean,还由其他bean(如注解式处理器适配器).```xml&lt;mvc:annotation-drivern /&gt; 注册Handler（处理器）处理器开发方式有多种：实现HttpRequestHandler接口、实现Controller接口、注解方式等。不过企业开发中，推荐使用注解方式开发处理器 注解方式必要的注解主要有以下两个 @Controller注解：在类上添加该注解，指定该类为一个请求处理器，不需要实现任何接口或者继承任何类。 @RequestMapping注解：在方法上或者类上添加该注解，指定请求的url由该方法处理。如果url-pattern配置的是*的话，url中的“”可以加也可以不加 (注解方式别忘记打开组件扫描) 处理器的返回值是ModelAndView对象，关于该对象，主要有两个功能 将数据存储到Request域中 设置响应视图，比如将视图设置为“/WEB-INF/jsp/item-list.jsp” 示例代码： 12345678910111213141516171819202122232425262728293031@Controllerpublic class ItemController &#123; @RequestMapping("/queryItem") public ModelAndView queryItem() throws Exception &#123; List&lt;Item&gt; itemList = new ArrayList&lt;&gt;(); //商品列表 Item item_1 = new Item(); item_1.setName("联想笔记本"); item_1.setPrice(6000f); item_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Item item_2 = new Item(); item_2.setName("苹果手机"); item_2.setPrice(5000f); item_2.setDetail("iphone6苹果手机！"); itemList.add(item_1); itemList.add(item_2); //创建modelandView对象 ModelAndView modelAndView = new ModelAndView(); //添加model modelAndView.addObject("itemList", itemList); //添加视图 modelAndView.setViewName("/WEB-INF/jsp/itemList.jsp"); return modelAndView; &#125;&#125; 注册HandlAdapter：处理器适配器RequestMappingHandlerAdapter(注解式处理器适配器) 对标记@ResquestMapping的方法进行适配 配置 12&lt;!--注解适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt; 另一种配置功能更加强大,除了配置了方式一的RequestMappingHandlerAdapter bean,还由其他bean（如注解式处理器映射器）. 1&lt;mvc:annotation-drivern /&gt; 注册View Resolver：视图解析器视图解析器配置 1234567&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 该视图解析器，默认的视图类就是JstlView，可以不写 --&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; InternalResourceViewResolver:支持jsp解析 viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包。此属性可以不设置，默认为JstlView refix 和suffix：查找视图页面的前缀和后缀，最终视图的址为：前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回的ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp” 完整的Spring-MVC示例相关依赖主要有 IOC相关依赖 MVC相关依赖 jstl依赖（用于jsp） maven-tomcat插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.liisyu&lt;/groupId&gt; &lt;artifactId&gt;mvc-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.7.RELEASE&lt;/spring.version&gt; &lt;maven.compiler.plugin.version&gt;3.8.0&lt;/maven.compiler.plugin.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring IOC 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring MVC依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring MVC依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!--maven的JDK编译级别--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;maven.compiler.plugin.version&#125;&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8081&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;!-- 放行main/resources下的配置文件 如果不放行spring mybatis等配置文件不会被打到包里从而导致错误 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 配置步骤 配置web.xml(创建DispatcherServlet,加载Spring配置文件) Spring配置文件(开启注解驱动,组件扫描,配置试图解析器) 创建处理器(Controller) web.xml配置配置前端控制器 设置了初始化参数contextConfigLocation,按指定路径加载配置文件 如果不指定初始化参数，它会默认加载/WEB-INF/${servlet-name}-servlet.xml(本例就是/WEB-INF/springmvc-servlet.xml) 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; sprinv-mvc.xml配置1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!--处理器扫描--&gt; &lt;context:component-scan base-package="com.liisyu.controller"/&gt; &lt;!-- 配置注解的适配器和映射器，同时还注入了很多其他的bean --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 显式的配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; 处理器处理器的创建方式有多种，如 实现HttpRequestHandler接口 实现Controller接口 注解的方式(推荐),需要注意以下两点类上加上@Controller注解（必须是Controller，可以通过源码找到答案）类上或者方法上面要加上@RequestMapping注解（必须的） 123456789101112131415161718192021222324252627282930313233343536373839/** * @author liisyu * @date 2019/3/2 */@Controllerpublic class DemoController &#123; @RequestMapping("queryItem") public ModelAndView queryItem() &#123; // 查询数据库，用静态数据模拟 List&lt;Item&gt; itemList = new ArrayList&lt;&gt;(); // 商品列表 Item item_1 = new Item(); item_1.setName("联想笔记本_3"); item_1.setPrice(6000f); item_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Item item_2 = new Item(); item_2.setName("苹果手机"); item_2.setPrice(5000f); item_2.setDetail("iphone6苹果手机！"); itemList.add(item_1); itemList.add(item_2); ModelAndView mvAndView = new ModelAndView(); // 设置数据模型,相当于request的setAttribute方法，实质上，底层确实也是转成了request（暂时这样理解） // 先将k/v数据放入map中，最终根据视图对象不同，再进行后续处理 mvAndView.addObject("itemList", itemList); // 设置视图(逻辑路径) mvAndView.setViewName("item/item-list"); // mvAndView.setViewName("/WEB-INF/jsp/item/item-list.jsp"); return mvAndView; &#125;&#125; POJO类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.liisyu.POJO;import java.util.Date;/** * @author liisyu * @date 2019/3/2 */public class Item &#123; private Integer id; private String name; private Float price; private String pic; private Date createtime; private String detail; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name == null ? null : name.trim(); &#125; public Float getPrice() &#123; return price; &#125; public void setPrice(Float price) &#123; this.price = price; &#125; public String getPic() &#123; return pic; &#125; public void setPic(String pic) &#123; this.pic = pic == null ? null : pic.trim(); &#125; public Date getCreatetime() &#123; return createtime; &#125; public void setCreatetime(Date createtime) &#123; this.createtime = createtime; &#125; public String getDetail() &#123; return detail; &#125; public void setDetail(String detail) &#123; this.detail = detail == null ? null : detail.trim(); &#125; @Override public String toString() &#123; return "Item [id=" + id + ", name=" + name + ", price=" + price + ", pic=" + pic + ", createtime=" + createtime + ", detail=" + detail + "]"; &#125;&#125; jsp(不需要看，只是使用的时候用到)item-edit.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;修改商品信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 上传图片是需要指定属性 enctype="multipart/form-data" --&gt; &lt;!-- &lt;form id="itemForm" action="" method="post" enctype="multipart/form-data"&gt; --&gt; &lt;form id="itemForm" action="$&#123;pageContext.request.contextPath &#125;/updateItem.do" method="post"&gt; &lt;input type="hidden" name="id" value="$&#123;item.id &#125;" /&gt; 修改商品信息： &lt;table width="100%" border=1&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="name" value="$&#123;item.name &#125;" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="price" value="$&#123;item.price &#125;" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;%-- &lt;tr&gt; &lt;td&gt;商品生产日期&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="createtime" value="&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td&gt; &lt;c:if test="$&#123;item.pic !=null&#125;"&gt; &lt;img src="/pic/$&#123;item.pic&#125;" width=100 height=100/&gt; &lt;br/&gt; &lt;/c:if&gt; &lt;input type="file" name="pictureFile"/&gt; &lt;/td&gt; &lt;/tr&gt; --%&gt; &lt;tr&gt; &lt;td&gt;商品简介&lt;/td&gt; &lt;td&gt;&lt;textarea rows="3" cols="30" name="detail"&gt;$&#123;item.detail &#125;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" align="center"&gt;&lt;input type="submit" value="提交" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; C:item-list.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/itemList.do" method="post"&gt;查询条件：&lt;table width="100%" border=1&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;商品列表：&lt;table width="100%" border=1&gt;&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;生产日期&lt;/td&gt; &lt;td&gt;商品描述&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt;&lt;c:forEach items="$&#123;itemList &#125;" var="item"&gt;&lt;tr&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/itemEdit.do?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 测试: 1tomcat7:run 打开localhost:8081/queryItem Controller返回值Controller返回值(不使用注解)Controller返回值可以是 ModelAndView类 void 返回字符串(推荐) 返回ModelAndViewcontroller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view 设置数据模型,相当于request的setAttribute方法，先将k/v数据放入map中，最终根据视图对象不同，再进行后续处理 123456ModelAndView mvAndView = new ModelAndView();mvAndView.addObject("itemList", itemList);// 设置视图(逻辑路径)mvAndView.setViewName("item/item-list"); void在controller方法形参上可以定义request和response 方法写法如下 123void doSomething(HttpServletRequest request,HttpServletResponse response)&#123; ...&#125; 通过request和response,进行Servlet操作 返回字符串返回字符串由三种表示方式 第一种： 返回逻辑视图名 1return "item/item-list" 想要传数据，则只需要传入Model参数，并对其进行操作 1234void doSomething(HttpServletRequest request,Model model)&#123; model.addAttribute(key, value); return "item/item-list";&#125; 第二种：redirect重定向 1return "redirect:testRedirect" 相当于“response.sendRedirect()”,且浏览器URL发生改变，Request域不能共享 第三种： forward转发 1return "forward:testForward" 相当于“request.getRequestDispatcher().forward(request,response)”,浏览器URL不发送改变,Request域可以共享 Controller返回值(使用注解)关于Controller返回值的注解，只要有 @ResponseBody @RequestBody @ResponseBody12@ResponseBodypublic Demo 该注解可以通过内置的9种HttpMessageConverter，匹配不同的Controller返回值类型，然后进行不同的消息转换处理。 将转换之后的数据放到HttpServletResponse对象的响应体返回到页面 不同的HttpMessageConverter处理的数据，指定的ContentType值也不同。 @RequestBody该注解的作用和@ResponseBody注解正好相反，它是处理请求参数的Http消息转换的。 常用的HttpMessageConverterMappingJacksonHttpMessageConverter： 专门处理POJO类型 默认使用MappingJackson的JSON处理能力，将后台返回的Java对象（POJO类型），转为JSON格式输出到页面 将响应体的Content-Type设置为application/json；charset=utf-8 StringHttpMessageConverter: 专门处理String类型 调用response.getWriter()方法将String类型的字符串写回给调用者 将响应体的Content-Type设置为text/plain；charset=utf-8 URL路径映射将@RequstMapping配置到方法上，进行URL路径的映射 123@RequestMapping(value="/item")或@RequestMapping("/item")//多个url 映射到同一方法上去@RequestMapping(value=&#123;"/item",”/queryItem”&#125;) 窄化请求映射将@RequstMapping配置到 class 类上，指定通用的请求前缀， 限制此类下的所有方法的访问请求url必须以请求前缀开头，通过此方法对url进行模块化分类管理。 如,想要访问add方法，那请求url必须是/item/add 1234567@RequestMapping(value="/item")class demo&#123; @RequestMapping("/add") public void add()&#123; ... &#125;&#125; 请求方法限定主要是限制客户端访问的请求方式 限定GET请求，,@RequestMapping(method = RequestMethod.GET) 限定POST请求，@RequestMapping(method = RequestMethod.POST) GET，POST都可以,@RequestMapping(method={RequestMethod.GET,RequestMethod.POST}) Spring整合第三方框架Spring-MyBatisSpring-Redis附录Xml配置文件1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro]]></title>
    <url>%2Fblog%2F2018%2F02%2F11%2FShiro.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Verification</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2Fblog%2F2018%2F02%2F10%2FServlet.all%2F</url>
    <content type="text"><![CDATA[Servlet基础Servlet规范是建立在HTTP规范基础上，HTTP 1.1规范支持OPTIONS、GET、POST、HEAD、PUT、DELETE以及TRACE等7中Web访问方式,只需要了解POST和GET即可 GET: 表示查询信息，URL中可以附带少量信息，URL总长度不超过255个字符，且参数会显示在浏览器地址栏 POST: 表示提交信息，一般用于大数据信息或者文件，长度不受限制，且参数不会显示在浏览器地址栏 Servlet 工作流程servlet 工作流程: 浏览器提交的请求是遵循HTTP协议的文本，而这段文本有服务器（以Tomcat为例）Tomcat接受并解析 Tomcat将请求封装成了HttpServletRequest类型的request对象。所有HTTP头数据都可以通过request相应的方法查询到 Tomcat把输出流封装为HttpServleteResponse类型的response对象，通过设置resonse属性就可以控制输出内容。 Tomcat的目录结构Web程序部署在Tomcat的/webapps下面 文件夹 描述 / Web应用根目录 /WEB-INF/ Tomcat会隐藏该文件夹下的所有文件，保护它们不能通过浏览器直接访问 /WEB-INF/web.xml 配置文件 /WEB-INF/classes class类文件都放在该文件下面，包括Servlet类 /WEB-INF/lib/ jar包存放 Servlet结构 接口/类 描述 ServletConfig 接口，在初始化期间将信息传递给servlet的servlet配置对象 Servlet 接口，定义所有servlet必须实现的方法 GenericServlet 抽象类，一个通用的与协议无关的servlet HttpServlet 抽象类，提供要创建子类的抽象类，以创建适合Web站点的HTTP Servlet CGIServlet 实现类，用于Web应用程序的CGI调用servlet，用于执行符合通用网关接口（CGI）规范的脚本 DefaultServlet 实现类，大多数Web应用程序的默认资源服务servlet ，用于提供静态资源，如HTML页面和图像 ServletConfig接口123456789101112 //返回此servlet实例的名称 public String getServletName(); //返回对调用者正在执行的ServletContext的引用 public ServletContext getServletContext(); //返回包含已命名的initialization参数，如果参数不存在，则返回null public String getInitParameter(String name); //返回servlet初始化参数的名称,保存在Enumeration对象中 public Enumeration&lt;String&gt; getInitParameterNames();&#125; Servlet 接口123456789101112131415161718public interface Servlet &#123; //初始化Servlet public void init(ServletConfig config) throws ServletException; //获取Servlet配置 public ServletConfig getServletConfig(); //允许servlet响应请求 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; //返回有关servlet的信息，例如author，version和copyright public String getServletInfo(); //由servlet容器调用，以向servlet指示servlet正在停止服务。只有在servlet的service方法中的所有*线程都已经退出或超过一段时间后，才会调用此方法 public void destroy();&#125; GenericServlet属性12//配置类private transient ServletConfig config 方法123456789101112131415161718192021222324252627282930Overridepublic String getInitParameter(String name) &#123; return getServletConfig().getInitParameter(name);&#125;@Overridepublic Enumeration&lt;String&gt; getInitParameterNames() &#123; return getServletConfig().getInitParameterNames();&#125;@Overridepublic ServletConfig getServletConfig() &#123; return config;&#125;@Overridepublic ServletContext getServletContext() &#123; return getServletConfig().getServletContext();&#125;@Overridepublic void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init();&#125;@Overridepublic String getServletName() &#123; return config.getServletName();&#125; HttpSerlvet主要看以下两个方法 12345678910111213141516171819202122//处理GET请求protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; String protocol = req.getProtocol(); String msg = lStrings.getString("http.method_get_not_supported"); if (protocol.endsWith("1.1")) &#123; resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg); &#125; else &#123; resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg); &#125;&#125;//处理POST请求protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String protocol = req.getProtocol(); String msg = lStrings.getString("http.method_post_not_supported"); if (protocol.endsWith("1.1")) &#123; resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg); &#125; else &#123; resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg); &#125;&#125; DefaultServlet默认的Serlvet类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void init() throws ServletException &#123; if (getServletConfig().getInitParameter("debug") != null) debug = Integer.parseInt(getServletConfig().getInitParameter("debug")); if (getServletConfig().getInitParameter("input") != null) input = Integer.parseInt(getServletConfig().getInitParameter("input")); if (getServletConfig().getInitParameter("output") != null) output = Integer.parseInt(getServletConfig().getInitParameter("output")); listings = Boolean.parseBoolean(getServletConfig().getInitParameter("listings")); if (getServletConfig().getInitParameter("readonly") != null) readOnly = Boolean.parseBoolean(getServletConfig().getInitParameter("readonly")); if (getServletConfig().getInitParameter("gzip") != null) gzip = Boolean.parseBoolean(getServletConfig().getInitParameter("gzip")); if (getServletConfig().getInitParameter("sendfileSize") != null) sendfileSize = Integer.parseInt(getServletConfig().getInitParameter("sendfileSize")) * 1024; fileEncoding = getServletConfig().getInitParameter("fileEncoding"); globalXsltFile = getServletConfig().getInitParameter("globalXsltFile"); contextXsltFile = getServletConfig().getInitParameter("contextXsltFile"); localXsltFile = getServletConfig().getInitParameter("localXsltFile"); readmeFile = getServletConfig().getInitParameter("readmeFile"); if (getServletConfig().getInitParameter("useAcceptRanges") != null) useAcceptRanges = Boolean.parseBoolean(getServletConfig().getInitParameter("useAcceptRanges")); // Sanity check on the specified buffer sizes if (input &lt; 256) input = 256; if (output &lt; 256) output = 256; if (debug &gt; 0) &#123; log("DefaultServlet.init: input buffer size=" + input + ", output buffer size=" + output); &#125; // Load the web resources resources = (WebResourceRoot) getServletContext().getAttribute( Globals.RESOURCES_ATTR); if (resources == null) &#123; throw new UnavailableException("No resources"); &#125; if (getServletConfig().getInitParameter("showServerInfo") != null) &#123; showServerInfo = Boolean.parseBoolean(getServletConfig().getInitParameter("showServerInfo")); &#125;&#125; CGIServlettodo 自定义Servlet实现想要实现Servlet,只需要继承HttpServlet,主要重写三个方法 doGet() doPost() getLastModified() 123456789101112131415161718192021222324/** * @author liisyu * @date 2019/3/5 */public class servlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); &#125; //返回该Servlet生成的文档的更新时间，对Get方式访问有效 //返回的时间为相对于1970.01.01 08:00:00的毫秒数 //返回值是-1则认为是实时更新，默认-1 @Override protected long getLastModified(HttpServletRequest req) &#123; return super.getLastModified(req); &#125; &#125; Servlet-配置主要配置 &lt; servlet &gt;:配置类 &lt; servlet-mapping &gt;：配置访问方式 配置serlvet定义完Servlet类后，还需要告诉Web容器该如何访问这个Servlet，而这个配置在web.xml中完成 &lt; servlet-name &gt;: 可取任意字符串，唯一,用于其他标签使用(如&lt; servlet-mapping &gt;) &lt; servlet-class&gt;: 配置Serlvet类 &lt; init-param &gt;: (可选)用于配置初始化参数 &lt; param-name &gt;: 配置参数名 &lt; param-value &gt;: 配置参数值 &lt; load-on-startup &gt;: 配置加载方式 值大于0: 在启动时加载该Servlet，值越小，优先级越高 值为0：在第一次请求时加载 123456789&lt;servlet&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.liisyu.servlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 配置servlet访问方式配置好servlet类后，需要配置对其的访问方式，使用&lt; serlvet-mapping &gt;标签 &lt; servlet-name&gt;: 指定引用的Serlvet名称，Servlet会使用该访问方式 &lt; url-pattern &gt;: 配置该serlvet的访问方式 如：/servlet,想要访问MyServlet，那么url为:http://localhost:8080/ + 项目路径(如/serlvet) + ${url-pattern} 允许通配符 ,代表任意字符,如 /servlet/FirstServlet.,表示可以访问任意后缀的FirstServlet 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/MyServlet.*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 获取配置的初始化参数值12// servlet方法getServletContext().getInitParam(String paramName) 上下文参数要想配置全局的参数，可以使用&lt; context-param &gt;标签 1234&lt;context-param&gt; &lt;param-name&gt;allowed fil type&gt;&lt;/param-name&gt; &lt;param-value&gt;.git, .jpg, .bmp&lt;/param-value&gt;&lt;/context-param&gt; 在java中获取全局上下文，可以使用 12// 属于servlet的方法getServletConfig().getServletContext(); Request请求请求会被封装成HttpServletRequest对象，包含了请求地址、请求参数等所有信息 1234//设置request编码方式req.setCharacterEncoding("UTF-8");//其他req.getxxx方法,太多，看API Response响应服务器对浏览器的响应会被封装成HttpServletResponse对象，要对浏览器操作，只需操作该对象123456789101112131415161718192021//设置response的编码方式resp.setCharacterEncoding("UTF-8");//设置文档类型为HTML类型resp.setContentType("text/html"); //设置文档类型为HTML类型resp.setContentType("image/jep");//设置文档类型为Wordresp.setContentType("application/msword");//获取字符型输出流，输出到浏览器PrintWriter writer = resp.getWriter();//二进制输出流，比方说输出图片ServletOutputStream outputStream = resp.getOutputStream();//输出writer.flush();outputStream.flush(); title: Servlet-资源tags: Servlet-资源categories: Servlet Servlet-表单信息GET方式提交的表单URL：路径 + “?”,各变量以 &amp; 相连 可能需要设置编码方式1req.setCharacterEncoding("utf-8"); 获取各变量以 &amp; 相连的部分1request.getQueryString() 获取表单信息1request.getParameter("name"); POST方式提交的表单URL: 不会变化 该方法只返回null1request.getQueryString() 获取表单信息1234//获取单个参数request.getParameter("name");//获取同名多个参数，返回数组request.getParameters("like"); javaweb-资源配置资源对于一些资源，可以在web.xml使用标签&lt; env-entry &gt;来配置（该标签只能配置java.lang包下的标准类型变量，即Stirng和八种基本变量） 12345&lt;env-entry&gt; &lt;env-entry-name&gt;name&lt;/env-entry-name&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt; &lt;env-entry-value&gt;liisyu&lt;/env-entry-value&gt;&lt;/env-entry&gt; 注入资源Servlet是如何获取web.xml的初始参数的？ 在java5.0后，引入了@Resource注解，可以帮我们将参数注射到Servlet类中(可注入java bean 、String、8大基础类) 12@Resource(name="name")private String name; 使用JDNI获取资源12Context context = new InitialContext();String name = (String)context.loolup("name"); 完整的生命周期概述： Tomcat在启动的时候，会根据loadn-on-startup的值来创建Servlet(大于1: 启动时初始化；等于0，第一次请求时初始化) Servlet对象会处理所有客户的请求，且为单例形式，只有当服务器关闭时，才销毁该对象 当多个客户端并发请求Servlet时，服务器会启动多个线程分别执行service()方法 相关方法 init (): Servlet通过该方法进行初始化 service：Servlet通过该方法处理客户端请求 destroy():通过该方法终止 JVM垃圾回收 init(): 创建和加载数据，这些数据存在于Serlvet的整个生命周期 只被调用一次 在Saerlvet第一次创建时调用 service(): 用于处理客户掉的请求，根据HTTP的请求类型，来觉得调用doGet()或doPost() 无需改动，修改方法直接重载doGet()或doPost() doGet(): 处理GET请求 doPost(): 处理POST请求 一种常用做法时在doPost()里调用doGet(),达到代码复用 destroy: 关闭数据库连接，停止后台线程，把Cooike列表或点击计数器写入磁盘，并执行其他类的清理 调用该方法后，Servlet对象被比标记为回收，等待JVM清理 重定向与跳转跳转(forword)跳转是通过RequestDispathcer对象的forward(aRequest, aResponse)方法来是实现的 实现一个简单的Serlvet跳转到另一个Serlvet123RequestDispatcher dispatcher = request.getRequestDispatcher("/servlet/HelloServlet");dispatcher.forward(request,response); 注：getRequestDispatcher()参数必须以”/“开始，表示Web根目录 此外，forword()跳转不止这一种 Servlet跳转到Servlet Servlet跳转到页面 Servlet跳转到文件(包括WEB-INF下的文件) 只要getRequestDispatcher()的参数路径不同，就可以跳转 重定向(Redirect):重定向是利用服务器返回的状态码来实现的。当客户掉浏览器请求服务器时，服务器端会返回一个状态码 设置状态码1response.setStatus(int stauss) 状态码解释 状态码 描述 1xx 信息状态码，表示请求已经被接受，正在处理 2xx 正确状态码，表示请求已被正确接受并处理，没有错误发生,如200(表示一切正常） 3xx 重定向状态码，如301（资源永久换位置,永久重定向）；302（资源临时换了地址,临时性重定向），通常服务器会发送HTTP Location来重定向到正确的新位置 4xx 请求错误状态码，如401(无权访问)，404(无资源)， 405(访问方式错误，如Servlet只接受Post访问) 5xx 服务器错误状态码，如500(程序出现异常而中途停止运行) CookieCookie常用属性 Cookie-编码对于编码，中文属于Unicode字符，占据4个字符，而英文数以ASCII字符，占据2个字符。 Cookie中要使用中文，可以使用java.net.URLEncoder类进行编码1234new Cookie( URLEncoder.encode("姓名", "UTF-8"), URLEncoder.encode("张三", "UTF-8") ) 对于解码，则使用java.net.URLDecoder类12URLDecoder.decode(aCookie.getName(), "UTF-8")URLDecoder.decode(aCookie.getValue(), "UTF-8") Cookie-有效期Cookie的maxAge控制着Cookie的有效期，单位为秒 获取: getMaxAge() 设置: setMaxAge() maxAge的值 正数：cookie会在${maxAge}秒之后自动消失，浏览器会将maxAge持久化写入到本地Cookies文件中 负数：仅在本浏览器窗口以及本窗口打开的子窗口有效，关闭窗口立即失效(maxAge默认-1) 0：表示立即失效，因为Cookie机制没有提供删除Cookie操作，一般都设置为0，失效的Cookieh会被浏览器从Cooike文件中删除 Cookie-删除与修改Cookie并不提供删除和修改 想要修改，只需要新建一个同名的Cooike，并添加到response中覆盖原有的Cooike 想要删除，只需仙剑一个同名的Cookie，将其maxAge属性设置为0，并添加到response中覆盖原有的Cooike 无论是修改还是Cookie，新建的Cookie除value、maxAge属性外，其他属性要一致。否则浏览器会将其视为不同的Cookie Cookie的不可跨域名性 Cookie在客户端由浏览器管理，它能保证A网站的Cookie只能由A网站使用，B网站无法使用，这就是不可跨域性 浏览器保证不可跨域名性是通过域名 正常情况下，即使是一级域名下的两个二级域名(如code.baidu.com、images.baidu.com),也是不共享Cookie的 Cookie设置共享使用的是Cookie的domain属性12//所有baidu.com名下的二级域名都可以使用该CookieaCookie.setDomain(&quot;.baidu.com&quot;); 注意:domain参数必须以 . 开始 想要为两个完全不同的域名设置共享Cookie，方式为 生成两个Cookie 生成的Cookie通过设置domain分别将对方域名添加进去 Cookie安全属性HTTP协议不光无状态，还不安全。使用HTTP协议的数据不经过任何加密就直接在网络上传播，有被截获的可能 不希望Cookie在HTTP等非安全协议中传输，可以设置secure属性12//浏览器将只会在HTTPS, SSL等安全协议中传输此CookieaCookie.setSecure(true); 注意secure属性并不是对Cookie加密,想要更高的安全性,还是需要对Cookie内容进行加密,解密 Cookie-编码对于编码，中文属于Unicode字符，占据4个字符，而英文数以ASCII字符，占据2个字符。 Cookie中要使用中文，可以使用java.net.URLEncoder类进行编码1234new Cookie( URLEncoder.encode("姓名", "UTF-8"), URLEncoder.encode("张三", "UTF-8") ) 对于解码，则使用java.net.URLDecoder类12URLDecoder.decode(aCookie.getName(), "UTF-8")URLDecoder.decode(aCookie.getValue(), "UTF-8") SessionSession除Cookie外的另一种记录客户状态的机制,当客户端访问服务器时,服务器会将客户端的信息以session的形式保存到服务器.客户端再次访问时,只需要从Session中寻找该客户的状态即可 Session 对应类为javax.servlet.http.HttpSession,属于key-value存储方式 获取Session1234// Session 不存在返回nullrequest.getSession();// Session不存在,如果aBoolean=true,新建一个Session再返回request.getSession(aBoolean); 设置/获取session属性12aSession.setAttribute(key, value);aSession. getAttribute(key); session常用方法 Servlet-session-生命周期生命周期 Session在客户端第一次请求时创建,需要注意的是只有在访问jsp,servlet等程序时才会创建(JSP底层时通过Servlet实现的),只访问HTML等静态资源时不会产生Session的;(为了获取高速度,Session一般保存在内存中) 当用户持续访问,服务器每次都会刷新Session的最后访问时间 用户每次访问服务器,服务器就会认为该用户的Session活跃了一次 如果Session长时间不活跃,服务器会从内存中删除Session Servlet-session-浏览器从浏览器到服务器来讲,Session需要浏览器的支持 因为HTTP的无状态性,Session需要通过Cookie来作为标识 服务器会自动向浏览器发送一个名为JSESSIONID的Cookie,它的值为该Session的id 该Cookie的maxAge为-1,仅在当前浏览器有效,且不同窗口不共享 注意新开的窗口会生成新的Session,但子窗口除外子窗口会公用父窗口的Session(右键-&gt;在新窗口打开,就是子窗口) Servlet-session-有效期Session的有效期 由maxInactiveInterval属性控制,一旦超时(从不活跃的时间算起),Session就会被删除 Tomcat中session默认时间为20分钟12aSession.setMaxInactiveInterval(int seconds);aSession.getMaxInactiveInterval(); session还提供了立即失效的方法1aSession.invalidate(); 此外,session超时时间可以通过web.xml来设置12345&lt;!-- web.xml --&gt;&lt;session-config&gt;&lt;!-- 单位:分 --&gt; &lt;session-timeout&gt;60&lt;/session-timeout&gt;&lt;/session-config&gt; 如果Cookie被禁用当某些浏览器并不支持Cookie或者Cookie被禁用的话,想要使用Session,需要进行URL地址重写 原理是将Session的id信息写到URL地址中 服务器通过解析URL获取Session的id 假设由如下URL1www.lalaal.com?name=li&amp;age=18 通过以下方法可以实现URL地址重1response.encodeURL("www.lalaal.com?name=li&amp;age=18"); 该方法会自动判断浏览器支不支持Cookie,如果不支持,则将Seesino的id重写到URL中,此时,URL可能变为1www.lalaal.com;jsessionid=0UIJHGIGGIOGIUGHJLJIUGI?name=li&amp;age=18 如果是页面重定向,则使用以下方法(效果与encodeURL()方法相同)1response.sendRedirect(repsonse.encodeRedirectURL("www.lalaal.com?name=li&amp;age=18")) Session手动禁止使用CookieJavaWeb通过配置来禁止Cookie,具体步骤为 打开META-INF(没有则自己创,该目录与WEB-INF同级) 打开context.xml(没有自己创),输入以下内容 12&lt;?xml version='1.0' encoding='UTF-8'&gt;&lt;Context path='/mywebpapp' cookie='false' /&gt; 也可以修改tomcat全局配置文件12&lt;!-- conf/context.xml --&gt;&lt;Context cookie='false' /&gt; 注意改配置只是禁止Session使用Cookie作为标识,斌不能阻止其他Cookie的读写 Session对比cookie 存储方式不同: Cookie只能保存ASCII字符,如果要存储Unicode或二进制数据,需要进行编码; Session可以存取任何类型数据,从基本类到Java类都没有问题 存储位置不同: Cookie存放客户端浏览器中 Session存放在服务器中 隐私安全不同: Cookie是对客户端可见的,恶意程序可能会复制,修改Cookie的内容; Session是服务器可见的,对客户端透明(所以Cookie不宜保存敏感信息,如账号密码) 有效期不同: Cookie可以通过setMaxAge(Integet.MAX_VALUE)来达到永久记录信息; Session无法永久记录信息,因为其依赖于Cookie,而该Cookie又是maxAge=-1,只要关闭了浏览器Session就会失效,且设置过长时间的Seesion会导致内存溢出 对服务器负担不同: Cookie是保存在客户端的,不占用服务器资源; Session保存在服务器内存中,如果访问用户多,会造成产生大量Session,消耗服务器大量内存 浏览器支持不同: Cookie一旦被禁用,就会失效;Cookie可以设置成本浏览器窗口和子窗口内有效(maxAge=-1),或所有浏览器窗口有效(maxAge&gt;0); Session只能在本浏览器窗口和子窗口有效;Session在Cookie被禁用的情况下,可以使用URL地址重写方式生效; 跨域名不同: Cookie支持跨域名访问(通过domain属性) Session只能在它所在的域名有效 过滤器(Filter)过滤器: 用于在Servlet之外对request和response进行修改 滤镜链(FilterChain): 包含多个过滤器 request抵达Servlet之前会先经过滤镜链中所有的过滤器 response从Servlet传送到客户端浏览器之前也会先经过滤镜链中所有的过滤器 Filter处理过程: Filter接口Filter接口：javax.serlvet.Filter Filter接口的三个方法 init() doFilter() destryo() 1234567891011121314151617public interface Filter &#123; /** *web程序启动时调用，用于初始化Filter *@param filterConfig 从该参数获取初始化信息，ServletContext */ public void init(FilterConfig filterConfig) throws ServletException; /** *过滤器具体处理方法 *@param chain 滤镜链，通过chain.doFilter(request, response)将请求传给下一个Filter或Servlet */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; public void destroy();&#125; 注:chain.doFilter(request, response)会将请求传递给chain中的下一个Filter直到所有Filter走完，则交给Servlet处理 Filter配置Filter需要配置在web.xml中才能生效,用法类似于Serlvet的配置 12345678910111213141516&lt;!-- web.xml --&gt; &lt;filter&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.liisyu.MyFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;param&lt;/param-name&gt; &lt;param-value&gt;param&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/jsp/*&lt;/url-pattern&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;/filter-mapping&gt; 在&lt; url-pattern &gt;标签中配置过滤规则，可以多个 在&lt; dispatcher &gt;标签中配置达到Servlet的方式 REQUEST: 表示仅当直接请求Serlvet时才生效,默认 FORWORD: 表示仅当某Servlet通过FORWORD到该Serlvet时才生效 INCLUDE: JSP相关 ERROR: JSP相关 注:必须同时满足&lt; url-pattern &gt;和&lt; dispatcher &gt;,才能使Filter生效多个Filter同时满足时，执行顺序按照&lt; filter-mapping &gt;的配置顺序执行 监听器（Listener）Listener用于监听Java web中的事件，例如创建、修改、删除Session、request、context等 当某一事件触发时（无需知道它怎么触发），就会调用相应的Listener(无需知道怎么调用)，开发者关心的是在Linstener中编写处理代码 配置监听器非常简单123456&lt;!-- web.xml --&gt;&lt;listener&gt; &lt;listener-class&gt; com.liisyu.listener.MyListener &lt;/listener-class&gt;&lt;/listener&gt; Servlet-Listener-分类Servlet 2.5规范中，共有8种监听器接口和6种事件 一类是监控对象的创建与销毁 HttpSessionListener: 监控Session的创建与销毁 ServletContextListener: 监控context的创建与销毁 ServletRequestListener: 监控request的创建与销毁 一类是监控对象的属性变化 HttpSessionAttributeListener ServletContextAttributeListener ServletRequestAttributeListener 一类是监听Session对象 HttpSessionBindingListener HttpSessionActivationListener 监控对象的创建与销毁HttpSessionListener: 创建Session时执行sessionCreated() 超时或执行session.invalidate()时执行sessionDestroyed() 可用于收集在线者的信息 ServletContextListener: 服务器启动或者热部署war包时执行contextInitialized()方法 服务器关闭或者只关闭该Web时执行contextDestroy()方法 可用于启动时获取web.xml里的配置参数 ServletRequestListener: 用户每次请求request都会执行requestInitailzed()方法 request处理完毕自动销毁前执行requestDestroy()方法 注意一个HTML中如果有多个图片，一次请求会出发多个request事件 监控对象的属性变化HttpSessionAttributeListener： 添加属性：执行sessionAdded() 更新属性：执行sessionReplaced() 删除属性：执行sessionRemoved() ServletContextAttributeListener 添加属性：执行contextAdded() 更新属性：执行contextReplaced() 删除属性：执行contextRemoved() ServletRequestAttributeListener 添加属性：执行requestAdded() 更新属性：执行requestReplaced() 删除属性：执行requestRemoved() 监听Session对象HttpSessionBindingListener: 当对象被放到Session里时执行valueBound() 当对象从Session里移除，执行valueUnbound() 对象必须实现了Listener HttpSessionActivationListener 服务器关闭时，会将Session内容保存到硬盘上（钝化过程），会执行sessionWillPassivate() 服务器启动时，会将Session内容从硬盘上重新加载,会执行sessionDidActivate() 对象必须实现了Listener]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reids]]></title>
    <url>%2Fblog%2F2018%2F02%2F09%2FRedis.all%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Reids</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mockito]]></title>
    <url>%2Fblog%2F2018%2F02%2F07%2Fmockito.all%2F</url>
    <content type="text"><![CDATA[maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; &lt;version&gt;2.25.1&lt;/version&gt;&lt;/dependency&gt; 静态导入工具包，方便使用1import static org.mockito.Mockito.*; Stub(桩/存根)桩：用来替换一部分功能的程序段。桩程序可以用来模拟已有程序的行为（比如一个远端机器的过程）或是对将要开发的代码的一种临时替代 如1234567# 建立一个LinkedList类型的mock对线 LinkedList mockedList = mock(LinkedList.class);# 存根 when(mockedList.get(0)).thenReturn("first");# 存根后，当执行mockedList.get(0)方法时，就返回定义的值 System.out.println(mockedList.get(0)); Mock对象的创建方式一：利用Class文件进行Mock创建1mock(SomeClass.class); 方式二：使用注解12345678//首先需要调用初始化方法，将测试类作为参数传入@Beforepublic void init()&#123; MockitoAnnotations.initMocks(this);&#125;//需要模拟化的类上使用@Mock注解@MockLinkedList mockedList; 论证参数匹配Mockito提供的匹配类: ArgumentMatchers123456789101112LinkedList mockedList = mock(LinkedList.class); // anyInt():ArgumentMatchers中的方法，表示参数可以是任何整数 when(mockedList.get(anyInt())).thenReturn("element"); System.out.println(mockedList.get(999)); //isValid(): 用户自定义的匹配方法，返回自定义的匹配器实现 //使用用户自定义的参数匹配方式 when(mockedList.contains(argThat(isValid()))).thenReturn("element"); //可以使用lambd表达式 //验证如何长度大于5的字符串 verify(mockedList).add(argThat(someString -&gt; someString.length() &gt; 5)); 需要注意的是，如果使用了参数匹配器，则所有参数都必须使用匹配器123456//正确，anyInt(), anyString(), eq()都是匹配器 verify(mock).someMethod(anyInt(), anyString(), eq("third argument")); //above is correct - eq() is also an argument matcher//错误，"third argument"并不是匹配器 verify(mock).someMethod(anyInt(), anyString(), "third argument"); 验证调用次数 123456789101112131415161718192021222324252627LinkedList mockedList = mock(LinkedList.class);//using mockmockedList.add("once");mockedList.add("twice");mockedList.add("twice");mockedList.add("three times");mockedList.add("three times");mockedList.add("three times");//默认验证一次，如下代码效果相同verify(mockedList).add("once");verify(mockedList, times(1)).add("once");//验证多次verify(mockedList, times(2)).add("twice");verify(mockedList, times(3)).add("three times");//验证从没执行过的verify(mockedList, never()).add("never happened");//验证至多/至少_次verify(mockedList, atLeastOnce()).add("three times");verify(mockedList, atLeast(2)).add("three times");verify(mockedList, atMost(5)).add("three times"); 按顺序验证验证一：单个Mock1234567891011List singleMock = mock(List.class);singleMock.add("was added first");singleMock.add("was added second");//为mock对线创建InOrderInOrder inOrder = inOrder(singleMock);//验证执行顺序，以下两个方法顺序互换，则报错inOrder.verify(singleMock).add("was added first");inOrder.verify(singleMock).add("was added second"); 验证二：多个Mock1234567891011121314//创建对各Mock对线List secondMock = mock(List.class);List firstMock = mock(List.class);firstMock.add("was called first");secondMock.add("was called second");////为多个Mock对线创建InOrderInOrder inOrder = inOrder(firstMock, secondMock);//将确保在secondMock.add之前调用firstMock.addinOrder.verify(firstMock).add("was called first");inOrder.verify(secondMock).add("was called second"); 查找冗余的调用个人理解：verifyNoMoreInteractions用于验证Mock方法调用后是否有验证，而如果只调用了方法啊，但没有验证的话，表明这个方法还处于交互状态。123456789//using mocksmockedList.add("one");mockedList.add("two");verify(mockedList).add("one");//following verification will fail// 下面的验证将会失败,mockedList.add("two");还处于交互状态verifyNoMoreInteractions(mockedList); 确保在模拟上从未发生过互动verifyZeroInteractions就是调用了verifyNoMoreInteractions方法，只是语义不同而已123456789//using mocks - only mockOne is interactedmockOne.add("one");//ordinary verificationverify(mockOne).add("one");//verify that other mocks were not interactedverifyZeroInteractions(mockTwo, mockThree); 连续调用（迭代器式存根）123456789101112131415LinkedList mockedList = mock(LinkedList.class);when(mockedList.add("some arg"))， .thenReturn(false)//thenReturn的返回类型与add返回类型相同 .thenReturn(true) .thenReturn(true);//第一次调用 输出falseSystem.out.println(mockedList.add("some arg"));//第二次调用 输出trueSystem.out.println(mockedList.add("some arg"));//第三次调用 输出true，如果接下来还有嗲用，继续执行最后一个存根System.out.println(mockedList.add("some arg")); 此外，还可以简写12when(mockedList.add(&quot;some arg&quot;)) .thenReturn(false, true, false); thenReturn() 使用具有相同匹配器或参数的多个存根而不是链接调用，则每个存根将覆盖前一个存根 使用回调函数进行存根使用thenReturn()或thenThrow()基本可以满足测试需求，但还可以通过通用的Answer接口来实现复杂的存根1234567891011when(mock.someMethod(anyString())).thenAnswer( new Answer() &#123; public Object answer(InvocationOnMock invocation) &#123; Object[] args = invocation.getArguments(); Object mock = invocation.getMock(); return "called with arguments: " + Arrays.toString(args); &#125;&#125;);//Following prints "called with arguments: [foo]"System.out.println(mock.someMethod("foo")); doReturn()| doThrow()| doAnswer()| doNothing()| doCallRealMethod()一系列方法 在存根为void时使用,如下使用异常对void方法进行存根 123456LinkedList mockedList = mock(LinkedList.class);//doXxxx().when().someMethod()doThrow(new RuntimeException()).when(mockedList).clear();//将会 throws RuntimeException:mockedList.clear(); 监视实例对象可以创建创建实例对象的Spy,当你使用Spy时，会调用真正的方法;但spy并不会将调用委托给实例对象，而是创建了它的副本。 12345678910111213141516171819202122//创建实例List list = new LinkedList();//创建实例的spyList spy = spy(list);//存根when(spy.size()).thenReturn(100);//使用spy来使用真正的add()方法spy.add("one");spy.add("two");//prints "one"System.out.println(spy.get(0));//size()输出存根：100//如果不size()方法没有存根，就会调用实例对象的方法System.out.println(spy.size());//spy也可以验证verify(spy).add("one");verify(spy).add("two"); 使用Spy 应该考虑与doXxxx联合使用12345678List list = new LinkedList();List spy = spy(list);//错误，spy.get(0)抛出IndexOutOfBoundsExceptionwhen(spy.get(0)).thenReturn("foo");//必须使用doXxxx进行存根doReturn("foo").when(spy).get(0); 真正的部分模拟(1.8)设置未存根方法的默认返回值(1.7)123Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); 捕获断言的参数(1.8)]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Mockito</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2Fblog%2F2018%2F02%2F06%2Fmaven.all%2F</url>
    <content type="text"><![CDATA[Maven基础介绍Maven安装MAVEN下载地址 maven下载有src(源码版本)和bin(二进制版本)，选择bin版本(注意，Maven依赖于JDK) 解压** 1sudo tar xzvf apache-maven-3.6.0-bin.tar.gz -C /opt 配置 1vim ~/.bashrc 添加 12export M2_HOME=/opt/apache-maven-3.6.0export PATH=$&#123;M2_HOME&#125;/bin:$PATH 测试 123mvn --version# 或mvn-v Maven目录 安装目录 目录名 说明 bin mvn相关脚本 boot 只包含plexus-classworlds文件,类加载器框架 conf 配置文件 lib JAVA类库文件 LICENSE * NOTICE * README.txt * ~/.m2 目录所有Maven构件都被存储到该仓库中，本地仓库默认存在于该目录下 Maven配置文件maven的配置文件存在于两个地方 全局，安装目录下，路径为M2_HOME/conf/settings.xml 用户范围，用户目录下，路径为 ~/.m2/settings.xml 坐标坐标用于jar包的查找，由groupId + artifactId + version组成，如下面代码是spring-context的坐标.packaging是一个可选选项，用于指定maven项目的打包方式 12345&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-context&lt;/artifactId&gt;&lt;version&gt;5.1.6.RELEASE&lt;/version&gt;&lt;packaging&gt;jar/war&lt;/packaging&gt; Maven的三种仓库仓库的查找顺序 本地仓库本地仓库会从远程仓库或中央仓库中下载jar包 自定义设置本地仓库位置：%maven%/conf/setting.xml 1234# 默认位置$&#123;user.home&#125;/.m2/repository# 自定义位置修改 &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; 远程仓库需要自己搭建 中央仓库中央仓库地址 配置阿里镜像在setting.xml中配置 1234567&lt;!-- 找到mirrors标签,在里面添加添加 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; Maven快速构建项目maven提供了很多archetype（原型），只要在命令行输入相应的参数，即可一键构建项目（第一次可能会很慢，因为需要下载各种插件） 如构建一个web项目 12345mvn archetype:generate \ -DarchetypeGroupId=org.apache.maven.archetypes \ -DarchetypeArtifactId=maven-archetype-webapp \ -DgroupId=com.mycompany.app \ -DartifactId=my-webapp 一般的maven项目目录结构如下 目录 说明 pom.xml 包含此项目的项目对象模型 $ {basedir} / src / main / java 应用程序源 $ {basedir} / src / test / java 测试源 $ {basedir} / target / classes 编译后的文件 在idea中新建一个Maven项目，也提供了许多原型 POM文件Pom文件是Maven的配置文件，通过它来进行jar包管理 元素 说明 project pom.xml的顶级元素 modelVersion POM使用的对象模型的版本,很少变化 groupId 创建项目的组织或组 artifactId 项目生成的artifact(通常是JAR文件)的唯一名称 packaging 指示aritfact要使用的包类型,默认jar version aritfact的版本，SNAPSHOT表示开发状态 name 项目显示名称，通常用于Maven生成的文档中 url 指示可以找到项目站点的位置。这通常用于Maven生成的文档中 description 项目的基本描述。这通常用于Maven生成的文档中 构建生命周期要理解Maven的生命周期，必须知道以下三个概念 构建生命周期 构建阶段 插件目标 以上3个概念，基本上是has-a的关系,如构建生命周期由多个构建阶段组成; 除此之外，还需要了解下不会在命令行调用的阶段 构建生命周期Maven 有3个内置的生命周期 default: 处理项目部署 clean：处理项目的清理 site：处理项目站点文档的创建 构建阶段构建生命周期中的每一个都由不同的构建阶段列表定义，其中构建阶段表示生命周期中的阶段 插件目标构建阶段由零个、一个或多个插件目标组成，表示特定任务如, clean 和 package为构建阶段， dependency:copy-dependencies是一个插件目标 1mvn clean dependency:copy-dependencies package 执行此操作，相当于先执行 clean阶段，然后在执行 dependency:copy-dependencies目标，最后再执行 package阶段。 不会再命令行调用的某个阶段此阶段是不会在命令行调用:以连字符（pre-，post- 或process- *）命名的阶段通常不会从命令行直接调用 设置项目使用构建生命周期打包package*在 &lt; packaging &gt;元素可以设置如jar、war、ear、pom等值，没有指定，默认为 jar。每一个包都包含一个绑定到特定阶段的目标列表，如 jar包将绑定以下目标以构建生命周期的阶段 (阶段)Phase （插件目标）plugin:goal process-resources resources:resources compile compiler:compile process-test-resources resources:testResources test-compile compiler:testCompile test surefire:test package jar:jar install install:install deploy deploy:deploy 插件除了像 package这样的默认绑定目标，在项目中配置插件是第二种向阶段添加目标的方式。插件就是一些 artifacts,用于提供目标,且插件可以具有一个或多个目标.如 Compiler插件，有两个目标 compile : 编译主代码 testCompile ：编译测试源码 如下，设置一个 modello插件该插件会将 modello:java 目标默认绑定到 generate-sources阶段 1234567891011121314151617181920... &lt;plugin&gt; &lt;groupId&gt;org.codehaus.modello&lt;/groupId&gt; &lt;artifactId&gt;modello-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;configuration&gt; &lt;models&gt; &lt;model&gt;src/main/mdo/maven.mdo&lt;/model&gt; &lt;/models&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;... 如果需要自己指定阶段display 插件会在 process-test-resources阶段执行目标 display:time 123456789101112131415... &lt;plugin&gt; &lt;groupId&gt;com.mycompany.example&lt;/groupId&gt; &lt;artifactId&gt;display-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;process-test-resources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;time&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;... 执行顺序多个目标绑定到特定阶段，则使用的顺序是首先执行打包(package)中的目标，然后执行POM中配置的目标 具体生命周期clean生命周期 构建阶段 描述 pre-clean 在实际项目清理之前执行所需的过程 clean 删除上一个版本生成的所有文件 post-clean 执行完成项目清理所需的过程 default生命周期 构建阶段 描述 validate 验证项目是否正确，并提供所有必要信息。 initialize 初始化构建状态，例如设置属性或创建目录。 generate-sources 生成任何包含在编译中的源代码。 process-sources 处理源代码，例如过滤任何值。 generate-resources 生成包含在包中的资源。 process-resources 将资源复制并处理到目标目录，准备打包。 compile 编译项目的源代码。 process-classes 从编译中对生成的文件进行后处理，例如对Java类进行字节码增强。 generate-test-sources 生成任何包含在编译中的测试源代码。 process-test-sources 处理测试源代码，例如过滤任何值。 generate-test-resourcess 创建用于测试的资源。 process-test-resources 将资源复制并处理到测试目标目录中。 test-compile 将测试源代码编译到测试目标目录中 process-test-classes 对来自测试编译的生成文件进行后处理，例如对Java类进行字节码增强。适用于Maven 2.0.5及以上版本。 test 使用合适的单元测试框架运行测试。这些测试不应要求打包或部署代码。 prepare-package 在实际包装之前执行准备包装所需的任何操作。这通常会导致包的解包，处理版本。（Maven 2.1及以上） package 获取已编译的代码并将其打包为可分发的格式，例如JAR。 pre-integration-test 在执行集成测试之前执行所需的操作。这可能涉及诸如设置所需环境之类的事情。 integration-test 如有必要，将程序包处理并部署到可以运行集成测试的环境中。 post-integration-test 执行集成测试后执行所需的操作。这可能包括清理环境。 verify 运行任何检查以验证包是否有效并符合质量标准。 install 将软件包安装到本地存储库中，以便在本地用作其他项目的依赖项。 deploy 在集成或发布环境中完成，将最终包复制到远程存储库以与其他开发人员和项目共享。 site生命周期 构建阶段 pre-site 在实际项目站点生成之前执行所需的过程 site 生成项目的站点文档 post-site 执行完成站点生成所需的进程，并准备站点部署 site-deploy 将生成的站点文档部署到指定的Web服务器 内置生命周期绑定构建阶段默认绑定的目标 clean生命周期绑定 Phase plugin:goal clean clean:clean default生命周期绑定packaging ejb / ejb3 / jar / par / rar / war Phase plugin:goal process-resources resources:resources compil e compiler:compile process-test-resources resources:testResources test-compile compiler:testCompile test surefire:test package ejb:ejb or ejb3:ejb3 or jar:jar or par:par or rar:rar or war:war install install:install deploy deploy:deploy packaging ear Phase plugin:goal generate-resources ear:generate-application-xml process-resources resources:resources package ear:ear install install:install deploy deploy:deploy Packaging maven-plugin Phase plugin:goal generate-resources plugin:descriptor process-resources resources:resources compile compiler:compile process-test-resources resources:testResources test-compile compiler:testCompile test surefire:test package jar:jar and plugin:addPluginArtifactMetadata install install:install deploy deploy:deploy Packaging pom Phase plugin:goal package install install:install deploy deploy:deploy site生命周期绑定 Phase plugin:goal site site:site site-deploy site:deploy maven依赖关系Scope依赖作用域Maven一共由三种classpath：编译Classpath、测试Classpath、运行Classpath compile（默认值）：在编译、运行、测试、打包都有效； provided：编译、测试时有效，运行、打包无效； test：仅在测试时有效； runtime：测试、运行、打包时有效； system：不推荐使用，使用system作用域不会去本地仓库寻找依赖，要指定本地路径； import: 导入依赖范围（不会对三种classpath产生实际影响） 依赖的传递性依赖传递：添加依赖的jar包如果还依赖其他jar包，则在添加时会一起引入但是对于不同的依赖范围，会由不同的依赖性传递。可选依赖不会传递 其规则如下 如A依赖B，B依赖C，B在A中的依赖范围为compile,C在B中的依赖范围为runtime，那么，C在A中的依赖范围为runtime 左：B在A中的依赖范围；上：C在B中的依赖范围 compile provided runtime test compile compile(*) - runtime - provided provided - provided - runtime runtime - runtime - test test - test - 依赖冲突如图所示，Base-project由3个子项目组成，A-project依赖Tools.jar 1.0版本，C-project依赖Tools.jar 2.0版本。Base-project同时依赖Tools.jar两个版本，但这造成了冲突 解决冲突方式一：依赖的最接近定义该方式无需任何设置，maven会自动优先选择路径较短的依赖，即Tools.jar 1.0 解决冲突方式二：直接添加可以直接在Base-project中指定依赖的版本 解决冲突方式三：依赖排除可以在Base-project中使用 &lt; exclusions &gt;标签，来排除不需要的依赖 12345678&lt;dependency&gt; ... &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artigactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; 解决冲突方式四：依赖管理使用依赖管理，将会锁定版本，并且锁定后其他地方无需再写版本号或者版本号无效，因为已经锁定了。需要注意的是，依赖管理不会下载依赖 123456789&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artgactId&gt; &lt;version&gt;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 可选依赖通过&lt; optional &gt;来设置依赖是否是可选依赖，可选依赖将不会传递。 12345678910111213&lt;project&gt; ... &lt;dependencies&gt; &lt;!-- declare the dependency to be set as optional --&gt; &lt;dependency&gt; &lt;groupId&gt;sample.ProjectA&lt;/groupId&gt; &lt;artifactId&gt;Project-A&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- value will be true or false only --&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 可选依赖的使用场景：主要是为了让项目实现多个特性，而这些特性是互斥的，即用户不可能同时使用特性。比如两个数据库的依赖。而真正使用时，依赖于该项目的其他项目肯定要明确声明使用的特性（建议能不用就不用） 过滤资源maven 只会把.java文件编译后放入target/classes文件夹，而忽略其他文件。所以，静态资源文件需要放行 如下 1234567891011121314151617&lt;project&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;!-- **表示所有层级 --&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 聚合与继承聚合聚合：使用一条命令即可构建多个模块，而不用到各个模块下使用mvn命令。用于快速构建多个模块 使用方式: 创建一个上级Maven项目 打包方式设置为pom 使用&lt; modules &gt;标签聚合其他模块 12345678&lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;&lt;artifactId&gt;my-webapp&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;modules&gt; &lt;module&gt;otherModule&lt;/module&gt; &lt;module&gt;otherModule2&lt;/module&gt;&lt;/modules&gt; 语句和方式运行命令时，Maven会线解析聚合模块的POM，分析要构建的模块，并计算出一个反应堆构建顺序，然后根据这个顺序一次构建各个模块 继承当模块之间存在类似于父子关系时，可以使用继承（父类声明的配置供子POM使用），以实现“一处声明，多出使用”的目的。主要用于重用配置 使用对于父类POM。只需要注意packaging为pom 123456&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;&lt;artifactId&gt;my-webapp&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;name&gt;my-webapp Maven Webapp&lt;/name&gt; 子类POM: 使用&lt; parent &gt;声明父模块，需要指定父模块的坐标 如果父模块在本地，可以使用&lt; relativePath &gt;指定父POM的相对路径，默认为../pom.xml（在项目构建时会先找相对路径的父模块，找不到再去本地仓库找） 123456789&lt;parent&gt; &lt;artifactId&gt;my-webapp&lt;/artifactId&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;artifactId&gt;children&lt;/artifactId&gt; 可继承的pom元素 groupId：项目组ID，项目坐标的核心元素； version：项目版本，项目坐标的核心元素； description：项目的描述信息； organization：项目的组织信息； inceptionYear：项目的创始年份； url：项目的url地址 develoers：项目的开发者信息； contributors：项目的贡献者信息； distributionManagerment：项目的部署信息； issueManagement：缺陷跟踪系统信息； ciManagement：项目的持续继承信息； scm：项目的版本控制信息； mailingListserv：项目的邮件列表信息； properties：自定义的Maven属性； dependencies：项目的依赖配置； dependencyManagement：醒目的依赖管理配置； repositories：项目的仓库配置； build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等； reporting：包括项目的报告输出目录配置、报告插件配置等。 Maven常用命令查看当前项目已解析依赖 1mvn dependency:list 查看当前项目已解析依赖树 1mvn dependency:tree 分析依赖,重点观察 [warning] 警告 1mvn dependency:analyze]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL深入]]></title>
    <url>%2Fblog%2F2018%2F02%2F05%2Fmysql.deep.all%2F</url>
    <content type="text"><![CDATA[基础架构》 MySQL基础架构示意图，MySQL分为Server层和存储引擎层两部分 》 Server层： 包括连接器、查询缓存、分析器、优化器、执行器等，蕴含MySQL大量核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等 多个存储引擎共用一个Server层 》 存储引擎层： 负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。 现在最常用的存储引擎是InnoDB,从MySQL5.5开始变为默认存储引擎 连接器》 负责跟客户端建立连接，获取权限、维持和管理连接。 》 一般的连接命令： 1mysql -h$ip -P$port -u$user -p 》 连接命令中的mysql是客户端工具，用来跟服务器连接。在完成经典的 TCP 握手后，连接器开始认证身份，然后输入密码 用户名或密码不对， “Access denied for user”的错误，然后客户端程序结束执行 认证通过，连接器从权限表查询出用户的权限。之后这个连接里的权限判断逻辑，都依赖于此时读到的权限(也就意味着建立连接后用户的权限被修改也不会影响当前连接，除非建立新的连接才会生效改动) 》 连接之后，可以用以下命令查看连接状态 1show processlist 》 Command显示 Sleep 这一列，表示当前用户处于空闲状态 》 对于空闲状态，客户端如果长时间没有动作，连接器是会自动断开它的，默认为8h，由 wait_timeout 参数控制 断开之后再发请求，会受到错误提示:”Lost connection to MySQL server during query”,此时需要重新连接了 数据库连接: 长连接：如果客户端持续有请求，则一直使用同一个连接 短链接：每次执行完很少的查询就断开连接，下次查询再重新建立连接 》 建立连接过程复杂，所以尽量使用长连接 缺点：有时候MySQL占用内存涨得特别快 原因：MySQL在执行过程中临时使用的内存管理在连接对象里面。这些资源会在断开连接时才释放。所以长连接累积下来，会导致内存占用过大，被系统强制杀掉（OOM），从现象看是MySQL异常重启 》 解决长连接内存占用过大问题 定期断开长连接，使用一段时间或程序里面执行过一个占用内存过大的查询后 MySQL5.7及以上的版本，可以在每次执行一个比较大的操作后，通过 mysql_reset_connection来重新初始化连接资源（不需要重复验证，但连接会恢复成最初状态） 查询缓存》 MySQL可能会将执行过的查询语句和结果，会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果执行的查询语句能够直接在这个缓存中找到key，如果能命中缓存，那么这个value就会被直接返回给客户端，这样效率会高很多 》 并不推荐使用！！！原因如下 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空 将参数query_cache_type设置成DEMAND关闭 MySQL8.0删除 分析器》 没有命中缓存，分析器会如下运作 先做“词法分析”，如从 SELECT 识别出这是一个查询语句，从t_table识别成表名t_table,把id识别成列id 再做”语法分析”,语法分析器会检查你的SQL语句是否满足MySQL语法,如果语法出错，会提示”You have an error in your SQL syntax” 优化器》 经过分析器之后，MySQL已经知道需要做什么，但在执行之前，需要优化。 》 优化器是在表里面有多个索引的时候，决定使用那个索引。或者在一个语句有多表关联（join）的时候，决定各个表达的连接顺序。 》 如下代码 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。 两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案 1mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 执行器》 执行器首先会判断是否有相应的权限，无则返回错误提示。 》 有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口，如下代码 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 1mysql&gt; select * from T where ID=10; 》 在慢查询日志中可以看到一个 rows_examined 字段，表示这个语句执行过程中扫面了多少行（也有可能不完全相同） 更新语句执行流程》 流程： 首先，在执行语句前要先连接数据库，即连接器的工作； 一旦在一个表上有更新，那么整个表相关的查询语句都会被清空（一般不建议使用查询缓存的原因） 分析器会通过词法和语法解析知道这是一条更新语句 优化器决定使用ID这个索引 执行器负责具体执行，找到这一行，然后更新 》 与查询不同之处，更新流程还涉及两个重要的日志模块 redo log（重做日志） binlog（归档日志） redo log(InnoDB特有)》 在MySQL里存在一个问题：如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。 》 MySQL为了解决这个问题，使用了WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘.具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存;同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。 》 InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写 》 write pos:当前记录的位置，一边写一边后移，到末尾后返回0位置;checkpoint:当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件;它们之间的距离代表着redo log剩余空间，如果没checkpoint和write pos没有距离，说明redo log已满，则需要擦除一些记录（即cehckpoint右移） 》 有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。也就是说当故障发生时，MySQL可以通过redo log记录的数据修改信息结合磁盘上的数据，来保证数据没有丢失。 》 参数设置 》 》 innodb_flush_log_at_trx_commit: 这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。建议设置成1，这样可以保证MySQL异常重启之后数据不丢失。 binlog》 与redo log日志的不同点 redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。 redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。 redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 binlog主要用于备份，而redo log主要用于崩溃恢复 》 Binlog有两种模式，statement模式的话是记sql语句， row模式会记录行的内容（两条，更新前和更新后） 》 参数设置 》》 sync_binlog:这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。建议设置成1，这样可以保证MySQL异常重启之后binlog不丢失。 InnoDB引擎update语句时的内部流程》 建表语句 1mysql&gt; create table T(ID int primary key, c int); 》更新语句,C+1 1mysql&gt; update T set c=c+1 where ID=2; 》流程： 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。 执行器生成这个操作的binlog，并把binlog写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。 》 流程图如下： 》 两阶段提交：redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。 为什么要两阶段提交》 以让数据库恢复到半个月内任意一秒的状态为例，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果数据库半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog,同时系统会定期做整库备份 》 当需要恢复到指定的某一秒时 首先，找到最近的一次全量备份进行恢复 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。 》 如果不用两阶段提交会怎么样? 先写redo log后写binlog:假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。 先写binlog后写redo log:如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。 以上两种情况在系统异常后，都无法保证库值的一致性 》 利用了两阶段提交后 redo log记录的日志，即使异常重启，也会刷新到磁盘 而bin log主要用于记录 当redo log 处于prepare,而bin log写入失败，事务就会回滚 而redo log 处于commit状态，即使发生异常，也会刷新到磁盘中 事务隔离》 SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ） 》 实例代码 12mysql&gt; create table T(c int) engine=InnoDB;insert into T(c) values(1); 》 在不同事务下，V1、V2、V3的返回值分别是 若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。 若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。 》 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。 在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的 读未提交”隔离级别下直接返回记录上的最新值，没有视图概念； “串行化”隔离级别下直接用加锁的方式来避免并行访问。 》 如果是Oracle数据库迁移到MySQL,因为Oracle默认隔离级别其实就是“读提交”,所以需要修改MySQL（将启动参数transaction-isolation的值设置成READ-COMMITTED） 》 查看当前事务隔离级别 1show variables like &apos;transaction_isolation&apos;; 事务隔离的实现》 在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。 》 如图所示，以下是”可重复读“的回滚日志，假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。 》 不同时刻启动的事务会有不同的read-view。如图中看到的，当前值是4，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC），对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到 》 当没有事务再需要用到这些回滚日志时，回滚日志会被删除。也就是说，当系统里没有比这个回滚日志更早的read-view的时候，回滚日志会被删除 》 尽量不要使用长事务 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间 在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小 事务的启动方式》 MySQL的事务启动方式有以下几种 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback set autocommit=0，这个命令会将这个线程的自动提交关掉。当执行一个SQL语句，就会启动事务，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接(如果是长连接，就会导致长事务！！) 》 所以，建议使用set autocommit=1，显示启动事务;通过以下方式提交，可以在提交之后，开启一个新的事务 1COMMIT WORK AND CHAIN; 》 此外，可以在information_schema库的innodb_trx这个表中查询长事务 12#查找持续时间超过60s的事务select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60 》 注意：》》 begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句（第一个快照读语句），事务才真正启动；如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot 这个命令 索引索引的常见模型》 三种常见索引数据结构 哈希表:适用于只有等值查询的场景,比如Memcached及其他一些NoSQL引擎 有序数组:只适用于静态存储引擎，比如要保存的是2017年某个城市的所有人口信息,这类不会再修改的数据 搜索树 InnoDB 的索引模型》 在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。每一个索引在InnoDB里面对应一棵B+树。 123456# 主键列为ID的表，表中有字段k，并且在k上有索引mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine=InnoDB; 》 表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下 》 从图中可以看出，索引类型分为两类 主键索引:主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index） 非主键索引:非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index） 》 基于主键索引和普通索引的查询的区别 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树； 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表 非主键索引的查询需要多扫描一棵索引树，所以尽量使用组件索引 索引维护》 B+树为了维护索引有序性，在插入新值的时候需要做必要的维护 》 主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小，从性能和存储空间方面考量，自增主键往往是更合理的选择 回表有如下初始化数据库语句： 12345678create table T (ID int primary key,k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT &apos;&apos;,index k(k))engine=InnoDB;insert into T values(100,1, &apos;aa&apos;),(200,2,&apos;bb&apos;),(300,3,&apos;cc&apos;),(500,5,&apos;ee&apos;),(600,6,&apos;ff&apos;),(700,7,&apos;gg&apos;); 》 执行如下查询语句 1select * from T where k between 3 and 5 》 它的执行流程如下 在k索引树上找到k=3的记录，取得 ID = 300； 再到ID索引树查到ID=300对应的R3； 在k索引树取下一个值k=5，取得ID=500； 再回到ID索引树查到ID=500对应的R4； 在k索引树取下一个值k=6，不满足条件，循环结束。 》 回到主键索引树搜索的过程，称为回表,可以看出上述查询回表了两次(2和4) 》 如何通过索引优化，避免回表？ 覆盖索引 最左前缀原则 覆盖索引》 如果将执行语句改为 1select ID from T where k between 3 an 》 这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表;在这个查询里面，索引k已经“覆盖了”我们的查询需求，称为覆盖索引 》 问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？ 12345678910CREATE TABLE `tuser` ( `id` int(11) NOT NULL, `id_card` varchar(32) DEFAULT NULL, `name` varchar(32) DEFAULT NULL, `age` int(11) DEFAULT NULL, `ismale` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`), KEY `id_card` (`id_card`), KEY `name_age` (`name`,`age`)) ENGINE=InnoDB 》 身份证号是市民的唯一标识,根据身份证号查询市民信息的需求，只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引,有以下好处 如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间 (注意：索引字段的维护总是有代价,，在建立冗余索引来支持覆盖索引时需要权衡考虑) 最左前缀原则》 如果为每一种查询都设计一个索引，索引将会过多 》 继续以市民表为例，当需求变为根据身份证号查询家庭地址（业务出现概率不频繁），普通做法有 直接走全表扫描(没有索引，慢) 单独为一个不频繁的请求创建一个（身份证号，地址）的索引（有索引，但索引会越来越多） 》 以上两种做法都太过于浪费，但B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录;最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符 》 如，使用（name，age）这个联合索引,可以看到，索引项是按照索引定义里面出现的字段顺序排序的 》 那么，想要查的是所有名字第一个字是“张”的人，SQL语句的条件是”where name like ‘张%’，这样做的好处就是 没有为name建立索引(减少了一个索引) 但是通过(name, age)索引加快了查询 所以我们在建立联合索引的时候,如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的 》 在回到根据身份证号查询家庭地址,业务上用的多的是(身份证，姓名)这个联合索引，完全可以通过使用“最左前缀”，加快查询 索引下推》 以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩” 1mysql&gt; select * from tuser where name like &apos;张%&apos; and age=10 and ismale=1; 》 没有索引下推优化前 从ID3开始一个个进行回表(InnoDB并不会去看age的值,只是按顺序把“name第一个字是’张’”的记录一条条取出来回表) 到主键索引上找出数据行 再对比字段值(age是否等于10，ismale) 》 在MySQL 5.6 引入的索引下推优化后 InnoDB在(name,age)索引内部就判断了age是否等于10,对于不等于10的记录，直接判断并跳过 等于10的值再回表 到主键索引上找出数据行 再对比字段值(ismale) 索引选择》 以市民系统为例，如果利用身份证做索引，但由于身份证号字段比较大，并不建议把身份证号当做主键，那么只能 创建唯一索引 创建普通索引 》 从性能的角度考虑，哪个更高？ 查询过程》 以上图为例，执行 1select id from T where k=5 》 搜索步骤 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索 》 InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB（linux内存页大小为4k） 》 因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。 》 如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。但是，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。 》 结论：两种索引对查询过程带来的性能差距不大 更新过程》 先了解什么是change buffer 当更新数据时，如果数据页在内存中就直接更新 如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，不执行从磁盘中读入这个数据页。在下次查询需要访问这个数据页的时候，将数据页读入内存，执行change buffer中操作 将change buffer中的操作应用到原数据页，得到最新结果的过程称为mergea. 访问数据页会触发merge(即2中的方式) b. 系统有后台线程会定期merge c. 在数据库正常关闭（shutdown）的过程中，也会执行merge操作 change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置（如50，表示change buffer的大小最多只能占用buffer pool的50%） 》 利用change buffer的好处 将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升 数据读入内存是需要占用buffer poo,这种方式还能够避免占用内存，提高内存利用率 》 唯一索引的更新就不能使用change buffer 所有的更新操作都要先判断这个操作是否违反唯一性约束(如要插入(4,400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断)，既然读入了内存，自然不需要change buffer 》 性能对比，对于数据页已经在内存中读入的，仅仅只是多了步判断，差别不大 对于唯一索引来说，找到3和5之间的位置，判断到没有冲突, 插入这个值，语句执行结束； 对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束 》 如果数据页没有在内存中读入 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束； 对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了 》 很明显，普通索引利用change buffer减少了随机磁盘访问，对更新性能的提升明显 》 结论：更新过程利用普通索引性能更好 正确的选择》 一般情况下，对于查询，无论时普通索引和唯一索引性能几乎无差，但对于更新操作，需要考虑如下 一般情况下，尽量选择普通索引 如果所有的更新后面，都马上伴随着对这个记录的查询,应该关闭change buffer change buffer 和 redo log》 关于redo log和WAL，请看SQL更新语句执行过程章节 》 WAL和change buffer提升性能的核心机制，也的确是尽量减少随机读写，概念容易混淆 》 执行如下语句,假设k1数据页在内存中，而K2数据页不在内存中 1mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2); 》 从图中可以看，该语句分为四个部分:内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1） 》 更新语句主要执行了以下操作 Page 1在内存中，直接更新内存； Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息 将上述两个动作记入redo log中（图中3和4） 》 该操作一共执行了两次内存写入（1、2），一次磁盘写入（3） ，且图中的两个虚线箭头，是后台操作，不影响更新的响应时间 》 之后，执行一次查询请求 1select * from t where k in (k1, k2) 》 如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关 》 如下图所示 读Page 1的时候，直接从内存返回 要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果，此时这个数据页才会被读入内存 》 两者区别在于: redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写） change buffer主要节省的则是随机读磁盘的IO消耗 索引错选》 在MySQL中一张表其实是可以支持多个索引的,但具体使用哪个索引，并不是使用者来指定，而是通过优化器的来选择的 索引错选示例》 建表语句: 12345678CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `b` (`b`)) ENGINE=InnoDB； 》 往表t插入10万行记录从(1,1,1)到(100000,100000,100000) 123456789101112delimiter ;;create procedure idata()begin declare i int; set i=1; while(i&lt;=100000)do insert into t values(i, i, i); set i=i+1; end while;end;;delimiter ;call idata(); 》 通过以下语句查看,使用的是a索引 1explain select * from t where a between 10000 and 20000; 》 接下来，如下图所示执行 Session A:开启事务 Session B:删除数据，调用存储过程重新插入10W行数据 1234567891011# Time: 2019-04-08T08:02:08.692765Z# User@Host: root[root] @ localhost [] Id: 4# Query_time: 0.009771 Lock_time: 0.000132 Rows_sent: 10001 Rows_examined: 10001SET timestamp=1554710528;select * from t where a between 10000 and 20000;# Time: 2019-04-08T08:02:14.660639Z# User@Host: root[root] @ localhost [] Id: 4# Query_time: 0.009404 Lock_time: 0.000126 Rows_sent: 10001 Rows_examined: 10001SET timestamp=1554710534;select * from t force index(a) where a between 10000 and 20000;​``` --&gt; MySQL中的锁》 根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类 全局锁》 全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 12#让整个库处于只读状态（FTWRL）Flush tables with read lock 》 使用该a命令后，以下语句被阻塞:数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句 》 全局锁的典型使用场景是，做全库逻辑备份; 》 但是让库只读，有以下弊端 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆； 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟 》 官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的(可重复读隔离级别可以获取一致性视图) 》 有了single-transaction，为什么还要FTWRL? 并不是所有的引擎都支持事务，如MyISAM，备份就需要FTWRL方法了。 》 另一种让全库进入只读状态的方法 1set global readonly=true 》 但是推荐使用FTWRL，原因： 在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大 在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。 》 事务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都是会被锁住的 表级锁》 MySQL里面表级别的锁有两种： 表锁 元数据锁（meta data lock，MDL) 表锁》 语法 1234# 加锁 lock tables &lt;table-name&gt; read/write[,&lt;table-name&gt; read/write]# 释放锁,断开连接时也会自动释放 unlock tables 》 注意：lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象,如在线程A中执行以下语句 其他线程写t1、读写t2的语句都会被阻塞 线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作 1lock tables t1 read, t2 write; MDL锁》 MDL(MySQL 5.5版本引入)不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。当对一个表做增删改查（DML）操作的时候，加MDL读锁；当要对表做结构变更操作(DDL)的时候，加MDL写锁 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行 》 给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据，如果对表进行操作不慎，会出现问题 》 如上图所示 Seesion A 启动，表会自动加上MDL读锁 Seesion B启动，需要的也是MDL读锁，正常执行 Session C启动，需要写锁，因为MDL读锁未释放，阻塞 （关键）Session D启动，因为Session C阻塞后会对之后对锁的请求进行阻塞，所以Session D也被阻塞(客户端有重试机制，超时后会再起一个新session再请求的话，这个库的线程很快就会爆满) 》 那么如何安全的执行DDL? 解决长事务：在DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务 设定等待时间：在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句(MariaDB/AliSQL 已经支持 NOWAIT/WAIT 语法) 123# 遗憾的是MySQL不支持ALTER TABLE &lt;tbl_name&gt; NOWAIT add column ...ALTER TABLE &lt;tbl_name&gt; WAIT N add column ... 行锁》 MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁.MyISAM引擎就不支持行锁,InnoDB是支持行锁;行锁就是针对数据表中行记录的锁 两阶段锁》 如下图所示，事务B的update语句会被阻塞(如果是MyISAM,不会阻塞，原因是只有表锁，DML语句都获取MDL读锁),这也说明了，事务A持有的两个记录的行锁 》 在InnoDB事务中，行锁是在需要的时候才加上的，而是要等到事务结束时才释放。这个就是两阶段锁协议。此外，行锁锁的是索引。 》 如何优化行锁？以电影票在线交易业务为例， 从顾客A账户余额中扣除电影票价； 顾客C要在影院B买票 给影院B的账户余额增加这张电影票价； 记录一条交易日志。 》 顾客A和C事务冲突，他们同时更新影院账户的余额，需要修改同一行数据。如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度;所以，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放 死锁和死锁检测》 如图所示 事务A等待事务B释放id=2的行锁 事务B等待事务A释放id=1的行锁 两者均处于等待对方的资源释放，就是进入了死锁状态 》 解决思索的策略 通过参数innodb_lock_wait_timeout来设置超时时间(默认50s) 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on（默认on），表示开启这个逻辑 》 对于第一种方案，时间设置过长显然不行，而时间设置过短，如果只是简单的等待而不是死锁，因此退出事务，那么就会误伤了 》 所以，正常情况下我们还是要采用第二种策略,但死锁检测存在一个问题，那就是要耗费大量的CPU资源 每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务 》 解决办法 如果能确保不发生死锁，可以临时关闭死锁检测（不推荐） 控制并发度，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低 》 对于控制并发度，一种是在客户端做并发控制，如每个客户端限制5个并发线程，但如果客户端数量过多，就不太行了。另一种是使用中间件，对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了；还有一种方法是将一条更新记录拆分成逻辑上的多行来减少锁冲突，但业务复杂度可能会大大提高 RR与行锁，隔离还是不隔离》对于RR隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样 》对于行锁，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，会被锁住，进入等待状态 》那么，如果事务进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么？ 》在MySQL里，有两个“视图”的概念： 一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。 另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。 快照在MVCC里是怎么工作的》 在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。（注意，这个快照是基于整库的） 在事务开始时，会向InnoDB事务系统申请一个唯一的事务ID，transaction id，该id按申请顺序严格递增 当每个事务更新数据时，会生成新的一个数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id 更新语句同时会生成undo log（回滚日志），用于获取到旧的数据 》 如下图是一行数据被多个事务连续更新后的状态（commit之后） 》 如图当前版本最新是V4，而V1,V2,V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的 》 那么，InnoDB是怎么定义那个“100G”的快照的？ InnoDB为每个事务构造了一个数组，用来保存所有启动了但还没提交的事务ID 组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位 》 那么，当启动一个事务时，一个数据版本的row trx_id,有以下几种情况 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；（低于低水位） 果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；（高于高水位） 如果落在黄色部分（数组部分），那就包括两种情况a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见 》 如何以后的更新，生成的版本肯定是在2或者3a条件下，即不可见 总结：对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况 版本未提交，不可见； 版本已提交，但是是在视图创建后提交的，不可见； 版本已提交，而且是在视图创建前提交的，可见。 实例解析1234567CREATE TABLE `t` ( `id` int(11) NOT NULL, `k` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;insert into t(id, k) values(1,1),(2,2); 》 如图所示结果为：事务B查到的k的值是3，而事务A查到的k的值是1（事务C没有begin/commit，表示这个update语句本身就是一个事务，语句完成的时候会自动提交；） 》 假设 事务A开始前，系统里面只有一个活跃事务ID是99； 事务A、B、C的版本号分别是100、101、102，且当前系统里只有这三个事务； 三个事务开始前，(1,1）这一行数据的row trx_id是90 》 可以看到 第一次更新操作由事务C完成，所以此时最新版本的row rex_id是102，90变为旧版本 第二次更新操作由事务B完成，此时最新版本的row rex_id是103 事务A开始读试图，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的a.找到(1,3)的时候，判断出row trx_id=101，比高水位大，处于红色区域，不可见； b.接着，找到上一个历史版本，一看row trx_id=102，比高水位大，处于红色区域，不可见； c.再往前找，终于找到了（1,1)，它的row trx_id=90，比低水位小，处于绿色区域，可见。 》 为什么事务B读出来的是(1,3)? 首先事务B创建试图肯定是先于事务C的 如果在更新之前执行一次查询语句，读出来的确是是(1,1) 但如果是更新操作，就会应用到一条规则：先读后写，而这个读，只能读当前的值，称为“当前读”（current read）a. 所以根据当前读的值，拿到的数据是(1,2),更新新版本后就是(1,3)了 SELECT 语句加锁实现当前读》 如果将A的查询语句加上lock in share mode 或 for update，也能读取版本号为101的数据 1234# 加了读锁（S锁，共享锁）select k from t where id=1 lock in share mode;# 加了写锁(写锁（X锁，排他锁）)select k from t where id=1 for update; 》 原理： 如果事务C更新语句且没有提交的话，那么必定会给该行添加了写锁 事务A添加读锁或者写锁，因为事务C而堵塞，直到事务C提交位置 以此事务B更新数据获取到行锁，如果事务C不提交的话，也会被堵塞 》 事务的可重复读的能力是怎么实现的？ 可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待 读提交》 读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图； 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图 事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻： (1,3)还没提交，属于情况1，不可见； (1,2)提交了，属于情况3，可见。]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2Fblog%2F2018%2F02%2F04%2Fmysql.all%2F</url>
    <content type="text"><![CDATA[命令行操作登录MySQL123mysql -u root -p //指定用户(-u)、密码登录(-p)、主机(-h,默认localhost)、端口(-P,3306)；mysql -u root -p -h myserver -P 9999 查看帮助文档12//例如查看指令**SELECT**help SELECT 退出操作123exit//或者quit 测试服务器》 查看mysql的一些基本信息： 1/usr/bin/mysqladmin -u root -p version 》 查看mysql的变量: 1/usr/bin/mysqladmin -u root -p variables 》 验证是否能关闭mysql: 1/usr/bin/mysqladmin -u root -p shutdown 》 再次启动Mysql: 1/usr/bin/mysqld_safe --user=mysql &amp; 》 查看数据库: 123/usr/bin/mysqlshow -u root -p//指定数据库则显示数据库中的表/usr/bin/mysqlshow -u root -p test 》 查看表中主句: 1/usr/bin/mysql -e "SELECT prod_name FROM products" -u root -p test 》 显示服务器状态： 1service mysql status 导入sql文件》 命令行模式： 12//（指定sql文件的完全路径）source [$&#123;path&#125;.*sql] 数据库相关操作创建数据库1CREATE DATABASE &lt;database-name&gt; [CHARACTER SET 字符集] 使用数据库1USE &lt;database-name&gt; 查看所有数据库1SHOW DATABASES; 显示创建数据库语句1SHOW CREATE DATABASE &lt;Databasee-name&gt; 删除数据库1DROP DATABASE &lt;database-name&gt; 查看正在使用的数据库1SELECT database() 表相关操作创建表12345678910CREATE TABLE &lt;table-name&gt; ( &lt;column-name&gt; 类型(长度) 约束, &lt;column-name&gt; 类型(长度) 约束);// 不存在则创建CREATE TABLE IF NOT EXISTS &lt;table-name&gt;( &lt;column-name&gt; 类型(长度) 约束, &lt;column-name&gt; 类型(长度) 约束) 》 约束 NULL或NOT NULL:在定义列时加入这两个关键字，表示允许NULL或不允许NULL,默认为NULL PRIMARY KEY (column1,column2 ): 定义主键/组合主键 AUTO_INCREMENT: 自动增量,每次执行INSERT，自动对该列增量，赋值下一个可用的值。可以在INSERT语句中插入指定值，只要是没有使用的，该值回代替自动生成的值。 DEFAULT &lt; value &gt;:指定默认值 查看当前数据库所有表:1SHOW TABLES; 显示创建表语句1SHOW CREATE TABLE &lt;table-name&gt; 查看表列(结构)1SHOW COLUMNS FROM &lt;table-name&gt; 查看表列另一种方式(效果一样)1DESCRIBE &lt;table-name&gt; 查看自动增量的值(该函数回获取最后一个AUTO_INCREATEMENT的值) 1SELECT last_insert_id() 修改表》 添加列 1ALTER TABLE &lt;table-name&gt; ADD &lt;column-name&gt; 类型(长度) 约束; 》 修改类类型、长度、约束 1ALTER TABLE &lt;table-name&gt; MODIFY &lt;column-name&gt; 类型(长度) 约束; 》 修改列名 1ALTER TABLE &lt;table-name&gt; CHANGE &lt;old-column-name&gt; &lt;new-column-name&gt; 类型(长度) 约束; 》 删除列 1ALTER TABLE &lt;table-name&gt; DROP &lt;column-name&gt; 》 修改表名 1RENAME TABLE &lt;old-table-name&gt; TO &lt;new-table-name&gt; 》 修改表的字符集 1ALTER TABLE &lt;table-name&gt; CHARACTER SET 字符集; 定义外键1234ALTER TABLE &lt;table-name&gt; ADD CONSTRAINT &lt;约束名称&gt; FOREIGN KEY(主表外键字段) REFERENCES 从表(从表主键) 》 示例： 123456789//外键属性//- fk_orderitems_orders：外键字段的名字//- FOREIGN KEY(order_num)：当前表的外键字段//- REFERENCES orders(order_num)：对应的表的字段(orders表的order_num字段)ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_ordersFOREIGN KEY(order_num) REFERENCES orders(order_num) 删除外键1ALTER TABLE DROP FOREIGN KEY 外键字段名 用户相关操作注意:日常开发不应使用root用户 获取所有账号列表,》 系统的 mysql 数据库存放了用户信息表 user 12USE mysql;SELECT user FORM user; 创建用户123CREATE USER 用户名 # 创建用户并指定密码CREATE USER 用户名 IDENTIFIED BY &apos;密码&apos; 重命名1RENAME USER 原名 TO 更改名 设置/更新密码1SET PASSWORD 》 示例1 ：设置指定用户密码， Password（） 函数加密 1SET PASSWORD FOR famel = Password(&apos;123456&apos;) 》 示例2 ：设置当前登录用户 1SET PASSWORD =Password(&apos;123456&apos;) 删除账号1DROP USER 用户名 》 查看用户权限(新用户没有任何权限，只能登录MySQL) 1SHOW GRANTS FOR 用户名 授权1GRANT 权限 ON 数据库.表 TO 用户 》 示例 123//赋予了 famle 用户关于数据库 crashcourse 下所有表的 SELECT 权限 GRANT SELECT ON crashcourse.* TO famel 授权多次,权限用 “,” 分隔 1GRANT SELECT, INSERT ON database.table TO famel; 删除权限1REVOKE 权限 ON 表 FROM 用户 》 GRENT 和 REVOKE 可以在几个层次上控制访问权限 整个服务器， GRANT ALL 和 REVOKE ALL 整个数据库, ON database.* 特定表, ON database.table 特定列 特定存储过程 可用权限 权 限 说 明 ALL 除GRANT OPTION外的所有权限 ALTER 使用ALTER TABLE ALTER ROUTINE 使用ALTER PROCEDURE CREATE 使用CREATE TABLE CREATE ROUTINE 使用CREATE PROCEDURE CREATE TEMPORARYTABLES 使用CREATE TEMPORARY TABLE CREATE USER 使用CREATE USER、DROP USER、RENAME USER和REVOKEALL PRIVILEGES CREATE VIEW 使用CREATE VIEW DELETE 使用DELETE DROP 使用DROP TABLE EXECUTE 使用CALL和存储过程 FILE 使用SELECT INTO OUTFILE和LOAD DATA INFILE GRANT OPTION 使用GRANT和REVOKE INDEX 使用CREATE INDEX和DROP INDEX INSERT 使用INSERT LOCK TABLES 使用LOCK TABLES PROCESS 使用SHOW FULL PROCESSLIST RELOAD 使用FLUSH REPLICATION CLIENT 服务器位置的访问 REPLICATION SLAVE 由复制从属使用 SELECT 使用SELECT SHOW DATABASES 使用SHOW DATABASES SHOW VIEW 使用SHOW CREATE VIEW SHUTDOWN 使用mysqladmin shutdown（用来关闭MySQL） SUPER 使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER和SET GLOBAL。还允许mysqladmin调试登录 UPDATE 使用UPDATE USAGE 无访问权限 SELECT查询语法》 通过DISTINCT关键字，将SELECT检索的结果，只返回不同值 123456SELECT [DISTINCT] &lt;column-name&gt;,&lt;column-name&gt;,... FROM &lt;table-name&gt; [WHERE 条件][GROUP BY][HAVING][ORDER BY][LIMIT] 查询原理》 单表查询原理 根据WHERE条件过滤表中的记录，形成中间表（用户不可见） 根据SELECT的选择列从中间表中选择相应的列进行返回最终结果 》 两表连接查询 对两表求积（笛卡儿积）并用ON条件和连接类型进行过滤形成中间表 根据WHERE条件过滤中间表记录 根据SELECT的选择列从中间表中选择相应的列进行返回最终结果 》 多表连接查询 先对第一个第二个表按照两表连接查询 查询结果和第三个表做连接，以此n+,知道所有表结束 最终形成一个中间表 根据WHERE条件过滤表中的记录，形成中间表（用户不可见） 根据SELECT的选择列从中间表中选择相应的列进行返回最终结果 别名查询123456//单列别名SELECT &lt;column-name&gt;,&lt;column-name&gt; AS &lt;alias-name&gt;,... FROM &lt;table-name&gt; //多列别名SELECT (&lt;column-name&gt;,&lt;column-name&gt;) AS &lt;alias-name&gt;,... FROM &lt;table-name&gt; //表别名SELECT &lt;column-name&gt;,&lt;column-name&gt; ,... FROM &lt;table-name&gt; AS &lt;alias-name&gt; 运算查询1SELECT &lt;column-name&gt;*10, &lt;column-name&gt;+20 AS &lt;alias-name&gt; ,... FROM &lt;table-name&gt; SELECT 子句SELECT 子句顺序 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在安祖计算聚焦时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 WHERE（位于ORDER BY之前）指定单个搜索条件12//WHERE 条件,条件由&lt;column-name&gt;、运算符、数据组成WHERE &lt;column-name&gt; 运算符 数据 WHERE 可用条件》 比较运算符： 运算符 描述 &gt;, &lt;, &lt;=, &gt;=, =, &lt;&gt; 大于、小于、小于等于、大于等于、等于，不等于 BETWEEN…AND 某区间的值（包含头尾） IN() 指定IN()中的特定值，如IN(100,200) LIKE ‘’ 模糊查询 IS NULL/IS NOT NULL 判空 》 逻辑运算符： 运算符 描述 AND 多条件同时成立 OR 多条件任一成立,优先级低于AND，可用()来提升优先级 NOT 否定其后的条,mysql仅支持对IN、BETWEEN、EXISTS句子取反 》 注： 字符串类型用单引号’’括起来 值与字符串类型比较时，字符串会转为值。系统采取截取方式，截取字符串前面的数值，如02asda那么就是02,而对于字母开头的,就直接转为0。 通配操作符LIKE》 % 通配符：匹配0、1或多个字符 12//找出所有以jet开头的数据WHERE prod_name LIKE 'jet%'; 》_ 通配符：匹配单个字符 12//将会匹配1 ton anvil,而不会匹配 .5 ton anvi WHERE prod_name LIKE '_ ton anvil' 》注: 尾空格会干扰通配符匹配。如anvil后多了一个或多个空格。”%anvil “将会不匹配到它，解决方法是在后面也加一个%. %anvil% 或使用函数去除。 %无法匹配NULL值，即”LIKE ‘%’”不会匹配到值NULL的行。 不要过度使用通配符，能使用其他操作符就使用其他操作符 通配符置于开始，搜索最慢（即尽量不要使用在开头） 正则表达式REGEXP》 MySQL用WHERE子句对正则表达式提供了支持,其用法与LIKE相似 进行OR匹配：使用 “|” 12//将匹配到包含1000或2000的行,两个以上则1000|2000|3000| WHERE prod_name REGEXP '1000|2000' 》 匹配几个字符之一,使用” [] “ 12//[123]表示匹配1或2或3，是[1|2|3]的缩写，[^123]将匹配除这几个字符外的任何数据。[]相当于一个字符集合。WHERE prod_name REGEXP '[123] ton' 》 匹配范围 12345[a-z][A-Z]：匹配字母 [0-9]: 匹配数字[a-z0-9]：组合使用 》匹配特殊字符,使用\ \ 123456如想要匹配点&quot;.“，则REGEXP &apos; \ \ . &apos;,也可以用来引用元字符，如 \ \ f：换页 \ \ n：换行 \ \ r：回车 \ \ t：制表 \ \ v：纵向制表 》 匹配字符类,即自定义的字符集称为字符类 1234567891011[:alnum:]：任意字符和字母（同[a-zA-Z0-9]） [:alpha:]：任意字符(同[a-zA-Z]) [:blank:]：空表和制表(同[\\t]) [:cntrl:]：ASCII控制符(ASCII 0到31和127) [:digit:]：任意数字（同[0-9]） [:graph:]：任意可打印字符，与[:print:]相同，但不包括空格 [:lower:]：任意小写字母(同[a-z]) [:print:]：任意可打印字符，与[:graph:]相同，且包括空格 [:punct:]：即不再[:alnum:]也不再[:cntrl:]中的任意字符 [:upper:]：任意大写字母（同[A-Z]） [:xdigit:]：任意十六进制数字(同[a-fA-F0-9]) 》 匹配多个实例，通过正则表达式重复元字符完成 1234567如[0-9][0-9][0-9][0-9]相当于[0-9]&#123;4&#125;相当于[:digit:]&#123;4&#125; &quot;*&quot;：0个或1个或多个 &quot;+&quot;：1个或多个，相当于&#123;1,&#125; &quot;?&quot;：0个或一个，相当于&#123;0,1&#125; &quot;&#123;n&#125;&quot;：n个 &quot;&#123;n,&#125;&quot;：n个或多于n个 &quot;&#123;n,m&#125;&quot;：n~m个 》 定位符，匹配特定位置的文本 12345如^[0-9\\.]，匹配以数字或小数点开始。(注意^的位置，如果是在集合里[^0-9\\.],则是否定该集合) &quot;^&quot;：文本的开始 &quot;$&quot;：文本的结尾 [[:&lt;:]]：词的开始 [[::]]：词的结尾 LIKE与RNGEXP的不同123456//匹配整个列的值，即要完全匹配LIKE &apos;1000&apos;//该值只要在列中出现，则匹配REGEXP &apos;1000&apos;//想要匹配整个列REGEXP &apos;^1000$&apos; GROUP BY(WHERE子句之后，ORDER BY之前)1GRPUP BY &lt;column-name&gt; 》 创建分组,通过GROUP BY将数据按vend_id分组后，COUNT（*）将会对分组后的数据分别计算一次。 123SELECT vend_id, COUNT(*) AS num_prodsFROM productsGOURP BY vend_id HAVING》 HAVING WHERE是过滤行，而HAVING是过滤分组 WHERE是在分组前过滤，而HAVING是在分组后过滤 HAVING支持所有WHERE操作符 12345//过滤分组,按cust_id分组，然后过滤出行数大于等于2组。SELECT cust_id, COUNT(*) AS ordersFROM ordersGROUP BY cust_idHAVING count(*) = 2 ORDER BY（位于 WHERE 之后）》 ORDER BY： DESC:降序 ASC:升序(默认) 12345ORDER BY &lt;column-name&gt; [DESC/ASC]//按多个列进行排序（先根据列1排，在根据列2排）ORDER BY &lt;column-name&gt;,&lt;column-name2&gt; [DESC/ASC]//指定排序方向的多个列排序，DESC/ASC只应用到直接位于其前面的列名ORDER BY &lt;column-name&gt; [DESC/ASC],&lt;column-name2&gt; [DESC/ASC] 》 ORDER BY 子句中使用的列通常为要显示的列，但用非检索的列排序数据也是完全合法的 LIMIT》 MySQL特有的语法，实现了物理分页 》 物理分页：直接在数据库中进行分页，最终只返回分页后的数据 12345//offset:起始位置//rows:每页多少行SELECT * FROM &lt;table-name&gt; LIMIT [offset,] rows;//另一种写法SELECT * FROM &lt;table-name&gt; LIMIT rows OFFSET [offset]; 》 示例 12//从第2位置开始返回3行(（第一行为0)：LIMIT 2,3 子查询》 又叫内部查询，即嵌套在其他查询中的查询；包含内部查询的被成为外部查询 利用子查询过滤》 将一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句 12345SELECT cust_idFROM ordersWHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &apos;TNT2&apos;) 作为计算字段使用子查询1234567SELECT cust_name, cust_state. (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS ordersFROM customersORDER BY cust_name 组合查询 UNION》 使用组合查询的两种情况 在单个查询中从不同的表返回类似结构的数据 对单个表执行多个查询，按单个查询返回数据 》 创建组合查询:如，通过UNION连接两个SELECT 1234567SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;=5UNIONSELECT vend_id, prod_id, prod_priceFROM productsWHERE vend_id IN(1001, 1002) 》 UNION规则 UNION必须由两条或以上SELECT语句组成，语句之间用UNION分割 UNION中的每个查询必须包含相同列、表达式或聚集函数（次序可以不同） 列数据列下必须兼容。（可不必完全相同，但必须隐含转换的类型） 》 包含或取消重复的行 UNION：自动去除重复的行 UNION ALLL：返回全部的行 》 对组合查询结果排序： 在最后一个SELECT后面加ORDER BY，将排序所有SELECT语句返回的结果。 全文本搜索》 搜索text数据（MyISAM支持，InnoDB不支持） 》 启用全文本搜索FULLTEXT Mysql会根据FULLTEXT（）的指示对它进行索引，自动维护该索引。在增加、更新或删除行时，索引随之自动跟新。 可以在创建表时指定FULLTEXT（不推荐），也可以稍后指定。 先导入数据，在定义FULLTEXT，有助于更快导入索引（更新索引需要时间） 123456789CREATE TABLE productnotes( note_id int NOT NULL ATUO_INCREMENT, prod_id char(10) NOT NULL, note_date datetime NOT NULL, note_nect text NULL, PRIMARY KEY(note_id), FULLTEXT(note_text)) ENGINE = MyISAM 》 进行全文本搜索Match()和Against() Match()指定所搜的列 Against()指定搜索表达式 12345//如，将会搜索包含rabbit的文本,不区分大小写SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit') 》 与LIKE的区别 LIKE以不特别有用的顺序返回数据 全文本搜索返回以文本匹配的良好程度排序的顺序(如rabbit作为第3个词的行等级比作为第20个词的行高) 》 查询扩展WITH QUERY EXPANSION 用来放宽返回的全文本搜索结果的范围 首先进行基本的全文本搜索，找出匹配的行， 其次，检查这些匹配行并选择所有有用的词，最后，再次使用有用的词进行一次全文本上搜索。 123SELECT note_textFROM productnotesWHERE Match(note_text) Against(&apos;anvils&apos; WITH QUERY EXPANSION) 》 布尔文本搜索IN BOLEAN MODE，可以提供内容细节 要匹配的词 要排斥的词（如果某行包含这个词，则不反回改行。即使包含匹配的词） 排列提示（指定某些词比其他词更重要） 表达式分组 另外一些内容 12345//匹配heavy,但排除任何以rope开始的词或行SELECT note_textFROM productnotesWHERE Match(note_text) Against ('heavy -rope*' IN BOOLEAN MODE) 》 全文本布尔操作符 12345678+：包含，词必须存在-：排除，词必须不出现：包含，而且增加等级&lt;：包含，而且减少等级()：把词组成子表达式（允许子表达式作为一个组被包含、排除、排列）~：取消一个词的排序值*：词尾通配符&quot;&quot;：定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语） 》 示例1 12345//包含rabbit和bait的行SELECT note_textFROM productnotesWHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE) 》 示例2: 12345//至少包含rabbit和bait其中一个的行SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE) 》 示例3: 12345//匹配短语rabbit bait而不是匹配两个词SELECT note_textFROM productnotesWHERE Match(note_text) Against('"rabbit bait"' IN BOOLEAN MODE) 》 示例4: 12345//至少包含rabbit和bait其中一个的行，增加rabbit的等级，降低bait的等级SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit &lt;bait' IN BOOLEAN MODE) 》 示例5 12345//至少包含safe 和combination其中一个的行，降低combination的等级SELECT note_textFROM productnotesWHERE Match(note_text) Against('+safe +(&lt;combination)' IN BOOLEAN MODE) 》 全文本搜索使用说明 在索引全文本数据时，短词被忽略且从索引中排除。（短词：3个或3个一下字符的词） MySQL带有一个内建的非用词列表，这些词在索引时被忽略 高频词汇会被当做非用词（一个词出现在50%以上的行,该规则不用于IN BOOLEAN MODE） 如果表中的行数少于3行，则全文本搜索不反回结果(要么没有，要么至少出现在50%行中) 忽略此种的单引号。如don’t索引为dont 不具有此分隔符的语言不能恰当地返回全文本搜索结果（汉语、日语） 仅在MyISAM引擎中支持全文本搜索 INSERT插入完整的行》 插入规则： 列可以不按次序，但值与列次序一一对应，没有值的使用NULL值 可以省略某些列，但该列必须允许NULL值或在表定义中给出了默认值 提高性能：INSERT INTO耗时，且可能降低等待处理的SELECT语句的性能。如果数据检索是最重要的，可以使用INSERT LOW_PRIORITY INTO来降低INSERT语句的优先级(同样适用UPDATE和DELETE) 1234567891011INSERT INTO &lt;table-name&gt;( &lt;column-name&gt;, &lt;column-name2&gt;, &lt;column-name3&gt;， ... ) VALUES( &lt;value&gt;, &lt;value&gt;, &lt;value&gt;, ... ) 插入多个行》 每组值用一堆圆括号括起来，用逗号分隔 12345678910111213141516171819INSERT INTO &lt;table-name&gt;( &lt;column-name&gt;, &lt;column-name2&gt;, &lt;column-name3&gt;， ...)VALUES( &lt;value&gt;, &lt;value&gt;, &lt;value&gt;, ...),( &lt;value&gt;, &lt;value&gt;, &lt;value&gt;, ...),... 插入检索出的数据:123456INSERT INTO &lt;table-name&gt; ( &lt;column-name&gt;, &lt;column-name2&gt;, &lt;column-name3&gt;， ...) SELECT * FROM &lt;table&gt; UPDATE》 使用前特别注意！： 不要省略WHERE子句，因为稍不注意，可能更新表中所有行 更新数据12345678910111213141516171819UPDATE &lt;table-name&gt; SET &lt;column-name&gt;=&lt;value&gt;, &lt;column-name2&gt;=&lt;value2&gt;, &lt;column-name3&gt;=&lt;value3&gt;, &lt;column-name4&gt;=&lt;value4&gt;, ... WHERE 条件;//忽略错误，继续更新(UPDATE在更新时如果出现错误，整个操作都会被取消)UPDATE INGNORE &lt;table-name&gt; SET &lt;column-name&gt;=&lt;value&gt;, &lt;column-name2&gt;=&lt;value2&gt;, &lt;column-name3&gt;=&lt;value3&gt;, &lt;column-name4&gt;=&lt;value4&gt;, ... WHERE 条件;//删除某个列的值,可以将其设置为NULL&lt;column-name&gt;=NULL DELETE使用前特别注意！！！ 不要省略WHERE子句，因为稍不注意，可能删除表中所有行 DELETE删除的是整行。想要删除列，还是要用UPDATE 删除行123DELETE FROM &lt;table-name&gt; WHERE 条件;//删除所有行DELETE FROM &lt;table-name&gt;; 更快的全部删除1TRUNCATE TABLE &lt;table-name&gt; 》 区别： TRUNCATE实际上是删除原表重新创建，而不是逐行删除,清空AUTO_INCREMENT记录数 DELETE是一条一条删除，不清空AUTO_INCREMENT记录数 更新和删除所遵循的习惯》 规则如下： 除非打算更新和删除所有行。否则不要用不带WHERE的UPDATE、DELETE语句 保证每个表都有逐渐，尽可能像`WHERE子句那样使用它 对UPDATE和DELETE语句使用WHERE子句前，先使用SELECT进行测试，保证正确的记录。 使用强制实施完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。 MySQL没有撤销按钮，所以要小心使用UPDATE和DELETE 函数常用的文本处理函数123456789101112Concat(): 拼接字段Left()：返回串左边的字符Length()：返回串的长度Lecate()：找出串的一个子串Lower()：将串转换为小写Upper()：将串转换为大写LTrim()：去掉串左边的空格RTrim()：去掉串右边的空格Trim()：去掉串两边的空格Right()：返回串右边的字符Soundex()：返回串的SOUNDEX值SubString()：返回子串的字符 常用时间和日期处理函数1234567891011121314151617AddDate()：增加一个日期（天、周等）AddTime()：增加一个时间（时、分等）CurDate()：返回当前日期CurTime()：返回当前时间Date()：返回日期时间的日期部分DateDiff()：计算两个日期之差Date_Add()：高度灵活的日期运算函数Date_Format()：返回一个格式化的日期或时间串Day()：返回一个日期的天数部分DayOfWeek()：对于一个日期，返回对应的星期几Hour()：返回一个时间的小时部分Minute()：返回一个时间的分钟部分Month()：返回一个日期的月份部分Now()：返回当前日期和时间Second()：返回一个时间的秒部分Time()：返回一个日期时间的时间部分Year()：返回一个日期的年份部分 》 检索日期 1234//假设order_date数据类型datetime，其格式为2005-09-01 21:21:53,所以需要使用Date()来提取order_date的日期部分SELECT cust_id, order_numFROM ordersWHERE Date(order_date) = '2005-09-01' 》 注意： 日期格式必须为 yyyy-mm-dd ,如2005年9月1日，则- 2005-09-01 数值处理函数123456789Abs()：返回一个数的绝对值Cos()：返回一个角度的余弦Exp()：返回一个数的指数值Mod()：返回一个除操作的余数Pi()：返回圆周率Rand()：返回一个随机数Sin()：返回一个角度的正弦Sqrt()：返回一个数的平方根Tan()：返回一个角度的正切 聚焦函数123456AVG()函数：返回某列的平均值(忽略值为NULL的行) COUNT(*):对表中行的数据进行计算，包含空值NULL COUNT(column):对特定列中具有值的行进行计数，忽略NULL值。 MAX()函数：返回某列的最大值(忽略NULL值)MIN()函数：返回某列的最小值（与MAX()相反）SUM()：返回某列值之和（忽略NULL值）,如，计算总金额时使用 字符集》 重要术语 字符集：字母和符号的集合 编码：某个字符集成员的内部表示 校对：规定字符如何比较的指令 字符集相关操作》 显示所有可用的字符集以及每个字符集的描述和默认校对 1SHOW CHARACTER SET 》 查看Mysql支持的校对完整列表 1SHOW COLLATION 》 查看数据库默认的字符集 1SHOW VARIABLES LIKE &apos;character%&apos; 》 查看数据库默认的校对： 1SHOW VARIABLES LIKE &apos;collation%&apos; 》 在创建表时指定字符集和校对 12345CREATE TABLE mytable( column1 INT, column2 VARCHAR(10)) DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; MySQL使用字符集和校对规则 明确指定两个 只指定CHARACTER SET，则使用此字符集及其默认的校对 都不知道，则使用数据库默认 列级别的字符和校对12345CRETE TABLE mytable(column3 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci) DEFAULT CHARACTER ser HEBREW COLLATRE hebrew_general_ci`` 数据类型常用数据类型 数据类型 说明 CHAR 1～255个字符的定长串。它的长度必须在创建时指定，否则MySQL假定为CHAR(1) ENUM 接受最多64 K个串组成的一个预定义集合的某个串 LONGTEXT 与TEXT相同，但最大长度为4 GB MEDIUMTEXT 与TEXT相同，但最大长度为16 K SET 接受最多64个串组成的一个预定义集合的零个或多个串 TEXT 最大长度为64 K的变长文本 TINYTEXT 与TEXT相同，但最大长度为255字节 VARCHAR 长度可变，最多不超过255字节。如果在创建时指定为VARCHAR(n)m则可存储0到n个字符的变长串（其中n≤255） 数值数据类型》 MySQL中没有专门存储货币的数据类型，一般情况下使用 1DECIMAL(8, 2) 数据类型 说 明 BIT 位字段，1～64位。（在MySQL 5之前，BIT在功能上等价于TINYINT BIGINT 整数值，支持9223372036854775808～9223372036854775807（如果是UNSIGNED，为0～18446744073709551615）的数 BOOLEAN（或BOOL） 布尔标志，或者为0或者为1，主要用于开/关（on/off）标志 DECIMAL（或DEC） 精度可变的浮点值 DOUBLE 双精度浮点值 FLOAT 单精度浮点值 INT（或INTEGER） 整数值，支持2147483648～2147483647（如果是UNSIGNED，为0～4294967295）的数 MEDIUMINT 整数值，支持8388608～8388607（如果是UNSIGNED，为0～16777215）的数 REAL 4字节的浮点值 SMALLINT 整数值，支持32768～32767（如果是UNSIGNED，为0～65535）的数 TINYINT 整数值，支持128～127（如果为UNSIGNED，为0～255）的数 日期和时间数据类型 数据类型 说 明 DATE 表示1000-01-01～9999-12-31的日期，格式为YYYY-MM-DD DATETIME DATE和TIME的组合 TIMESTAMP 功能和DATETIME相同（但范围较小） TIME 格式为HH:MM:SS YEAR 用2位数字表示，范围是70（1970年）～69（2069年），用4位数字表示，范围是1901年～2155年 二进制数据类型 数据类型 说 明 BLOB Blob最大长度为64 KB MEDIUMBLOB Blob最大长度为16 MB LONGBLOB Blob最大长度为4 GB TINYBLOB Blob最大长度为255字节 多表关系》 多表关系 一对一（一夫一妻） 一对多(会员与订单) 对多多(商品与订单) 一对一》 概述 主表添加外键字段，该字段的约束为唯一 添加外键约束 一对多》 概述 主表添加外键字段，该字段的约束为不唯一 添加外键约束 多对多》 概述 需要重建表完成多对多 实质为两个一对多的关系 首先创建中间表，并在其中创建多对多关系中两张表的外键列 中间表添加外键约束 中间表添加联合主键约束 联结》 当数据存储在多个表中，使用联结方式，在单条SELECT 语句检索出数据。 JOIN按照功能可分为 CROSS JOIN(交叉连接) INNER JOIN(内连接或等值连接) OUTER JOIN(外连接) 》 此外，还有其他连接 自连接: 双表都是自身时使用 自然联结: 多表连接查询所有列，保证出现重复列 交叉连接》 又名笛卡儿积连接,检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。 1234//隐式交叉连接SELECT * FROM A,B;//显示交叉连接SELECT * FROM A CROSS JOIN B; 内连接或等值连接》 内连接使用比较运算符根据每个表共有的列的值匹配两个表中的行 1234//隐式内连接SELECT * FROM A,B WHERE A.id = B.id;//显示内连接SELECT * FORM A INNER JOIN B ON A.id = B.id; 外连接》 外连接包括 左外连接 右外连接 》 此外，外连接需要有主表或者保留表的概念；查询结果会以主表为主，从表记录匹配不到，则补NULL 左外连接》 其中A为主表 123SELECT * FROM A LEFT JOIN B ON A.id = B.od;//或SELECT * FROM A LEFT OUTER JOIN B ON A.id = B.od; 右外连接》 其中B为主表 123SELECT * FROM A RIGHT JOIN B ON A.id = B.od;//或SELECT * FROM A RIGHT OUTER JOIN B ON A.id = B.od; 》 使用表别名(可以省写表名) 12345SELECT cust_name, cust_contactFROM customers AS c, orders AS o, orderitems AS oiWHERE c.cust_id = o.cust_idAND oi.order_num = o.order_numAND prod_id = &apos;TNT2&apos; 自联结》 使用情况，如一个货物id为DTNTR,想要查询这个货物对应厂商的其他货物，就需要使用自联结了。（p1、p2实际为一张表） 第一步：查询到id为DTNTR对应的vend_id 第二步：查询到vend_id对应的prod_id, prod_name 1234SELECT p1.prod_id, p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id = p2.vend_idAND p2.prod_id = &apos;DTNTR&apos; 自然联结》 使用情况，在对表进行联结时，肯定会有至少一个列的值时重复的。而自然联结，就是排除多次出现的列。使每个列只返回一次，具体做法 对一张表使用SELECT * 其他表的列使用明确的子集 12345678910SELECT c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_priceFROM customers AS c, orders AS o, orderitems AS oiWHERE c.cust_id = o.cust_idAND oi.order_num = o.order_numAND prod_id = &apos;FB&apos; 事务》 事务： 指的是逻辑上一组操作，组成这个事务的各个执行单元，要么一起成功,要么一起 InnoDB引擎支持 》 相关术语 事务（transaction）：指一组SQL语句； 回滚（rollback）：撤销指定SQL语句的过程 提交（commit）：将为存储的SQL语句结果写入数据库表 保留点（savepoint）：指事务处理中设置的临时占位符（placeholder），可以对它发布回滚（与回滚整个事务处理不同） 》 事务的特性(ACID) 原子性（Atomicity）原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚 一致性（Consistency）一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态(如转账，两个人怎么转，总金额是不会变的) 隔离性（Isolation）隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离 持久性（Durability）持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作 事务并发问题（隔离性导致）在事务的并发操作中可能会出现一些问题： 脏读：一个事务读取到另一个事务未提交的数据。 不可重复读：一个事务因读取到另一个事务已提交的数据。导致对同一条记录读取两次以上的结果不一致。(update操作，读取的内容改变) 幻读：一个事务因读取到另一个事务已提交的数据。导致对同一张表读取两次以上的结果不一致。(insert、delete操作,返回的结果行数改变) 事务隔离级别MySQL数据库为我们提供的四种隔离级别（由低到高）： Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 Read committed (读已提交)：可避免脏读的发生。 Repeatable read (可重复读)：可避免脏读、不可重复读的发生。[MySQL默认] Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 》 注意 》》 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观&gt;锁来控制。 事务SQL》 开始事务 1START TRANSACTION . 》 回滚事务 只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后） 事务处理可以用来管理INSERT、UPDATE、DELETE 不能回滚CREATE和DROP操作 1ROLLBACK 提交事务 数据库默认是自动提交的 但在事务处理快中，不会自动提交，需要手动COMMIT 1COMMIT 》 关闭事务：执行COMMIT和ROLLBACK后自动关闭 》 设置保留点 1SAVEPOINT point 》 回滚到保留点 1ROLLBACK TO point 》 释放保留点:（执行完ROLLBACK或COMMIT后自动释放，或RELEASE SAVEPOINT明确释放） 》 更改系统默认的提交行为 12//表示不自动提交。Mysql默认自动提交。SET autocommit=0 索引》 简介 使用索引的目的时为了优化查询速度 索引时一种特殊的文件或者叫数据结构（InnoDB数据表上的索引是表空间的一个组成部分），它包含对数据表里的所有记录的引用指针 通俗的讲，索引就相当一数据库的目录 》 因为索引是在存储引擎中实现，所以不同存储引擎有不同索引 MyISAM和InnoDB:只支持BTREE索引 MEMORY/HEAP存储引起：支持HASH和BTREE索引 索引分类》 索引分类 单列索引 组合索引 》 单列索引 普通索引：MySQL中基本索引类型，没有限制，允许定义索引的列中插入重复值和空值 唯一索引：索引列中的值必须是唯一的，但允许NULL 主键索引：特殊唯一索引，不允许NULL 》 组合索引 在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。 》 全文索引 全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引。 此外，还有空间索引，不常用. 创建索引》 普通索引的创建 12345678//创建索引CREATE INDEX &lt;index-name&gt; ON &lt;table-name&gt;( &lt;column-name&gt;(length))//另一种方式ALTER TABLE &lt;table-name&gt; ADD INDEX &lt;index-name&gt; ON ( &lt;column-name&gt;(length)) 》 唯一索引的创建 1234//创建索引CREATE UNIQUE INDEX &lt;index-name&gt; ON &lt;table-name&gt;( &lt;column-name&gt;(length)) 》 全文索引创建 1234//创建索引CREATE FULLTEXT INDEX &lt;index-name&gt; ON &lt;table-name&gt;( &lt;column-name&gt; (length)) 》 组合索引的创建 123456//创建索引CREATE [FULLTEXT/UNIQUE] INDEX &lt;index-name&gt; ON &lt;table-name&gt;( &lt;column-name&gt;(length), &lt;column-name&gt;(length) ...) 删除索引1DROP INDEX &lt;index-name&gt; ON &lt;table-name&gt; MySQL的锁》 简介： 事务在对某个数据对象（如表、记录等）操作之前，先向系统发出请求，对其加锁，加锁后事务就对数据库对象有一定的控制，在事务释放它的锁之前，其他事务不能更新此数据对象。 数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问访问 MySQL数据库由于存在多种数据存储引擎,每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别 》 MySQL各存储引擎使用了三种类型（级别）的锁定机制 行级锁定:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高 页级锁定:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 表级锁定:开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低 》 MySQL这三种锁定的特点和各自的优劣所在 按照锁的粒度来分：行级锁、表级锁、页级锁定 按照锁的功能来分：共享读锁和排他写锁 》 各引擎对锁的支持 MyISAM和MEMORY存储引擎采用的表级锁 BDB采用的是页面锁，也支持表级锁 InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。 排他锁》 介绍: 又称写锁，X锁 允许当前请求进行读取和修改，同时阻塞其他请求读取和修改 共享锁》 介绍: 又称读锁，S锁 允许当前请求进行读取，同时阻塞其他请求修改,但其他请求可以进行读取 行级锁》 特点 行级别粒度，最小的粒度 由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能 更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用 缺点 锁定资源的颗粒度很小，占用系统资源大,并发度最高 过多的锁也最容易发生死锁 表级锁》 特点 表级别粒度，最大的粒度 实现逻辑简单，带来的系统负面影响最小 获取锁和释放锁的速度很快 不会出现死锁 更适合于以查询为主，只有少量按索引条件更新数据的应用 》 缺点 出现锁定资源争用的概率高,并发度差 页级锁》 特点 MySQL特有的锁 所需资源和粒度都介于表级锁和行级锁之间 并发处理能力在三种锁之间最高 》 缺点 会发生死锁 MyISAM引擎的锁机制》 MyISAM只有表级锁 表共享读锁（table read lock） 表独占写锁（table write lock）。 》 MyISAM表的读、写操作之间、以及写操作之间的隔离级别是串行级别，其处理流程如下： MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁 在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁 用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁 》 注意:MyISAM是不支持事务的 MyISAM手动更改优先级》 方式: 通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。 给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。 MyISAM的并发插入》 MyISAM存储引擎有一个系统变量，concurrent_insert，专门用来控制并发插入行为的，值可以为0，1，2. 值为0：不允许插入 值为1：如果mysql没有空洞（中间没有被删除的行），MyISAM运行一个进程读表的时候，另一个进程从表尾插入记录，这也是mysql默认设置。 值为2，无论MyISAM表中有没有空洞，都允许在表尾并行的插入。 InnoDB引擎的锁机制》 与MyISAM不同: 支持事务 支持行级锁 》 流程 对于UPDATE、DELETE、INSERT语句，Innodb会自动给涉及的数据集加排他锁（X） 对于普通SELECT语句，Innodb不会加任何锁。 Innodb行锁模式以及加锁方法》 Innodb锁模式一共分为 共享锁 排他锁 意向锁(意向共享锁、意向排他锁) 》 冲突情况： 共享锁 排他锁 意向共享锁 意向排他锁 共享锁 兼容 冲突 兼容 冲突 排他锁 冲突 冲突 冲突 冲突 意向共享锁 兼容 冲突 兼容 兼容 意向排他锁 冲突 冲突 兼容 兼容 表级锁和行级锁之间的冲突》 如下情况 事务A：行级锁，锁定行H，只读 事务B：表级锁，锁定了行H的表，读写 》 数据库的解决办法: 意向锁 意向锁是一个表级锁，可以分为意向共享锁(IS)、意向排他锁（IX） 事务A必须先申请意向锁，再申请行级锁 事务B在申请表级锁时，发现表已经有了意向锁，会被阻塞 触发器(MySQL5)》 触发器：MySQL响应以下任意语句自动执行的的一条MySQL语句 其他MySQL语句不支持触发器 只有表支持触发器，视图不支持 每个表最多支持6个触发器（每条INSERT、UPDATE、DELETE的之前之后）. 123DELETEINSERTUPDATE 》 触发器失败 BEFORE触发器失败，不执行请求操作 BEFORE触发器或语句本身失败，不执行AFTER触发器 》 创建触发器 1CREATE TRIGGER 》 示例 12345678//触发器在INSERT语句成功后，对每个插入的行显示一次Product added- 创建了名为newproduct的触发器。- AFTER INSERT表示触发器在INSERT语句成功后执行- FOR EACH ROW表示代码对每个插入行执行- SLELECT 'Product added'触发器执行的操作，即显示文本信息Product addedCREATE TRIGGER newproduct AFERT INSERT ON productsFOR EACH ROW SLELECT 'Product added' 》 删除触发器: 触发器无法更新或覆盖，想要修改触发器，必须先删再创。 1DROP TRIGGER 触发器名 INSERT触发器》 INSERT触发器 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行 在BEFROE INSERT触发器中，NEW 的值也可以被更新。 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。 》 示例 1234//order_num是一个AUTO_INCREMENT列,当orders表成功插入一行数据时，这行数据会保存到NEW中。此触发器执行的操作是SELECT NEW.order_num,即把自动生成的标号显示出来。CREATE TRIGGER neworder AFTER INSERT ON ordersFOR EACH ROW SELECT NEW.order_num; DELETE触发器》DELETE触发器 在DELETE触发器代码内，可以引用名为OLD的虚拟表，访问被删除的行 OLD中的值都是只读，无法更新 12345678//将被删除的行的数据保存到archive_orders表中。BEGIN END块的好处是触发器器能容纳多条SQL语句。CREATE TRIGGER deleteorder BEFORE DELETE ON rodersFOR EACH ROWBEGIN INSERT INTO archive_orders(order_num, order_date, cust_id) VALUES (OLD.order_num, OLD.order_date, OLD.cust_id) END; UPDATE触发器》 UPDATE触发器 在UPDATE触发器代码中，可以引用名为OLD的虚拟表访问以前的值，引用名为NEW的虚拟表访问新更新的值 BEFORE UPDATE触发器中，NEW中的值可能也被更新OLD只读，不能更新 》示例： 1234//在更新以前出发，保证更改的值永远是大写。即在更新前，先对值进行处理。（这就是所谓的NEW值可能被更新）CREATE TRIGGER updatevendor BEFORE UPDATE ON vendorsFOR EACH ROW SET NEW.ven_state = Upper(NEW.vend_state); 视图（MySQL5 ）》 什么是视图 将一个SELECT的查询结果包装成一个虚拟的表 本身不包含数据，仅仅用来查看存储在别处的数据的一种设施。 》 视图的好处： 重复SQL语句 鸡蛋花复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节 使用表的组成部分而不是整个表 保护数据，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 》 规则和限制 与表一样，视图名唯一 对于可创建的视图数目没有限制 为了创建视图，必须具有足够的访问权限 可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图 ORDER BY可以用在视图中。但如果从该视图检索数据SELECT中也含有ORDER BY,那么视图中的ORDER BY被覆盖。 视图不能索引，也不能由关联的触发器或默认值 视图可以和表一起使用。例如编写一条联结表和视图的SELECT语句 创建视图1CREATE VIEW 视图名 》 示例： 12345CREATE VIEW prdouccustomers ASSELECT cust_name, cust_contact, prod_idFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_idAND orderitems.order_num = orders.order_num 查看创建视图的语句1SHOW CREATE VIEW viewname 更新视图》 方式一：先DROP在CREATE 》 方式二：不存在则创建，存在就覆盖 1CREATE OR REPLACE VIEW 》 个人理解： 创建完视图后，发现通过SHOW TABLES可以查看到视图（暂且理解为视图其实算是一种特殊的表） 通过SHOW CREATE TABLE 视图,也可以显示视图的创造语句（更加觉得视图是一种特殊的表） 在实际使用中，可以当表来进行操作(WHERE，ORDER BY等) 虽然视图也可以做到更新（改动基表），但视图本身是用于检索，所以想要更新数据，还是直接操作基表比较好 存储过程(MySQL5)创建存储过程PROCEDURE 存储过程名() BEGIN 语句; END123CREATE PROCEDURE productname()...END; 》 示例 12345CREATE PROCEDURE productpricing()BEGIN SELECT avg(prod_price) AS priceaverageFROM products;END; 命令行模式下的DELIMITER //》 MySQL命令行默认使用;来表示分隔符。而MySQL语句也使用;表示。这样还没执行到END，就在前面的;就结束了。DELIMITER //是将MySQL命令行的分隔符修改。 123456DELIMITER //CREATE PROCEDURE productpricing()BEGIN SELECT avg(prod_price) AS priceaverageFROM products;END// 使用存储过程1CALL productpricing() 删除存储过程》 过程不存在回产生错误，可使用DROP PROCEDURE IF EXISTS 存储过程名 12DROP PROCEDURE 存储过程名DROP PROCEDURE IF EXISTS 存储过程名 使用参数》 主要参数如下 IN：传递给存储过程 OUT：从存储过程传出 INOUT：可传入传出 1234567891011121314//IN需要传入数据（20005）,SELECT的数据通过INTO传入到ototal中。通过SELECT @total查看变量的值。CREATE PROCEDURE ordertotal( IN onumber INT, OUT ototal DECIMAL(8, 2))BEGIN SELECT sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO ototal;END;CALL ordertotal(20005, @total);SELECT @total; 检查存储过程1SHOW CREATE PROCEDURE 存储过程 列出所有存储过程1WHO PROCEDURE STATUS 可以使用LIKE过滤,如1WHO PROCEDURE STATUS LIKE &apos;ordertotal&apos; 使用游标(MySQL5)》 游标(cursor) 存储在MySQL服务器上的数据库查询，不是SELECT语句，而是被该语句检索出来的结果集。 根据需要滚动或浏览其中的数据 主要用于交互式应用 只能用于存储过程（和函数） 游标的使用 先声明游标，这个过程没有检索数据。只用来定义要使用的SELECT语句 声明后，打开游标。这个过程用前面定义的SELECT语句把数据检索出来 对于填有数据的游标，根据需要检索各行 在结束游标使用时，必须关闭游标（如果不明确关闭游标，MySQL会在达到END语句时自动关闭） 创建游标1DECLARE 游标名 CURSOR FOR 》 示例 12345678910111213//如,定义了名为ordernumbers的游标CREATE PROCEDURE processorders()BEGIN -- 定义游标DECLARE ordernumbers CURSORFOR SELECT order_num FROM orders;-- 打开游标OPEN ordernumbers;-- 关闭游标CLOSE ordernumbers;END; 打开游标1OPEN 游标名 关闭游标1CLOSE 游标名 使用游标数据1FETCH 》 示例 1234567891011121314151617//FETCH语句会自动从第一行开始把order_num列复制到变量o中(这里并没有操作变量o)CREATE PROCEDURE processorders()BEGIN -- 定义一个本地变量oDECLARE o INT;-- 定义游标DECLARE ordernumbers CURSORFOR SELECT order_num FROM orders;-- 打开游标OPEN ordernumbers;-- 获取数据FETCH ordernumbers INTO o;-- 关闭游标CLOSE ordernumbers;END; 》 该存储过程执行后，会循环检索数据，从第一行到最后一行 FETCH在REPEAT内，所以会反复执行。根据UNTIL done END REPEAT;，直到done为真时结束循环(done默认0，表示假) CONTINUE HANDER：在条件出现时被执行的代码。这里表名当SQLSTATE ‘02000’出现时，将SET done = 1 SQLSTATE ‘02000’表示一个未找到的条件，当REPEAT没有更多行出供循环而不能继续时，就会出现这个条件 12345678910111213141516171819202122232425CREATE PROCEDURE processorders()BEGIN -- 定义一个本地变量o和一个布尔值变量doneDECLARE done BOOLEAN DEFAULT 0;DECLARE o INT;-- 定义游标DECLARE ordernumbers CURSORFOR SELECT order_num FROM orders;-- 定义了一个continue handler,在条件出现时将done设置成1DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done=1;-- 打开游标OPEN ordernumbers;REPEAT -- 获取数据 FETCH ordernumbers INTO o;UNTIL done END REPEAT;-- 关闭游标CLOSE ordernumbers;END; 》 示例： 创建了一个ordertotals表 定义了一个变量t,使用ordertotal()存储过程为其复制 通过INSERT INTO 将o和t的值插入ordertotals表中 使用 CALL processorders();来使用存储过程,这时表ordertotals应该已经创建好并且有数据了 使用SELECT * FROM ordertotals;来查看下数据 1234567891011121314151617181920212223242526272829303132333435363738394041CREATE PROCEDURE processorders()BEGIN -- 定义一个本地变量o、t和一个布尔值变量doneDECLARE done BOOLEAN DEFAULT 0;DECLARE o INT;DECLARE t DECIMAL(8, 2);-- 定义游标DECLARE ordernumbers CURSORFOR SELECT order_num FROM orders;-- 定义了一个continue handlerDECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done=1;-- 创建一个表来存储结果CREATE TABLE IF NOT EXISTS ordertotals( order_num INT, total DECIMAL(8, 2));-- 打开游标OPEN ordernumbers;REPEAT -- 获取数据 FETCH ordernumbers INTO o; -- 这里是在学习存储过程中写的一个存储过程,用来计算t的值 CALL ordertotal(o, t); -- 把数据插入表 INSERT INTO ordertotals(order_num, total) VALUES(o, t);UNTIL done END REPEAT;-- 关闭游标CLOSE ordernumbers;END;CALL processorders();SELECT * FROM ordertotals; 备份》 mysqldump 转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。mysqlhotcopy 从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序）。 》 BACKUP TABLE或SELECT INTO OUTFILE 转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错 数据可以用RESTORE TABLE来复原。 》 FLUSH TABLES 为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2Fblog%2F2018%2F02%2F03%2Fjvm.all%2F</url>
    <content type="text"><![CDATA[JVM运行时数据区java将内存的管理权力全部交给了虚拟机，如下是JVM所管理的内存区域图 程序计数器 程序计数器 是一块较小的内存空间，属于线程私有的内存 可以看成是当前线程所指向的字节码的行号指示器，字节码解释器依靠计数器的值来选取下一个要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能也需要以来于计数器 由于java是多线程的切换的方式实现的，为了保证切换回后有恢复到正确的位置，所以每一条线程都有一个计数器 如果线程执行的是java代码，则计数器记录正在执行的虚拟机字节码指令的地址；如果是Native方法，计数器为Undefined 唯一一个没有规定任何OutOfMemoryError情况的区域 Java虚拟机栈 Java虚拟机栈 线程私有的内存，为Java方法服务 虚拟机栈用来描述Java方法的内存模型，即每个方法在执行的同时会创建一个栈帧,用于存储局部变量表、操作数栈、动态链接、方法出口等信息;每一个方法调用直到完成的过程，对应一个栈帧在虚拟机栈中的入栈到出栈的过程 虚拟机栈中存在一个局部变量表 规定了两种异常状态： StackOverflowError和OutOfMemoryError 局部变量表 存放了编译期可知的基本数据类型、对象引用、returnAddress类型 对象引用：reference类型，可能是执行对象起始地址的引用指针，可以能是指向代表对象的句柄或其他与此对象相关的位置 returnAddress类型: 指向一条字节码指令的地址 局部变量空间(Solt)：基本数据类型的long和double会占据两个局部变量空间(Slot),其余数据类型占据一个 局部变量表在编译期就已经完成了内存空间的分配,运行期间不会改变 本地方法栈 本地方法栈 与虚拟机栈类似，线程私有的内存，为Native方法服务 规定了两种异常状态： StackOverflowError和OutOfMemoryError HotSpot VM中，直接将本地方法栈和虚拟机栈合二为一 Java堆 Java堆： JVM内存最大的一块,被线程共享，在虚拟机启动时创建 用于存放对象示例和数组，GC的最要区域 Java堆在物理空间上可以不连续，只要逻辑上连续即可 如果没有内存完成示例分配，会抛出OutOfMemoryError异常 方法区 方法区 线程间共享内存，别名Non-Heap(非堆);又被称为永久代^13 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常 运行时常量池 属于方法区的一部分，用于存放编译期生成的各种字面量和符号引用 无法申请到内存时抛出OutOfMemoryError异常 直接内存 直接内存： 并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中的内存区域 ;在JDK1.4后加入了NIO类，引入了基于通道与缓冲区的I/O方式，该类可以使用Native函数库直接分配堆外内存，然后通过一个存储在 java堆 中的 DirectByteBuffer对象作为这块内存存的引用进行操作; 会受到本机总内存以及处理器寻址空间的限制。会抛出OutOfMemoryError异常 垃圾回收与算法对象存活判定算法Java 虚拟机想要通过垃圾回收器回收，必需要先判定哪些对象需要回收，通常有两种判定方式 引用计数法 可达性分析算法 引用计数法 算法步骤 给对象添加一个引用计数器 每当有地方引用它，计数器+1 引用失效，计数器-1 计数器为0则表示没有任何地方使用这个对象 算法优点： 实现简单 判定效率高 算法缺点：难以解决对象之间相互循环引用，如下示例 12345objA.instance = objB;objB.instance = objA;//即使objeA,objB都为null了，但它们的Instance字段互相引用对方，使这两个对象的计数器永远不为0，GC收集器永远无法回收objA = null;objB = null; 可达性分析算法 算法步骤 通过一系列 GC Roots作为对象的起始点 从这些起始节点向下搜索，搜索走过的路径被称为 引用链 如果一个对象没有任何引用链，证明此对象不可用 如图 Object1、Object2、Object3都存在与GC Roots联通的 引用链,所以仍然存活 虽然object 5、6、7之间相互关联，但它们与 GC Roots无关联，所以会被判定为可回收对象 在Java语言中，可作为 GC Roots 的对象包括 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法去区中常量引用的对象 本地方法栈中JNI(即Native方法)引用的对象 在可达性分析算法中，对于不可用的对象，并不会马上回收，它至少要经理两次标记过程 第一次进行可达性分析后没有与GC Roots相连的引用链，则标记第一次； 在标记完后，进行依次筛选 如果当前对象没有覆盖finalize()方法或者finalize()方法已经被JVM调用过，JVM会将这两种情况视为“没必要执行”，其他的则视为有必要执行，进入下一步 对于有必要执行finalize()的对象，会把它放入到F-Queue队列中，并由一个虚拟机自动建立的，优先级低的Finalizer线程去执行它。GC 会对该队列进行第二次标记，如果在此时对象与引用链上的对象建立关联，则将该对象移出即将回收集合。如果第二次标记时仍然时不可达对象，那么就被真正回收 垃圾回收算法标记-清除算法(Mark-Sweep) 算法分为 标记 和 清除两个阶段 标记处所有需要回收的对象(标记过程看 ”可达性分析算法” 这一章的内容) 标记完成后统一回收 该算法有两处不足 效率低，无论是标记还是清除效率都不高 空间问题，清除后会产生大量不连续内存碎片 复制收集算法(Copying) 算法步骤 将内存分为大小相等的两块 每次使用其中一块，当被使用的内存块用玩了，则将该内存块中存货对象复制到另一块上，然后一次性清空该块。 算法不足之处：有一半空间是没有使用的 标记整理法标记整理法是针对老年代的算法，它的步骤与 标记清除法 类似 标记处所有需要回收的对象(标记过程看 ”可达性分析算法” 这一章的内容) 所有存活对象移动到一端，然后直接清理端边界意外的内存 分代收集算法（Generational Collection）该算法是根据对象存货周期的不同将内存划几块，一般将Java堆分为 新生代(Young Generation)和老年代(Tenured/Old Generation),然后根据各个年代的特点选择不同的算法 新生代特点： 新生代对象存活较少，每次需要回收大量对象，所以复制操作较少，通常使用复制算法 新生代一般以1:1:8 的比例划分为两个Survivor（SurvivorFrom,SurvivorTo）和一个Eden空间，每次使用Eden空间和其中一个Survivor，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中 MajorGC步骤： 复制：将 Eden和 SurvivorFrom 复制到另一块SurvivorTo中(复制过程中可能出现晋升老年代、空间不足等情况，具体处理详细看《内存分配与回收策略》) 清空：将 Eden和 SurvivorFrom内容清空 互换：将 SurvivorFrom 与SurvivorTo互换，即原SurvivorTo成为下一次GC的SurvivorFrom 老年代特点 老年代对象存活率大，回收数量少，没有额外空间对它进行分配担保，则必须使用 标记清除法 或 标记整理法 新生代的对象在一定条件下，就会晋升为老年代对象(详细看《内存分配与回收策略》) 永久代​ 永久代即方法区，主要存放Class和Meta(元数据)，Class会在被加载时候放入该区域，因为GC不会在主程序运行期对方法区进行清理，所以该区域会随着加载的Class增多而最终导致抛出OOM。为了清理方法区，HotSpot VM将GC分代算法扩展至方法区，即使用Java堆的永久代来实现方法区, 这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器。不过收益一般很小 ​ 在Java8中，永久代已经被一处，被元数据区（元空间）取代，它们的区别在于元空间大小受本地内存限制。类的元数据放入native memoery,字符串池和类的静态变量放入java队中，好处是加载多少类的元数据就不再由MaxPermSize控制，而是由系统的实际可用空间控制 垃圾收集器HotSpot 提供的收集器，收集器的连线表示它们可以配合使用 Serial 收集器Serial收集器 新生代收集器，单线程 JVM运行在 Client模式 下的默认 新生代收集器 它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（有一种叫法，叫 Stop The World ），直到它收集结束; Serial收集器优点： 简单高效，尤其是单个CPU环境。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率；只需要控制好能接受的停顿时间，那还是一个很好的选择 ParNew 收集器 ParNew收集器 新生代收集器,Serial收集器的并行^4多线程版本,其余行为与Serial收集器相同； 是运行在Server模式下的JVM的首选新生代收集器 唯一一个可以配合CMS的收集器 在单CPU下由于存在线程交互开销，性能可能低于Serial收集器 默认开启的线程数与CPU数量相同 ParNew收集器优点：多线程、高效 Parallel Scsvenge收集器Parallel Scsvenge 新生代收集器，,同时也是并行^4的多线程收集器,与ParNew 收集器几乎一致 Parallel Scsvenge与其他收集器的区别：关注点与其他收集器不同 ​ a. 其他浏览器关注点：尽可能缩短垃圾收集时用户线程的停顿时间 ​ b. Parallel Scsvenge关注点：控制吞吐量 适用于后台运算而不需要太多交互的任务 Parallel Scsvenge优点：在高吞吐量下最高效率利用CPU时间，尽快完成程序的运算任务 Parallel Scsvenge提供了两个参数用于精确控制吞吐量 -XX:MaxGCPauseMillis : 控制最大垃圾收集停顿时间(大于0的毫秒数)，收集器尽可能保证内存回收花费时间不超过设定值，时间缩短靠的是牺牲吞吐量和新生代空间换取的 -XX:GCTimeRatio : 直接设置大小（大于0小于100，垃圾手机时间占总时间的比率，即吞吐量的倒数）,如设置成19，那么GC时间就是 1/(1+19)= 5%,默认值99，即GC时间1%(1/(1+99)) Parallel Scsvenge其他参数 XX:+UserAdaptiveSizePolicy: 开关参数，用于打开GC自适应的调节策略, 打开后，无需手工指定新生代大小、Eden与Survior的比例等细节参数，JVM会自动调节。 Serial Old 收集器Serial Old Serial 老年代版本，单线程收集器，使用标记-整理算法 主要用于Client模式下的虚拟机，与Serial 收集器搭配使用 在Server模式下，有两大用途 a. 与Parallel Scsvenge收集器搭配使用 b. 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用 Parallel Old收集器Parallel Old Parallel Scsvenge老年代版本，多线程收集器，使用标记-整理算法 Parallel Old + Parallel Scsvenge 组合，适用于注重吞吐量以及CPU资源敏感的场合 CMS收集器 CMS收集器（Coucurrent mark swrrp） 老年代收集器，基于 标记清除算法实现 是以获取最短回收停顿时间为目标的收集器 它的运作过程如下 初始标记： 暂停所有的其他线程，只是记录下直接与GC Roots相连的对象，速度很快 ；需要Stop The World 并发标记： 进行GC Roots Tracing(GC Root 追踪过程),同时开启GC和用户线程 重新标记： 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要Stop The World 并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫 CMS优点：对交互比较高的程序提升较大，总体上，CMS收集器的内存回收与用户线程并发进行 CMD也被称为 并发低停顿收集器，但存在3个缺点： CMS对CPU敏感 默认启动的回收线程数为(CPU数量+3)/4，比如CPU数是2个，那么开启的线程数为1，占了50%的CPU资源，这样很可能导致用户程序的执行速度降低50%。 CMS收集器无法处理浮动垃圾^3 CMS式基于标记清除算法实现，所以会产生大量空间碎片 G1收集器 G1收集器 面向服务端应用的多线程垃圾收集器，基于标记-整理算法实现 它将整个Java堆划分成大小相等的独立区域(Region),虽然保留新生代和老年代概念，但新生代和老年代不再物理隔离，都属于Region(不需要连续)的集合； 空间整合： a. 从整体看，G1是基于 标记整理算法实现的； b. 从局部(Region)来看，G1是基于 复制算法实现的；这两种算法都不会产生内存空间碎片 可预测的停顿：相对于CMS的大优势，G1可以建立可预测的停顿时间模型，让使用者明确指定一个长度为M毫秒的时间片段，消耗在垃圾收集上的时间不得超过M秒 G1收集器优点： 并发执行GC，缩短Stop The World 停顿时间 避免在整个Java堆中进行垃圾收集 可控停顿时间 不产生内存碎片 不需要其他收集器配合，独立完成新生代和老年代的回收 G1可预测的停顿原因 ​ 由于划分成了多个Region，G1会根据Region的价值大小(回收所获取的空间大小和回收所需时间的经验值)，在后台维护一个优先级列表，优先回收最大的Region,从而保证在有限时间内获得更高的回收小路 G1收集器的运作大致分为以下几个步骤： 初始标记： a. 标记 GC Roots能直接关联的对象,需要Stop The World b. 修改TAMS（Next Top at Mark Start）的值，目的是让一下阶段用户程序并发运行时，能正确在Region中创建新对象 并发标记： 进行可达性分析，找出存活对象，耗时长 最终标记： a. 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要Stop The World b. 将这段时间对象变化记录在线程Remebered Set Logs里，然后将其合并到Remebered Set中 筛选回收： 对各个Region的回收价值和成本进行排序，根据用户希望的GC停顿时间来指定回收计划 垃圾收集器参数总结 参数 描述 UseSerialGC 虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收 UseParNewGC 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收 UseConcMarkSweepGC 打开此开关后，使用ParNew+ CMS + Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 UseParallelGC 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old (PS Mark Sweep)的收集器组合进行内存回收 UserParallelOldGC 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收 SurvivorRatio 新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Survivor = 8:1 PretenureSizeThreshold 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 MaxTenuringThreshold 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代 UseAdaptiveSizePolicy 动态调整Java堆中各个区域的大小以及进入老年代的年龄 HandlePromotionFailure 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况 ParallelGCThreads 设置并行GC时进行内存回收的线程数 GCTimeRatio GC时间占总时间的比率，默认值是99， 即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效 MaxGCPauseMillis 设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效 CMSInitiatingOccupancyFraction 设置CMS收集器在老年代时间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效 UseCMSCompactAtFullCollection 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效 CMSFullGCsBeforeCompaction 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用CMS收集器时生效 内存分配与回收策略规则一：对象优先在Eden分配 ​ 大多数情况下，对象在新生代的Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC^1 规则二：大对象^9直接进入老年代 经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集器以获取足够的连续空 间来存储它们 PretenureSizeThreshold参数：令大于这个值的对象直接在老年代分配 规则三：长期存活的对象进入老年代 虚拟机通过对象年龄计数器来识别对象应该放置在新生代还是老年代 对象年龄计数器 如果对象在Eden出生并经过第一次Minor GC^1后能存活，并能被Survivor容纳，那么该对象会被移动到Survivor空间中，且对象年龄为1； 之后，每进行一次Minor GC^1，对象没有被回收的化，年龄+1； 年龄到达一定值（默认15），就会晋升到老年代中。 MaxTenuringThreshold参数：设置对象晋升老年代的阈值 规则四：动态对象年龄判断 虚拟机为了更好的适应不同程序的内存状况，并不是要求对象必须年龄到达阈值才晋升为老年代 当Survivor空间中相同年龄所有对象的大小的总和大于Survivor空间的一半，那么年龄大于等于该值年龄的对象直接晋升到老年代 ​ 规则五：空间分配担保 在Minor GC^1之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间 是，则可以确保Minor GC^1是安全的,进行一次Minor GC^1 否，则还需要查看HandlePromotionFailure设置值是否允许担保失败 ​ a. 允许，检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小 ​ 大于：则再一次尝试Minor GC^1 ​ 小于：则进行一次Full GC^2 ​ b. 不允许，则进行一次Full GC^2 为什么需要空间担保分配 新生代采用的是复制收集算法，按照8:1:1的分配方式，只有一个Survivor空间来进行轮换备份，如果在Minor GC^1后依旧还有大量对象存活，导致Survivor不够用时，就需要老年代进行分配担保，将无法容纳的对象直接存入老年代 老年代要进行担保，必须是它本身还有多余的能容纳这些对象的空间。而到底有多少对象存活在Minor GC^1无法得知，所以只能通过以前的回收晋升到老年代的对象的评价大小来作为经验值。 ​ a. 老年代剩余空间大于经验值，那么就可以尝试Minor GC^1，这仅仅只是一次尝试，依旧会导致担保失败(Handle Promition Failure),不得不进行一次Full GC^2来获取更多的空间； ​ b. 小于经验值的话，也需要进行Full GC^2来获取更多的空间。 HandlePromotionFailure参数：开关参数，建议打开，避免Full GC^2关于频繁 方法区的回收 方法区（即永久代）垃圾回收率较低，主要回收的时废弃常量和无用的类。废如字符串”abc”在常量池但没有任何对象引用用它，则该字符串就是废弃常量；而判断无用的类，则必须满足以下三个条件 该类实例都已经被回收 加载该类的ClassLoader已被回收 该类的java.lang.Class对象没有被引用，无法在任何地方通过反射访问该类方法 满足三个条件，只能说是可以回收，是否要回收，HotSpot提供了 -Xnoclassgc 参数对齐进行控制;还可以使用 -verbose:class(Product版虚拟机中使用) 和 -XX:+TraceClassLoadd(Product版虚拟机中使用) 、 -XX:+TraceClassUnLoading(FastDebug版虚拟机中使用) 查看加载和卸载信息; 引用reference 什么是引用? 在JDK1.2 以前，引用被定义为：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用 在JDK1.2之后，引用被分为了四种: 强引用、软引用、弱引用、虚引用,四种引用强度依次减弱 强引用: 指在程序代码之中普遍存在的，类似”Object obj = new Object()”这类引用，只要强引用还在，垃圾收集器不会回收被引用的对象 软引用：软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果还没有足够的内存，则抛出内存溢出异常。在JKD1.2后使用 SoftReference 类 来实现软引用 弱引用：弱引用关联的对象，在垃圾收集器工作时，无论是否内存足够，都会被回收。在JKD1.2后使用 WeakReference 类来实现软引用 虚引用：又被称为幽灵引用或者幻影引用。对象被虚引用关联，完全不会对其生存时间造成任何影响，也无法通过虚引用来获取对象实例。该引用的唯一作用是在被关联对象回收后收到一个系统通知；在JKD1.2后使用 PhantomReference 类来实现软引用 虚拟机性能监控和故障处理工具JDK命令行工具工具位于$JAVA_HOME/bin,如比较熟悉的java、javac JDK监控和故障处理工具表： 名称 主要作用 jps JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程 jstat JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据 jinfo Configguration Info for Java，显示虚拟机配置信息 jmap Memory Map for Java,生成虚拟机的内存转储快照 jhat JVM Heap Analysis Tool,用于分析heapdump（jmap内存转储）文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果 jstack Stack Trace For Java,显示虚拟机的线程快照 jps:虚拟机j进程状况工具jps功能： ​ 列出正在运行的虚拟机进程,显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一id(LVMID, Local Virtual Machine Identifier) jps命令格式： ​ jps可以通过RMI协议^11查询开启了RMI服务的远程虚拟机进程状态 12//hostid为RMI注册表中注册的主机名jps [options] [hostid] jps工具常用选项 选项 作用 -q 只输出LVMID -m 输出虚拟机进程启动时传递给主类main()函数的参数 -l 输出主类的全名，如果进程执行的是jar包，输出Jar路径 -v 输出虚拟机进程启动时JVM参数 jstat ： 虚拟机统计信息监视工具jstat是用于监视虚拟机各种运行状态信息的命令行工具,它可以本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据 jstat命令格式 123456789101112/*** interval: 查询间隔* count: 查询次数* 省略以上两个参数，说明值查询一次* option：要查询的虚拟机信息*/jstat [option vmid [interval] [s|ms] [count]]// vmid：// 1. 如果是本地虚拟机进程，vmid与lvmid一致// 2. 如果是远程虚拟机进程，格式如下[protocol:][//]lvmid[hostname[:port]/servername] option选项：主要分类装载、垃圾收集、运行期编译状况 选项 作用 -class 监视类装载、卸载数量、总空间以及类装载所耗费的时间 -gc 监视Java堆状况，包括Eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息 -gccapacity 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间 -gcutil 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 -gccause 与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因 -gcnew 监视新生代GC状况 -gcnewcapacity 监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间 -gcold 监视老年代GC状况 -gcoldcapacity 监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间 -gcpermcapacity 输出永久代使用到的最大、最小空间 -compiler 输出JIT编译器编译过的方法、耗时等信息 -printcompilation 输出已经被JIT编译的方法 示例 12//250毫秒查询一次进程id为2764的垃圾收集情况，一共查询20次jstat -gc 2764 250 20 显示列描述（部分） 列名称 详细描述 Loaded 被加载类的数量 Bytes 被加载字节数量，以“KB”为单位 Unloaded 被卸载类的数量 Time 加载和卸载类行为耗费时间 Compiled 成功编译任务数量 Failed 失败编译任务数量 Invalid 无效编译任务数量 Time 编译任务耗费时间 FailedType 最近一次失败编译任务对应的编译类型 FailedMethod 最近一次失败编译任务对应的类名和方法名 S0C 当前Survivor区0内存容量 S1C 当前Survivor区1内存容量 S0U Survivor区0使用内存 S1U Survivor区1使用内存 EC 当前Eden区内存容量 EU Eden区使用内存 OC 当前老年代内存容量 OU 老年代使用内存 PC 当前永久代内存容量 PU 永久代使用内存 YGC 年轻代GC事件数量 YGCT 年轻代GC耗费时间 FGC Full GC事件数量 FGCT Full GC耗费时间 GCT jinfo: Java配置信息工具jinfo功能： ​ 实时地查看和调整虚拟机各项参数 jinfo 命令格式 1jinof [option] pid option参数 选项 作用 -v 查看未被指定的参数的系统默认值 -sysprops 将虚拟机进程的System.getProperties()的内容打印出来 -flag 查询参数值 -flag [+/-] name 查询参数值，修改一部分运行期可写的虚拟机参数 -flag name=value 同上 示例 12//查询CMSInitiatingOccupancyFraction的参数值jinfo -flag CMSInitiatingOccupancyFraction 4578 jmap：Java内存映像工具jmap功能： 用于生产堆转储快照（一般称为heapdump或dump文件） 查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。 jmap命令格式 1jmap [option] vmid jmap选项表 选项 作用 -dump 生成Java堆转储快照，格式为：-dump：[live,]format=b,file=,其中live子参数说明是否只dump出存活的对象 -finalizerinfo 显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效 -heap 显示Java堆详细信息，如使用哪种回收器，参数配置，分代情况等。只在Linux/Solaris平台下有效 -histo 显示堆中对象的统计信息，包括类、实例数量、合计容量 -permstat 以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效 -F 当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linus/Solaris平台下有效 jhat: 虚拟机堆转储快照分析工具jhat功能： 与jmap搭配使用，来分析jmap生成的堆转储快照 内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看 不建议使用，有其他更好的替代，所以不想看下去了 jstack: Java堆栈跟踪工具jstack功能： 用于生成虚拟机当前时刻的线程快照^12（一般称为threaddump或者javacore文件） 生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因 jstack命令格式 1jstack [option] vmid jstack工具主要选项 选项 作用 -F 当正常输出的请求不被响应时，强制输出线程堆栈 -l 除堆栈外，显示关于锁的附加信息 -m 如果调用本地方法的话，可以显示C/C++堆栈 在JDk1.5中，java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能。在实际项目中可以用这个方法做管理员页面，以便随时使用浏览器来查看线程堆栈 Java VisualVM内存监控功能限定java堆的大小为100m,最大和最小设置为同一个值可以避免堆自动扩展 12345678910111213141516171819202122/** * VM Args: -Xms100m -Xmx100m -XX:+UseSerialGC * 代码作用 * 以64KB/50毫秒的速度往Java堆中填充数据 */public class HeapOOM &#123; static class OOMObject&#123; public byte[] placeholder = new byte[64 * 1024]; &#125; public static void fillHeap(int num) throws InterruptedException&#123; List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++)&#123; Thread.sleep(50); list.add(new OOMObject()); &#125; System.gc(); &#125; public static void main(String[] args) throws Exception&#123; fillHeap(1000); &#125;&#125; Class类结构一个Class文件对应着唯一的一个类或接口的定义信息，但要注意的是，类和接口的定义信息并不一定在文件里，因为它并不一定以磁盘文件的形式存在 Class文件是一组以8位字节为基础单位的二进制流，各个数据之间紧密相连。当数据高于8位时，会按照高位在前^14:的方式分割成若干个8位字节进行存储 Class文件结构中含有两种数据： 无符号数： 属于基本类型，以u1、u2、u4、u8代表1、2、4、8个字节的无符号数，可以用来描述数字、索引引用、数量值或按照UTF-8编码构成字符串值 表： 表是由多个无符号数和其他表作为数据项构成的复合数据类型，习惯以_info结尾。整个Class文件，就是一张表 Class文件格式 类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count - 1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fields fields_count u2 methods_count 1 method_info methods methods_count u2 attribute_count 1 attribute_info attributes attributes_count 魔数与Class版本号Class文件的头4个字节被称为魔数，它的唯一作用是标识这是一个可以被虚拟机接受的Class文件。 123456789101112//可以看到0~3 四个字节即为Class的魔数为：CAFEBABE，咖啡宝宝//4~5字节表示次版本号//6~7字节表示主版本好,0x34换成10进制就是52，JDK1.1支持45.0~45.65535的Class文件。JDK1.2的话，可以执行45.0~46.65535的Class文件。这里的52，说明使用的是JDK1.8 Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000000: CA FE BA BE 00 00 00 34 00 41 0A 00 0D 00 2B 07 J~:&gt;...4.A....+.00000010: 00 2C 0A 00 02 00 2B 05 00 00 00 00 00 00 00 32 .,....+........200000020: 0A 00 2D 00 2E 07 00 2F 0A 00 07 00 2B 0B 00 30 ..-..../....+..000000030: 00 31 0A 00 32 00 33 0A 00 0C 00 34 07 00 35 07 .1..2.3....4..5.00000040: 00 36 01 00 09 4F 4F 4D 4F 62 6A 65 63 74 01 00 .6...OOMObject..00000050: 0C 49 6E 6E 65 72 43 6C 61 73 73 65 73 01 00 06 .InnerClasses...00000060: 3C 69 6E 69 74 3E 01 00 03 28 29 56 01 00 04 43 &lt;init&gt;...()V...C00000070: 6F 64 65 01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 常量池常量池 可以理解为Class文件中的资源仓库 是Class文件结构中与其他项目关联最多的数据类型 占用Class文件空间最大的项目之一 Class文件中第一个出现的表类型数据项目 在回顾Class文件 1234567891011//8~9字节代表了常量池的的入口，是一个u2类型的数据，代表常量池容量计数值。Ox0041,换成10进制的话就是65，该数值说明常量池中有64项常量，索引范围从1~64。计数从1开始计数（除了常量池，其他计数都从0开始）//剩下的第0项常量有特殊含义，表示不引用任何一个常量池项目 Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000000: CA FE BA BE 00 00 00 34 00 41 0A 00 0D 00 2B 07 J~:&gt;...4.A....+.00000010: 00 2C 0A 00 02 00 2B 05 00 00 00 00 00 00 00 32 .,....+........200000020: 0A 00 2D 00 2E 07 00 2F 0A 00 07 00 2B 0B 00 30 ..-..../....+..000000030: 00 31 0A 00 32 00 33 0A 00 0C 00 34 07 00 35 07 .1..2.3....4..5.00000040: 00 36 01 00 09 4F 4F 4D 4F 62 6A 65 63 74 01 00 .6...OOMObject..00000050: 0C 49 6E 6E 65 72 43 6C 61 73 73 65 73 01 00 06 .InnerClasses...00000060: 3C 69 6E 69 74 3E 01 00 03 28 29 56 01 00 04 43 &lt;init&gt;...()V...C00000070: 6F 64 65 01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 常量池存放两大类常量： 字面量(Literal): 如字符串，声明为final的常量等 符号引用(Symbolic References)：属于编译原理方面的概念，主要包含以下三类 a. 类和接口的全限定名（Fully Qualified Name） b. 字段的名称和描述符（Descriptor） c. 方法的名称和描述符 每一个常量都是一张表，并且一共有14种不同结构的表，表开始的第一位是一个u1类型的标志位，代表当前常量属于那种常量类型。 标志位值对应的具体含义 类型 标志 描述 CONSTANT_utf8_info 1 UTF-8编码的字符串 CONSTANT_Integer_info 3 整形字面量 CONSTANT_Float_info 4 浮点型字面量 CONSTANT_Long_info ５ 长整型字面量 CONSTANT_Double_info ６ 双精度浮点型字面量 CONSTANT_Class_info ７ 类或接口的符号引用 CONSTANT_String_info ８ 字符串类型字面量 CONSTANT_Fieldref_info ９ 字段的符号引用 CONSTANT_Methodref_info １０ 类中方法的符号引用 CONSTANT_InterfaceMethodref_info １１ 接口中方法的符号引用 CONSTANT_NameAndType_info １２ 字段或方法的符号引用 CONSTANT_MothodType_info １６ 标志方法类型 CONSTANT_MethodHandle_info １５ 表示方法句柄 CONSTANT_InvokeDynamic_info １８ 表示一个动态方法调用点 常量池中常量项结构总表 常量 选项 类型 描述 CONSTANT_Utf8_info tag u1 值为1 length u2 UTF-8编码的字符串占用的字节数 bytes u1 长度为length的UTF-8编码的字符串 CONSTANT_Integer_info tag u1 值为3 bytes u4 按照高位在前存储的int值 CONSTANT_Float_info tag u1 值为4 bytes u4 按照高位在前存储的float值 CONSTANT_Long_info tag u1 值为5 bytes u8 按照高位在前存储的long值 CONSTANT_Double_info tag u1 值为6 bytes u8 按照高位在前存储的double值 CONSTANT_Class_info tag u1 值为7 index u2 指向全限定名常量项的索引 CONSTANT_String_info tag u1 值为8 index u2 指向字符串字面量的索引 CONSTANT_Fieldref_info tag u1 值为9 index u2 指向声明字段的类或接口描述符CONSTANT_Class_info的索引项 index u2 指向字段描述符CONSTANT_NameAndType的索引项 CONSTANT_Methodref_info tag u1 值为10 index u2 指向声明方法的类描述符CONSTANT_Class_info的索引项 index u2 指向名称及类型描述符CONSTANT_NameAndType的索引项 CONSTANT_InterfaceMethodref_info tag u1 值为11 index u2 指向声明方法的接口描述符CONSTANT_Class_info的索引项 index u2 指向名称及类型描述符CONSTANT_NameAndType的索引项 CONSTANT_NameAndType_info tag u1 值为12 index u2 指向该字段或方法名称常量项的索引 index u2 指向该字段或方法描述的索引 CONSTANT_MethodHandle_info tag u1 值为15 reference_kind u2 值必须在[1,9]之间，它决定了方法句柄的类型，方法句柄类型的值表示方法句柄的字节码行为 reference_index u2 值必须是对常量池的有效引用 CONSTANT_MethodType_info tag u1 值为16 descriptor_index u2 值必须是对常量池的有效引用,常量池在索引处的项必须是CONSTANT_Utf8_info结构,表示方法的描述符 CONSTANT_InvokeDynamic_info tag u1 值为18 bootstrap_method_attr_index u2 值必须是当前Class文件中引导方法表的bootstrap methods[]数组的有效索引 name_and_type_index u2 值必须是对当前常量池的有效索引,常量池在该处的索引必须是CONSTANT_NameAndType_info结构,表示方法名和方法描述符 Javap ：Class 字节码分析工具使用方式1javap -verbose MyClass.class 示例 通过Javap分析某文件后，输出如下结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273D:\idea project\demo\out\production\demo&gt;javap -verbose HeapOOM.classClassfile /D:/idea project/demo/out/production/demo/HeapOOM.class Last modified 2019-4-16; size 1055 bytes MD5 checksum 9bb713cc4933abd1b5aa25c296c1c4c7 Compiled from &quot;HeapOOM.java&quot;public class HeapOOM minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #13.#43 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #44 // java/util/ArrayList #3 = Methodref #2.#43 // java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V #4 = Long 50l #6 = Methodref #45.#46 // java/lang/Thread.sleep:(J)V #7 = Class #47 // HeapOOM$OOMObject #8 = Methodref #7.#43 // HeapOOM$OOMObject.&quot;&lt;init&gt;&quot;:()V #9 = InterfaceMethodref #48.#49 // java/util/List.add:(Ljava/lang/Object;)Z #10 = Methodref #50.#51 // java/lang/System.gc:()V #11 = Methodref #12.#52 // HeapOOM.fillHeap:(I)V #12 = Class #53 // HeapOOM #13 = Class #54 // java/lang/Object #14 = Utf8 OOMObject #15 = Utf8 InnerClasses #16 = Utf8 &lt;init&gt; #17 = Utf8 ()V #18 = Utf8 Code #19 = Utf8 LineNumberTable #20 = Utf8 LocalVariableTable #21 = Utf8 this #22 = Utf8 LHeapOOM; #23 = Utf8 fillHeap #24 = Utf8 (I)V #25 = Utf8 i #26 = Utf8 I #27 = Utf8 num #28 = Utf8 list #29 = Utf8 Ljava/util/List; #30 = Utf8 LocalVariableTypeTable #31 = Utf8 Ljava/util/List&lt;LHeapOOM$OOMObject;&gt;; #32 = Utf8 StackMapTable #33 = Class #55 // java/util/List #34 = Utf8 Exceptions #35 = Class #56 // java/lang/InterruptedException #36 = Utf8 main #37 = Utf8 ([Ljava/lang/String;)V #38 = Utf8 args #39 = Utf8 [Ljava/lang/String; #40 = Class #57 // java/lang/Exception #41 = Utf8 SourceFile #42 = Utf8 HeapOOM.java #43 = NameAndType #16:#17 // &quot;&lt;init&gt;&quot;:()V #44 = Utf8 java/util/ArrayList #45 = Class #58 // java/lang/Thread #46 = NameAndType #59:#60 // sleep:(J)V #47 = Utf8 HeapOOM$OOMObject #48 = Class #55 // java/util/List #49 = NameAndType #61:#62 // add:(Ljava/lang/Object;)Z #50 = Class #63 // java/lang/System #51 = NameAndType #64:#17 // gc:()V #52 = NameAndType #23:#24 // fillHeap:(I)V #53 = Utf8 HeapOOM #54 = Utf8 java/lang/Object #55 = Utf8 java/util/List #56 = Utf8 java/lang/InterruptedException #57 = Utf8 java/lang/Exception #58 = Utf8 java/lang/Thread #59 = Utf8 sleep #60 = Utf8 (J)V #61 = Utf8 add #62 = Utf8 (Ljava/lang/Object;)Z #63 = Utf8 java/lang/System #64 = Utf8 gc 该文件的二进制显示123456789 Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000000: CA FE BA BE 00 00 00 34 00 41 0A 00 0D 00 2B 07 J~:&gt;...4.A....+.00000010: 00 2C 0A 00 02 00 2B 05 00 00 00 00 00 00 00 32 .,....+........200000020: 0A 00 2D 00 2E 07 00 2F 0A 00 07 00 2B 0B 00 30 ..-..../....+..000000030: 00 31 0A 00 32 00 33 0A 00 0C 00 34 07 00 35 07 .1..2.3....4..5.00000040: 00 36 01 00 09 4F 4F 4D 4F 62 6A 65 63 74 01 00 .6...OOMObject..00000050: 0C 49 6E 6E 65 72 43 6C 61 73 73 65 73 01 00 06 .InnerClasses...00000060: 3C 69 6E 69 74 3E 01 00 03 28 29 56 01 00 04 43 &lt;init&gt;...()V...C00000070: 6F 64 65 01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 分析： 可以看到，常量池的偏移量为(0x0000 0008),其对应的16进制值为0x0041,即10进制的65，与Javap显示结果相同，有64常量； 接下来是第一个常量，偏移量0X0000 000A是其标志位，对应值为0x000A,即进制的10，查阅标志位值对应的具体含义可知，标志10代表的是CONSTANT_Methodref_info,也就是类中方法的符号引用。查阅常量项结构总表,其结构如下 CONSTANT_Methodref_info tag u1 值为10 index u2 指向声明方法的类描述符CONSTANT_Class_info的索引项 index u2 指向名称及类型描述符CONSTANT_NameAndType的索引项 ​ 也就是接下来的4个字节，含义为 ​ a. 偏移量0x0000 000B: 值0x000D(12),也就是指向了常量池的第十二项常量 ​ b. 偏移量0x0000 0000D: 值0x002B(33),也就是指向了常量池的第四十三项常量 ​ 再来看javap的显示结果的第一个常数,确实是Methodref类型，指向了13,43号常量 1#1 = Methodref #13.#43 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V 注意：CONSTANT_Utf8_info类型常量 该类型的常量是用来记录UTF-8编码的字符串，它用length选项来表示字符串的大小，因为length的类型为u2，所以其长度最大为65535 该类型的常量会被用来描述Class文件中方法名、字段名，也就是说，这也限制了它们的大小为65535,即Java不能定义超过64K大小的方法名或变量名 常量 选项 类型 描述 CONSTANT_Utf8_info tag u1 值为1 length u2 UTF-8编码的字符串占用的字节数 bytes u1 长度为length的UTF-8编码的字符串 访问标志常量池结束后，紧接着的两个字节代表访问标志（access_flags）,这个标志用于识别一些类或者接口层次的访问信息，包括 Class是接口还是类 如果是类，是否被声明为final 是否为public 是否为abstract …… 访问标志含义表access_flags一共有16个标志位(2字节)可以使用，当前值定义了8个，每个标志位上的值都有特殊含义，没有则都为0 标志名称 标志值 含义 ACC_PUBLIC 0x0001 是否为public类型 ACC_FINAL 0x0010 是否被声明为final，只有类可设置 ACC_SUPER 0x0020 是否允许使用invokespecial字节码指令的新语义，invokespecial指令的语意在JDK 1.0.2发生过改变，为了区别这条指令使用哪种语义，JDK 1.0.2之后编译出来的类的这个标志都必须为真 ACC_INTERFACE 0x0200 标识这是一个接口 ACC_ABSTRACT 0x0400 是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类值为假 ACC_SYNTHETIC 0x1000 标识这个类并非由用户代码产生的 ACC_ANNOTATION 0x2000 标识这是一个注解 ACC_ENUM 0x4000 标识这是一个枚举 示例:假设一个类是普通java类，并不接口、枚举、注解,由用户代码产生，被public修饰，没有被声明为final，abstarct,由JDK1.8编译，那么根据表中定义，它的访问标志就是 12345//第一个0:不是枚举、注解,由用户代码产生//第二个0：不是接口、abstract类型//2：由JDK1.8编译//1：为public类型0x0021 索引、父类索引和与接口索引集合Class由类索引、父类索引、接口索引这三项数据来确定这个类的继承关系，三个索引排序在访问标志之后 类索引： 使用两个u2类型数据的索引值表示，指向一个类型为CONSTANT_Class_info的类描述符常量，跟据该常量找到对应的CONSTANT_Utf8_info类型常量中的全限定字符串 用于确定该类的全限定名 父类索引： 使用两个u2类型数据的索引值表示，指向一个类型为CONSTANT_Class_info的类描述符常量，跟据该常量找到对应的CONSTANT_Utf8_info类型常量中的全限定字符串 用于确定类的父类的全限定名，父类索引只有一个 所有类的父类索引都不为0，当然，除了java.lang.object 接口索引 u2类型数据的集合 被实现的接口将会按照implements的顺序从左到右排列在索引集合中 入口的u2类型数据为计数器(interfaces_counts)，表示索引表的容量，该类没有索引，则计数器值为0,后面接口索引不占用字节 字段表集合字段表(field_info) 用于描述接口或者类中声明的变量 包括类级变量和实例级变量，不包括在方法内部声明的局部变量 字段表不会列出从父类接口中继承的字段，但有可能列出代码之中不存在的字段 字段可包含信息 字段的作用域(public、private、protected) 是实例变量还是类变量（static） 可变性（final） 并发可见性（volatile修饰符，是否强制从内存读写） 可否被序列化(transient) 字段数据类型（基本类型、对象、数组） 字段名称 以上信息，对于修饰符，很容易用标志位来表示；而对于数据类型，字段名称，就需要引用常量池中的常量了 字段表结构 类型 名称 数量 含义 u2 access_flags 1 字段和方法的访问修饰符 u2 name_index 1 常量池索引，代表字段的简单名称 u2 descriptor_index 1 常量池索引，代表字段和方法的描述符 u2 attributes_count 1 字段和方法的额外附加属性数量 attribute_info attributes attributes_count 字段和方法的额外的附加属性 简单名称：没有类型和参数修饰的方法或字段名称，如text()的简单名称就是text 字段和方法的描述符：用来描述字段的数据类型、方法和参数列表（包括数量、类型以及顺序）和返回值 access_flags字段访问标志 标志名称 标志值 含义 ACC_PUBLIC 0x0001 字段是否为public ACC_PRIVATE 0x0002 字段是否为private ACC_PROTECTED 0x0004 字段是否为protected ACC_STATIC 0x0008 字段是否为static ACC_FINAL 0x0010 字段是否为final ACC_VOLATILE 0x0040 字段是否为volatile ACC_TRANSIENT 0x0080 字段是否为transient ACC_SYNTHETIC 0x1000 字段是否由编译器自动产生 ACC_ENUM 0x4000 字段是否是enum类型 使用方法可以查看访问标志/访问标志含义表 描述符字符含义描述基本数据类型、void、对象 标志符 含义 B 基本数据类型byte C 基本数据类型char D 基本数据类型double F 基本数据类型float I 基本数据类型int J 基本数据类型long S 基本数据类型short Z 基本数据类型boolean V 基本数据类型void L 对象类型,如Ljava/lang/Object 描述数组： ​ 使用[ + 描述字符来表示数组，如int[]将会被描述为 “[I” 描述方法： 按照先参数列表，后返回值的顺序描述,表示形式为(参数列表)+返回值 如void inc(),描述为()V; 如java.lang.String toStirng()描述为()Ljava/lang/String; 如int togo(int i, char[] source);描述为(I[C)I 方法表方法表中的代码，存放于方法属性表集合中的Code属性中 方法表结构与字段表十分相似 类型 名称 数量 u2 access_flags 1 u2 name_index 1 u2 descriptor_index 1 u2 attributes_count 1 attribute_info attributes attributes_count 方法访问标志 标志名称 标志值 含义 ACC_PUBLIC 0x00 01 方法是否为public ACC_PRIVATE 0x00 02 方法是否为private ACC_PROTECTED 0x00 04 方法是否为protected ACC_STATIC 0x00 08 方法是否为static ACC_FINAL 0x00 10 方法是否为final ACC_SYHCHRONRIZED 0x00 20 方法是否为synchronized ACC_BRIDGE 0x00 40 方法是否是有编译器产生的方法 ACC_VARARGS 0x00 80 方法是否接受参数 ACC_NATIVE 0x01 00 方法是否为native ACC_ABSTRACT 0x04 00 方法是否为abstract ACC_STRICTFP 0x08 00 方法是否为strictfp ACC_SYNTHETIC 0x10 00 方法是否是有编译器自动产生的 重载实现重载方法，需要满足 与原方法具有相同的简单名称 与原方法不同的特征签名 特征签名：一个方法中各个参数在常量中的字段符号引用集合，也就是说返回值不包含在特征签名中，所以Java不能仅仅依靠返回值不同来重载方法。注意：在Class文件格式中特征签名范围更大，只要描述符不完全一致就可以，也就是返回值不同的两个方法也是可以共存的 属性表集合属性表 在Class文件、字段表、方法表中，均有携带自己的属性表集合，以用于描述某些场景的专有信息 属性表对数据项目的顺序没有严格限制，只需要属性名不重复即可 每个属性的名称都是从常量值中引用一个CONSTANT_Utf8_info常量来表示 属性的结构完全自定义，只需要一个u4长度的属性去说明属性值所占用的位数 最简单的属性表结构 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u1 info attribute_length 常用属性 属性名称 使用位置 含义 Code 方法表 Java代码编译成的字节码指令 ConstantValue 字段表 final关键字定义的常量池 Deprecated 类，方法，字段表 被声明为deprecated的方法和字段 Exceptions 方法表 方法抛出的异常 EnclosingMethod 类文件 仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法 InnerClass 类文件 内部类列表 LineNumberTable Code属性 Java源码的行号与字节码指令的对应关系 LocalVariableTable Code属性 方法的局部便狼描述 StackMapTable Code属性 JDK1.6中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配 Signature 类，方法表，字段表 用于支持泛型情况下的方法签名 SourceFile 类文件 记录源文件名称 SourceDebugExtension 类文件 用于存储额外的调试信息 Synthetic 类，方法表，字段表 标志方法或字段为编译器自动生成的 LocalVariableTypeTable 类 使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加 RuntimeVisibleAnnotations 类，方法表，字段表 为动态注解提供支持 RuntimeInvisibleAnnotations 表，方法表，字段表 用于指明哪些注解是运行时不可见的 RuntimeVisibleParameterAnnotation 方法表 作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法 RuntimeInvisibleParameterAnnotation 方法表 作用与RuntimeInvisibleAnnotations属性类似，作用对象哪个为方法参数 AnnotationDefault 方法表 用于记录注解类元素的默认值 BootstrapMethods 类文件 用于保存invokeddynamic指令引用的引导方式限定符 Code属性java程序方法体中的代码经过编译器处理后，最终会变为字节码存储在Code属性中。接口或者抽象类中的方法，就可能不存在Code属性。如果将Java程序中的信息分为代码^15和元数据^16两部分，那么整个Class文件，Code属性用于描述代码，其他数据项目描述原数据 Code属性结构 类型 名称 数量 描述 u2 attribute_name_index 1 指向CONSTANT_Utf8_info型常量的索引，默认值Code，表示属性名称 u4 attribute_length 1 属性值长度 u2 max_stack 1 操作数栈深度的最大值，虚拟机根据这个值分配栈帧(Stack Frame)中的操作栈深度 u2 max_locals 1 局部变量表所需的存储空间，单位Slot,除了基本类型，还存放了方法参数（包括this）、显示异常处理参数（catch块定义的异常、方法体中定义的局部变量；Slot可重用，编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小 u4 code_length 1 编译器编译后生成的字节码指令长度（虽然u4级别长度，但虚拟机限制了一个方法不允许超过65535长度，所以实际只能使用u2的长度） u1 code code_length c存储字节码指令的一系列字节流，每个 指令为u1类型 u2 exception_table_length 1 exception_info exception_table exception_length u2 attributes_count 1 attribute_info attributes attributes_count JVM是如何使用Code属性？Exceptions 属性Exceptions 属性: ​ 列举出方法中可能抛出的受查异常(Checked Exceptions),即方法描述时在throws关键字后面列举的异常 Exceptions 属性表结构 名称 类型 数量 描述 attribute_name_index u2 1 attribute_length u4 1 number_of_exceptions u2 1 抛出受查异常数量 exception_index_table u2 number_of_exceptions 指向常量池中的CONSTANT_Class_info型常量的索引，代表该受查异常的类型 LineNumberTable属性LineNumberTable属性： 用来描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系 非运行时必需属性,但默认生成到Class文件中，可以通过javac -g:none或javac -g:lines手动取消或生成这项信息 主要影响为抛出异常时，显示出错的行号；在调式程序时按照源码行来设置断点 名称 类型 数量 描述 attribute_name_index u2 1 attribute_length u4 1 line_number_table_length u2 1 line_number_table line_number_info line_number_table_length 是一个line_number_table_length长度，类型为line_number_info的集合，line_number_info表包含了start_pc(字节码行号)和line_number（Java源码行号）两个u2类型数据项 LocalVariableTable属性LocalVariableTable属性: 用于描述栈帧中局部变量表中的变量与java源码中定义的变量之间的关系 非运行时必需属性,但默认生成到Class文件中，可以通过javac -g:none或javac -g:vars手动取消或生成这项信息 主要影响为党其他人引用这个方法时，所有的参数名称丢失，导致IDE将会使用诸如arg0、arg1之类的占位符替代原有参数名，并不影响运行，但会影响代码的编写并且在调式期间无法根据参数名称从上下文中获取参数 名称 类型 数量 attribute_name_index u2 1 attribute_length u4 1 local_variable_table_length u2 1 local_variable_table local_variable_info local_variable_table_lengt local_variable_info：代表了一个栈帧与源码中的局部变量的关联，其数据结构如下 start_pc和length组成了局部变量在字节码之中的作用域范围 名称 类型 数量 描述 start_pc u2 1 局部变量的生命周期开始的字节码偏移 length u2 1 局部变量作用该范围覆盖的长度 name_indec u2 1 指向CONSTANT_Utf8_info，代表局部变量的名称 descriptor_index u2 1 指向CONSTANT_Utf8_info，代表局部变量的描述符 index u2 1 局部变量在栈帧局部变量表中Slot的位置 LocalVariableTypeTable属性在JDK1.5后引入，与LocalVariableTable相似，区别在于将记录描述符的descriptor_index替换成了字段的特征签名，目的时为了描述泛型类型 （原因时描述符中的泛型参数化类型被擦除掉后，描述符无法准确描述泛型类型） SourceFile属性SourceFile属性 用于记录生成这个Class文件的源码文件名，该属性长度固定 非运行时必需属性,但默认生成到Class文件中，可以通过javac -g:none或javac -g:s97rce手动取消或生成这项信息 影响在于对于内部类，其类名和类文件是不一致的，如果不生产这项属性，当抛出异常时，堆栈中将不会显示出错误代码所属的文件名 SourceFile属性结构表 SourceFile属性名称 类型 数量 描述 attribute_name_index u2 1 attribute_length u4 1 sourcefile_index u2 1 指向CONSTANT_Utf8_info,常量值为源码文件的文件名 ConstantValue属性ConstantValue属性 通知虚拟机自动为静态变量赋值，只有被static关键字修饰的变量才可以使用这项属性 虚拟机在对非类变量和变量的赋值方式和时刻不同 非static类型的变量：赋值实在实例构造器&lt; init &gt;方法中进行 对于类变量，有两种方式可以选择 a. 在类构造器&lt; clinit &gt;方法中赋值 b. 使用ConstanValue属性赋值 Sun Javac编译器选择方式为： a. 如果同时使用final和static修饰变量，并且该变量是基础类型或者String类型，则通过ConstanValue属性进行初始化。 b. 如果这个变量没有被final修饰，或不是基础类型和String类型,则选择&lt; clinit &gt;方法初始化 名称 类型 数量 attribute_name_index u2 1 attribute_length u4 1 constantvalue_index u2 1 InnerClasses属性InnerClasses属性 用于记录内部类和宿主类之间的关联 如果类中定义了内部类，编译器就会为它以及内部类生成InnerClasses属性 InnerClasses属性结构表 名称 类型 数量 描述 attribute_name_index u2 1 attribute_length u4 1 number_of_class u2 1 内部类信息个数 inner_classes inner_classes_info number_of_class 包含number_of_class个inner_classes_info（描述内部类信息） inner_classes_info表结构 名称 类型 数量 描述 inner_class_info_index u2 1 指向CONSTANT_Class_info，内部类符号引用 outer_class_info_index u2 1 指向CONSTANT_Class_info，外部类符号引用 inner_name_index u2 1 指向CONSTANT_Utf8_info,内部类名称，如果是匿名内部类则为0 inner_class_access_flags u2 1 内部类访问标志 inner_class_access_flags访问标志含义 标志名称 标志值 含义 ACC_PUBLIC 0x0001 内部类是否为public ACC_PRIVATE 0x0002 内部类是否为private ACC_PROTECTED 0x0004 内部类是否为protected ACC_STATIC 0x0008 内部类是否为static ACC_FINAL 0x0010 内部类是否为final ACC_INTERFACE 0x0020 内部类是否为一个接口 ACC_ABSTRACT 0x0400 内部类是否为abstract ACC_SYNTHETIC 0x1000 内部类是否为编译器自动产生 ACC_ANNOTATION 0x4000 内部类是否是一个注解 ACC_ENUM 0x4000 内部类是否是一个枚举 DeprecatedDeprecated属性：用于表示某个类、字段或者方法，不推荐使用 Synthetic属性Synthetic属性： 属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念 标识一个类、字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加 所有由非用户代码生成的类、方法、字段都应当至少设置Synthetic属性或者ACC_SYNTHETIC标志位，但是，是实例构造器&lt; init &gt; 和类构造器 &lt; clinit &gt;无需设置，最典型的例子： Bridge Mthod Sunthetic属性结构 类型 名称 数量 描述 u2 attribute_name_index 1 u4 attribute_length 1 值必须为0x0000 0000,因为没有任何属性值需要设置 StackMap Table 属性StackMap Table 属性 会在虚拟机加载的字节码验证阶段被新类型检查验证器(Type Checker)使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器 该属性包含多个栈映射帧（Stack Map Frames）,每个栈映射帧都显示或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的严重类型；类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一定字节码指令是否符合逻辑约束 版本号大于等于50的class文件，如果没有该属性，说明它带有隐式的StackMapTable属性，作用等同于number_of_entries值为0的StackMapTable属性 一个Code属性最多只能由一个StackMapTable属性 名称 类型 数量 描述 attribute_name_index u2 1 attribute_length u4 1 number_of_entries u2 1 stack_map_frame entries stack_map_frame number_of_entries Signature属性Signature属性 非运行时必须，长度固定，出现于类、属性表和方法表结构的属性表中 用于任何类、接口、初始化方法或者成员的泛型签名，如果它们包含了类型变量或参数化类型，则Signature属性会为它记录泛型签名信息 使用该属性主要原因是java语言的泛型擦除实现的伪泛型 名称 类型 数量 描述 attribute_name_index u2 1 attribute_length u4 1 signature_index u2 1 值必须是一个对常量池的有效索引。常量池在该索引的项必须是CONSTANT_Utf8_info接口，表示类签名、方法签名、字段类型签名（取决于当前的Signature是谁的属性，如类的属性，则就是类签名） BootStrapMethods属性BootStrapMethods属性 可变长度属性，位于类文件的属性表中 用于保存invokedynamic指令引用的引导方法限定符 如果某个类文件结构的常量池中曾经出现过CONSTANT_InvokeDynamic_info类型常量，则必须存在一个明确的BootStrapMethods属性 类文件属性表中最多只能有一个BootStrapMethods属性 BootStrapMethods属性结构 名称 类 型 数 量 描 述 attribute_name_index u2 1 attribute_length u4 1 num_bootstrap_methods u2 1 bootstrap_methods bootstrap_method num_bootstrap_methods bootstrap_method属性结构 名称 类 型 数 量 描 述 bootstrap_method_ref u2 1 值必须是一个对常量池有效的索引，常量池在该索引处的值必须是一个CONSTANT_MethodHandle结构 num_bootstrap_arguments u2 1 bootstrap_arguments u2 num_bootstrap_arguments 数组的每个成员必须是一个对常量池的有效索引，且该索引处的结构必须是CONSTANT_String_info、CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info、CONSTANT_MethodType_info 虚拟机类加载机制类加载过程加载在加载阶段，虚拟机主要功能 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 验证在验证阶段，虚拟机主要功能 确保Class文件的字节路中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的 安全 大体上会完成4个人阶段的验证 a. 文件个hi验证 b. 元数据验证 c. 字节码验证d. 符号引用验证 准备在准备阶段，虚拟机主要功能：正式为类变量分配内存并设置变量初始值，但需要注意 仅为类变量分配内存，不包括实例变量 初始值指数据类型的零值，而不是代码中赋值的初始值（真正赋值操作要在初始化阶段）. 存在一个例外，如果字段存在ConstantValue属性，就会直接进行赋值操作（也就是常量字段） 解析在解析阶段，虚拟机主要功能：将常量池内的符号引用替换称直接引用 符号引用 指的是CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info等类型的常量 以一组符号来描述引用的目标，可以是任何形式的字面量 与虚拟机存在布局可以不同，只要能接受的符号引用必须一致 直接引用： 可以是直接指向目标的 指针、相对偏移量或是一个能间接定位到目标的句柄 直接引用与虚拟机的内存布局相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同 引用的目标必定存在于内存 初始化在初始阶段，虚拟机主要功能：执行类构造器&lt; clinit &gt;()方法。虚拟机严格规定了有且只有的五种情况必须立即对类进行初始化 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，类没有初始化则必须初始化(也就是new关键字对象、读取或设置类的静态字段(常量除外)、调用类静态方法) 使用java.lang.reflect包的方法对类进行反射调用时 当初始化一个类时，发现其父类没初始化，则先触发父类的初始化 当虚拟机启动时，用户指定要执行的主类（main方法），虚拟机会先初始化这个类 使用JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实力最后解析结果为REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄，如果这个方法句柄对应的类没有初始化，则线初始化 被动引用所有引用类的方式都不会触发初始化，称为被动引用 通过子类引用父类的静态字段，不会导致子类初始化 通过数组定义来引用类，不会触发此类的数组化 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 接口的初始化接口的加载过程与类时一致的，编译器会为接口生成”&lt; Clinit &gt;()”类构造器，主要用于初始化接口中所定义的成员变量，与类初始化不同的是，接口不需要接口先完成初始化，只有在真正使用到父接口时（如引用接口中定义的常量）才会初始化 类加载器在类加载阶段，虚拟机需要通过一个类的全限定名来获取定义此类的二进制字节流，而这个动作，被放到了Java虚拟机的外部实现，这个实现的模块就是类加载器 类加载器的功能 实现类的加载动作 类加载器与类共同确定类在Java虚拟机中的唯一性，也就是说，比较两个类的相等的前提是在同一个类加载器下才有意义，不然肯定不相同 类加载分类 启动类加载器(Bootstrap ClassLoader)： 负责加载 JAVA_HOME\lib 目录中的类，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（仅按文件名识别，如 rt.jar）的类，开发者无法直接使用 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的类，或通过 java.ext.dirs 系统变量指定路径中的类库，开发者可直接使用 应用程序类加载器(Application ClassLoader):又加系统加载器，应用程序默认类加载器，负责加载用户路径（classpath）上的类库。开发者可以直接使用 双亲委派模型如图所示的类加载器之间的层次关系，被称为类的双亲委派模型（Parents Delegation Model）。要求除了顶层的启动类加载器外，其他的类加载器必须由父类加载器。 双亲委派模型工作流程 如果一个类加载器收到了类加载请求，它会先把这个请求委派给父类加载器区完成，每一个层次的类加载器都是如此（所以加载请求最终传送到启动类加载器中） 当父类加载器反馈无法完成这个加载请求（它的范围内没有找到所需的类），子类加载器才会尝试自己加载 双亲委派模型优点： 可以让Java类随着它的类加载器一起具备了带有优先级的层次关系，即优先加载父类范围内的类。如类Java.lang.Object,存放于rt.jar之中，由启动类加载器进行加载。在该模型下，只会优先加载Java.lang.Object,从而保证Object类的唯一性。 如果没有使用双亲委派模型，自定义一个Java.lang.Object,并把它放在ClassPath下，然后每一个类加载器都加载了自己的Object，使得一个系统中出现多个Object类，导致Java类型体系中最基础的行为也无法保证 OSGI：模块热部署OSGI 环境下，类加载器不在世双亲委派模型的树状结构，而是进一步发展为更为复杂的网状接口；它实现了模块化热部署。当收到类加载请求时，OSGI将按照一下的顺序进行类搜索 将以java.*开头的类委派给父类加载器 否则，将委派列表名单内的类委派给父类加载器加载 否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载 否则，查找当前Bundle的ClassPath,使用自己的类加载器加载 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派个Fragment Bundle的类加载器加载 否则，查找Dynamic Import 列表的Bundle，委派给对应Bundle的类加载器加载 否则，类查找失败 除了1、2两点符合双亲委派外，其余的类查找都是在平级类加载器中进行的 HotSpot虚拟机对象对象的创建 从语言层面上，创建一个对象只是使用new关键字，而在虚拟机中，当遇到一个new指令，执行步骤如下 检查这个指令的参数能够在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否被加载、解析、初始化；如果没有，则先进行类加载 在类加载检查通过后，虚拟机为新的对象分配内存，内存大小在类加载完后可以确定，而内存分配需要考虑两点: 内存的分配方式和分配的安全性 将分配到的内存空间初始化为0(不包括对象头)，如果使用TLAB，可以提前至TLAB分配时进行 对对象进行必要设置，如设置对象是哪个类的示例，对象的hash code等,而这些信息存放在 对象头 中，此时一个对象创建完成 执行init,初始化对象 内存分配方式： 指针碰撞：如果内存规整，用过的和没用过的各自一边。那么只需要往中间放置一个指针作为分界点指示器，分配内存仅仅就是移动指针而已。 空闲列表(Free List)： 如果内存不规整，即用过的和没用过的互相交错，那么就需要虚拟机来维护一个列表，该列表上记录了可用的内存 内存是否规整，取决于所采用的垃圾收集器 分配的安全性：即多线程下的指针指向 方式一： 对分配内存空间动作采用同步处理: 实际上虚拟机就是采用CAS配失败重试的方式保证原子性 方式二：将内存分配的动作划分在不同空间中进行，即在每个线程在Java堆中先划分出一小块内存,被称为本地线程分配缓冲(TLAB),只有TLAB用完并分配新的TLAB时，才需要同步锁定 对象的内存布局 在HotSpot虚拟机中，对象在内存中存储布局分三块区域 对象头 实例数据 对齐填充 对象头 对象头包括两部分信息 第一部分：存储对象自身的运行时数据 这部分数据被称为 Mark Word， 如HashCode,GC分代年龄，锁状态标志，线程持有锁，偏向线程id，偏向时间戳等；在32位和64位虚拟机中长度分别为32bit和64bit。它是一个非固定的数据结构，以便于尽量在极小的空间内存储更多的信息。 第二部分: 类型指针 虚拟机通过该指针确定对象是哪个类的实例，但并不是所有对象数据必须保留类型指针，即查找对象的元数据并不一定要经过对象本身 如果是数组，对象头还需要一个额外的数据记录数组长度。(虚拟机可以通过元数据确定Java对象大小，而从数组的元数据是不可能知道数组大小的) 实例数据 实例数据存储程序代码中定义的各种类型的字段内容，包括父类继承和子类本身定义。这部分的存储顺序受到虚拟机分配策略参数和字段在java源码中定义的顺序影响。 HotSpot默认分配策略: longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers),可以明显看出，相同宽度的字段会被分配在一起。 对齐填充对齐填充不是必须存在的，仅仅起到占位符的作用，因为HotSpot要求对象起始地址必须是8的倍数（即对象大小必须是8的整数倍），如果对象实例数据部分没有对齐，那么就需要通过对齐填充来补全 对象的访问定位为了使用对象，必须从栈上的renference数据来操作对上的具体对象。而renference只规定了一个指向对象的引用，并没有定义访问方式。所以，对于对象的访问方式，取决于虚拟机，目前主流方式有使用句柄和直接指针两种。 使用句柄访问步骤： java会在堆中划分出一块内存来当句柄池 reference中存储的对象就是句柄地址 句柄中包含了对象的实例数据与类型数据的具体地址 优势：使用句柄访问最大好处就是reference稳定，对象移动时无需更改reference,只会改变j句柄中的实例数据指针 使用直接指针reference中存储的对象就是对象实例数据的地址 优势：使用直接指针好处就是速度快，少一层指针定位的时间开销(HotSpot使用这种方式) 虚拟机字节码指令表 字节码 助记符 指令含义 0x00 nop None 0x01 aconst_null 将null推送至栈顶 0x02 iconst_m1 将int型-1推送至栈顶 0x03 iconst_0 将int型0推送至栈顶 0x04 iconst_1 将int型1推送至栈顶 0x05 iconst_2 将int型2推送至栈顶 0x06 iconst_3 将int型3推送至栈顶 0x07 iconst_4 将int型4推送至栈顶 0x08 iconst_5 将int型5推送至栈顶 0x09 lconst_0 将long型0推送至栈顶 0x0a lconst_1 将long型1推送至栈顶 0x0b fconst_0 将float型0推送至栈顶 0x0c fconst_1 将float型1推送至栈顶 0x0d fconst_2 将float型2推送至栈顶 0x0e dconst_0 将double型0推送至栈顶 0x0f dconst_1 将double型1推送至栈顶 0x10 bipush 将单字节的常量值(-128~127)推送至栈顶 0x11 sipush 将一个短整型常量(-32768~32767)推送至栈顶 0x12 ldc 将int,float或String型常量值从常量池中推送至栈顶 0x13 ldc_w 将int,float或String型常量值从常量池中推送至栈顶(宽索引) 0x14 ldc2_w 将long或double型常量值从常量池中推送至栈顶(宽索引) 0x15 iload 将指定的int型本地变量推送至栈顶 0x16 lload 将指定的long型本地变量推送至栈顶 0x17 fload 将指定的float型本地变量推送至栈顶 0x18 dload 将指定的double型本地变量推送至栈顶 0x19 aload 将指定的引用类型本地变量推送至栈顶 0x1a iload_0 将第一个int型本地变量推送至栈顶 0x1b iload_1 将第二个int型本地变量推送至栈顶 0x1c iload_2 将第三个int型本地变量推送至栈顶 0x1d iload_3 将第四个int型本地变量推送至栈顶 0x1e lload_0 将第一个long型本地变量推送至栈顶 0x1f lload_1 将第二个long型本地变量推送至栈顶 0x20 lload_2 将第三个long型本地变量推送至栈顶 0x21 lload_3 将第四个long型本地变量推送至栈顶 0x22 fload_0 将第一个float型本地变量推送至栈顶 0x23 fload_1 将第二个float型本地变量推送至栈顶 0x24 fload_2 将第三个float型本地变量推送至栈顶 0x25 fload_3 将第四个float型本地变量推送至栈顶 0x26 dload_0 将第一个double型本地变量推送至栈顶 0x27 dload_1 将第二个double型本地变量推送至栈顶 0x28 dload_2 将第三个double型本地变量推送至栈顶 0x29 dload_3 将第四个double型本地变量推送至栈顶 0x2a aload_0 将第一个引用类型本地变量推送至栈顶 0x2b aload_1 将第二个引用类型本地变量推送至栈顶 0x2c aload_2 将第三个引用类型本地变量推送至栈顶 0x2d aload_3 将第四个引用类型本地变量推送至栈顶 0x2e iaload 将int型数组指定索引的值推送至栈顶 0x2f laload 将long型数组指定索引的值推送至栈顶 0x30 faload 将float型数组指定索引的值推送至栈顶 0x31 daload 将double型数组指定索引的值推送至栈顶 0x32 aaload 将引用类型数组指定索引的值推送至栈顶 0x33 baload 将boolean或byte型数组指定索引的值推送至栈顶 0x34 caload 将char型数组指定索引的值推送至栈顶 0x35 saload 将short型数组指定索引的值推送至栈顶 0x36 istore 将栈顶int型数值存入指定本地变量 0x37 lstore 将栈顶long型数值存入指定本地变量 0x38 fstore 将栈顶float型数值存入指定本地变量 0x39 dstore 将栈顶double型数值存入指定本地变量 0x3a astore 将栈顶引用类型数值存入指定本地变量 0x3b istore_0 将栈顶int型数值存入第一个本地变量 0x3c istore_1 将栈顶int型数值存入第二个本地变量 0x3d istore_2 将栈顶int型数值存入第三个本地变量 0x3e istore_3 将栈顶int型数值存入第四个本地变量 0x3f lstore_0 将栈顶long型数值存入第一个本地变量 0x40 lstore_1 将栈顶long型数值存入第二个本地变量 0x41 lstore_2 将栈顶long型数值存入第三个本地变量 0x42 lstore_3 将栈顶long型数值存入第四个本地变量 0x43 fstore_0 将栈顶float型数值存入第一个本地变量 0x44 fstore_1 将栈顶float型数值存入第二个本地变量 0x45 fstore_2 将栈顶float型数值存入第三个本地变量 0x46 fstore_3 将栈顶float型数值存入第四个本地变量 0x47 dstore_0 将栈顶double型数值存入第一个本地变量 0x48 dstore_1 将栈顶double型数值存入第二个本地变量 0x49 dstore_2 将栈顶double型数值存入第三个本地变量 0x4a dstore_3 将栈顶double型数值存入第四个本地变量 0x4b astore_0 将栈顶引用型数值存入第一个本地变量 0x4c astore_1 将栈顶引用型数值存入第二个本地变量 0x4d astore_2 将栈顶引用型数值存入第三个本地变量 0x4e astore_3 将栈顶引用型数值存入第四个本地变量 0x4f iastore 将栈顶int型数值存入指定数组的指定索引位置 0x50 lastore 将栈顶long型数值存入指定数组的指定索引位置 0x51 fastore 将栈顶float型数值存入指定数组的指定索引位置 0x52 dastore 将栈顶double型数值存入指定数组的指定索引位置 0x53 aastore 将栈顶引用型数值存入指定数组的指定索引位置 0x54 bastore 将栈顶boolean或byte型数值存入指定数组的指定索引位置 0x55 castore 将栈顶char型数值存入指定数组的指定索引位置 0x56 sastore 将栈顶short型数值存入指定数组的指定索引位置 0x57 pop 将栈顶数值弹出(数值不能是long或double类型的) 0x58 pop2 将栈顶的一个(对于非long或double类型)或两个数值(对于非long或double的其他类型)弹出 0x59 dup 复制栈顶数值并将复制值压入栈顶 0x5a dup_x1 复制栈顶数值并将两个复制值压入栈顶 0x5b dup_x2 复制栈顶数值并将三个(或两个)复制值压入栈顶 0x5c dup2 复制栈顶一个(对于long或double类型)或两个(对于非long或double的其他类型)数值并将复制值压入栈顶 0x5d dup2_x1 dup_x1指令的双倍版本 0x5e dup2_x2 dup_x2指令的双倍版本 0x5f swap 将栈顶最顶端的两个数值互换(数值不能是long或double类型) 0x60 iadd 将栈顶两int型数值相加并将结果压入栈顶 0x61 ladd 将栈顶两long型数值相加并将结果压入栈顶 0x62 fadd 将栈顶两float型数值相加并将结果压入栈顶 0x63 dadd 将栈顶两double型数值相加并将结果压入栈顶 0x64 isub 将栈顶两int型数值相减并将结果压入栈顶 0x65 lsub 将栈顶两long型数值相减并将结果压入栈顶 0x66 fsub 将栈顶两float型数值相减并将结果压入栈顶 0x67 dsub 将栈顶两double型数值相减并将结果压入栈顶 0x68 imul 将栈顶两int型数值相乘并将结果压入栈顶 0x69 lmul 将栈顶两long型数值相乘并将结果压入栈顶 0x6a fmul 将栈顶两float型数值相乘并将结果压入栈顶 0x6b dmul 将栈顶两double型数值相乘并将结果压入栈顶 0x6c idiv 将栈顶两int型数值相除并将结果压入栈顶 0x6d ldiv 将栈顶两long型数值相除并将结果压入栈顶 0x6e fdiv 将栈顶两float型数值相除并将结果压入栈顶 0x6f ddiv 将栈顶两double型数值相除并将结果压入栈顶 0x70 irem 将栈顶两int型数值作取模运算并将结果压入栈顶 0x71 lrem 将栈顶两long型数值作取模运算并将结果压入栈顶 0x72 frem 将栈顶两float型数值作取模运算并将结果压入栈顶 0x73 drem 将栈顶两double型数值作取模运算并将结果压入栈顶 0x74 ineg 将栈顶int型数值取负并将结果压入栈顶 0x75 lneg 将栈顶long型数值取负并将结果压入栈顶 0x76 fneg 将栈顶float型数值取负并将结果压入栈顶 0x77 dneg 将栈顶double型数值取负并将结果压入栈顶 0x78 ishl 将int型数值左移指定位数并将结果压入栈顶 0x79 lshl 将long型数值左移指定位数并将结果压入栈顶 0x7a ishr 将int型数值右(带符号)移指定位数并将结果压入栈顶 0x7b lshr 将long型数值右(带符号)移指定位数并将结果压入栈顶 0x7c iushr 将int型数值右(无符号)移指定位数并将结果压入栈顶 0x7d lushr 将long型数值右(无符号)移指定位数并将结果压入栈顶 0x7e iand 将栈顶两int型数值”按位与”并将结果压入栈顶 0x7f land 将栈顶两long型数值”按位与”并将结果压入栈顶 0x80 ior 将栈顶两int型数值”按位或”并将结果压入栈顶 0x81 lor 将栈顶两long型数值”按位或”并将结果压入栈顶 0x82 ixor 将栈顶两int型数值”按位异或”并将结果压入栈顶 0x83 lxor 将栈顶两long型数值”按位异或”并将结果压入栈顶 0x84 iinc 将指定int型变量增加指定值(如i++, i–, i+=2等) 0x85 i2l 将栈顶int型数值强制转换为long型数值并将结果压入栈顶 0x86 i2f 将栈顶int型数值强制转换为float型数值并将结果压入栈顶 0x87 i2d 将栈顶int型数值强制转换为double型数值并将结果压入栈顶 0x88 l2i 将栈顶long型数值强制转换为int型数值并将结果压入栈顶 0x89 l2f 将栈顶long型数值强制转换为float型数值并将结果压入栈顶 0x8a l2d 将栈顶long型数值强制转换为double型数值并将结果压入栈顶 0x8b f2i 将栈顶float型数值强制转换为int型数值并将结果压入栈顶 0x8c f2l 将栈顶float型数值强制转换为long型数值并将结果压入栈顶 0x8d f2d 将栈顶float型数值强制转换为double型数值并将结果压入栈顶 0x8e d2i 将栈顶double型数值强制转换为int型数值并将结果压入栈顶 0x8f d2l 将栈顶double型数值强制转换为long型数值并将结果压入栈顶 0x90 d2f 将栈顶double型数值强制转换为float型数值并将结果压入栈顶 0x91 i2b 将栈顶int型数值强制转换为byte型数值并将结果压入栈顶 0x92 i2c 将栈顶int型数值强制转换为char型数值并将结果压入栈顶 0x93 i2s 将栈顶int型数值强制转换为short型数值并将结果压入栈顶 0x94 lcmp 比较栈顶两long型数值大小, 并将结果(1, 0或-1)压入栈顶 0x95 fcmpl 比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将-1压入栈顶 0x96 fcmpg 比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将1压入栈顶 0x97 dcmpl 比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将-1压入栈顶 0x98 dcmpg 比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将1压入栈顶 0x99 ifeq 当栈顶int型数值等于0时跳转 0x9a ifne 当栈顶int型数值不等于0时跳转 0x9b iflt 当栈顶int型数值小于0时跳转 0x9c ifge 当栈顶int型数值大于等于0时跳转 0x9d ifgt 当栈顶int型数值大于0时跳转 0x9e ifle 当栈顶int型数值小于等于0时跳转 0x9f if_icmpeq 比较栈顶两int型数值大小, 当结果等于0时跳转 0xa0 if_icmpne 比较栈顶两int型数值大小, 当结果不等于0时跳转 0xa1 if_icmplt 比较栈顶两int型数值大小, 当结果小于0时跳转 0xa2 if_icmpge 比较栈顶两int型数值大小, 当结果大于等于0时跳转 0xa3 if_icmpgt 比较栈顶两int型数值大小, 当结果大于0时跳转 0xa4 if_icmple 比较栈顶两int型数值大小, 当结果小于等于0时跳转 0xa5 if_acmpeq 比较栈顶两引用型数值, 当结果相等时跳转 0xa6 if_acmpne 比较栈顶两引用型数值, 当结果不相等时跳转 0xa7 goto 无条件跳转 0xa8 jsr 跳转至指定的16位offset位置, 并将jsr的下一条指令地址压入栈顶 0xa9 ret 返回至本地变量指定的index的指令位置(一般与jsr或jsr_w联合使用) 0xaa tableswitch 用于switch条件跳转, case值连续(可变长度指令) 0xab lookupswitch 用于switch条件跳转, case值不连续(可变长度指令) 0xac ireturn 从当前方法返回int 0xad lreturn 从当前方法返回long 0xae freturn 从当前方法返回float 0xaf dreturn 从当前方法返回double 0xb0 areturn 从当前方法返回对象引用 0xb1 return 从当前方法返回void 0xb2 getstatic 获取指定类的静态域, 并将其压入栈顶 0xb3 putstatic 为指定类的静态域赋值 0xb4 getfield 获取指定类的实例域, 并将其压入栈顶 0xb5 putfield 为指定类的实例域赋值 0xb6 invokevirtual 调用实例方法 0xb7 invokespecial 调用超类构建方法, 实例初始化方法, 私有方法 0xb8 invokestatic 调用静态方法 0xb9 invokeinterface 调用接口方法 0xba invokedynamic 调用动态方法 0xbb new 创建一个对象, 并将其引用引用值压入栈顶 0xbc newarray 创建一个指定的原始类型(如int, float, char等)的数组, 并将其引用值压入栈顶 0xbd anewarray 创建一个引用型(如类, 接口, 数组)的数组, 并将其引用值压入栈顶 0xbe arraylength 获取数组的长度值并压入栈顶 0xbf athrow 将栈顶的异常抛出 0xc0 checkcast 检验类型转换, 检验未通过将抛出 ClassCastException 0xc1 instanceof 检验对象是否是指定类的实际, 如果是将1压入栈顶, 否则将0压入栈顶 0xc2 monitorenter 获得对象的锁, 用于同步方法或同步块 0xc3 monitorexit 释放对象的锁, 用于同步方法或同步块 0xc4 wide 扩展本地变量的宽度 0xc5 multianewarray 创建指定类型和指定维度的多维数组(执行该指令时, 操作栈中必须包含各维度的长度值), 并将其引用压入栈顶 0xc6 ifnull 为null时跳转 0xc7 ifnonnull 不为null时跳转 0xc8 goto_w 无条件跳转(宽索引) 0xc9 jsr_w 跳转至指定的32位offset位置, 并将jsr_w的下一条指令地址压入栈顶 Hotspot 虚拟机参数表官网查询地址: Hotspot 虚拟机参数表 Java内存模型TPS（每秒事务处理数 Transactions Per Second）：衡量一个服务器性能的高低好坏的一个重要指标：表示一秒内服务端评价能响应的请求总数 Java内存模型(Java Memory Model, JMM)：用于屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致性的内存访问效果 硬件的效率与一致性​ 并发执行计算任务和充分利用处理器，是提升性能的关键。但事实上，想要更好的执行运算任务，光靠处理器是不够的。因为处理器在处理数据时会与内存进行交互，必然会存在IO操作，然而处理器与存储设备之间的运算速度之间差距太大，所以现在的计算机系统加入了一层高速缓存来作为内存与处理器之间的缓冲，使其京可能接近处理器运算速度。它的运作流程为：将运算需要使用到的数据复制到缓存中，让运算快速运行，运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。 ​ 高速缓存虽然解决了处理器与内存的速度矛盾，但也带来了一个新的问题：缓存一致性（Cache Coherence）。在处理系统中，每个处理器都有独立的高速缓存，但同时又共享同一主内存（Main Memory）,当多个处理器的运算任务都设计同一块主内存的时候，可能会导致缓存数据的不一致。为了解决这个问题，在处理器访问缓存时，会遵循一些协议（不同物理机器协议也会不同），使得缓存数据一致。在这个基础上，所谓的内存模型，就可以理解为在特定操作协议下，对特定内存或高速缓存进行读写访问的过程抽象 ​ 除了高速缓存外，乱序执行优化(Out-Of-Order Execution)也是使处理器内部的运算单元能尽量被利用的方法，也就是说，在处理过程中，计算的先后顺序可能与输入代码中的顺序不一致，只保证最后的结果一致。Java虚拟机的即时编译器也有类似的指令重排序(Instruction Reorder)优化 主内存和工作内存​ Java内存模型主要是用于定义程序中各个共享变量（包括实例字段、静态字段、构成数组对象的元素）的访问规则，即变量在内存和存储设备之间的读写。而对于局部变量、方法参数这些线程私有变量，因其不存在竞争问题，所以并不在Java内存模型中。 ​ Java内存模型规定所有变量都存储在主内存中，每条线程拥有自己的工作内存（Working Memroy）,作为高速缓存的角色。工作内存会保存该线程所用到的从主内存拷贝而来的变量（但并不会拷贝整个变量），然后在其中进行操作。不同线程之间的工作内存相互独立，想要传递数值则必须通过主内存进行 ​ 可以看到，java内存模型与上一节的高速缓存模型结构类似 内存间交互操作如何从主内存拷贝变量到工作内存，又如何从工作内存将数据同步到主内存，且保证操作为原子性，Java内存模型共定义了8中操作完成 操作 描述 作用位置 lock（锁定） 把一个变量标识为一条线程独占状态 主内存 unlock（解锁） 把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 主内存 read（读取） 把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 工作内存 load（载入） 把通过read操作从主内存中得到的变量值放入工作内存的变量副本中 工作内存 use（使用） 把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作 工作内存 assign（赋值） 把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 工作内存 store（存储） 把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作使用 工作内存 write（写入） 把通过store操作从工作内存中得到的变量的值放入主内存的变量中 工作内存 ​ 例如，如果要执行变量从主内存复制到工作内存，就需要顺序执行read和load操作；如果需要把工作内存同步到主内存，就需要顺序执行store和write操作。类似于这样的操作，Java内存模型只要求保证执行顺序即可，允许在其中插入其他命令。 ​ Java内存模型对8中操作的定制了一些必须满足的规定 不允许read和load、store和write操作之一单独出现。 不允许线程丢弃它的最近的assign操作，即变量在工作内存中改变之后，必须同步回主内存。 不允许线程把没有经过assign操作的变量，同步回主内存。 一个新的变量只能在主内存中诞生，即对一个变量进行use、store操作之前，必须先执行过load、assign操作。 一个变量在同一时刻只能被一条线程执行lock操作，一旦lock成功，可以被同一线程重复lock多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。 对一个变量执行lock操作，将会清空工作内存中该变量的值，所以在执行引擎使用这个变量前，需要重新执行load或assign操作对其进行初始化。 对一个变量执行unlock操作之前，必须先把该变量同步回主内存(执行store、write操作)。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许unlock一个被其他线程lock的变量 对Volatile型变量的特殊规则Java内存模型对Volatile定义了一些特殊的访问规则，volatile是Java虚拟机提供了一个轻量级的同步机制，它能保证变量的可见性，但不能保证原子性。 如执行以下程序，该程序虽然使用了volatile，但其仍然是线程不安全的。cool++ 指令在虚拟机中，实际上是由四条指令构成，可能在执行iconst_1或者iadd，其他线程完全有可能改变了cool的值（实际上，就算只有一条指令，也不能说明这条指令是原子操作，字节码指令在解释器中也是要运行多行代码） 12345678private static final volatile int cool;cool = cool ++;// cool++的字节码指令0: getstatic #3 // Field cool:I3: iconst_14: iadd5: putstatic #3 // Field cool:I 除了保证可见性的特性外，volatile的另一个特性是禁止指令重排序优化 特殊规则如下 只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load操作。线程T对变量V的use操作可以认为是与线程T对变量V的load和read操作相关联的，必须一起连续出现。这条规则要求在工作内存中，每次使用变量V之前都必须先从主内存刷新最新值，用于保证能看到其它线程对变量V所作的修改后的值。 只有当线程T对变量V执行的前一个动是assign的时候，线程T才能对变量V执行store操作；并且，只有当线程T对变量V执行的后一个动作是store操作的时候，线程T才能对变量V执行assign操作。线程T对变量V的assign操作可以认为是与线程T对变量V的store和write操作相关联的，必须一起连续出现。这一条规则要求在工作内存中，每次修改V后都必须立即同步回主内存中，用于保证其它线程可以看到自己对变量V的修改。 假定操作A是线程T对变量V实施的use或assign动作，假定操作F是操作A相关联的load或store操作，假定操作P是与操作F相应的对变量V的read或write操作；类型地，假定动作B是线程T对变量W实施的use或assign动作，假定操作G是操作B相关联的load或store操作，假定操作Q是与操作G相应的对变量V的read或write操作。如果A先于B，那么P先于Q。这条规则要求valitile修改的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。 对于long和double性变量的特殊规则​ java内存模型对于64位数据的特殊规定：运行虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位操作（在JDK1.5后，读为原子性，写操作拆分），也就是说对这两种数据类型的操作是非原子性的，这就是所谓的非原子性协定（Nonatomic Treatment of double and long Variables）。之所以要分为两次32位操作，主要原因是受限于硬件，必须差分成32bit来处理。虽然，这么做，线程是很有可能得到一个半个变量的值，但实际上是很少见的情况。更何况，现在的虚拟机商家早就自己实现了64位数据的原子性操作，所以我们一般不需要生命volatile变量 原子性、可见性、有序性​ 原子性（Atomicity）：即对变量的操作在完成前是完全不受干扰，要执行就执行完成，要么就不执行。Java内存除了提供的8个操作用于保证原子性，其中，lock和unlock操作没有开放给用户，但虚拟机提供了monitorenter和monitorexit两个字节码指令来隐式使用这两个操作，sysnchronized关键字便是使用了这两个字节码指令来完成原子性操作的 ​ 可见性(Visibility)：即一个线程改变共享值，所有线程都可以感知这个变化。Java内存保证可见性的机制为修改变量后同步刷新回主内存，读取变量前会先从主内存中刷新。volatile、synchronized和final，都可以实现可见性。final实现可见性的原理为：被final修饰的字段在构造器中一旦初始化完成，并且this没有引用逃逸，其他线程就能看见该字段的值 ​ 有序性(Ordering)：如果在本线程内观察，所有的操作都是有序的（体现为线程内表现为串行的语义&quot;）；如果在一个线程观察另一个线程，所有的操作都是无序的(体现为指令重排序和工作内存于主内存同步延迟`)。volatile关键字禁止指令重排序，synchronize规定持有同一个锁的两个同步快只能串行地进入 先行发生原则(happens-before)先行发生原则十分重要，它规定了代码执行的顺序，如果没有顺序性的保障，虚拟机就有可能进行重排序。 以一个简单例子为例 1234int a = 0;int b = 2;int c = a +b;a= b-2; 这段代码没有任何问题？是的，但如果没有先行发生原则的保证，那虚拟机重新排序后可能按以下顺序执行,那问题就大了 1234int a = 0;a= b-2;int c = a +b;int b = 2; 事实上，在先行发生原则下，保证了虚拟机会按照从上到下来执行语句（当然可能进行重排序优化，但起码保证了执行结果不会出错） Java提供的具体规则如下 程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对于同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。 volatile变量规则（Volatile Variable Rule）：对于一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间的先后顺序。 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。 线程中断规则（Thread Interrupt Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。 需要注意的是，就算按照先行发生原则下的代码，在时间上的执行也不一定是顺序的，如“指令重排序” 指令重排序as-if-serial:意为所有操作的顺序可以为了优化而重排序，但结果保持不变。但只适用于单线程 单线程下的重排序如下示例，step1和step2之间没有数据依赖关系，但stpe1、step2与step3存在数据依赖关系 123int a = 1; //step1int b = 2; //step2int c = a + b; //step3 上述代码的happens-before关系为 123step1 happens-before step2 // 程序顺序次序规则step2 happens-before step3 // 程序顺序次序规则step1 happens-before step3 // 传递性 但事实上并不一定会按照上述的顺序执行，而很有可能为了优化而改变顺序 多线程下的重排序多线程下的排序，将会改变执行结果 12345678910111213class demo&#123; int a = 0; iboolean flag = false; public void writer()&#123; int a = 1; //step1 boolean flag = true;//step2 &#125; public void read()&#123; if(flag)&#123;//step3 int b = a+a;//step4 &#125; &#125;&#125; 如果线程A执行wirter()方法，线程B执行read()方法,可能出现以下两种情况 情况1：step1 、step2之间没有依赖关系，进行重排序，导致a的值没有改变的时候，step4就读取了a，导致结果错误 1234flag = true; //线程Aif(flag)//线程Bint b = a+a;//线程Ba = 1//线程A 情况2：step3、step4存在控制依赖关系，当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。在猜测执行的影响下，step的a+a操作很有可能提前读取a的值，然后把计算结果存入到一个。名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来setp3的条件判断为真时，就把该计算结果写入变量b中。但是，结果已经发生改变12345temp = a *a;//线程B,读取到了为a初始化之前的值flag = true;//线程Aif(flag)//线程Bint b = temp;//线程Ba = 1//线程B volatile、synchronize、final重排序规则volatile：禁止重排序，即当执行到volatile修饰的变量时，位于其前面的语句肯定已经执行（前面语句的顺序可以重排），位于其后面的语句肯定没有执行（后面语句的顺序可以重排） synchronize：规定持有同一个锁的两个同步快只能串行地进入 final重排序有两个规则 1234567891011121314151617181920public class FinalExample &#123; int i; //普通变量 final int j; //final变量 static FinalExample obj; public void FinalExample () &#123; //构造函数 i = 1; //写普通域 j = 2; //写final域 &#125; public static void writer () &#123; //写线程A执行 obj = new FinalExample (); &#125; public static void reader () &#123; //读线程B执行 FinalExample object = obj; //读对象引用 int a = object.i; //读普通域 int b = object.j; //读final域 &#125;&#125; 规则1：在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序，如果再细化分解，该规则包含两个方面 禁止编译器把 final 域的写重排序到构造函数之外 编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外 1234567//线程A的执行顺序构造函数开始j = 1 // 写入final域StoreStore屏障构造函数结束把构造对象的引用赋值给变量obj//引用赋值i = 1; //写入普通域，随便排序 规则2：在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障 12345//线程B执行顺序int a = object.i; //读取普通域，随便排序FinalExample object = obj //读对象引用LoadLoad屏障 // 插入屏障，在读final域之前int b = object.j; // 读final域 需要注意的是，在使用final要防止this的引用逃逸 12345678910111213141516171819public class FinalReferenceEscapeExample &#123; final int i; static FinalReferenceEscapeExample obj; public FinalReferenceEscapeExample () &#123; i = 1; //1写final域 obj = this; //2 this引用在此“逸出” &#125; public static void writer() &#123; //线程A执行 new FinalReferenceEscapeExample (); &#125; public static void reader &#123; //线程B执行 if (obj != null) &#123; //3 int temp = obj.i; //4 读取final域 &#125; &#125;&#125; 如上代码,线程A、B的执行顺序可能如下， 123456构造函数开始 //线程Aobj=this; //线程A，引用逃逸，obj变为可见if (obj != null// 线程Bint temp = obj.i; //线程B，读取final域，读取到了final域初始化之前的值i = 1; //线程A，final域初始化构造函数结束 可以看出，在构造函数返回前，被构造的对象的引用不能为其他线程可见，因为此时的 final 域可能还没有被初始化 脚注]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 并发]]></title>
    <url>%2Fblog%2F2018%2F02%2F02%2Fjava-thread.all%2F</url>
    <content type="text"><![CDATA[Thread现代操作系统在运行一个程序时，会为其创建一个进程 。而线程，是现代操作系统调度的最小单元，也叫轻量级进程； 线程好处 更好的利用处理器核心 更快的响应时间 更好的编程模型 构造函数在构造函数内部，都是调用了一个init()方法来进行初始化 123456789public Thread()public Thread(Runnable target)Thread(Runnable target, AccessControlContext acc)public Thread(Runnable target, String name)public Thread(String name)public Thread(ThreadGroup group, Runnable target) public Thread(ThreadGroup group, Runnable target, String name)public Thread(ThreadGroup group, Runnable target, String name,long stackSize)public Thread(ThreadGroup group, String name) init()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Initializes a Thread. * * @param g 线程组 * @param target 任务对象 * @param name 线程的名字 * @param stackSize 线程所需栈大小，0表示忽略此参数 * @param acc ？？？ * @param inheritThreadLocals 如果为true，将会从构造线程继承局部线程的初始值 */private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; // 线程名在构造函数中的默认值为"Thread-" + 线程的编号 if (name == null) &#123; throw new NullPointerException("name cannot be null"); &#125; this.name = name; //当前线程。即为Thread的父线程 Thread parent = currentThread(); //获取安全管理器？？？？ SecurityManager security = System.getSecurityManager(); if (g == null) &#123; /* Determine if it's an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) &#123; g = security.getThreadGroup(); &#125; /* If the security doesn't have a strong opinion of the matter use the parent thread group. */ if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) &#123; if (isCCLOverridden(getClass())) &#123; security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID();&#125; ThreadGroup表示一组线程，可以包括其他线程组。为除了初始线程组外，每个线程组都有父线程。该类属于Java.lang包中，如果在构造Thread时指定了线程组，那么就会将Thread加入到线程组中。方便与线程的管理。（未指定默认为null） todo 创建线程 既然要运行线程，必然需要创建线程对象，java有三种创建线程的方式 通过java.lang.Runnable接口(推荐) 继承java.lang.Thread类 使用线程池获取线程对象(详细看《Excutor框架》) 通过java.lang.Runnable接口(推荐) Runnable接口只有一个run()方法，是一个函数式接口，所以可以运用lambda表达式 12345//Runnable接口源码@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; 具体实现方式为 12345//使用lambda表达式，省去了实现Runnable接口//task code 写run()方法的实际逻辑处理Runnable runnable = () -&gt;&#123;task code&#125;Thread threadA = new Thread(runnable);Thread threadB = new Thread(runnable); 继承java.lang.Thread 具体实现方式为 1234567//继承Thread并重写run()方法public class MyThread extends Thread &#123; @Override public void run() &#123; task code &#125;&#125; 两种方式的区别 为什么要选择通过java.lang.Runnable接口的方式创建线程？ 将运行机制和任务进行分开解耦,Thread类负责运行机制，Runnable接口负责任务方法 减少线程开销，如果使用方式二，对于每个任务都需要创建一个线程；而方式一可以通过传入不同的Runnable,来实现一个线程执行不同任务 启动线程 线程对象在初始化完成之后,调用如下方法启动线程 1aThread.start() aThread.run()并不是启动线程，只是运行了run()方法 终止线程线程有多种终止线程的方式. 分为主动、被动 被动： a. run方法执行到最后一句，并且return返回 b. 出现了方法中没有捕获的异常 主动 a. 使用stop()，已经废弃 b. 通过Thread类提供的interrupt()方法请求中断线程 c. 使用boolean变量控制 interrupt() 中断线程 线程通过一标识位属性，来表示该线程是否被中断；中断某个线程，实际就是设置这个标识位 1234567891011121314151617181920212223242526272829//中断某个线程public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0();&#125;//判断线程是否中断//如果线程中断，则返回true；但如果线程已经终止，那么无论是否被中断过，都会返回false public boolean isInterrupted() &#123; return isInterrupted(false); &#125;//静态方法，对当前线程的中断标识位进行复位public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125;//JNI 方法，当ClearInterrupted为true时，会复位中断标识private native boolean isInterrupted(boolean ClearInterrupted); 此外，许多声明抛出InterruptedException的方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除 线程状态 获取线程状态 12//java 5新增public State getState(); Thread在内部定义了一个枚举类 1234567891011121314public enum State &#123; NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;&#125; NEW（新创建）状态 创建了线程但没有执行start()方法，此时处于新创建状态 RUNNABLE (可运行) 状态 调用了start()方法的线程就处于RUNNABLE状态，需要注意的是，该状态下的线程可能正在运行，也可能没有运行，所以是运行态 BLOCKED （阻塞）状态 当系统试图获取一个内部的对象锁（注意，不是java.util.concurrent库中的锁），但该锁已被其他锁持有，当前线程就会进入阻塞状态 WAITING (等待)状态 调用Object.wait方法、Thread.join方法，或者等待java.util.concurrent库中的Lock或Condition时,会进入等待状态 TIME_WAITING (计时等待)状态 线程因调用了某些带超时参数的方法时，会计入该状态。该状态会持续到超时期满或者接收到适当的通知 TERMINATER (终止)状态 线程终止时的状态 线程状态的变迁 Java将操作系统中的运行和就绪两个状态合并称为可运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法 线程优先级 Thread类定义了三个优先级常量和一个成员变量 *priority* ，利用该成员变量来控制优先级;优先级的范围: 1~10,默认5 1234567891011121314private int priority;/*** The minimum priority that a thread can have.*/public final static int MIN_PRIORITY = 1;/*** The default priority that is assigned to a thread.*/public final static int NORM_PRIORITY = 5;/*** The maximum priority that a thread can have.*/public final static int MAX_PRIORITY = 10; 设置优先级 (需要注意的是，优先级收操作系统的影响，如在ubuntu下会忽略线程优先级) 12345678910111213public final void setPriority(int newPriority) &#123; ThreadGroup g; checkAccess(); if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123; throw new IllegalArgumentException(); &#125; if((g = getThreadGroup()) != null) &#123; if (newPriority &gt; g.getMaxPriority()) &#123; newPriority = g.getMaxPriority(); &#125; setPriority0(priority = newPriority); &#125;&#125; 获取优先级 123public final int getPriority() &#123; return priority;&#125; 守护线程守护线程是一种支持型线程,它主要被用作程序中后台调度以及支持性工作，当只有守护线程时，Java虚拟机会退出 Thread类定义了一个成员变量 daemon 来标识该线程是否为守护线程, 12/* Whether or not the thread is a daemon thread. */private boolean daemon = false; 相关方法 12345678910111213//设置守护线程public final void setDaemon(boolean on) &#123; checkAccess(); if (isAlive()) &#123; throw new IllegalThreadStateException(); &#125; daemon = on;&#125;// 判断是否为守护线程public final boolean isDaemon() &#123; return daemon;&#125; 需要注意的是 Daemon属性需要在启动线程之前设置，不能在启动线程之后设置 Daemon中的finally块并不一定执行(JVM提前退出) 未捕获异常处理器 Thread类中定义了两个处理器，用来处理run()方法可能出现的异常。run()方法不能抛出受查异常，而非受查异常会导致线程终止，但在线程终止之前，异常会被传到处理器中。 1234567//如果不设置，则未捕获异常处理器为空// null unless explicitly setprivate volatile UncaughtExceptionHandler uncaughtExceptionHandler;// null unless explicitly set//静态的默认处理private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler; 设置未捕获异常处理器 1234public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)// 静态方法为每一个线程设置一个默认的处理器public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) 如果没有设置未捕获异常处理器的话，那么默认的异常处理器为java.lang.ThreadGroup类,该类是UncaughtExceptionHandler的实现类，其处理异常方式如下 该线程有父线程，则执行父线程的uncaughtException()方法;没有，则进入2 调用Thread.getDefaultUncaughtExceptionHandler(),调用静态的默认处理器；如果返回null,则进入3 如果异常(Throwable)是TreadDeath的一个实例，则什么都不做；否则，进入4 线程名字以及Throwable的栈轨迹输出到System.err上 123456789101112131415public void uncaughtException(Thread t, Throwable e) &#123; if (parent != null) &#123; parent.uncaughtException(t, e); &#125; else &#123; Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler(); if (ueh != null) &#123; ueh.uncaughtException(t, e); &#125; else if (!(e instanceof ThreadDeath)) &#123; System.err.print("Exception in thread \"" + t.getName() + "\" "); e.printStackTrace(System.err); &#125; &#125;&#125; Thread.join()的使用 含义： 线程A拥有线程B的索引，并再内部方法调用了线程B的threadB.join() 线程A必须等待线程B终止，才能从threadB.join()方法返回 join()内部利用了通知/等待机制 线程其他方法1234567891011//使线程休 眠//单位毫秒。抛出InterruptedException异常 public static native void sleep(long millis) throws InterruptedException;//返回代表当前执行线程的对象，静态方法Thread.currentThread();//过期方法,原因是无法保证能释放占有的资源，容易引发死锁suspend()：暂停 resume()：恢复 stop()：停止 线程间的通信如果线程只是独立运行，那将毫无意义。当多个线程相互配合完成工作时，才会发挥巨大的价值。 线程的安全性多线程在再带来巨大的性能的同时，也引发了安全问题 想要编写线程安全的代码，核心在于要对对象状态[^3]访问操作进行管理，特别是对共享[^1]的和可变[^2]的状态的访问。当多个线程对一个对象的可变状态变量进行访问时，就可能引发线程安全性问题；所以必须得采用同步机制来协同这些线程对状态变量的访问； java主要的同步机制有 synchronized 关键字 volatile Lock 原子变量 等待/通知机制在线程的通信过程中，往往会出现：一个线程修改了对象的值，另一个线程感知变化，进行相应的操作。那系统需要保证一个线程改变时另一个线程能及时做出反应。而等待/通知机制，可以在确保及时性的同时，降低开销。 等待/通知机制核心思想 线程A调用对象O的wait()进入等待状态 线程B执行完程序后，调用对象O的notify()/notifyAll()方法 线程A收到通知从wait()方法返回，执行它的操作 等待/通知机制相关方法 调用wait()、notify()以及notifyAll()时需要注意的细节 使用wait()、notify()和notifyAll()时需要先对调用对象加锁。 调用wait()方法后,线程状态由RUNNING变为WAITING,并将当前线程放置到对象的等待队列。 notify()或notifyAll()方法调用后,等待线程依旧不会从wait()返回,需要调用notify()或notifAll()的线程释放锁之后,等待线程才有机会从wait()返回。 notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中,而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列,被移动的线程状态由WAITING变为BLOCKED。 从wait()方法返回的前提是获得了调用对象的锁 等待/通知经典范式通过任务的不同，可以将线程分为 等待方（消费者线程,感知变化，进行相应的操作） 通知方(生产者线程,修改某个对象的值) 等待方规则: 获取锁对象 如果条件不满足,那么调用对象的wait()方法,被通知后仍要检查条件。 条件满足则执行对应的逻辑。 伪代码: 123456synchronized(aObject.class) &#123; while(condition) &#123; aObject.wait(); &#125; doSomething;&#125; 通知方规则： 获取所对象 改变条件 通知所有等待在对象上的线程。 伪代码： 1234synchronized(aObject.class) &#123; change condition to true; aObject.notifyAll();`&#125; 管道流管道流主要用于线程通信时的数据传输，而传输的媒介为内存。Java.io一共提供了四种具体的管道流实现 PipedOutputStream：字节输出流 PipedInputStream：字节输入流 PipedReader：字符输入流 PipedWriter：字节输出流 对于管道流，输入/输出流必须绑定起来,也就是调用connect()方法,否则会抛出异常 12//将输出流和输入流进行连接,否则在使用时会抛出IOExceptionaPipedWriter.connect(aPipedReader); 示例123456789101112131415161718192021222324252627282930313233343536373839404142public class Piped &#123; public static void main(String[] args) throws Exception&#123; PipedWriter pipedWriter = new PipedWriter(); PipedReader pipedReader = new PipedReader(); //连接输入输出流 pipedReader.connect(pipedWriter); Thread printThread = new Thread(new Print(pipedReader), "PrintThread"); printThread.start(); int receive = 0; try &#123; // 输出流将数据写入receive while ((receive = System.in.read()) != -1) &#123; pipedWriter.write(receive); &#125; &#125; finally &#123; pipedWriter.close(); &#125; &#125; static class Print implements Runnable&#123; private PipedReader in; public Print(PipedReader in)&#123; this.in = in; &#125; @Override public void run() &#123; int receive = 0; try&#123; //读入数据并输出 while ((receive = in.read()) != -1)&#123; System.out.print((char) receive); &#125; &#125;catch (IOException e)&#123; &#125; &#125; &#125;&#125; 顺序执行，join()方法如果需要让线程A必须再另一个线程B执行完后再执行，可以在线程A中调用线程B的join()方法 1234567public final void join() throws InterruptedException //超时等待，如果指定时间内线程没有执行完，直接返回//millis： 微秒//nanos： 额外的纳秒public final synchronized void join(long millis)public final synchronized void join(long millis, int nanos) join()的部分源码，可以看出，join()使用了通知/等待经典范式 12345678// 加锁当前线程对象public final synchronized void join() throws InterruptedException &#123; // 条件不满足,继续等待 while (isAlive()) &#123; wait(0); &#125;// 条件符合,方法返回&#125; 线程变量ThreadLocalThreadLocal,即线程变量(泛型),是一个以ThreadLocal对象为键、任意对象为值的存储结构；一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。 ThreadLocal的目的是让每个线程都拥有一个线程私有的数据，并且线程之间彼此不影响。通常会被定义为private static 123456// 创建ThreadLocal&lt;T&gt; aThreadLocal = new ThreadLocal&lt;T&gt;();// 设置值public void set(T value) // 获取值public T get() 示例以下是常用Profiler类，用于计算时间差 12345678910111213141516171819202122public class Profiler &#123; private static final ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = new ThreadLocal&lt;Long&gt;() &#123; // initialValue()方法用于设置get()方法的初始值 //如果在调用get()方法前没有调用set()方法，那么get()会在第一次调用时会调用initialValu()方法来获取并设置初始值 protected Long initialValue() &#123; //返回初始值 return System.currentTimeMillis(); &#125; &#125;; public static void begin() &#123; TIME_THREADLOCAL.set(System.currentTimeMillis()); &#125; public static long end() &#123; return System.currentTimeMillis() - TIME_THREADLOCAL.get(); &#125; public static void main(String[] args) throws Exception &#123; Profiler.begin(); TimeUnit.SECONDS.sleep(1); System.out.println("Cost: " + Profiler.end() + " mills"); &#125;&#125; Java1.5之前的线程安全锁对象和条件对象锁对象 如下代码，一旦一个线程封锁了锁对象，其他任何线程都无法通过lock()语句，会被阻塞，直到第一个线程释放锁对象 1234567myLock.lock();try&#123; do something&#125;finally&#123; myLock.unlock();&#125; 条件对象ConditionCondition用于管理那些获得锁但无法执行有用工作的线程，当条件不满足时，先主动释放掉锁，进入等待状态，等到条件满足在进行操作。一个锁对象，可以对应对各条件对象 12345678910111213//ThreadAmyLcok.lock();//锁定try&#123; //获取一个条件对象 aCondtion = myLock.newCondition(); //当条件不满足时，通过条件对象让线程阻塞，并释放锁 //该线程很一直处于阻塞状态，直到其他线程aCondition.signal()，唤醒等待的线程 //被唤醒后如果条件满足，则可以退出循环，继续操作了 while(!(ok to proceed))&#123; aCondition.await(); &#125;&#125; 条件对象需要设置几个方法 123456//让线程阻塞并释放锁await();//唤醒单个被await()阻塞的队列signal();//唤醒所有被await()阻塞的队列signalAll() 在Object中，已经定义了三个类似的方法 123456//让线程阻塞并释放锁wait();//唤醒单个被await()阻塞的队列notify();//唤醒所有被await()阻塞的队列notifyAll(); 为什么要设置两套唤醒方法？ 其实在java1.5 前，只能通过关键字synchronized关键字来隐式获取锁对象和条件对象,或者传入显式的对象，即所有方法都可以锁对象，而且，并不能直接获取条件对象，所以，在Object中设置了三个关于唤醒等待的方法 而java1.5之后，有了专门的显式锁，同时可以显式获取到对应的条件对象，为了区分两者，所以就有了两套 volatile关键字java是支持多个线程访问同一个对象或者对象的成员变量，但每个线程，拥有的是它们的**拷贝**.因此，这个拷贝的对象**可能不是最新**的。当然，如果使用`锁机制`的话肯定没问题，但如果仅仅为了读写一两个实例域而使用锁，**开销就显得有点大**了。volatile关键字就是为`实例域`提供了一种免锁的机制。 Volatile工作方式 访问数据时，告知程序需要从共享内存中获取 改变数据时，告知程序需要同步刷新回共享内存。 保证所有线程对变量访问的可见性，但不保证其原子性 Volatile使用条件volatile是不能保证操作的原子性，如果想要使用volatile达到线程安全，必须同时满足下面两个条件 对变量的写操作不依赖于当前值(如x++,其操作其实是读-&gt;添加-&gt;赋值三个操作，需要保证原子性，所以不能使用volatile) 该变量没有包含在具有其他变量的不变式中 正确使用 volatile 示例状态标志 实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件 123456789101112volatile boolean shutdownRequested; ... public void shutdown() &#123; shutdownRequested = true; &#125; public void doWork() &#123; //每次循环，都会读取最新的shutdownRequested值，如果使用synchronized,就需要加锁，阻塞、唤醒等一些列操作 while (!shutdownRequested) &#123; // do stuff &#125;&#125; 一次性安全发布对于以下语句，实际上又三个步骤 分配内存空间 初始化对象 对象指向内存空间 1theFlooble = new Flooble(); 但实际上，2，3可能重排，变为 分配内存空间 对象指向内存空间 初始化对象 再看如下代码 Thread A进行initInBackground()时，到达第二步，对象指向内存空间 Thread B在此时读取theFlooble,不为空，但对象却还没初始化 使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前 123456789101112131415161718192021//Thread Apublic class BackgroundFloobleLoader &#123; public volatile Flooble theFlooble; public void initInBackground() &#123; // do lots of stuff theFlooble = new Flooble(); // this is the only write to theFlooble &#125;&#125; // Thread Bpublic class SomeOtherClass &#123; public void doWork() &#123; while (true) &#123; // do some stuff... // use the Flooble, but only if it is ready if (floobleLoader.theFlooble != null) doSomething(floobleLoader.theFlooble); &#125; &#125;&#125; synchronized关键字 java从1.0开始，每个对象都有一个内部的对象锁，关键字synchronized可以修饰方法或者方法块所使用的就是该对象的内部对象锁和相关的条件 1234567891011121314public synchronized void method()&#123; do something;&#125;//可以把它看成public void method()&#123; //this.intrinsicLock相当于内部对象锁 this.intrinsicLock.lock(); try&#123; do something; &#125;finally&#123; this.intrinsicLock.unlock(); &#125;&#125; 不同的是，内部对象只有一个条件对象(毕竟，不能显式的newCondition来获取条件对象) 123this.intrinsiCondition.await();this.intrinsiCondition.signal();this.intrinsiCondition.signalAll(); 事实上，synchronized关键字锁的是this,可以通过如下代码来验证 1234//这种synchronized(obj)的方式通过一个对象来实现额外的原子操作，被称为客户端锁定，但并不推荐使用synchronized(this)&#123; ...&#125; 此外，可以通过如下代码来验证关键字也可以使用在静态方法上，此时锁的是对象的class文件,可以通过如下代码来验证 123synchronized(aObject.class)&#123; ...&#125; synchronized带来便捷的同时，也存在了一些局限性 不能中断一个试图获取锁的程序 试图获取锁不能设置超时 只能单一条件 JVM中的synchronized对于同步块的实现使用了monitorenter和monitorexit指令；同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED。本质是对一个对象的监视器（monitor）进行获取，而这个获取过程是排他的。 监视器 任意一个对象都拥有自己的监视器 同步块或同步方法执行时必须获取该对象的监视器，才能进入； 没有获取到监视的线程将会被阻塞在同步块和同步方法的入口处，线程进入同步队列，状态变为BLOCKED状态。 名词解释： 可见性：一个线程对共享变量值的修改，能够及实地被其他线程看到 排他性：即线程对块或方法的独立占有 当两个或两个以上线程同时对同一数据进行访问修改，可能会出现错误。这种情况被称为竞争条件(race condition) 1234567//代码会执行以下几个步骤//1. 将account[1]加载到寄存器//2. i +1//3. 将结果写回account[1]//如果线程A执行了第1、2步，被抢夺了运行权。线程B夺过并修改了i的值，此时再回到线程A执行第3步，就会发生错误。account[1] = i++; Locks包Java 1.5 之后添加了Locks包，在这之前，Java程序是靠synchronized来保障实现锁的功能。而Locks包的加入，使得对于锁的操作性更高 Locks包结构UML图 主要的类 类/接口名 描述 Since AbstractQueuedSynchronizer 队列同步器，是实现同步组件或锁的基本 1.5 Lock 锁接口 1.5 ReadWriteLock 读写锁接口 1.5 ReentrantLock 重入锁 1.5 ReentrantReadWriteLock 重入读写锁 1.5 Condition 用于支持Lock的等待/通知机制 1.5 LockSupport 提供对线程的阻塞和唤醒的方法 1.5 后期添加的类 类/接口名 描述 Since AbstractOwnableSynchronizer 1.6 AbstractQueuedLongSynchronizer 1.6 StampedLock 1.8 Lock 接口 Java SE 5之后，并发包中新增了Lock接口,在使用时需要显式地获取和释放锁。 Lock接口提供的synchronized关键字不具备的主要特性 Lock特性 Lock的API Lock的使用Lock的使用非常简单,但需要注意： 不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放 123456Lock lock = new ReentrantLock();lock.lock();try &#123;&#125; finally &#123; lock.unlock();&#125; 队列同步器(AbstractQueuedSynchronizer)队列同步器 简称AQS，是一个抽象类，是用来构建锁或者其他同步组件的基础框架,是实现锁或同步组件的关键 设计：基于模板方法模式，使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。 子类通过继承它（推荐定义成静态内部类），来进行管理同步状态 AQS管理同步状态AQS主要提供三个方法来改变或访问同步状态 123456//获取当前同步状态。getState()//设置当前同步状态。setState(int newState)：//使用CAS设置当前状态，该方法能够保证状态设置的原子性compareAndSetState(int expect,int update)： AQS可重写的方法 AQS提供的模板方法 实现自定义同步组件时，将会调用同步器提供的模板方法，而模板方法就会调用AQS可重写的那些个方法。同步器提供的模板方法如下,其大致分为三类 独占式获取与释放同步状态 共享式获取与释放同步状态 查询同步队列中的等待线程情况 AQS的使用想要实现一个锁或者组件，步骤如下 在锁或组件类内部创建一个继承于AQS的静态内部类 确定是独占式还是共享式，然后选择相应的AQS方法进行重写 a. 独占式：重写tryAcquire()和tryRelease()方法 b. 共享式：重写tryAcquireShared()和tryReleaseShared()方法 重写isHeldExclusively()方法，用于判断当前线程是否被独占 维护一个AQS子类成员，将所有的操作委托给该成员。可以直接使用重写过的方法，也可以使用AQS提供的模板方法（模板方法会调用重写过的方法） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Mutex &#123; //同步器子类Sync，推荐定义为内部静态类 private static class Sync extends AbstractQueuedSynchronizer&#123; /** * 因为是独占锁，所以需要重写独占式获取和释放同步状态的方法，即tryAcquire()和tryRelease() * 以及isHeldExclusively()方法：判断当前同步器是否在独占式模式下被占用 */ @Override protected boolean isHeldExclusively() &#123; //独占式的话。state == 1为占用，0表示没有占用 return getState() == 1; &#125; /** * 获取锁，将状态设置为1，并设置当前线程为独占模式所有者 * @param arg * @return */ @Override protected boolean tryAcquire(int arg) &#123; //使用CAS方式来设置状态，只有成功设置状态，才进入方法体中，而其他线程都会因为设置失败而获取锁失败 if(compareAndSetState(0, 1))&#123; //setExclusiveOwnerThread继承与AQS，它会将传入的值赋值给一个成员变量exclusiveOwnerThread // 该变量为Thread类型，表示独占模式同步的当前所有者，该变量可用于重入锁的判断 setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; /** * 释放锁，将状态设置为0，清除独占模式的所有者 * @param arg * @return */ @Override protected boolean tryRelease(int arg) &#123; //如果状态为0，说明没有锁可以释放，则抛出异常 if(getState() == 0) &#123; throw new IllegalMonitorStateException(); &#125; //清除独占模式的所有者 setExclusiveOwnerThread(null); //将状态设置为0 setState(0); return true; &#125; &#125; // 接下来将所有锁有关的操作代理到Sync private final Sync sync = new Sync(); // 获取锁,acquire为AQS的模板方法，意为独占式获取同步状态 public void lock() &#123;sync.acquire(1); &#125; public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; public void unlock() &#123; sync.release(1); &#125; ......&#125; 队列同步器的实现分析 实现一个队列同步器，主要包括以下四个部分 同步队列 提供独占式同步状态获取与释放方法 提供共享式同步状态获取与释放方法 提供超时获取同步状态等同步器的核心数据结构与模板方法 同步队列 同步队列是为了将没有获取同步状态的线程先保存，然后通过FIFO双向队列完成 *`同步状态`* 的管理,其处理逻辑如下 线程A和线程B同时获取同步状态，A获取成功，相当于获取到了锁；B获取失败后进入线程中断，将B打包成节点放入到队列尾部 线程A执行完毕，释放同步状态（释放锁），因为FIFO的原则，获取到队列的首节点，从节点获取到相应的线程信息，唤醒该线程，线程被唤醒后，再次尝试获取同步状态； 节点同步队列一版包含头节点和尾节点 12private transient volatile Node head;private transient volatile Node tail; 每一个节点的属性如下： 以下是同步队列的基本结构 入队操作 对于入列操作，因为可能又多个线程同时操作入列，所以需要保证其安全性，同步器提供了一个基于CAS的设置尾节点的方法compareAndSetTail() 入队的完整操作需要实现三个操作 node.prev指向原tail节点 将node设置成tail节点 原tail节点的后继节点指向node 12345678910Node t = tail;//node为需要入列的节点//先将node的前驱节点设置为原tail节点node.prev = t;// 通过CAS方法，判断tail是否于当前对象的tail一致（如果其他线程已经更改了tail，就会不一致）//如果一致，那就将当前对象的tail更新为node(注意更新的是tail而不是t！！！)if (compareAndSetTail(t, node)) &#123; t.next = node; return t;&#125; 关于compareAndSetTail(),方法内使用了Unsafe工具类，该类提供了硬件级别的原子操作 它一共由内存值（或者说偏移量）、期望值、更新值 它会先判断内存值与期望值是否一致，一致才将内存值更新为更新值 this：需要更新的对象，结合tailOffset计算出内存值 expect：期望值，该值用于比较 update：更新值，成功后更新的内存值（注意不是更新期望值） 123private final boolean compareAndSetTail(Node expect, Node update) &#123; return unsafe.compareAndSwapObject(this, tailOffset, expect, update); &#125; 出队操作设置首节点是通过获取同步状态成功的线程来完成的，能设置首节点的线程必定已经获取到了同步状态，所以不需要CAS，只需要将首系欸但设置为原首节点的后继结点并断开原首节点的next引用即可 12345private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null;&#125; 独占式同步状态获取与释放独占式同步状态获取释放流程 获取流程 AQS通过模板方法acquire()方法来进行独占式的同步状态获取 它会先使用tryAcquire()方法尝试获取同步状态，则由该方法返回；(详细看 《AQS工作原理》，对其进行重写) 123456//AQS源码 public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; 如果获取失败，会调用addWaiter方法，将当前的线程构造成一个同步节点，加入到AQS的同步队列尾部 首先它会尝试一次快速将节点加入到AQS同步队列 如果加入失败，那么就要调用enq(),以死循环的方式不断尝试将节点加入到同步队列，直到成功 最后方法会返回这个节点 12345678910111213141516171819202122232425262728293031323334353637private Node addWaiter(Node mode) &#123; //创建节点 Node node = new Node(Thread.currentThread(), mode); //尾节点 Node pred = tail; //尝试快速添加，可能由于多个请求并发进行而添加失败 if (pred != null) &#123; //尾节点设置为新节点的前驱节点 node.prev = pred; //使用compareAndSetTail,确保节点能够被线程安全添加列尾 if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //快速添加失败，进入死循环添加，将并发添加节点的请求通过CAS变得“串行化” enq(node); return node; &#125; //通过“死循环”来保证节点的正确添加，CAS private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; 成功创建节点并加入同步队列后，acquireQueued()会拿着这个节点，以死循环的方式获取同步状态，而获取同步状态的具体实现依旧是利用了tryAcquire()方法 1234567891011121314151617181920212223242526//AQS//在“死循环”中尝试获取同步状态，而只有 前驱节点 是头节点才能够尝试获取同步状态 final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; //设置中断标记 boolean interrupted = false; for (;;) &#123; //获取前驱节点 final Node p = node.predecessor(); //判断结点的前驱节点是否为头节点，因为头节点是获取成功状态的节点，如果当前节点的前驱节点是头节点的话，那么下一个获取同步状态的就是这个节点了 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 对于selfInterrupt()，它是当两种方式获取状态都失败后，让线程中断 123static void selfInterrupt() &#123; Thread.currentThread().interrupt(); &#125; 释放流程 当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，唤醒其后继节点能够继续获取同步状态。因为独占式的释放并定时已经获取到同步状态的线程，所以不需要保证CAS 12345678910public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; //unparkSuccessor()使用LockSupport来唤醒处于等待状态的线程 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 共享式同步状态获取与释放 与独占式的区别在于:同一时刻能否有多个线程同时获取到同步状态 获取流程利用AQS的acquireShared()来共享式获取同步状态 共享式获取同步状态与独占式实现的不同点在于 a. 独占式尝试获取同步状态返回的是布尔值 b. 共享式尝试获取同步状态返回的值是Int类型,只要int 大于等于0，就可以获取同步状态 共享式获取流程类似于独占式 a. 先通过tryAcquireShared()尝试获取 b. 获取失败进入doAcquireShared()以死循环方式获取 123456789101112131415161718192021222324252627282930313233//tryAcquireShared(int arg)方法会返回一个int，如果int大于0，说明能够获取同步状态public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125; //doAcquireShared()在当前节点的前驱节点为头节点时，会尝试获取同步状态，如果返回值大于等于0，表示获取成功private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 释放流程 通过调用releaseShared(int arg)方法释放同步状态，因为共享式的释放可以同步进行，所以需要使用 doReleaseShared()方法以死循环和CAS方式保证安全释放 12345678public final boolean releaseShared(int arg) &#123; //tryReleaseShared:必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证,，因为释放同步状态的操作会同时来自多个线程。(独占式则不需要，因为是一个线程释放) if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 独占式超时获取同步状态独占式超时同步状态获取流程 获取流程同步器通过调用doAcquireNanos()方法可以超时获取同步状态，即在指定的时间段内获取同步状态，其逻辑如下 主要需要计算出需要睡眠的时间间隔nanosTimeout，公式为：nanosTimeout-=now-lastTime（其中now为当前唤醒时间，lastTime为上次唤醒时间） 如果nanosTimeout大于0则表示超时时间未到，需要重新计算超时间隔nanosTimeout，继续睡眠nanosTimeout纳秒，反之，表示已经超时 123456789101112131415161718192021222324252627282930313233343536private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; //上次唤醒时间 long lastTime = System.nanoTime(); final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; //-----------------重点----------------------------- if (nanosTimeout &lt;= 0) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); long now = System.nanoTime(); //计算时间，当前时间now减去睡眠之前的时间lastTime得到已经睡眠的时间delta，然后被原有超时时间nanosTimeout减去，得到了还应该睡眠的时间.当然如果小于0了，说明已经超时了 nanosTimeout -= now - lastTime; lastTime = now; if (Thread.interrupted()) throw new InterruptedException(); &#125; //----------------------------------------------------------- &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 如果nanosTimeout小于等于spinForTimeoutThreshold（1000纳秒）时，将不会使该线程进行超时等待，而是进入快速的自旋过程(非常短的超时等待无法做到十分精确) 阻塞与唤醒当线程获取同步状态失败后，系统会将其打包成node节点放入同步队列，然后在死循环中不断尝试获取同步状态。这里靠考虑一个问题，如果每个线程都在进行死循环获取，那么必定会导致性能下降。所以应当利用阻塞和唤醒机制，来避免这个问题。 阻塞在获取流程中，往往还存在这样一段代码，就是用来阻塞线程的 123if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt())&#123; interrupted = true;&#125; 但是，当线程获取同步状态失败后，它不会立即阻塞，而是先通过shouldParkAfterFailedAcquire()方法来判断是否需要阻塞，它其流程为 如果当前线程的前驱节点状态为SINNAL，则表明当前线程需要被阻塞（注意判断的是节点的状态，不是线程的状态） 如果当前线程的前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false 如果前驱节点非SINNAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SINNAL，返回false 12345678910111213141516private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; //获取前驱节点等待状态 int ws = pred.waitStatus; //如果前驱节点为等待状态，则直接返回true if (ws == Node.SIGNAL) return true; if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 如果shouldParkAfterFailedAcquire()返回true了，就会执行parkAndCheckInterrupt()方法,将线程阻塞，同时返回中断状态 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); //调用LcokSupport 阻塞线程 return Thread.interrupted(); // 返回中断状态&#125; 唤醒在唤醒节点的时候，可能发生后继节点为空或者被中断的情况，此时需要跳过该后继节点然后寻找合适的节点。而通常会从tail开始找起，原因在于node.next仍然可能会存在null或者取消了，所以采用tail回溯办法找第一个可用的线程 12345678910111213141516171819private void unparkSuccessor(Node node) &#123; //获取当前节点的状态 int ws = node.waitStatus; //如果状态小于0，则设置为0 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); //后继节点 Node s = node.next; //后继节点为null或者其状态 &gt; 0 (超时或者被中断了)，则需要跳过后继节点，然后选择一个合适的节点 if (s == null || s.waitStatus &gt; 0) &#123; s = null; //从tail节点来找可用节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);//通过LcokSupport来唤醒线程 &#125; 重入锁(ReentrantLock) 支持重进入的锁，它表示该锁能够支持同一个线程对资源的重复加锁，synchronized关键字是隐式支持重入的 为什么要用到重入锁，如下场景 线程A通过aLock.lock()获取了锁 锁未被释放，线程A再次aLock.lock()获取锁，此时将无法获取，导致自己被自己阻塞 实现重进入 线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞,需要解决两个问题 线程再次获取锁：判断当前线程是否为锁的占有者，是，则获取成功 锁的最终释放：利用计数器记录锁获取的次数，每次释放时计数器自减，当为0时表示锁成功释放 获取流程 ReentrantLock支持获取锁时的公平和非公平性选择 公平性：锁获取是顺序的，先请求锁的先获取锁 非公平性: 效率比公平性锁高，默认 ReentrantLock非公平性实现非公平性的实现，主要是 利用AQS的exclusiveOwnerThread变量（Thread类，用于记录获取锁的线程），判断判断当前线程是否跟获取锁的线程是同一个线程 是同一个锁的话，增加同步状态的值 123456789101112131415161718192021//获取锁//判断当前线程是否为获取锁的线程来决定获取操作是否成功//重复获取只是添加了同步状态值final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123;//通过判断当前线程是否跟获取锁的线程是同一个线程 int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); //则将同步状态值进行增加并返回true,表示获取成功,相当于成功获取锁的线程再次获取锁，只是增加了同步状态值 setState(nextc); return true; &#125; return false;&#125; ReentrantLock公平性实现比起非公平实现，区别在于判断条件多了hasQueuedPredecessors(),判断当前线程所对应的节点是否有前驱节点，如果有，该方法返回true。也就是说，只有前驱线程获取并释放锁之后才能继续获取锁 1234567891011121314151617181920212223242526272829303132protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 多了条件判断,如果有前驱节点，!hasQueuedPredecessors() 会返回flase，无法获取锁 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125;//AQS中的方法public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; //判断头节点和尾节点是否是同一节点，如果h == t,说明同步队列没有节点，肯定没有前驱节点 // 第二步判断，如果头节点的后继节点为空(只有一个节点，自然没有前驱节点) 或者 有后继节点但判断后继节点对应的线程是否是当前线程 //通过三个判断来判断出当前线程的是否是下一个需要执行的 return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); &#125; 释放流程释放流程：前n-1次方法必定返回false，只有同步状态为0时，才返回true 12345678910111213protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; 线程“饥饿”线程饥饿变现为 一个线程连续获取非公平性锁的情况 ，原因为刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待,从而造成线程饥饿（使得其他线程只能在同步队列中等待） 有线程饥饿为什么非公平锁还是默认？ 公平锁锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。 读写锁 读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞;读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升 java 5.0之前是如何做的? 使用Java的等待通知机制 写操作开始，其他读操作等待，直到通知(防止幻读) 有了读写锁后怎么做？ 读操作，获取读锁，允许多个线程获取读锁进行访问，后继无法获取写锁 写操作，获取写锁,后续其他线程读写操作均被阻塞，但本线程可以获取读锁 ReadWriteLock接口读写锁的接口,仅定义了获取读锁和写锁的两个方法 1234public interface ReadWriteLock &#123; Lock readLock();//获取读锁 Lock writeLock();//获取写锁&#125; ReentrantReadWriteLockReentrantReadWriteLock是ReadWriteLock的具体实现 它包含了特性 除此之外，它还提供了其它方法 读写锁的实现分析 ReentrantReadWriteLock的实现，主要包括： 读写状态的设计 写锁的获取与释放 读锁的获取与释放 锁降级 读写状态的设计 读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态.写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态 如何在一个变量上维护多种状态？ 使用“按位切割” 高16位表示读，低16位表示写 如何确定状态? 通过位运算 写状态：status_value&amp;0x0000FFFF(高16位全部抹去) 写状态+1：status_value +1 读状态：status_value&gt;&gt;&gt;16(无符号补0右移16位) 读状态+1：status_value+(1&lt;&lt;16)，也就是status_value+0x00010000 写锁的获取与释放获取流程 写锁是一个支持重进入的排它锁 如果当前线程已经获取了写锁，则增加写状态 如果当前线程在获取写锁时，读锁已经被获取其他或当前线程获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态 12345678910111213141516171819202122//写锁获取protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); int c = getState(); //获取写锁状态 int w = exclusiveCount(c); if (c != 0) &#123; //从c != 0-&gt;当前线程存在锁，w == 0,没有写锁，说明存在的是读锁 // 存在读锁或者当前获取线程不是已经获取写锁的线程时，写锁无法获取 if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error("Maximum lock count exceeded"); setState(c + acquires); return true; &#125; if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123; return false; &#125; setExclusiveOwnerThread(current); return true;&#125; 释放流程写锁释放与ReentrantLock类似 读锁的获取与释放获取流程 读锁是一个支持重进入的共享锁，它能够被多个线程同时获取 在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取; 如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态 逻辑如下： 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态 如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁 123456789101112131415protected final int tryAcquireShared(int unused) &#123; for (;;) &#123; int c = getState(); int nextc = c + (1 &lt;&lt; 16); // 这一步判断是否状态值已满 if (nextc &lt; c) throw new Error("Maximum lock count exceeded"); //如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态 if (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread()) return -1; //增加读状态，成功获取读锁 if (compareAndSetState(c, nextc)) return 1; &#125; &#125; 释放流程读锁释放，每次减少读状态(线程安全的，可能有多个读线程同时释放读锁)，减少的值是（1&lt;&lt;16） 锁降级锁降级指的是写锁降级成为读锁，以如下代码为例 当数据变化，update变为false(布尔类型且volatile修饰),所有访问该方法的线程，感知变化，但只有一个线程能获取到写锁，进行修改数据 写锁修改完数据后，先获取读锁，再释放写锁，这样的获取写锁-&gt;获取读锁-&gt;释放写锁的过程，就是锁降级 如果不在释放写锁前，获取锁 123456789101112131415161718192021222324252627public void processData() &#123; //读锁会被写锁阻塞 readLock.lock(); if (!update) &#123; // 必须先释放读锁 readLock.unlock(); // 锁降级从写锁获取到开始 writeLock.lock(); try &#123; if (!update) &#123; // 准备数据的流程（略） update = true; &#125; //再次获取读锁 readLock.lock(); &#125; finally &#123; writeLock.unlock(); &#125; // 锁降级完成，写锁降级为读锁 &#125; //step_join try &#123; // 使用数据的流程（略） &#125; finally &#123; readLock.unlock(); &#125;&#125; 为什么要用到锁降级（即释放写锁前线获取读锁）？ 假设线程A释放写锁后不获取读锁，运行到了step_join这个位置 此时线程B获取了写锁并修改了数据，但此时的线程A无法获取到线程B更新的数据,继续使用数据就会不一致（注意此时setp_join位置线程A是没有任何锁的） 但如果加了读锁呢，线程A拥有读锁，线程B因为线程A持有读锁，就算获取了写锁也只能进入等待状态，直到线程A释放读锁，才能进行数据修改 问题1：其实不用锁降级，单单依靠volatile和写锁，也能保证数据的安全性，那么为什么要用锁降级呢？ 个人猜想：写锁会导致其他线程完全堵塞，而读锁是可以多线程访问的。比方说除了写锁锁定的代码外，其他代码是可以线程共享的，那么写锁降级读锁可以充分利用读锁的共享机制 问题2：为什么不支持锁升级（获取读锁-&gt;获取写锁-&gt;释放读锁） 在《深入理解JVM》一书中提到，这是为了保证数据的可见性，当读锁已经被多个线程获取，其中任意线程成功修改获取了写锁并修改了数据，则其更新对其他获取到读锁的线程是不可见的。 个人认为：当获取到读锁时，写锁根本获取不到啊！！！ LockSupport工具LockSupport工具被用于阻塞或唤醒一个线程，是构建同步组件的基础工具,它提供了一组公共的静态方法 park* ()方法：用于阻塞当前线程 unPark(Thread thread)方法：用于唤醒被阻塞的线程 LockSupport提供的方法 在java 1.6后，LockSupport添加了以下3个方法,不难发现，其实这三个方法是基于原先方法的重载，多了一个blocker参数。,blocker是用来标识当前线程在等待的对象(阻塞对象),该对象主要用于问题排查和系统监控(能传递更多的信息)，可以通过dump 线程来对比 123public static void parkNanos(Object blocker, long nanos) public static void park(Object blocker)public static void parkUntil(Object blocker, long deadline) Condition接口 任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式；而Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式 Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁,Condition依赖Lock对象 Condition的（部分）方法以及描述 condition对比Object Condition的实现分析 ConditionObject是AQS的内部类,每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。 Condition的实现，主要包括： 等待队列 等待 通知 等待队列 FIFO的队列 节点包含了一个线程引用（在Condition对象上等待的线程），复用了同步器中节点的定义 拥有首节点（firstWaiter）和尾节点（lastWaiter） 节点更新无需CAS,因为await()方法必然是获取了锁的线程 同步器拥有一个同步队列和多个等待队列 等待 调用了Condition.await()方法，该线程将会释放锁、构造成节点加入等待队列并进入等待状态 逻辑如下 当前线程必定是获取到锁的线程,即同步队列的首节点 该方法会将当前线程构造成节点并加入等待队列 释放同步状态,也就是释放锁 阻塞当前队列 调用acquireQueued()方法加入到获取同步状态的竞争中，为的是唤醒后重写抢回锁，并从await()返回 12345678910111213141516171819202122public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); // 当前线程加入等待队列 Node node = addConditionWaiter(); // 释放同步状态，也就是释放锁 int savedState = fullyRelease(node); int interruptMode = 0; // 被唤醒的程序将从循环中退出，isOnSyncQueue(node)判断当前节点是否已经在同步队列 while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; //调用同步器的acquireQueued()方法加入到获取同步状态的竞争中 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; 注意: 释放锁之后，线程只有被唤醒才能从LockSupport.park(this)返回 返回之后，只有抢到锁才能从await()方法中返回,所以需要通过acquireQueued()来重写抢回锁 通知 调用Condition的signal()方法,将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中 逻辑如下 当前线程必须是获取了到锁的线程（通过isHeldExclusively()检查） 移动等待队列首节点到同步队列并使用LockSupport唤醒节点中的线程 12345678910public final void signal() &#123; // 判断当前线程获取到了锁的线程 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); // 获取等待队列的首节点 Node first = firstWaiter; if (first != null) // 移动到同步队列并使用LockSupport唤醒节点中的线程 doSignal(first);&#125; Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。 ConcurrentHashMap 为什么要使用ConcurrentHashMap？ 线程不安全的HashMap会引起死循环（查看文章-&gt; HashMap会引起死循环） 用线程安全的HashTable效率又非常低下（线程都竞争同一把锁） java 1.8中的CurrentHashMap有了较大的不同（以下介绍的是java 7 的版本） ConcurrentHashMap的锁分段技术 数据分段存储，并为每段数据配锁 当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问 Java 1.7中的ConcurrentHashMapConcurrentHashMa结构 由Segment数组结构和HashEntry数组结构组成 Segment是一种可重入锁（ReentrantLock）,包含一个HashEntry数组 HashEntry则用于存储键值对数据 当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁 ConcurrentHashMap的初始化初始化segments数组参数 变量 描述 concurrencyLevel 用于计算ssize，最大值65535，即16位 ssize segments数组的长度，值必须为2的N次方，目的是方便位运算 sshift ssize从1向左移位的次数 segmentShift 用于定位参与散列运算的位数，等于32-sshift（之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的） segmentMask 散列运算的掩码（掩码的二进制各个位的值都是1） 初始化 123456789101112131415if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS;int sshift = 0;int ssize = 1;//////计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度 (为了能通过按位与的散列算法来定位segments数组的索引)while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1;&#125;//初始化segmentShift = 32 - sshift;segmentMask = ssize - 1;this.segments = Segment.newArray(ssize); 初始化每个segment参数 变量 描述 initialCapacity ConcurrentHashMap的初始化容量，默认16 loadfactor m每个segment的负载因子 初始化 segment的容量 threshold = （int）cap*loadFactor 1234567891011//initialCapacity是ConcurrentHashMap的初始化容量,默认16 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY;int c = initialCapacity / ssize;if (c * ssize &lt; initialCapacity) ++c;int cap = 1;//变量cap就是segment里HashEntry数组的长度,大小为2^c [c∈(0,n)]while (cap &lt; c) cap &lt;&lt;= 1;for (int i = 0; i &lt; this.segments.length; ++i) this.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);//，loadfactor是每个segment的负载因子，默认0.75 定位Segment ConcurrentHashMap在插入和获取元素的时候，必须先通过散列算法定位到Segment,才能使用不同段的数据。 ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再散列，目的是减少散列冲突，使元素能够均匀地分布在不同的Segment上，从而提高容器的存取效率 12345678private static int hash(int h) &#123; h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16);&#125; ConcurrentHashMap通过以下散列算法定位segment 1234//默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到散列运算中final Segment&lt;K,V&gt; segmentFor(int hash) &#123; return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];&#125; 此外，定位HashEntry所使用的hash算法如下 1int index = hash &amp; (tab.length - 1); ConcurrentHashMap的操作get操作 get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读 123456public V get(Object key) &#123; //先进行一次再散列 int hash = hash(key.hashCode()); //再使用使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素 return segmentFor(hash).get(key, hash);&#125; 为什么get方法不用加锁？ 是它的get方法里将要使用的共享变量都定义成了volatile类型 根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作 put 操作 put方法里需要对共享变量进行写入操作，在操作共享变量时必须加锁，其逻辑如下 首先定位到Segment，然后在Segment里进行插入操作 第一步判断是否需要对Segment里的HashEntry数组进行扩容(在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold）) 第二步定位添加元素的位置，然后将其放在HashEntry数组里 如何扩容? 创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里(对Segment的扩容) size操作 要计算CurrentHashMap的大小，需要将Segment里的全局变量count累计相加，count是一个volatile变量，在获取时将得到最新的数据，但在计算相加前可能发生改变。 ConcurrentHashMap的做法如下 先尝试2次通过不锁住Segment的方式来统计各个Segment大小 如果果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小 通过使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化 Java并发中的队列 实现一个线程安全的队列有两种方式： 使用阻塞算法（可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现） 使用非阻塞算法(用循环CAS的方式来实现) 非阻塞队列ConcurrentLinkedQueue ConcurrentLinkedQueue 基于链接节点的无界线程安全队列 FIFO规则排序 采用了“wait-free”算法（即CAS算法）来实现 concurrentLinkedQueue类图 由head节点和tail节点组成 每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成 默认情况下head节点存储的元素为空，tail节点等于head节点 入队列 首先要理解入队操作(java入队操作与数据结构算法中的有些不同) 一个空的队列，插入节点A，Head.next设置为节点A，tail默认与head节点相同，也指向A 添加第二个节点B,节点A.next设置为节点B，同时更新tail指向节点B 添加第三个节点C，节点B.next设置为节点C 添加第四个节点D，节点C.next设置为节点D，同时更新tail指向节点D 可以看出，tail节点有可能不是尾节点(重点) 个入队过程逻辑如下 定位出尾节点(tail节点或者tail.next是尾节点) 使用CAS算法将入队节点设置成尾节点的next节点，如不成功则重试 1234567891011121314151617181920212223242526272829303132333435public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); // 入队前，创建一个入队节点 Node&lt;E&gt; n = new Node&lt;E&gt;(e); retry: // 死循环，入队不成功反复入队。 for (;;) &#123; // 创建一个指向tail节点的引用 Node&lt;E&gt; t = tail; // p用来表示队列的尾节点，默认情况下等于tail节点。 Node&lt;E&gt; p = t; for (int hops = 0; ; hops++) &#123; // 获得p节点的下一个节点。 Node&lt;E&gt; next = succ(p); // next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点 if (next != null) &#123; // 循环了两次及其以上，并且当前节点还是不等于尾节点 if (hops &gt; HOPS &amp;&amp; t != tail) continue retry; p = next; &#125; // 如果p是尾节点，则设置p节点的next节点为入队节点。 else if (p.casNext(null, n)) &#123; /*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/ if (hops &gt;= HOPS) casTail(t, n); // 更新tail节点，允许失败 return true; &#125; // p有next节点,表示p的next节点是尾节点，则重新设置p节点 else &#123; p = succ(p); &#125; &#125; &#125; &#125; 为什么ConcurrentLinkedQueue入队不是每次都变化tail节点? 减少CAS更新tail节点的次数，能提高入队的效率 ConcurrentLinkedQueue使用hops变量来控制并减少tail节点的更新频率 hops变量相当于tail与尾节点的长度，如果大于等于HOPS(默认1)，才更新节点 tail与尾节点越长，那么更新tail节点操作就越少，但是相对的每次定位到尾节点需要读取更多的节点（相当于通过添加对volatile变量的读操作减少写操作，而读操作开销要远远小于写操作，从而得到提升） 入队方法永远返回true，所以不能靠返回值判断是否入队成功 出队列 逻辑如下 与入队列相同，通过hops来减少更新head节点操作 head 节点内有元素，则弹出元素 head节点为空，弹出head.next,更新head节点 12345678910111213141516171819202122232425262728293031 public E poll() &#123; Node&lt;E&gt; h = head;// p表示头节点，需要出队的节点 Node&lt;E&gt; p = h; for (int hops = 0; ; hops++) &#123;// 获取p节点的元素 E item = p.getItem();// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,// 如果成功则返回p节点的元素。 if (item != null &amp;&amp; p.casItem(item, null)) &#123; if (hops &gt;= HOPS) &#123;// 将p节点下一个节点设置成head节点 Node&lt;E&gt; q = p.getNext(); updateHead(h, (q != null)q :p); &#125; return item; &#125;// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外// 一个线程修改了。那么获取p节点的下一个节点 Node&lt;E&gt; next = succ(p);// 如果p的下一个节点也为空，说明这个队列已经空了 if (next == null) &#123;// 更新头节点。 updateHead(h, p); break; &#125;// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点 p = next; &#125; return null; &#125; 阻塞队列（BlockingQueue） 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。 支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空 常用于生产者和消费者的场景 在阻塞队列不可用时，这两个附加操作提供了4种处理方式 抛出异常：队列满，再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常；队列空，当队列空时，从队列里获取元素会抛出NoSuchElementException异常 返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null 一直阻塞：队列满，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空 ·超时退出：队列满，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出；队列空，抛出元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出 如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true。 JDK 7提供了7个阻塞队列 ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。 DelayQueue：一个使用优先级队列实现的无界阻塞队列。 SynchronousQueue：一个不存储元素的阻塞队列。 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 ArrayBlockingQueue ArrayBlockingQueue: 由数组结构组成的有界阻塞队列 此队列按照先进先出（FIFO）的原则对元素进行排序 默认不保证线程公平的访问队列 创建一个公平的阻塞队列(即先阻塞先访问) 1ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true); 访问者的公平性是使用可重入锁实现的 12345678public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; LinkedBlockingQueue LinkedBlockingQueue 用链表实现的有界阻塞队列 默认和最大长度为Integer.MAX_VALUE FIFO PriorityBlockingQueue PriorityBlockingQueue 支持优先级的无界阻塞队列 默认情况下元素采取自然顺序升序排列 可以自定义类实现compareTo()方法来指定元素排序规则;也可以初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序 但不能保证同优先级元素的顺序 DelayQueue DelayQueue 支持延时获取元素的无界阻塞队列 使用PriorityQueue来实现， 队列中的元素必须实现Delayed接口 在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。 应用场景 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。 定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。 实现Delayed接口 第一步，在对象创建的时候，初始化基本数据 1234567private static final AtomicLong sequencer = new AtomicLong(0);ScheduledFutureTask(Runnable r, V result, long ns, long period) &#123; super(r, result); this.time = ns;//time记录当前对象延迟到什么时候可以使用 this.period = period; this.sequenceNumber = sequencer.getAndIncrement();//sequenceNumber来标识元素在队列中的先后顺序&#125; 第二步，实现getDelay方法 1234//该方法返回当前元素还需要延时多长时间，单位是纳秒(注意当time小于当前时间时，getDelay会返回负数)public long getDelay(TimeUnit unit) &#123; return unit.convert(time - now(), TimeUnit.NANOSECONDS);&#125; 第三步，实现compareTo方法来指定元素的顺序 12345678910111213141516171819public int compareTo(Delayed other) &#123; if (other == this) // compare zero ONLY if same object return 0; if (other instanceof ScheduledFutureTask) &#123; ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other; long diff = time - x.time; if (diff &lt; 0) return -1; else if (diff &gt; 0) return 1; else if (sequenceNumber &lt; x.sequenceNumber) return -1; else return 1; &#125; long d = (getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS)); return (d == 0) 0 : ((d &lt; 0) -1 : 1); &#125; 实现延时阻塞队列1234567891011121314151617181920//从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程long delay = first.getDelay(TimeUnit.NANOSECONDS);if (delay &lt;= 0) return q.poll();//leader：等待获取队列头部元素的线程//如果leader不等于空，表示已经有线程在等待获取队列的头元素,使用await()方法让当前线程等待信号else if (leader != null) available.await();else &#123; //leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间 Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; available.awaitNanos(delay); &#125; finally &#123; if (leader == thisThread) leader = null; &#125;&#125; SynchronousQueue SynchronousQueue 不存储元素的阻塞队列 每一个put操作必须等待一个take操作，否则不能继续添加元素 支持公平访问队列,默认非公平访问 非常适合传递性场景 吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue 创建公平性访问的SynchronousQueue 1234//fair == true -&gt; 公平访问public SynchronousQueue(boolean fair) &#123; transferer = fair ? new TransferQueue() : new TransferStack();&#125; LinkedTransferQueue LinkedTransferQueue 由链表结构组成的无界阻塞TransferQueue队列 相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。 transfer方法 transfer方法 如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者;。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回 1234//尝试把存放当前元素的s节点作为tail节点Node pred = tryAppend(s, haveData);//让CPU自旋等待消费者消费元素（自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。）return awaitMatch(s, pred, e, (how == TIMED), nanos); tryTransfer方法 用来试探生产者传入的元素是否能直接传给消费者 如果没有消费者等待接收元素，则返回false 如果消费了元素，则返回true 该方法无论消费者是否接收，方法立即返回；，而transfer方法是必须等到消费者消费了才返回 此外还有带有时间限制的tryTransfer（E e，long timeout，TimeUnit unit）方法 试图把生产者传入的元素直接传给消费者 如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false 如果在超时时间内消费了元素，则返回true。 LinkedBlockingDeque LinkedBlockingDeque 由链表结构组成的双向阻塞队列 因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争 相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法 在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。 双向阻塞队列可以 运用在“工作窃取”模式中。 阻塞队列的实现原理 在JDK中，使用通知模式实现;所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用 todo Java中的13个原子操作类 Java从JDK 1.5开始提供了java.util.concurrent.atomic包,一共包含13个类，属于4种类型的原子更新方式，分别是 原子基本类型 原子数组 原子引用 属性（字段）的原子更新器 PS：个人喜欢将1-3划分为用于代替普通类型的原子类。而4则是为普通类型提供原子操作的功能类 事实上，原子类原理 内置一个私有的相对应的变量(如原子布尔类型，内置了一个volatitle的boolean变量) 内置一个Unsafe变量，通过该变量来进行相应的原子操作 而原子更新器，则是将其他非原子类的字段修改操作变为原子操作 PS：原子类虽然可以基于实例进行初始化，但是由于其内置变量的私有化，所以只能靠原子类提供的方法注入参数 对于基本类型，值传递，原子类的操作不会影响原始的实例 对于数组，采用了clone()方法，所以原子类的操作还是不会影响原始的实例 原子基本类型类 Atomic包提供了以下3个类 AtomicBoolean：原子更新布尔类型。 AtomicInteger：原子更新整型。 AtomicLong：原子更新长整 以上三种的方法类似以AtomicIntege为例,常用方法如下 12345678910//以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。int addAndGet（int delta）//update）：如果内存中的值等于预期值，则以原子方式将该内存中的值设置为输入的值。boolean compareAndSet（int expect，int update）//以原子方式将当前值加1，注意，这里返回的是自增前的值int getAndIncrement()//最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值void lazySet（int newValue）//以原子方式设置为newValue的值，并返回旧值int getAndSet（int newValue） 使用示例 123AtomicInteger ai = new AtomicInteger(1);System.out.println(ai.getAndIncrement());System.out.println(ai.get()); 原子数组 Atomic包提供了以下3个类 AtomicIntegerArray：原子更新整型数组里的元素。 AtomicLongArray：原子更新长整型数组里的元素。 AtomicReferenceArray：原子更新引用类型数组里的元素。 以AtomicIntegerArray为例，其主要是提供原子的方式更新数组里的整型，常用方法如下 1234//以原子方式将输入值与数组中索引i的元素相加。int addAndGet（int i，int delta）：//如果内存中的值等于预期值，则以原子方式将数组位置i的元素设置成update值。boolean compareAndSet（int i，int expect，int update） 使用示例 12345int[] value = new int[]&#123;1, 2&#125;;AtomicIntegerArray ai = new AtomicIntegerArray(value);ai.getAndSet(0, 3);System.out.println(ai.get(0));System.out.println(value[0]); 原子引用类型引用类型可以指向并更改任何对象.但其本身没有对引用对象数据进行修改的方法，只能修改引用的对象 Atomic包提供了以下3个类 AtomicReference：原子更新引用类型。 AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 AtomicMarkableReference：原子更新带有标记位的引用类型 123456789101112public static AtomicReference&lt;User&gt; atomicReference = new AtomicReference&lt;&gt;();public static void main(String[] args) &#123; //修改User的name和Old两个字段，使用原子更新引用类型 User user = new User("liisyu", 18); atomicReference.set(user); User updateUser = new User("wang", 81); atomicReference.compareAndSet(user, updateUser);//安全的将引用指向updateUser System.out.println(atomicReference.get().getName()); System.out.println(atomicReference.get().getOld());&#125; 字段类的原子更新器原子操作类是唯一一个可以对原始变量发生改变的类，所以如果相对原始实例变量进行修改，可以使用该类 Atomic包提供了以下3个类,都是抽象类 AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 AtomicLongFieldUpdater：原子更新长整型字段的更新器。 AtomicStampedReference：原子更新带有版本号的引用类,该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现ABA问题 使用示例 第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性 第二步，更新类的字段（属性）必须使用public volatile修饰符 12345678910111213141516171819202122232425262728private static AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, "old");public static void main(String[] args) &#123; User user = new User("liisyu", 18); a.getAndIncrement(user)； //对user对象的old字段+1操作 System.out.println(a.get(user));// print 19; System.out.println(user.getOld());// print 19;&#125;static class User&#123; private String name; // 必须public volatile修饰 public volatile int old; public User(String name, int old) &#123; this.name = name; this.old = old; &#125; public String getName() &#123; return name; &#125; public int getOld() &#123; return old; &#125;&#125; Java并发中的工具类在JDK的并发包里提供了几个非常有用的并发工具类 CountDownLatch CyclicBarrier Semaphore Exchanger CountDownLatchCountDownLatch允许一个或多个线程等待其他线程完成操作。 假设我们在主线程开启了多个线程，而主线程需要在等待这些线程完成后再进行操作，那么通常做法为 12345678910public static void main(Stirngp[] args)&#123; threadA.start(); threadB.start(); // 利用join()方法，只有当线程完成时才会返回 threadA.join(); threadB.join(); //线程A、B完成后主线程继续运作 //main thread do something...&#125; 但是，join的实现原理是通过不停检查join线程是否存活，来使线程等待 1234// join部分代码片段，wait(0)：表示永远等待while (isAlive()) &#123; wait(0);&#125; 再来看看CountDownLatch的做法 通过计数器、countDown()、await()方法的组合使用，比起join()方法功能更为强大 a. run()方法中，根据countDown()插入的位置不同，可以在特定步骤完成下返回 b. CountDownLatch还提供了超时的await(long time，TimeUnit unit)方法 12345678910111213141516171819// 传入int类型参数，代表计数器，也就是等待2个线程完成static CountDownLatch c = new CountDownLatch(2);// 在run()方法中使用countDown(),该方法会让计数器值-1public static void main(String[] args) throws Exception&#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; //doSomething c.countDown(); &#125; &#125;; new Thread(runnable, "ThrEadA").start(); new Thread(runnable, "ThrEadB").start(); // await()会阻塞当前线程知道计数器的值为0 c.await(); System.out.println("回来了");&#125; 注意，CountDownLatch的计数器只能使用一次 CyclicBarrier同步屏障CyclicBarrier：，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 使用示例 CyclicBarrier(int parties): 会设置一个计数器，表示屏障拦截的线程数目 通过await()方法，来告知CyclicBarrier已经达到屏障，并阻塞当前线程 只有当达到屏障数量时，线程才会被唤醒 如下代码 a. 设置了拦截的线程数目为4个 b. 实际只有3个await()方法，也就是说，主线程和子线程将会永远等待 1234567891011121314151617181920212223// int参数代表屏障拦截的线程数 static CyclicBarrier c = new CyclicBarrier(4); // 在run()方法中使用countDown(),该方法会让计数器值-1 public static void main(String[] args) throws Exception&#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; //通过await(),告知CyclicBarrier线程已经到达屏障，并且阻塞当前线程 try&#123; System.out.println("到达屏障"); c.await(); &#125;catch (Exception e)&#123; &#125; &#125; &#125;; new Thread(runnable, "ThrEadA").start(); new Thread(runnable, "ThrEadB").start(); c.await(); System.out.println("回来了"); &#125; CyclicBarrier的计数器可以使用多次 12//重置计数器c. reset() CyclicBarrier适用于多线程计算数据，最后合并计算结果的场景 Semaphore 信号量Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源 构造函数1234567891011/***@permits 可允许的线程数*@fair 为true时，创建公平锁**/public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;public Semaphore(int permits, boolean fair) &#123;sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125; 方法123456intavailablePermits()：返回此信号量中当前可用的许可证数。intgetQueueLength()：返回正在等待获取许可证的线程数。booleanhasQueuedThreads()：是否有线程正在等待获取许可证。void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。 Exchanger 线程间的数据交换Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。具体为 线程A先执行exchange()方法,等待线程B 线程B执行exchange()方法后，表示到达同步点，可以进行数据交换 todo Fork/Join框架 Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。 工作窃取算法 工作窃取（work-stealing）算法 指某个线程从其他队列里窃取任务来执行. 通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行 窃取任务的线程永远从双端队列的尾部拿任务执行 优点:充分利用线程进行并行计算，减少了线程间的竞争 缺点:在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列 Fork/Join框架的设计 步骤 分割任务，通过fork类将任务切割成足够小的子任务 执行任务并合并结果，子任务放入双端队列中，多个线程从队列中获取；子任务执行结果放在同一个队列里，启动一个线程合并结果 Fork/Join使用两个类完成任务 ForkJoinTask,创建ForkJoin任务，提供fork()和join()方法,一般继承它的子类RecursiveAction：用于没有返回结果的任务。RecursiveTask：用于有返回结果的任 ForkJoinPool,ForkJoinTask需要通过ForkJoinPool来执行 任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。 使用Fork/Join框架 以计算1+2+3+4的结果为例 假设每个子任务最多执行两个数的相加，则设置分割的阈值是2 因为是有结果的任务，所以必须继承RecursiveTask 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class CountTask extends RecursiveTask&lt;Integer&gt; &#123; private static final int THRESHOLD = 2; // 阈值 private int start; private int end; public CountTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0;// 如果任务足够小就计算任务 boolean canCompute = (end - start) &lt;= THRESHOLD; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123;// 如果任务大于阈值，就分裂成两个子任务计算 int middle = (start + end) / 2; CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle + 1, end);// 执行子任务 leftTask.fork(); rightTask.fork();// 等待子任务执行完，并得到其结果 int leftResult=leftTask.join(); int rightResult=rightTask.join();// 合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125; public static void main(String[] args) &#123; ForkJoinPool forkJoinPool = new ForkJoinPool();// 生成一个计算任务，负责计算1+2+3+4 CountTask task = new CountTask(1, 4);// 执行一个任务 Future&lt;Integer&gt; result = forkJoinPool.submit(task); try &#123; System.out.println(result.get()); &#125; catch (InterruptedException e) &#123; &#125; catch (ExecutionException e) &#123; &#125; &#125;&#125; Fork/Join框架的异常处理 检查任务是否已经抛出异常或已经被取消 1aForkJoinTask.isCompletedAbnormally() 获取异常 12//返回Throwable对象，如果任务被取消了则返回CancellationException;任务没有完成或者没有抛出异常则返回nullaForkJoinTask.getException() Fork/Join框架的实现原理Executor框架 在JDK 5之前，java线程既是工作单元，也是执行机制，JDK 5之后把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供,其内部使用了线程池机制,通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作 Executor框架的两级调度模型 在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。也就是说，在Java程序中创建了一个线程，相当于本地系统创建了一个线程（如果创建太多线程可能让电脑死机） 如图所示 上层：java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程 底层：操作系统内核将这些线程映射到硬件处理器CPU上 Executor框架的成员 类/接口 描述 Executor 接口,是Executor框架的基础，它将任务的提交与任务的执行分离开来 ExecutorService 接口，描述管理线程终止的方法和可以生成Future类来跟踪一个或多个异步任务进度的方法 AbstractExecutorService 抽象类，提供ExecutorService的默认实现 ScheduledExecutorService 接口，描述可以安排命令在给定的延迟后运行，或定期执行 ThreadPoolExecutor 实现类，线程池的核心实现类,用来执行被提交的任务。 ScheduledThreadPoolExecutor 实现类，可以在给定的延迟后运行命令，或者定期执行命令 Executor该接口只描述了一个方法 12345public interface Executor &#123; //执行给定的命令 void execute(Runnable command);&#125; ExecutorService123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface ExecutorService extends Executor &#123; // 有序的关闭，不接受新的任务 void shutdown(); //尝试停止所有正在执行的任务，暂停等待任务的处理，并返回等待执行的任务列表 List&lt;Runnable&gt; shutdownNow(); // 判断是否关闭 boolean isShutdown(); //如果关闭后所有任务都已完成，则返回true boolean isTerminated(); //阻塞请求，直到任务完成 boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; // 提交Classable并执行，返回Future结果 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); //提交Runnable并执行，返回Future。当使用Future.get方法时会返回result &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); //提交Runnable并执行，返回Future。当使用Future.get方法时会返回null Future&lt;?&gt; submit(Runnable task); // 执行所有的任务 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; // 超时执行所有的任务 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; //执行所有任务，返回已成功完成任务的结果 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; //超时执行超时执行所有的任务，返回已成功完成任务的结果 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; AbstractExecutorService实现类Submit()、invokeAll、InvokeAny()方法 submit()方法submit本质上，就是使用了execute()来执行任务，但其会将任务封装成一个FutureTask对象，以便于获取任务结果 1234567891011121314151617181920public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask;&#125;public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result); execute(ftask); return ftask;&#125; newTaskFor()1234//构造并返回一个FutureTaskprotected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value);&#125; ThreadPoolExecutor在阿里巴巴代码规范中提到，不允许使用Executors区创建，而应该使用构造方法区构造 线程池能够带来3个好处 降低资源消耗:通过重复利用已创建的线程降低线程创建和销毁造成的消耗 提高响应速度:当任务到达时，任务可以不需要等到线程创建就能立即执行 提高线程的可管理性:线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控 线程池变量1234567891011121314// 用于保存worker对象的集合private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();// 用于保存需要执行的Runnableprivate final BlockingQueue&lt;Runnable&gt; workQueue;//饱和策略，用于在线程池满，队列满的情况进行处理private volatile RejectedExecutionHandler handler;// 空闲线程在终止之前等待新任务的最长时间private volatile long keepAliveTime;//核心线程池的基本大小private volatile int corePoolSize;//线程池中允许的最大线程数private volatile int maximumPoolSize;// 当执行程序创建新线程时使用的工厂private volatile ThreadFactory threadFactory; 线程池状态123456789101112private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));// COUNT_BITS用来划分状态区和线程数量区private static final int COUNT_BITS = Integer.SIZE - 3; //29// 线程数量private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;//状态值存储在高位,相当于左移29位private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;//该状态会接受新任务，并处理阻塞队列中的任务private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;//该状态不会接受新的任务，但会处理阻塞队列中的状态private static final int STOP = 1 &lt;&lt; COUNT_BITS;//该状态不接收、不处理任务，且会中断正在运行的任务private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;//所有任务终止，工作线程为0，并且正在执行terminated()方法private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;//terminated()方法已经完成 ctl其存储结构如下 拆包和装包ctl123456// CAPACITY相当于111_0000...，保留C的前3位，即算出状态值private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;// CAPACITY相当于000_1111...,即保留C的后29位，即算出线程数量private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;// rs: runStatem,wc : workerCount,即合并成ctlprivate static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 非解包ctl 的相关访问123456789101112private static boolean runStateLessThan(int c, int s) &#123; return c &lt; s;&#125;private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s;&#125;private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125; ctl原子方法12345678910111213//尝试原子的为线程数+1private boolean compareAndIncrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect + 1);&#125;// 尝试原子的为线程数-1private boolean compareAndDecrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect - 1);&#125;//尝试原子的为线程数-1，只有在突然终止一个线程时才调用private void decrementWorkerCount() &#123; do &#123;&#125; while (! compareAndDecrementWorkerCount(ctl.get()));&#125; 构造函数12345678910111213141516171819202122232425262728293031323334 /** * @param corePoolSize 线程池的基本大小 * @param maximumPoolSize 线程池中允许的最大线程数 * @param keepAliveTime 空闲线程在终止之前等待新任务的最长时间 * @param unit 线程活动保持时间的单位 * @param workQueue 在执行任务之前用于保存任务的队列 * @param threadFactory 当执行程序创建新线程时使用的工厂 * @param handler 在队列和线程池都满情况下使用的处理器 **/public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; TimeUnitTimeUnit是一个枚举类，它的实例有 DAYS：表示天 HOURS：表示小时 MINUTES：表示分支 MILLISECONDS：表示毫秒 MICROSECONDS：表示微秒 NANOSECONDS：表示纳秒 ThreadFactoryThreadFactory是一个接口，自定义工厂类需要重写newThread方法。 12345public interface ThreadFactory &#123; //获取线程 Thread newThread(Runnable r);&#125; 或者，Executors中提供了一个默认的工厂（静态内部类），可以通过以下方法获取 1Executors.defaultThreadFactory() 此外，开源框架Guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字(todo) RejectedExecutionHandlerRejectedExecutionHandler是一个接口，自定义饱和策略需要重写rejectedExecution方法 1234public interface RejectedExecutionHandler &#123; //用于解决ThreadPoolExcecutor.execute无法接受任务的情况 void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 在JDK 1.5中Java线程池框架提供了以下4种策略 AbortPolicy：直接抛出异常。（默认） CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉 实现各种线程池虽然不推荐使用Executors类来创建线程池，但可以了解下它 的一些思想 可重用固定线程数的线程池12345678910/*** 核心线程数和最大线程数指定* keepAliveTime设置为0，表示多余的空闲线程被立即终止**/ public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 单线程的线程池123456789101112/*** 核心线程数和最大线程数固定1* keepAliveTime设置为0，表示多余的空闲线程被立即终止* 使用无界队列作为线程池的工作队列**/public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 根据需要创建新线程的线程池123456789101112/*** 核心线程数为0* 最大线程数为Integer.MAX_VALUE，即maximumPool是无界（也不可能有这么多线程可以创建）* keepAliveTime设置为60L，表示多余的空闲线程会等待新任务60s之后才会被终止**/public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 向线程池提交任务可以使用两个方法向线程池提交任务 execute()：提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功 submit()：提交需要返回值的任务，线程池会返回一个Future类型的对象（详细看AbstractExecutorService） execute()execute()的执行流程 判断核心线程池里的线程是否都在执行任务；否，则创建新的线程来执行任务；是，则进入2 判断工作队列是否已经满；否，则将新提交的任务存储在这个工作队列里；是，则进入3 判断线程池的线程是否都处于工作状态;否，则创建一个新的工作线程来执行任务；是，则交给饱和策略来处理这个任务 123456789101112131415161718192021222324public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get();//获取值 //.如果正在运行少于corePoolSize的线程，则启动新线程,尝试给定命令作为其第一个任务并执行 if (workerCountOf(c) &lt; corePoolSize) &#123; //addWorker方法会创建新的线程并执行任务，true用于判断是否超出核心线程数 if (addWorker(command, true)) return; c = ctl.get(); &#125; //如果线程处于RUNNING状态，且成功把任务放入阻塞队列（等待执行） if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //再次检查RUNNING状态，如果线程池没有RUNNING，且能够从阻塞队列中删除任务 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command);//执行reject方法处理任务 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // addWorker执行任务失败，则执行reject方法处理 else if (!addWorker(command, false)) reject(command);&#125; addWokrer()addWoker()流程 第一步：判断是否能创建线程(循环retry) a. 如果线程池状态&gt;=SHUTDOWN，且传入的任务为空，并且阻塞队列为空，则直接返回false b. 判断工作线程数,如果core为ture,那么必须小于核心线程数；如果core为false,必须小于最大线程数。否则，直接返回false 第二步：创建线程并执行任务 a. 通过Worker类创建线程并执行，woker对象相当于一个工作线程，保存在HashSet中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/***检查是否可以添加一个新的工作者*core:* 用于判断核心线程数* 用于判断最大线程数***/private boolean addWorker(Runnable firstTask, boolean core) &#123; // retry里的操作用于检查是否可以创建一个新的线程 retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // 如果线程池的状态值大于或等SHUTDOWN，空任务，，空队列，则不处理提交的任务，直接返回 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; //判断工作线程数是否已经超出核心线程数或者最大线程数，没有，则跳出循环，准备创建一个新的线程 for (;;) &#123; int wc = workerCountOf(c); //两种情况则表示失败，直接返回 //1. 当工作线程超出容量 //2. core的值为true，如果线程大于核心线程量， if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //尝试使工作线程数+1 if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; // 开始创建循环（使用Woker类创建） boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); // 获取到锁后再一次进行检查（可能在获取锁之前任务线程池已经关闭等状况） try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); //添加worder到workers(hashSet)集合中 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true;// 添加成功标志 &#125; &#125; finally &#123; mainLock.unlock(); &#125; //检查完毕，执行线程 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; Worker类Worker类使处于ThreadPoolExecutor的内部类，是一个AQS的子类，实现了非重入互斥锁，并且实现了Runnable，也就是本身也可以作为一个任务 Worker 构造时，会将本身作为参数传入到构造的thread类中；并且传入的任务，将会作为它的第一个执行任务 当执行thread.start()方法时，会调用它的run()方法,而本质是调用了runWorker()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ final Thread thread; /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; //可以看到，创建线程时worker时作为一个Runnable被传入到方法中的 this.thread = getThreadFactory().newThread(this); &#125; /** 运行方法本质时调用了runWoker() */ public void run() &#123; runWorker(this); &#125; // Lock methods // // The value 0 represents the unlocked state. // The value 1 represents the locked state. protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125;&#125; runWorker()runWoker()是真正执行任务的地方,除了worker第一次添加的任务外，它还会利用循环获取阻塞队列中的任务，继续执行它，直到没有任务可以执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; //先释放锁，允许中断 w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; //循环获取任务，并执行；getTask()方法从阻塞队列中获取等待的任务，当队列中没有任务，该方法会被阻塞挂起，不会占用cpu资源 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; //真正的允许在这里 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; getTask（）gitTask()方法是用于获取阻塞队列中的任务 123456789101112131415161718192021222324252627282930313233343536373839private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; //poll()：如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null； //take()：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 关闭线程池可以通过调用线程池提供的两个方法来关闭线程池 shutdown：只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程（通常使用） shutdownNow：将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表（如果任务无需执行完成，则可以使用） 原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程(无法响应中断的任务可能永远无法终止) 判断是否关闭 1234//执行shutdown()和shutdownNow后就会返回trueaThreadPoolExecutor.isShutdown()//执行shutdown()和shutdownNow后,且任务全部关闭才返回trueaThreadPoolExecutor.isTerminaed() 合理地配置线程池要想合理地配置线程池，就必须首先分析任务特性 任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 任务的优先级：高、中和低。 任务的执行时间：长、中和短。 任务的依赖性：是否依赖其他系统资源，如数据库连接 建议使用有界队列 线程池的监控监控线程池的时候可以使用以下属性 taskCount：线程池需要执行的任务数量。 completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。 largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。 getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。 getActiveCount：获取活动的线程数。 线程池的实现原理线程池的处理逻辑 执行过程(ThreadPoolExecutor为例) 判断：如果当前运行的线程数n与corePoolSize如果n &lt; corePoolSize 则创建新线程来执行任务（执行这一步骤需要获取全局锁）;结束；如果n &gt;= corePoolSize,则将任务加入BlockingQueue,进行下一步判断 判断：BlockingQueue是否已满否则，则将任务加入队列中;结束；如果队列已满，则需要创建新的线程来处理任务（需要获取全局锁）;继续判断 判断：创建新进程后进程数是否超出maximumPoolSize是，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法否，则创建线程，结束 123456789101112131415public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); // 如果线程数小于基本线程数，则创建线程并执行当前任务 if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; // 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。 if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); &#125; else if (!addIfUnderMaximumPoolSize(command)) // 抛出RejectedExecutionException异常 reject(command); // is shutdown or saturated &#125;&#125; 线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行 12345678910111213//Woker类的run方法 public void run() &#123; try &#123; Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) &#123; runTask(task); task = null; &#125; &#125; finally &#123; workerDone(this); &#125; &#125; 线程池中的线程执行任务分两种情况 在execute()方法中创建一个线程时，会让这个线程执行当前任务 线程执行完任务后，会反复从BlockingQueue获取任务来执行。 ScheduledExecutorService12345678910111213141516171819202122public interface ScheduledExecutorService extends ExecutorService &#123; //延迟执行任务 public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit); //延迟执行任务 public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit); //周期性执行任务 public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit); //周期性执行任务 public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);&#125; ScheduledThreadPoolExecutor在阿里巴巴代码规范中提到，不允许使用Executors区创建，而应该使用构造方法区构造 ScheduledThreadPoolExecutor它主要用来在给定的延迟之后运行任务，或者定期执行任务 构造函数实际上ScheduledThreadPoolExecutor是利用父类ThreadPoolExecutor的构造函数来构建的，并且其使用的是DelayedWorkQueue队列 1234public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 线程任务任务框架成员 类/接口 描述 Future 接口，表示异步计算的结果，描述方法以检查计算是否完成、等待其完成、检索计算的结果（用于获取结果） Runnable 接口，任何类都可以实现，用于线程的执行，无返回参数 Callable 接口，描述返回结果的任务（用于产生结果） RunnableFuture 接口，描述一个Runnable和Future的整合 FutureTask 实现类，可取消的异步计算 Future1234567891011121314public interface Future&lt;V&gt; &#123; // 取消执行此任务 boolean cancel(boolean mayInterruptIfRunning);// 判断任务是否已经取消 boolean isCancelled();// 判断任务是否已经完成 boolean isDone();//必要时等待计算完成，然后检索其结果 V get() throws InterruptedException, ExecutionException;// 超时等地啊 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; Runnable12345@FunctionalInterfacepublic interface Runnable &#123; // 启动线程会调用该方法 public abstract void run();&#125; Callable12345@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; //计算结果 V call() throws Exception;&#125; RunnableFuture1234public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; //将此Future设置为其计算结果 void run();&#125; FutureTask1234//实现了RunnableFuture，也就是Runnable接口，可以交给Executor执行public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;&#123; &#125; FutureTask变量FutureTask状态初始时，状态为NEW 12345678private volatile int state;private static final int NEW = 0; // 初始状态private static final int COMPLETING = 1; // 任务完成状态private static final int NORMAL = 2;private static final int EXCEPTIONAL = 3;private static final int CANCELLED = 4;private static final int INTERRUPTING = 5;private static final int INTERRUPTED = 6; 构造函数12345678910111213141516171819202122232425262728293031public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125;//Executors.callable()public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result);&#125;//Executors中的RunnableAdapterstatic final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; public T call() &#123; task.run(); return result; &#125;&#125; 方法get()123456public V get() throws InterruptedException, ExecutionException &#123; int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L);// 利用awaitDone进行阻塞 return report(s);&#125; run()12345678910111213141516171819202122232425262728293031323334public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; //保存异常 setException(ex); &#125; if (ran) //保存结果 set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; awaitDone()123456789101112131415161718192021222324252627282930313233343536373839404142434445//等待中断或超时完成或中止, 会阻塞线程/***@timed 设置是否使用等待时间*@nanos 等待时间**/private int awaitDone(boolean timed, long nanos) throws InterruptedException &#123; final long deadline = timed ? System.nanoTime() + nanos : 0L; WaitNode q = null; boolean queued = false; for (;;) &#123; // 线程中断，则抛出异常 if (Thread.interrupted()) &#123; removeWaiter(q); throw new InterruptedException(); &#125; // 判断当前状态，大于COMPLETING说明任务已经完成，直接返回 int s = state; if (s &gt; COMPLETING) &#123; if (q != null) q.thread = null; return s; &#125; // 等于COMPLETING，表示任务已经完成，使用yield()方法让步，等待其状态变为NORMAL else if (s == COMPLETING) // cannot time out yet Thread.yield(); else if (q == null) q = new WaitNode(); else if (!queued) queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); else if (timed) &#123; nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) &#123; removeWaiter(q); return state; &#125; LockSupport.parkNanos(this, nanos); &#125; else LockSupport.park(this); &#125;&#125; get()12345678//用于获取结果，如果还没有完成，则会进入等待public V get() throws InterruptedException, ExecutionException &#123; int s = state; // 当处于NEW或者COMPLETING状态时，会导致线程阻塞 if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s);// 根据状态该,直接返回结果&#125; removeWaiter（）1234567891011121314151617181920212223////尝试取消链接超时或中断的等待节点以避免累积垃圾private void removeWaiter(WaitNode node) &#123; if (node != null) &#123; node.thread = null; retry: for (;;) &#123; // restart on removeWaiter race for (WaitNode pred = null, q = waiters, s; q != null; q = s) &#123; s = q.next; if (q.thread != null) pred = q; else if (pred != null) &#123; pred.next = s; if (pred.thread == null) // check for race continue retry; &#125; else if (!UNSAFE.compareAndSwapObject(this, waitersOffset, q, s)) continue retry; &#125; break; &#125; &#125;&#125; report()123456789//根据状态返回结果或抛出已完成任务的异常private V report(int s) throws ExecutionException &#123; Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x);&#125; Runnable接口和Callable接口 Runnable接口和Callable接口 可以被ThreadPoolExecutor或Scheduled-ThreadPoolExecutor执行 Runnable不会返回结果 Callable可以返回结果 12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125;@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; 工具类Executors可以把一个Runnable对象封装为一个Callable对象(适配器模式) 12345public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result);&#125; 实例线程的创建12345678910public class demo1 &#123; public static void main(String[] args) &#123; //直接利用了lambda表达式 new Thread(()-&gt;&#123; System.out.println("线程创建了"); &#125;, "线程1号").start(); &#125;&#125;// print线程创建了 利用boolean变量进行线程中断123456789101112131415161718192021222324252627282930313233public class Count &#123; public static void main(String[] args) throws Exception&#123; Runner runner = new Runner(); Thread thread = new Thread(runner); thread.start(); TimeUnit.SECONDS.sleep(5);//睡眠5秒 runner.cancel();//中断 &#125; private static class Runner implements Runnable&#123; private long i; //定义标志位 private volatile boolean symbol = true; @Override public void run() &#123; //只要symbol 为true 或者 线程没有中断，则run方法就就一直进行下去 while (symbol &amp;&amp; !Thread.currentThread().isInterrupted())&#123; //something to do i++; &#125; System.out.println(i); &#125; // 将symbol置为false，以终止线程 public void cancel()&#123; symbol = false; ystem.out.println("开始中断"); &#125;&#125; //print开始中断3358369448 线程状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package 线程状态;import jdk.nashorn.internal.ir.Block;import java.util.concurrent.TimeUnit;public class demo &#123; public static void main(String[] args) &#123; new Thread(new TimeWaiting(), "超时等待线程").start(); new Thread(new Waiting(), "等待线程").start(); new Thread(new Blocked(), "抢锁线程1，抢到").start(); new Thread(new Blocked(), "抢锁线程2，没抢到").start(); &#125; /** * 超时等待线程 */ static class TimeWaiting implements Runnable&#123; @Override public void run() &#123; while (true)&#123; SleepUtils.second(100); &#125; &#125; &#125; /** * 等待线程 */ static class Waiting implements Runnable&#123; @Override public void run() &#123; while (true)&#123; synchronized (Waiting.class)&#123; try&#123; Waiting.class.wait(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; static class Blocked implements Runnable&#123; @Override public void run() &#123; synchronized (Block.class)&#123; while (true)&#123; SleepUtils.second(100); &#125; &#125; &#125; &#125; public static class SleepUtils&#123; public static final void second(long seconds)&#123; try &#123; TimeUnit.SECONDS.sleep(seconds); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 先jps查看当前程序的pid 123456D:\Idea-projects\ThreadDemo&gt;jps143527780 Launcher11272 Jps4764 demo // 4764就是pid716 RemoteMavenServer 再通过jstack pid查看线程状态 1234567891011&quot;抢锁线程2，没抢到&quot; #15 prio=5 os_prio=0 tid=0x00000000199df000 nid=0x17dc waiting for monitor entry [0x000000001aabf000] java.lang.Thread.State: BLOCKED (on object monitor)&quot;抢锁线程1，抢到&quot; #14 prio=5 os_prio=0 tid=0x00000000199de800 nid=0x2e4 waiting on condition [0x000000001a9bf000] java.lang.Thread.State: TIMED_WAITING (sleeping)&quot;等待线程&quot; #13 prio=5 os_prio=0 tid=0x00000000199db800 nid=0x19e4 in Object.wait() [0x000000001a8bf000] java.lang.Thread.State: WAITING (on object monitor)&quot;超时等待线程&quot; #12 prio=5 os_prio=0 tid=0x00000000199db000 nid=0x2664 waiting on condition [0x000000001a7bf000] java.lang.Thread.State: TIMED_WAITING (sleeping)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java 并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 基础]]></title>
    <url>%2Fblog%2F2018%2F02%2F01%2Fjava.all%2F</url>
    <content type="text"><![CDATA[java 基本数据类型八大基础数据类型 java一共有8个基本数据类型 数据类型 存储需求 取值范围 前/后缀 int 4字节 -2^32~ 2^32-1 short 2字节 -2^16~ 2^16 -1 long 8字节 -2^64~2^64 -1 后缀：L或l,如40000L byte 1字节 -2^8 ~ 2^8 -1 float 4字节 后缀F或f double 8字节 默认，后缀可以是D或d char 1个字符 \u0000~\Uffff boolean true/false JAVA范围与j运行ava代码机器无关,因为Java程序必须保证在所有机器上都能够得到相同的结果，所以各种数据类型的取值范围必须固定。 浮点类型的特殊常量 特殊值 对应常量 正无穷大 Double.POSITIVE_INFINITY 、 Float.POSITIVE_INFINITY 负无穷大 Double.NEGATIVE_INFINITY、Float.NEGATIVE_INFINITY NaN(不是一个数) Double.NaN、Float.NaN 浮点类型不适用于无法接受舍入误差的金融计算中，如2.0 -1.1 会输出0.8999999999999999，而不是0.9 原因：浮点数值采用二进制系统表示法（二进制无法精确表示分数1/10） 如果不允许输入误差，需要使用 BigDecimal类 数值类型转换 对于将数值赋值给一个不同的数值类型变量时，需要进行转换，转化方式分为自动类型转换和强制类型转换 自动类型转换 满足以下条件将自动转换 这2种类型是兼容的。 目的类型数的范围比来源类型的大。 当以上2个条件都满足时,拓宽转换(widening conversion)发生数字类型和字符类型(char)或布尔类型(bollean)是不兼容的。字符类型(char)和布尔类型(bollean)也是互相不兼容的。 虚线表示数据可能丢失,如果对图中箭头反向转换，会报错，需要强制转换 强制转换1(target-type)value 截断(truncation):把浮点值赋给整数类型时一种不同的类型转换,小数部分会被舍去。 java 257强制转换赋值给byte会怎么样？323呢? 答：byte范围是256,所以257赋值后，值为1(257/256)。323为67(323/256) 表达式中的类型提升 所有byte型和short型的值在表达式中会被提升到int类型 好处：避免了计算过程中中间结果超出范围 缺点，可能需要多出一步强转 类型提升规则： 如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。 否则， 如果其中一个操作数是 float 类型， 另一个操作数将会转换为 float 类型。 否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 否则， 两个操作数都将被转换为 int 类型 12345byte a = 50;byte b = 20;int i = b * a; //okb = b * 2;//error,b * 2 会提升到int,b 是一个byte b = (byte)b; //ok 注意一个问题： 1234// a += 1,相当于 ++a,没有存在类型的提升byte a = 40;System.out.println(a += 1); //trueSystem.out.println(a = a + 1);// 无法编译成功 对象包装器和自动装箱 基本类型对应的类，被称为包装器。 包装器 原始 Integer int Long long Float float Double double Short short Byte byte Character char Void void Boolean boolean Number类 Integer、Long、Float、Double、Short、Short均继承于Number类 123456789101112131415161718192021222324//Number类源码package java.lang;public abstract class Number implements java.io.Serializable &#123; public abstract int intValue();// 输出int值,即将当前值转换成int值进行输出 public abstract long longValue();// 输出long值 public abstract float floatValue(); // 输出float值 public abstract double doubleValue(); // 输double值 public byte byteValue() &#123; return (byte)intValue(); &#125; public short shortValue() &#123; return (short)intValue(); &#125; private static final long serialVersionUID = -8742448824652078965L;&#125; 装箱和拆箱是编译器认可的，而不是虚拟机（编译器在生成类的字节码的时候，插入必要的方法调用，而虚拟机这是执行这些字节码） 自动装箱 将基本数据赋值给包装器123list.add(3);//自动装箱成list.add(Integer.valueOf(3)); 自动拆箱 将包装器对象赋值给基本数据 123int n = list.get(i);//自动拆箱int n = list.get(i).intValue(); 为什么要使用包装器类作用1：用于需对象类型的场合 如泛型类型,泛型是无法使用基本数据类型的 12List&lt;Integer list&gt; = ...;//正确List&lt;int&gt; = ...; // 错误 作用2：提供类的特性 通过包装器，可以利用类的特性进行更多的操作 12Integer i2 = new Integer("123");// Stirng 类型转换System.out.println(i.toString());//使用一些Object的方法 大数据类型(BigInteger和BigDecimal)java的基础类型是无法保证运算的准确性的，如果需要精确的运算，就要用到位于java.math包下的两个大数据类型 BigInteger：用于任意精度的整数运算 BigDecimal：用于任意经读的浮点数运算 普通类型转大数据类型 1234BigInter.valueOf(123);BigDecimal.valueof(23,3434); 大数据类型无法使用+、-、*、/运算符，而是使用运算方法 1234add();//加subtract();//减multiply();//乘divide(); //除 数组数组初始化1234//自动初始化值new type[size];//自定义初始化值int[] smallPrimes = &#123; 2, 3, 5, 7, 11, 13 &#125;; 初始化匿名数组1new int[] &#123; 17, 19, 23, 29, 31, 37 &#125; 多维数组1234567int twoD[][] = new int[4][5];// 也可以,第二维手工分配 int twoD[][] = new int[4][];twoD[0] = new int[5];twoD[1] = new int[5];twoD[2] = new int[5];twoD[3] = new int[5]; 运算符 运算符 结果 ~ 按位非(NOT)(一元运算) &amp; 按位与(AND), a &amp; b, 都为1时为1，其余为0；如果是布尔运算，则为 两者为true时为true &amp;#124 按位或(OR), a \&#124; b, 其中一个为1则为1 ^ 按位异或(XOR)，a ^b, 两值相同为1,（ a 异或两次b,还是a） &gt;&gt; 右移,被移走的最高位(最左边的位)由原来最高位的数字补充 &gt;&gt;&gt; 右移,左边空出的位以0填充 &lt;&lt; 左移,高阶位都被移出(并且丢弃),并用0填充右边 ?: 三元运算符(IF-THEN-ELSE)，condition ? expression1 : expression2; &amp;&amp; 短路与，a &amp;&amp; b, a为false，则不再考虑b,即使b报错 &#124;&#124; 短路或， a &#124;&#124; b,a为true，则不考虑b，即使b报错 流程控制语句选择语句if语句12if (condition) statement1;else statement2; switch语句 需满足: 表达式expression必须为byte,short,int或char类型。 每个case语句后的值value必须是与表达式类型兼容的特定的一个常量(它必须为一个常量,而不是变量)。 重复的case值是不允许的。 如果没有break语句,程序将继续执行下面的每一个case语句,直到遇到break语句(或switch语句的末尾) 12345678910111213141516switch (expression) &#123; case value1: // statement sequence break; case value2: // statement sequence break; . . . case valueN: // statement sequence break; default: // default statement sequence&#125; 循环语句while语句 while语句在循环一开始就计算条件表达式,若开始时条件为假,则循环体一次也不会执行 123while(condition) &#123;// body of loop&#125; do-while循环 do-while循环总是先执行循环体,然后再计算条件表达式，所以至少一次 123do &#123;// body of loop&#125; while (condition); for循环123for(initialization; condition; iteration) &#123;// body&#125; Java允许你在for循环的初始化部分和反复部分声明多个变量1234for(a=1, b=4; a&lt;b; a++, b--) &#123; System.out.println("a = " + a); System.out.println("b = " + b);&#125; 跳转语句break语句 作用： 在switch语句中,它被用来终止一个语句序列 能被用来退出一个循环 能作为一种“先进”的goto 语句来使用 break不是被设计来提供一种正常的循环终止的方法!!! 把 break 当作 goto 的一种形式来用,标签break语句的通用格式12345label:&#123; ... break label//直接跳出循环，调到label块的尾部执行some code..&#125;// some code.. continue语句 跳出当前循环，开始新的一次循环 return语句 return语句用来明确地从一个方法返回 对象与类 类： 对象的模板(template) 对象：类的一个实例(instance) 实例变量(instance variables)：定义在类中的数据或变量 类的成员: 定义在类中的方法和实例变量 类的组成方法参数数量可变的方法1public static double max(int aint, double... values) 方法重载 方法重载（overloaded）：同一个类中的2个或2个以上的方法可以有同一个名字,只要它们的参数声明不同即可 在一些情况下,Java的自动类型转换也适用于重载方法的自变量 123456//当只有double类型的方法时，会把int扩大到double void test(double a) &#123;System.out.println("Inside test(double) a: " + a);&#125;test(10);// print 10; 注意：返回方法不能称为重载的一个条件，原理可查看《JVM》中的 重载一节 域 默认初始化域 类型 值 基本数值类型 0 布尔值 false 对象引用 null 块初始化块 在一个类的声明中， 可以包含多个代码块；只要构造类的对象，这些块就会被执行 静态初始化块 对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块 123static&#123; some code&#125; 构造器无参构造器 没有编写构造器，系统就会提供一个无参数构造器，并将值默认初始化 可以 使用 this 关键字调用其他构造器,this放在第一行 ，这么做可以对公共的构造器代码部分只编写一次 构造器调用处理步骤 具体顺序如下 父类静态代码块 子类静态代码块 父类构造代码块 父类构造函数 子类构造代码块 子类构造函数 类的参数传递 计算机语言给子程序传递参数的方法有两种: 值传递：当一个简单类型传递给一个方法时,使用按值传递。将一个参数值(value)复制成为子程序的正式参数 引用传递：对象传递使用引用传递。参数的引用(而不是参数值)被传递给子程序参数 类之间的关系 关系 描述 依赖 uses-a 聚合 has-a 继承 is-a 更为详细的介绍看《设计模式》关系一节 内部类使用内部类的原因只要有以下三点 用于访问外部类的域，包括私有数据 内部类可以对于同包的其他类隐藏起来 定义回调函数且不需要写大量代码（匿名内部类） 静态内部类和内部类的区别内部类主要分为静态内部类和内部类，它们的区别如下 访问外部类 a. 静态嵌套类：只能访问外部类的静态变量和方法 b. 内部类：可以访问外部类的静态/非静态变量 方法和变量 a. 静态嵌套类：可以拥有静态方法和静态变量 b. 内部类：不能拥有静态方法和静态变量，但可以定义static final 变量 外部类引用 a. 静态嵌套类：没有外部类的引用 b. 内部类：有外部引用的类，可以使用OutClass.this来表示外部类 依赖性 a. 静态嵌套类：不依赖外部类 b. 内部类：依赖于外部类，一旦外部类被回收，内部类也会跟着回收 成员内部类使用场景：需要隐藏内部类并且需要访问外部类的域 123456789public class OutClass&#123; class Inner&#123; private static final int a = 1; ... &#125;&#125;//在其他类中实例化OutClass.InnerClass innerClass = new OutClass().new InnerClass(); 局部内部类（方法中的类）特点： 应用场景：只是用一次的类可以定义为局部类 对外部完全隐蔽，只能用于方法中 不能使用public等修饰符，只能默认，也就意味着它的作用域被限定在这个局部块中 不能在其他类中实例化，只能在本方法中使用，且创建语句必须在类定义之后 1234567891011// 这里的InnerClass,只有start方法知道它的存在public void start()&#123; class InnerClass&#123; public void method ( ActionEvent event)&#123; ... &#125; &#125; //创建 InnerClass aInnerCLass = new InnerClass(); ....&#125; 匿名内部类特点 相当于匿名内部类继承父类或实现接口 没有class关键字，直接new生成对象的引用 123456// 直接通过父接口来创建，方法实现直接写在&#123;&#125;SuperType aClass = new SuperType(construction parameters)&#123; //内部写方法和变量 ..... &#125; 静态嵌套类特点： 只是为了把一个类隐藏在另外一个类的内部 , 并不需要内部类引用外围类对象,此时可以将嵌套类明为static 声明在接口中的内部类自动成为 static 和 public 类(即接口中的都是静态公有内部类) 123456789101112public class OutClass&#123; private static int a; private int b; public static class InnerClass&#123; public void print()&#123; ...... &#125; &#125;&#125;//实例化,不依赖外部类OutClass.InnerClass inner = new Out.inner(); 抽象类 关键字：abstract 抽象类介绍 可以包含具抽象方法、具体数据、具体方法 类即使不含抽象方法，也可以将类声明为抽象类。 抽象类不能被实例化，但可以拥有构造器 抽象类是被继承的。 可以定义一个抽象类的对象变量，但只能引用非抽象子类的对象。 1234567public abstract Clss person&#123; private String name; public Person(String name)&#123; this.name = name; &#125; public abstract String geDescrption();&#125; 枚举类 如下枚举类Size，其中SMALL, MEDIUM, LARGE, EXTRA ,LARCE是它的实例 1Enum Size &#123; SMALL, MEDIUM, LARGE, EXTRA .LARCE &#125;; 因为直接存在实例，所以比较两个枚举类时，直接使用==（不需要构造新对象） 如果需要，可以添加构造器，方法，域 123456789//SMALL("s"),, MEDIUM("x")就相当于使用构造器进行了实例化public enum Size &#123; SMALL("s"), MEDIUM("x"); private String name; private Size(String name)&#123; this.name = name; &#125; public String getName()&#123;return name;&#125;&#125; 调用实例 1Size.SMALL.toString() 逆方法获取实例 1234//可以通过字符串数据来获取实例Size f = Enum.valueOf(Size.class, "SMALL");//实际上与下面方法效果一样，但无法使用字符串来获取相应的实例Size e = Size.SMALL; 获取枚举类的所有实例,返回一个数组 1Size[]values = Size.values(); 字符串字符串的构造函数 当创建一个String对象时，被创建的字符串是不能被改变的 123456789//创建空字符串String s = new String();// 通过字符数组创建字符串String(char chars[ ]);//指定字符数组一个子区域创建字符串String(char chars[ ], int startIndex, int numChars);//指定字节数组来创建字符串String(byte asciiChars[ ])String(byte asciiChars[ ], int startIndex, int numChars) 对于程序中的每一个字符串常量，Java会自动创建String对象 12//会创建一个字符串对象，且该对象将会被任何地方使用String s2 = "abc"; 字符串操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//返回指定位置的字符;char charAt(int where);//一次截取多个字符.包头不包尾，target[ ]为存放截取字符的数组，targetStart表示从什么位置开始存放void getChars(int sourceStart, int sourceEnd, char target[ ], int targetStart)；//字符串-&gt; 字节数组byte[ ] getBytes( )；//字符串-&gt;字符数组,可使用getChars()达到相同的效果char[ ] toCharArray( );//字符串比较,String重写equals方法，比较字符串的长度和字符boolean equals(Object str);boolean equalsIgnoreCase(String str)；//字符串区域比较，startIndex，str2StartIndex表示两字符串的起始位置，numChars表示比较的字符数boolean regionMatches(int startIndex, String str2,int str2StartIndex, int numChars)；boolean regionMatches(boolean ignoreCase,int startIndex, String str2,int str2StartIndex, int numChars)；//开头/结尾比较boolean startsWith(String str);boolean endsWith(String str);//字符串大小比较,默认比较的是ASCII码值// 大于0表示字符串大于str//等于0 表示字符串等于str// 小于0表示字符串小于strint compareTo(String str)；int compareToIgnoreCase(String str)；//查找ASCII码对应的字符出现的位置,ch为值,没有返回-1int indexOf(int ch); //第一次出现int lastIndexOf(int ch)；//最后一次出现//startIndex:起始搜索位置int indexOf(int ch, int startIndex);int lastIndexOf(int ch, int startIndex);//查找字符串出现的位置int indexOf(String str)；int lastIndexOf(String str)；int indexOf(String str, int startIndex);int lastIndexOf(String str, int startIndex);//从 startIndex 截取子字符串.(在endIndex结束，不包尾)String substring(int startIndex);String substring(int startIndex, int endIndex);//链接两个字符串,与+效果相同String concat(String str);//original 字符 被replacement 取代String replace(char original, char replacement);//去空格String trim( );//字符串大小写String toLowerCase( )String toUpperCase( ) 利用valueOf( )实现数据转换 valueOf()是String的静态方法，可以酱任何类转换成String类 12345static String valueOf(double num)static String valueOf(long num)static String valueOf(Object obj)//返回的是null或Obj.toString()static String valueOf(char chars[ ]) //返回字符数组所有字符的字符串static String valueOf(char chars[ ], int startIndex, int numChars) StringBuffer StringBuffer是可变长的和可写的字符序列,可以自动地增加空间，但通常还有比实际需要更多的预留字符 构造函数 12345678910111213//无参，默认可以存储16个字符public StringBuffer() &#123; super(16);&#125;// 自定义大小public StringBuffer(int capacity) &#123; super(capacity);&#125;//通过str初始化，且大小+16public StringBuffer(String str) &#123; super(str.length() + 16); append(str);&#125; 长度获取 12345678//得到当前StringBuffer的长度public int length() &#123; return count;&#125;//得到总的分配容量public int capacity() &#123; return value.length;&#125; 为某些字符预分配空间，添加缓冲区容量 1void ensureCapacity(int capacity) 设置缓冲区的大小,可用于缩短StringBuffer 1void setLength(int len) 获取/设置字符 12char charAt(int where)void setCharAt(int where, char ch) 将StringBuffer的子字符串复制给数组 12void getChars(int sourceStart, int sourceEnd, char target[ ],int targetStart) 将任一其他类型数据的字符串形式连接到调用StringBuffer对象的后面 123StringBuffer append(String str)StringBuffer append(int num)StringBuffer append(Object obj) 将一个字符串插入另一个字符串中 123456/***index: 插入位置**/StringBuffer insert(int index, String str)StringBuffer insert(int index, char ch)StringBuffer insert(int index, Object obj) 字符串翻转 1StringBuffer reverse( ) 删除字符串 12StringBuffer delete(int startIndex, int endIndex)StringBuffer deleteCharAt(int loc) 替换字符串 1StringBuffer replace(int startIndex, int endIndex, String str) 子串 12String substring(int startIndex)String substring(int startIndex, int endIndex) 继承 关键字 extends 表示继承 成员的访问与继承 子类方法不能够直接地访问超类的私有域。需要通过super调用父类的getter方法。 子类继承了父类的所有属性和方法，只不过父类的私有属性和方法子类是无法直接访问到的 super用法一：调用超类中定义的构造函数方法 子类可以通过spuer调用超类中定义的构造函数方法 1super(parameter-list); super( )必须是在子类构造函数中的第一个执行语句。 super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编 译器调用超类方法的特殊关键字。 用法二：类似于this的用法12//member既可以是1个方法也可以是1个实例变量super.member 方法重写(override） 如果子类中的一个方法与它超类中的方法有相同的方法名和类型声明,称子类中的方法重写(override)超类中的方法 方法重写应遵循“三同一小一大”原则： “三同”：即方法名相同，形参列表相同，返回值类型相同； “一小”：子类方法声明抛出的异常比父类方法声明抛出的异常更小或者相等； “一大”:子类方法的访问修饰符应比父类方法更大或相等 子类构造器 如果需要对对父类私有属性的初始化，必须通过 super 实现对超类构造器的调用，且在第一句 子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类的无参构造器。 如果超类没有不带参数的构造器， 并子类的构造器中必须显示地调用超类 的其他构造器,否则报错 多态 一个对象可以指示多种实际类型的现象被成为多态。 当一个子类对象的引用被赋给一个超类引用变量时,你只能访问超类定义的对象的那一部分(即由父类引用子类对象，无法调用子类的特有方法。)子类引用父类对象，需要强转。 动态绑定 动态方法调度是一种在运行时而不是编译时调用重载方法的机制,即在运行时能够自动地选择调用哪个方法的现象被称为动态绑定，这是Java实现运行时多态性的基础 理解方法调用 当一个重载方法通过超类引用被调用,Java根据当前被引用对象的类型来决定执行哪个版本的方法 调用过程的详细描述： 编译器査看对象的声明类型和方法名。【编译器已获得所有可能被调用的候选方法，同名不同参数的方法】 接下来，编译器将査看调用方法时提供的参数类型【编译器已获得需要调用的方法名字和参数类型。】。编译器没有找到与参数类型匹配的方法， 或者发现经过类型转换后 有多个方法与之匹配， 就会报告一个错误。 如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定（ static binding )。 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实 际类型最合适的那个类的方法。。假设 x 的实际类型是 D，它是 C 类的子类。如果 D 类定义了 方法 f(String，) 就直接调用它；否则， 将在 D 类的超类中寻找 f(String，) 以此类推。每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个 方法表（ method table), 其中列出了所有方法的签名和实际调用的方法。这样一来，在真正 调用方法的时候， 虚拟机仅查找这个表就行了 修饰符static 声明为static的变量实质上就是全局变量,但存在以下几条限制 它们仅能调用其他的static方法或者访问static数据。 它们不能以任何方式引用this或super 需要注意的是，虽然构造函数并不是static修饰，但静态方法是可以访问的。在《Think in Java》中提到过这样一句话：“即使没有显示地使用static关键字，构造器实际上也是静态方法” 静态域和静态方法 静态域（类域）：属于类，而不属于任何独立的对象，所有对象共享。 静态方法：一种不能向对象实施操作的方法，没有隐式参数 静态常量: static final修饰 使用静态方法的情况 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow（）） 一个方法只需要访问类的静态域 final作用一：定义常量 变量可以声明为final,这样做的目的是阻止它的内容被修改 final域：构建对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改 作用二：使用final阻止重写 声明成final的方法不能被重载 作用三：使用final阻止继承 声明成final的类不能被继承 作用四：修饰方法参数被修饰的方法参数在方法体内不能被改变 访问控制（作用域） 作用域 当前类 同一package 子孙类 其他package 描述 public √ √ √ √ 对所有类可见 protected √ √ √ × 对本包和所有子类可见 default √ √ × × 对本包可见,默认 private √ × × × 仅对本类可见 对于类来说，只有默认和public两种访问级别 Object类 Object 类是 Java 中所有类的始祖， 在 Java 中每个类都是由它扩展而来的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package java.lang;public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; public final native Class&lt;?&gt; getClass(); public native int hashCode(); public boolean equals(Object obj) &#123; return (this == obj); &#125; protected native Object clone() throws CloneNotSupportedException; public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0); &#125; protected void finalize() throws Throwable &#123; &#125;&#125; 在 Java 中，只有基本类型 （ primitive types) 不是对象， 例如，数值、 字符和布尔类型的 值都不是对象。 equals 方法 Object 类的equals()方法判断两个对象是否具有相同的引用,其本质等同于”==”,但有些类已经重写了 equals(),如String类 Java语言规范下的equals 自反性：对于任何非空引用x，x.equals(x)应该返回true 对称性：对于任何引用x和y，当且仅当y.equals(x)返回true，x.equals(y)也应该返回true 传递性：对于任何引用x、y、z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true 一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果 对于任何非空引用x，x.equals(null)应该返回true 完美equals建议 123456789101112131415public class E&#123; public boolean equals(Object otherObject)&#123; //先判断地址相同 if(this == otherObject) return true; //如果传入参数为null，无需比较 if(otherObject == null) return false; //类不同，肯定不同 if(getClass() != otherObject.getClass()) return false //此时可知参数是非null 的E类了 E other = (E)otherObject; //比较直，对象用equals比较，防止null值;数值用==比较 return Objects.equals(name, other.name) &amp;&amp; phone == other.phone &#125;&#125; hashCode方法 散列码（ hash code ) 是由对象导出的一个整型值，其值为对象的 存储地址 如果重新定义 equals方法，就必须重新定义 hashCode 方法， 以便用户可以将对象插入到散列表中 1234//这是一个由name、salary、hireDay组成的hashCode编码。public int hashCode()&#123; return Objects.hash(name, salary, hireDay)&#125; 反射反射： 在运行状态中，对任意一个类都能知道这个类的属性和方法，且对任意一个对象，都可以调用它的任意方法。 优点：灵活性高，因为反射属于动态编译，即只有到运行时才动态创建 、获取对象实例 缺点： a. 执行效率降低：因为反射的操作 主要通过JVM执行，所以时间成本会 高于 直接执行相同操作 b. 容易破坏类结构 大量应用于JavaBeans中，是Java组件的体系结构,反射可以用来: a. 在运行时分析类的能力 b. 在运行时查看对象，如编写一个toSring方法供所有类使用 c. 实现通用的数组操作代码 d. 利用Method对象 静态编译：在编译时确定类型 &amp; 绑定对象。如常见的使用new关键字创建对象 动态编译：运行时确定类型 &amp; 绑定对象。动态编译体现了Java的灵活性、多态特性 &amp; 降低类之间的藕合性 反射的主要类结构，位于java.lang.reflect包 类 描述 Class 类，用于保存对象运行时的信息 Field 类的域 Method 类的方法 Constructor 类的构造器 Class 类 Class类：Java运行时系统始终为所有的对象维护一个运行时的类型标识。这个信息跟踪每个对象所属的类，保存这些信息的类被称为Class Class常用方法1234567891011121314151617181920212223// 通过类名来获取Class对象public static Class&lt;?&gt; forName(String className);//返回一个了的新实例public T newInstance();// 返回类的Field对象数组public Field[] getFields()； //只返回该类与其超类的公有域public Field[] getDeclaredFields()// 返回该类与其超类的所有域public Field getField(String name)；//返回指定名称的公有域public Field[] getDeclaredFields(String name); //返回指定名称的域 //返回包含Method对象的数组public Method[] getMethods()；//返回类与实现的接口、继承的超类的公有方法public Method[] getDeclaredMethods()；//返回类与实现的接口的全部方法，但不包括由超类继承了的方法public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)；//返回指定名称和参数类型的公有方法public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)；//返回指定名称和参数类型的方法 //返回Constructor对象的数组 public Constructor&lt;?&gt;[] getConstructors(); //返回类的公有构造器public Constructor&lt;?&gt;[] getDeclaredConstructors(); //返回类的所有构造器public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes);//返回指定参数类型的公有构造器public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes);//返回指定参数类型的构造器 Class的比较每个类型只存在一个Class对象,所以使用==即可比较 123456// 对于2个String类型对象，它们的Class对象相同Class c1 = "Carson".getClass();Class c2 = Class.forName("java.lang.String");// 用==运算符实现两个类对象地址的比较System.out.println(c1 ==c2);// 输出结果：true 获取Class对象的三种方法1234567//方法1：静态方法(应该提供一个异常处理器)Class.forName(className);//方法2：Object的getClass()方法e.getClass();//方法3：Class cl1 = int.class;//int不是类，但int.class是一个类Class cl2 = Double[].class 创建实例的两种方法123456//方式一：使用Class对象的newInstance方法e.getClass().newInstance();//方式二：使用Constructor的newInstance()方法String s = "java.util.Random";Constructor c = Class.forName(s).getDeclaredConstructor(String.class, String.class, int.class);c.newInstance("liisyu", "boy", 18); Field 类Field类：类的域对象,用于获取和设置类的属性值 Filed类常用方法1234//返回 obj 对象中用 Field 对象表示的域值Object get ( Object obj ) //用一个新值设置 Obj 对象中 Field 对象表示的域void set ( Object obj , Object newValue ) 获取域对象 1Field aField = aClass.getDeclareField("fieldName"); 查看数据域的实际内容 123//Object obj 是一个包含该域的对象//对于get()方法如果域是一个String,那么返回成Object是没有问题的。但如果是一个基本数据类型，get()方法会自动将值打包成对象。aField.get(Object obj) 设置域12// obj: 设置的对象aFiled.set(obj, "newName"); 实例: 123456Employee maorl = new Employee("maorl", 39999, 10, 1, 1994);Class aClass = maorl.getClass();// 在这里，name是一个私有域，因为反射机制的默认是受Java访问控制的，所以get()方法会抛出一个IllegalAccessException。 Field aField = aClass.getDeclareField("name");//获取具体值Object value = aField.get(masorl); 覆盖访问控制（即访问无妨访问的域，破坏了封装性）。为了达到这个目的，可以使用Field、Method、Constructor对象的 setAccessible12// 此时，我们可以访问得到name域的值了。 aFiled.setAcessible(true) Method类 Method类：类的方法对象，可以获取类中方法信息和执行方法。 Method常用方法123456789//返回一个用于描述返回类型的Class对象public Class&lt;?&gt; getReturnType()；//obj: 执行改方法的对象aMethod.invoke(obj);// obj: 隐式参数(静态方法就传null,有点类似于feild.get()方法) //args: 显式参数//返回Object，所以可能需要进行类型转换（返回值是基本数据类型，会自动包装）public Object invoke(Object obj, Object... args)&#123;...&#125; Constructor类Constructor类：表示类的构造方法 Constructor常用方法12//构造一个该构造器所属类的实例，initargs为构造器的参数 public T newInstance(Object ... initargs); Field、Constructor、Method相似方法1234567891011121314//返回一个用于描述类中定义的构造器、方法或域的Class对象public Class&lt;T&gt; getDeclaringClass();//返回一个用于描述方法抛出的异常类型的Class对象数组public Class&lt;?&gt;[] getExceptionTypes() ；//返回一个用于描述构造器、方法或域的修饰符的整型数值，使用Modifier类可以分析这个返回值public int getModifiers()；//返冋一个用于描述构造器 、 方法或域名的字符串 public String getName();//返回一个用于描述参数类型的 Class 对象数组【Constructor、Method中存在的】public Class&lt;?&gt;[] getParameterTypes() ; Modifier类Modefier类用于解释类和成员变量的访问修饰符（访问修饰符通常会以Int形式存在，通过getModifiers()方法可以获得） 1234567891011121314//返回对应 modifiers 中位设置的修饰符的字符串表示static String toString ( int modifiers )// 检测方法名对应的修饰符static boolean isAbstract ( int modifiers )static boolean isFinal ( int modifiers )static boolean islnterface ( int modifiers )static boolean isNative ( int modifiers )static boolean isPrivate ( int modifiers )static boolean isProtected ( int modifiers )static boolean isPublic ( int modifiers )static boolean isStatic ( int modifiers )static boolean isStrict ( int modifiers )static boolean isSynchronized ( int modifiers )static boolean isVolatile( int modifiers ) AccessibleObject类用于设置反射对象的可访问标志，会破坏对象的封装 123456//为反射对象设置可访问标志.flag为 true 表明屏蔽 Java 语言的访问检查， 使得对象的私有属性也可以被査询和设置void setAccessible ( boolean flag )//返回反射对象的可访问标志的值boolean isAccessible ( ) //是一种设置对象数组可访问标志的快捷方法static void setAccessible ( AccessibleObject [ ] array , boolean flag ) 反射示例工厂模式的优化以简单工厂为基础，通过传入类名来创建子类实例（或者结合配置文件，达到更进一步的优化） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 抽象产品abstract class Product&#123; public abstract void show();&#125;//具体产品实现类public class ProductA extends Product&#123; @Override public void show() &#123; System.out.println("生产出了产品A"); &#125;&#125;public class ProductB extends Product&#123; @Override public void show() &#123; System.out.println("生产出了产品B"); &#125;&#125;//静态工厂public class Factory &#123; // 定义方法：通过反射动态创建产品类实例 public static Product getInstance(String ClassName) &#123; Product concreteProduct = null; try &#123; // 1. 根据 传入的产品类名 获取 产品类类型的Class对象 Class product_Class = Class.forName(ClassName); // 2. 通过Class对象动态创建该产品类的实例 concreteProduct = (Product) product_Class.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 3. 返回该产品类实例 return concreteProduct; &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) throws Exception &#123; // 1. 通过调用工厂类的静态方法（反射原理），从而动态创建产品类实例 // 需传入完整的类名 &amp; 包名 Product concreteProduct = Factory.getInstance("scut.carson_ho.reflection_factory.ProductA"); // 2. 调用该产品类对象的方法，从而生产产品 concreteProduct.show(); &#125;&#125; 使用反射实现动态代理详细查看《设计模式》代理模式一节 接口 接口方法都是public,可以不写。但是实现接口的时候必须写（实现类不写是default） 接口特性 接口的特性如下 无法实例化 能声明接口的变量，可以包含常量（共享，因为是public static final），不能包含实例域和静态方法(java 8.0后可以添加静态方法)，但可以提供默认方法 可以使用 instanceof 检查类是否属于某个特定的接口 接口可以继承接口 接口方法自动设置为public abstract,接口域自动设置为public static final 默认方法 可以为接口方法提供一个默认方法,使用default 修饰符标记 123public interface Comparable&lt;T&gt;&#123; default int compareTo(T other)&#123;return 0;&#125;&#125; 应用一12345678//把所有方法都设置为默认，程序员只需覆盖关心的方法即可public interface Demo()&#123; default void method1()&#123;&#125; default void method2()&#123;&#125; default void method3()&#123;&#125; default void method4()&#123;&#125; default void method5()&#123;&#125;&#125; 应用二：接口演化 假设我们现在有一个接口 A, Mas是其的一个实现类 12public interface A&#123;...&#125;publiic Class Max implements A&#123;...&#125; 后来，我们为A添加了一个新方法 newMethod 123public interface A&#123; void newMethod()&#123;&#125;&#125; 可能会出现以下情况 Mas类编译将会失败（没有重写newMethod） 不重新编译Mas类，在Mas调用newMethod时抛出AbstractMethodError 如果变为defalut方法，以上两个问题都会解决 Mas成功编译 不重新编译Mas,调用时会向上调用A接口的newMethod 解决默认方法冲突情况一：接口与父类冲突 父类优先 如接口定义了默认方法getName(),而父类中也定义了getName()方法，默认方法被忽略 情况二：接口与接口冲突： 手动覆盖。如接口A、Ｂ同时定义了默认的getName()方法，必需覆盖解决冲突。也可以在类中选择二者其一 12345Class Choose implements A,B&#123; public String getName()&#123; return A.super.getName(); &#125;&#125; 情况三：非默认 如果接口Ａ、Ｂ的方法是非默认方法，无论是否另一个有同名默认方法，必需重写 异常Error/Exception 异常对象都是派生于 Throwable 类的一个实例,但在下一层立即分解为两个分支 : Error 和 Exception Error Java 运行时系统的内部错误和资源耗尽错误。 Exception 真正需要关心的异常，分解为两个分支 : RuntimeException :程序错误导致的异常属于 RuntimeException，可能包含情况如下 a. 错误的类型转换 b. 数组访问越界 c. 访问到null指针 其他异常 :也可以说是受查异常，程序本身没有问题,但由于像I/O错误这类问题导致的异常属于其他异常（IOException）,可能包含情况如下a. 试图在文件尾部后面读取数据 b. 试图打开一个不存在的文件 c. 试图根据给定的字符串查找 Class 对象, 而这个字符串表示的类并不存在 受查异常和非受查异常 非受查异常: 派生于Error类或RuntimeException类的所有异常 受查异常：除了非受查异常其他的异常，必须抛出或者捕获处理 声明受查异常（throws） 受查异常需要在方法首部声明所有可能抛出的异常(通过关键字throws) 如下是Java类库中的一个类的构造器方法的声明1public FilelnputStream ( String name ) throws FileNotFoundException 子类异常和父类异常 在子类中覆盖了父类的一个方法 ，子类方法中声明的受查异常有以下约束 不能比父类方法中声明的异常更通用(子类方法中可以抛出更特定的异常, 或者根本不抛出任何异常) 父类类方法没有抛出任何受查异常, 子类也不能抛出任何受查异常 抛出异常(throw)throw用于主动抛出异常，而throws用于声明异常，并不一定真的抛出。 1throw EOFException();//执行到语句，说明这段代码的功能也就到这里了 再次抛出异常与异常链 在catch中抛出异常,目的是为了改变异常类型 方式一：123456try&#123;access the database&#125;catch ( SQLException e )&#123; throw new ServletException (" database error: " + e.getMessage());&#125; 方式二：更好的处理，并将原始异常设置成新异常的原因（推荐） 123456789101112131415//Throwable.initCause(Throwable cause) : 将Throwable的cause初始化为指定的值（不能是它本身） //Throwable.getCause():获取cause值try&#123; ...&#125;catch ( SQLException e )&#123; Throwable se = new ServletException("database error"); // Throwable.initCause(Throwable cause) se.initCause(e); throw se;&#125;// 获取原始异常Throwable.getCause() Throwabl e = se.getCasue(); 捕获异常(try/catch)块1234567891011121314151617try&#123; ...&#125;catch ( FileNotFoundException e )&#123; ...&#125;catch ( UnknownHostException e )&#123; ...&#125;catch ( IOException e )&#123; ...&#125;// catch 也可以进行合并（此时的异常变量e 变为 final 变量。即不能为e赋值不同的值）catch ( FileNotFoundException | nknownHostException e )&#123; ...&#125; finally子句 可以这样使用,有异常抛出就直接执行finally中的语句 12345try&#123;&#125;finally&#123;&#125; finally 中包含return,会覆盖原始方法中的return值 123456789//执行f(2),将会返回0public static int f (int n )&#123; try&#123; int r = n * n; return r; &#125;finally&#123; if ( n == 2) return 0 ; &#125;&#125; finally抛出异常带来的麻烦假设在try中抛出了一些非IOException, 而finally中的closed()方法也有可能抛出异常，这时，原始异常丢失，抛出closed方法的异常 12345 try&#123; ...&#125;finally&#123; in.closed();&#125; 解决也十分繁琐 12345678910111213141516InputStream in = ...;Exception ex = null ;try&#123; try&#123; code that might throw exceptions &#125;catch (Exception e)&#123; ex = e; throw e; &#125;&#125;finally&#123; try&#123; in.closed(); &#125;catch(Exception e)&#123; if(ex == null) throw e; &#125;&#125; 更好的解决办法: Java SE 7 新增的资源关闭处理. 带资源的try语句(Java SE 7) 当try块退出时，自动执行res.closed()。 对于colosed()可能抛出的异常，原来的异常会被抛出，而closed()异常会被自动捕获,并由Throwable.addSuppressed()添加到原来的异常中。（可以使用Throwableget.Suppressed()获取。） 123try (Resource res = ...；Ｒesource res2 = ...)&#123; ...&#125; 自定义异常 继承Exception 或其子类 ,一般异常有两个构造函数： 一个无参构造器 一个记录详细描述信息(超类Throwable.toString可以打印这些信息) 123456public MyExcpetion extends IOexception&#123; public MyExcpetion()&#123;&#125; public MyExcpetion(String message)&#123; super(message) &#125;&#125; Throwable 定义的方法 Exception类自己没有定义任何方法。,它继承了Throwable提供的一些方法 方法 描述 Throwable fillInStackTrace( ) 返回一个包含完整堆栈轨迹的Throwable对象,该对象可能被再次引发 String getLocalizedMessage( ) 返回一个异常的局部描述 String getMessage( ) 返回一个异常的描述 void printStackTrace( ) 显示堆栈轨迹 void printStackTrace(PrintStreamstream) 把堆栈轨迹送到指定的流 void printStackTrace(PrintWriterstream) 把堆栈轨迹送到指定的流 String toString( ) 返回一个包含异常描述的String对象。当输出一个Throwable对象时,该方法被println( )调用 Java的内置异常 Java 的 java.lang 中定义的非受查异常子类: 异常 说明 ArithmeticException 算术错误,如被0除 ArrayIndexOutOfBoundsException 数组下标出界 ArrayStoreException 数组元素赋值类型不兼容 ClassCastException 非法强制转换类型 IllegalArgumentException 调用方法的参数非法 IllegalMonitorStateException 非法监控操作,如等待一个未锁定线程 IllegalStateException 环境或应用状态不正确 IllegalThreadStateException 请求操作与当前线程状态不兼容 IndexOutOfBoundsException 某些类型索引越界 NullPointerException 非法使用空引用 NumberFormatException 字符串到数字格式非法转换 SecurityException 试图违反安全性 StringIndexOutOfBounds 试图在字符串边界之外索引 UnsupportedOperationException 遇到不支持的操作 java.lang 中定义的受查异常: 异常 说明 ClassNotFoundException 找不到类 CloneNotSupportedException 试图克隆一个不能实现Cloneable接口的对象 IllegalAccessException 对一个类的访问被拒绝 InstantiationException 试图创建一个抽象类或者抽象接口的对象 InterruptedException 一个线程被另一个线程中断 NoSuchFieldException 请求的字段不存在 NoSuchMethodException 请求的方法不存在 使用异常机制技巧 技巧如下 异常处理不能代替简单的测试 不要过分地细化异常 利用异常层次结构 不要只抛出 RuntimeException 异常 。 应该寻找更加适当的子类或创建自己的异常类 。 不要只捕获 Thowable 异常 不要压制异常 在检测错误时, “ 苛刻 ” 要比放任更好 在用无效的参数调用一个方法时 , 返回一个虚拟的数值, 还是抛出一个异常 , 哪种处理方式更好 如,当栈空时, Stack.pop() 是返回一个 null , 还是抛出一个异常? 在出错的地方抛出一个 EmptyStackException异常要比在后面抛出一g个NullPointerException 异常更好 不要羞于传递异常 建议解耦try/catch和try/finally 如下：12345678910InputStrean in = ...;try&#123; try&#123; ... &#125;finally&#123; in.closed(); &#125;&#125;catch(IOExcpetion o)&#123; ...&#125; 好处： 内层try/finally只有一个职责，确保关闭流 外层try/catch也只有一个职责，报告异常 这样设计不仅清楚，还能报告finally中的异常 lambda表达式 lambda表达式：可传递的代码块 12(param [, param, ...]) -&gt; &#123;表达式&#125; Lambda表达式省略 没有参数时：123()-&gt; &#123; ...&#125; 可以推导出参数类型时，可省略参数类型123(first, second)-&gt;&#123; first.length() - second.length()&#125; 只有一个参数，且可以推导类型，可省略 ()12event -&gt; System.out.print("This time is" + new Date()) 函数式接口 函数式接口 只有一个抽象方法的接口,需要这种接口的对象时，可以提供lambda表达式 函数式接口还可以定义Object的方法，即equals属于Object方法，所以Comparator属于函数式接口 1234567891011//如 Arrays.sort()这个方法，它的第二个参数是一个Comparator接口,Comparator接口就是一个函数式接口Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) ​```java@FunctionalInterface //表明其为函数式接口public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); //equals属于object方法 boolean equals(Object obj); ...&#125; 实例：123//在底层，Arrays.sort接受的是Comparator&lt; String &gt;这个对象,在这个对象调用compare方法时会执行lambda表达式。Arrays.sort(words, (first, second)-&gt;first.length() - second.length()); 函数式接口设计： 设计一个接口，其中只有一个抽象方法 可以用 @ FunctionalInterface 注解来标记这个接口，有两点好处 a. 如果不小心添加了一个抽象方法，编译器会产生错误消息 b. javadoc会指出该接口是函数接口 方法引用所谓的方法引用，即将现成的方法传递到其他代码中 12345Timer t = new Timer(1000, event -&gt; System.out.println(event));//可以直接将println方法传递到Timer构造器//System.out::println等同于 x -&gt; System.out.println(x)Timer t = new Timer(1000,System.out::println); 对于使用 :: ，一共有三种情况 1234567object::instanceMethodClass::staticMethod// 前2种情况中,方法引用等价于提供方法参数的lambda 表达式//如 Math::pow等价于(x,y)-&gt;Math.pow(x,y)) Class::instanceMethod//第3种情况，第1个参数会成为方法的目标 //如(String::compareTolgnoreCase等价于(x,y)-&gt;x.compareTOlgnoreCase(y)) 如果出现重载方法。则通过方法参数选择版本（如Math.max有两个版本，一个用于整数，一个用于double。选择哪一个版本取决于Math::max转换成哪一个函数式接口的方法参数） 可以在方法中引用this和super123this::equals//等同于x -&gt; this.equals(x) 构造器引用 构造器引用： 类似于方法引用，但方法名为new(可以理解为特殊的方法引用)，调用的构造器取决于上下文 123int[]::new //等价于x -&gt; new int[x] lambda变量作用域12345678910// ActionListener 是一个函数是接口，所以lambda表达式可以赋值给它pubic static void repeatMessage(String text, int delay)&#123; ActionListener aListener = event -&gt;&#123; System.out.println(text); &#125; new Timer(delay, aListener).start();&#125;//调用repeatMessage("hello", 1000);//print hello 如上代码，lambda表达式使用了外部的变量text,而真正执行lambda，可能要等到定时器运行为止，此时：text变量可能已经不存在了。 lambda是如何保存变量的,首先看lambda表达式的组成 一个代码块 参数 自有变量（即非参数且不在代码块中定义的，这里就是text） (自有变量的值，可以被lambda表达式捕获。具体细节为：lambda表达式最终会变为一个包含方法的实例对象，而自由变量的值会复制到这个对象的实例变量中) lambda捕获的限制限制一 不能在lambda表达式中改变捕获的自由变量的值 1234567public void static countDonw(int start, int end)&#123; ActionListener aListener = event -&gt;&#123; start--; System.out.println(start);//Error，不能改变捕获的变量 &#125; new Timer(delay, aListener).start();&#125; 限制二 不能捕获一个改变的变量 1234567public void static repeat(String text, int count)&#123; for(int i = 0; i &lt;= count; i++)&#123; ActionListener aListener = event -&gt;&#123; System.out.println(i);//Error，不能引用一个改变的变量 &#125; &#125;&#125; 在lambda中使用this 在一个 lambda 表达式中使用 this 关键字时, 是指创建这个 lambda 表达式的方法的 this参数 12345678public class Application()&#123; public void init()&#123; ACtionListener aLinstener = event -&gt; &#123; //调用的toString 会是Application的toString方法 System.out.println(this.toString); &#125; &#125;&#125; 处理Lambda表达式使用 lambda 表达式的重点是延迟执行,如果想耍立即执行代码 , 完全可以直接执行 , 而无需把它包装在一个lambda 表达式中 需要延迟执行的情况 在一个单独的线程中运行代码 多次运行代码 在算法的适当位置运行代码 (例如,排序中的比较操作） 发生某种情况时执行代码 (如,点击了一个按钮,数据到达,等等;） 只在必要时才运行代码 。 例：重复n遍动作 123456// Runnable是一个JAVA Api中提供的接口public static void repeat(int n, Runnable action)&#123; for(int i = 0; i &lt; n; i++) action.run();&#125;//当执行action.run()时，就会执行lambda主体repeat(10, () -&gt; System.out.println("Hellp world")); 泛型泛型类类型变量使用大写形式，在Java中 E表示集合的元素类型 K和V表示关键字与值类型 T(需要时还可以使用临近字母U,S)表示任意类型 123public class MyCLass&lt;T,U&gt;&#123; ...&#125; 泛型方法写法1： 12345//类型变量放在修饰符后面，返回值前面//可以在调用方法时指定Ｔ的类型，如MyClass.&lt;String&gt; get()，获取的返回值就是String类 public static &lt;T&gt; T get(T... a)&#123;...&#125; 写法2： 1234//只能使用普通的MyClass.get()，根据ＭyClass&lt;T&gt;类型变量决定public T get(T... a()&#123;&#125; 类型变量限定Ｔ本身可以是任何类型，但可以通过实现extends关键字来限制Ｔ 123456//限制T 类型必须实现Comparable接口public static &lt;T extends Comparable&gt; T min(T[] a)&#123; ...&#125;//多个限定，使用 &amp; 来分隔限定类型,使用 "," 来分隔类型变量&lt;T extends Comparable &amp; Serializable, U&gt; 注意: ​ 即使是限制接口，也是使用extends，而不是implement。T extends Comparable应理解为是Comparable的子类型，而不是实现或者继承Comparable 泛型与虚拟机类型擦除虚拟机只有普通类，没有泛型类这个概念。在虚拟机中，泛型类都会被还原成一个原始类型 翻译泛型类没有限定类型的泛型类替换方式 123456789public class Pair&lt;T&gt;&#123; private T first; ...&#125;//类型擦除后,T没有限定类型，会被替换成 Objectpublic class pair&#123; private Object first; ....&#125; 有限定类型的话的替换方式 123456789101112131415public class pair&lt;T extends Comparable &amp; Serializable&gt;&#123; private T first; ...&#125; //擦除后,会替换为第一个限定类型public class pair&#123; private Comparable first; ....&#125;//如果是 &lt;T extends Serializable&amp; Comparable&gt;public class pair&#123; private Serializable first; ....&#125; 翻译泛型泛型方法123public static &lt;T extends Comparable &gt; T min ( T[] a )//擦除类型后public static Comparable min(Comparable[] a) 翻译泛型表达式 第一步：对原始getFirst()的调用((T 擦除后替换成Object，方法返回Object)) 第二步：将Object强制转换为Employee 123456789101112//泛型类public class Pair&lt;T&gt;&#123; private T first; public Pair(T first)&#123; this.first = first; &#125; public &lt;T&gt; T getFirst()&#123;return first&#125;&#125;//泛型表达式Pair&lt;Employee&gt; buddies = ...;Employee buddy = buddies.getFirst(); 即getFirst()方法会变成 1234567//执行Employee buddy = buddies.getFirst();//第一步：get方法擦除public Object getFirst()&#123; return first;&#125;//第二步：再进行强转(Employee)buddies.getFirst(); 桥方法如下代码所示 12345678910111213141516171819202122class QHSchool extends School&lt;Student&gt;&#123; public void setStudent(Student son)&#123; System.out.println("QHSchool.setStudent"); &#125;&#125;class School&lt;T&gt;&#123; public void setStudent(T t)&#123; System.out.println("School.setStudent"); &#125;&#125;class Test&#123; public static void main(String[] args) &#123; Student student = new Student(); School&lt;Student&gt; school = new QHSchool(); school.setStudent(student); //print QHSchool.setStudent &#125;&#125; QHSchool和School经过类型擦除后，会有两个setStudent()方法,显然它们属于不同方法，而代码的本意，是想用QHSchool的方法覆盖掉父类的方法 12setStudent(Student son);setStudent(Object j); 但从结果来看，虚拟机正确的挑选了合适的方法,这其中便是桥方法的功劳，JVM会自动创建一个桥方法加入到子类方法中，用以覆盖了父类的方法，并调用子类的方法 123public void setStudent(Object object)&#123; setStudent((Student)object);&#125; 可以通过javap -c指令进行查看QHSchool,显示结果如下，很明显，该类中多出了一个方法，另一个方法即为桥方法 123456789101112131415 public void setStudent(Student); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String QHSchool.setStudent 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return public void setStudent(java.lang.Object); Code: 0: aload_0 1: aload_1 2: checkcast #5 // class Student 5: invokevirtual #6 // Method setStudent:(LStudent;)V 8: return&#125; 桥方法另一个知识点,桥方法带来的方法冲突 12345public Student getStudent()//QHSchoolpublic T getStudent()//School//擦除后,显然两个方法冲突public Student getStudent()//QHSchoolpublic Object getStudent()//School 通过javap -c命令查看，确实存在两个getStudent() 12345678910public Student getStudent(); Code: 0: aconst_null 1: areturnpublic java.lang.Object getStudent(); Code: 0: aload_0 1: invokevirtual #5 // Method getStudent:()LStudent; 4: areturn 然而，这并没有问题。虽然对于代码级别，虚拟机是通过方法名和参数来判断一个方法是否冲突。但对于虚拟机创建的桥方法来说，可以通过返回值类型进行判断（详细看《JVM》 重载 小节） 擦除后的冲突如下代码 123public class School&lt;T&gt;&#123; public boolean equals(T value)&#123;...&#125;&#125; 擦除后，由两个相同的方法，从而引发冲突 1234public class School&lt;T&gt;&#123; public boolean equals(Object value)&#123;...&#125; //School定义的 public boolean equals(Object value)&#123;...&#125; //Object继承的&#125; 解决办法：重新命名引发错误的方法 泛型约束于局限性泛型不能使用基本类型,需要使用包装器12School&lt;int&gt; //错误School&lt;Integer&gt;//正确 泛型不适用于类型查询如果试图查询一个对象是否属于某个泛型类型时， 使用 instanceof 会得到一个编译器错误 ， 如果使用强制类型转换会得到一个警告，也就是说，所有的类型查询只基于原始类型 123if(a instanceof School&lt;Student&gt;) // 错误School&lt;Student&gt; s = (School&lt;Student&gt;) a;// 警告 不能创建参数化类型的数组12//注意是不能创建，School&lt;Student&gt;[] ss是合法的School&lt;Student&gt;[] ss = new School&lt;Student&gt;[10];//错误 如果真要收集参数化类型对象，应该使用集合 1ArrayList&lt;School&lt;Student&gt;&gt; Varargs警告如果向一个参数可变的方法传递泛型类型的实例会得到警告 12345678public static &lt;T&gt; void addAll(T...ts);School&lt;Student&gt; s1 = ...;School&lt;Student&gt; s2 = ...;School&lt;Student&gt; s3 = ...;//调用方法时，虚拟机创建了一个School&lt;Student&gt;数组，违反了泛型不能创建参数化类型的数组，但不会报错，只是会警告addAll(s1, s2, s3); 对于警告，可以使用以下两种注解其中之一进行抑制 123@SuppressWarnings("unchecked")@SafeVaags 不能实例化类型变量123new T()// 错误new T[]// 错误T.class// 错误 不能再静态域或静态方法中使用类型变量12private static T singleInstance;//错误public static T getSingleInstance();//错误 泛型类不能继承异常，也不能被捕获123public class Problem&lt;T&gt; extends Excpetion&#123;&#125;// 错误，不能继承 catch( T t)//错误，不能捕获 但是，以下是合法的 12345678public static &lt;T extends Throwable &gt; void doWork(T t) throws T &#123;//正确 try&#123; &#125;catch(Throwable realCause)&#123; t.initCause(realCause); throw t; //正确 &#125;&#125; 泛型类型继承规则泛型之间可以继承, 1ArrayList&lt; T&gt; implements List&lt;T&gt; //ok 类型相同但泛型参数不同的两个类不是同一个类 1234List&lt;Student&gt;// 两个是不同的子类ArrayList&lt; Student&gt; // 可以转换成List&lt;Student&gt;ArrayList&lt; Teacher&gt; //不可以转换成List&lt;Student&gt; 通配符类型语法： 12345//表示MyClass，它的类型参数是SomeClass的子类MyClass &lt; ? extends SomeClass &gt;//如ClassA和ClassB都是SomeClass的子类,以下两个都是合法的MyClass&lt;ClassA&gt;MyClass&lt;ClassB&gt; 通配符的超类型限定通配符可以指定一个超类型限定 （ supertypebound ) ，语法如下 1234//限制该类必须是SomeClass的超类MyClass &lt; ? super ClassA &gt;//如，SomeClass是ClassA的超类，则以下方式合法MyClass&lt;SomeClass&gt; 集合Java中提供的集合接口 接口 描述 Collection 能使你操作对象组，它位于类集层次结构的顶层 List 扩展Collection去处理序列（对象的列表） Set 扩展Collection去处理集合，集合必须包含唯一元素 SortedSet 扩展Set去处理排序集合 其他相关的集合接口 接口 描述 Comparator 定义了两个对象如何比较 Iterator 枚举类集中的对象 ListIterator 扩展Iterator，允许双向遍历列表，并可以修改单元 Java为开发者提供的抽象类 抽象类 描述 AbstractCollection 实现大多数Collection接口 AbstractList 扩展AbstractCollection并实现大多数List接口 AbstractSequentialList 为了被类集使用而扩展AbstractList，该类集使用连续而不是随机方式访问其元素 AbstractMap 实现大多数的Map接口 通配符类型 Collection接口Collection接口是构造类集框架的基础。它声明所有类集都将拥有的核心方法 方法 描述 boolean add(Object obj) 将obj加入到调用类集中。如果obj被加入到类集中了，则返回true；如果obj已经是类集中的一个成员或类集不能被复制时，则返回false boolean addAll(Collection c) 将c中的所有元素都加入到调用类集中，如果操作成功（也就是说元素被加入了），则返回true；否则返回false void clear( ) 从调用类集中删除所有元素 boolean contains(Object obj) 如果obj是调用类集的一个元素，则返回true，否则，返回false boolean containsAll(Collection c) 如果调用类集包含了c中的所有元素，则返回true；否则，返回false boolean equals(Object obj) 如果调用类集与obj相等，则返回true；否则返回false int hashCode( ) 返回调用类集的散列码 boolean isEmpty( ) 如果调用类集是空的，则返回true；否则返回false Iterator iterator( ) 返回调用类集的迭代程序 Boolean remove(Object obj) 从调用类集中删除obj的一个实例。如果这个元素被删除了，则返回true；否则返回false Boolean removeAll(Collection c) 从调用类集中删除c的所有元素。如果类集被改变了（也就是说元素被删除了），则返回true；否则返回false Boolean retainAll(Collection c) 删除调用类集中除了包含在c中的元素之外的全部元素。如果类集被改变了（也就是说元素被删除了），则返回true，否则返回false int size( ) 返回调用类集中元素的个数 Object[ ] toArray( ) 返回一个数组，该数组包含了所有存储在调用类集中的元素。数组元素是类集元素的拷贝 Object[ ] toArray(Object array[ ]) 返回一个数组，该数组仅仅包含了那些类型与数组元素类型匹配的类集元素。数组元素是类集元素的拷贝。如果array的大小与匹配元素的个数相等，它们被返回到array。如果array的大小比匹配元素的个数小，将分配并返回一个所需大小的新数组，如果array的大小比匹配元素的个数大，在数组中，在类集元素之后的单元被置为null。如果任一类集元素的 类 型 都 不 是 array 的 子 类 型 ， 则 引 发 一 个ArrayStoreException异常 List接口List接口扩展了Collection,使用一个基于零的下标，元素可以通过它们在列表中的位置被插入和访问。 方法 描述 void add(int index, Object obj) 将obj插入调用列表，插入位置的下标由index传递。任何已存在的，在插入点以及插入点之后的元素将前移。因此，没有元素被覆盖 boolean addAll(int index, Collection c) 将c中的所有元素插入到调用列表中，插入点的下标由index传递。在插入点以及插入点之后的元素将前移。因此，没有元素被覆盖。如果调用列表改变了，则返回true；否则返回false Object get(int index) 返回存储在调用类集内指定下标处的对象 int indexOf(Object obj) 返回调用列表中obj的第一个实例的下标。如果obj不是列表中的元素，则返回-1 int lastIndexOf(Object obj) 返回调用列表中obj的最后一个实例的下标。如果obj不是列表中的元素，则返回-1 ListIterator listIterator( ) 返回调用列表开始的迭代程序 ListIterator listIterator(int index) 返回调用列表在指定下标处开始的迭代程序 Object remove(int index) 删除调用列表中index位置的元素并返回删除的元素。删除后，列表被压缩。也就是说，被删除元素后面的元素的下标减一 Object set(int index, Object obj) 用obj对调用列表内由index指定的位置进行赋值 List subList(int start, int end) 返回一个列表，该列表包括了调用列表中从start到end–1的元素。返回列表中的元素也被调用对象引用 ArrayList类ArrayList类 扩展于AbstractList，支持可随需要而增长的动态数组 优点：支持对元素的快速随机访问 缺点：插入、删除元素代价高 构造函数 123ArrayList( )ArrayList(Collection c)ArrayList(int capacity) LinkedList类LinkedList类 扩展于AbstractSequentialList,提供了一个链接列表数据结构 LinkedList实现的是双向列表 优点：适合数据的动态插入和删除 缺点：随机访问和遍历速度慢 构造函数 12LinkedList( )LinkedList(Collection c) 列表操作 123456789101112//在列表头添加元素void addFirst(Object obj)//在列表尾添加元素 void addLast(Object obj)//获取Object getFirst( )Object getLast( )//删除Object removeFirst( )Object removeLast( ) Set接口Set接口类似与Connection,但是对方法的行为更为严谨。容器不能添加重复元素，需要定义equals*()方法和hashCode()方法 SortedSet接口SortedSet接口扩展了Set并说明了按升序排列的集合的特性 方法 描述 Comparator comparator( ) 返回调用被排序集合的比较函数，如果对该集合使用自然顺序，则返回null Object first( ) 返回调用被排序集合的第一个元素 SortedSet headSet(Object end) 返回一个包含那些小于end的元素的SortedSet，那些元素包含在调用被排序集合中。返回被排序集合中的元素也被调用被排序集合所引用 Object last( ) 返回调用被排序集合的最后一个元素 SortedSet subSet(Object start, Object end) 返回一个SortedSet，它包括了从start到end–1的元素。返回类集中的元素也被调用对象所引用 SortedSet tailSet(Object start) 返回一个SortedSet，它包含了那些包含在分类集合中的大于等于start的元素。返回集合中的元素也被调用对象所引用 HashSet类HashSet 扩展于AbstractSet,使用散列表(Hash表)进行存储 两值相等判断：首先判断两个元素的哈希值，再比较equals()方法 相同的哈希值元素存放在一个哈希桶中 构造函数 12345HashSet( )HashSet(Collection c)HashSet(int capacity)//fillRatio : 负载因子,默认0.75,值在0.0~1.0之间HashSet(int capacity, float fillRatio) TreeSet类TreeSet 扩展于AbstractSet，使用树来进行存储，对象按升序存储 每次添加对象都会进行排序 a. Integer和String对象：可进行默认的TreeSet排序 b. 自定义对象：需要自定义对象实现Comparable接口，并重写compareTo()函数(返回负整数、零、整数代表小于、等于、大于) 构造函数 1234TreeSet( )TreeSet(Collection c)TreeSet(Comparator comp)TreeSet(SortedSet ss) Iterator接口 方法 描述 boolean hasNext( ) 如果存在更多的元素，则返回true，否则返回false Object next( ) 返回下一个元素。如果没有下一个元素，则引发NoSuchElementException异常 void remove( ) 删除当前元素，如果试图在调用next( )方法之后，调用remove( )方法，则引发IllegalStateException异常 ListIterator接口ListIterator接口扩展Iterator，允许双向遍历列表，并可以修改单元 方法 描述 void add(Object obj) 将obj插入列表中的一个元素之前，该元素在下一次调用next( )方法时，被返回 boolean hasNext( ) 如果存在下一个元素，则返回true；否则返回false boolean hasPrevious( ) 如果存在前一个元素，则返回true；否则返回false Object next( ) 返回下一个元素，如果不存在下一个元素，则引发一个NoSuchElementException异常 int nextIndex( ) 返回下一个元素的下标，如果不存在下一个元素，则返回列表的大小 Object previous( ) 返回前一个元素，如果前一个元素不存在，则引发一个NoSuchElementException异常 int previousIndex( ) 返回前一个元素的下标，如果前一个元素不存在，则返回-1 void remove( ) 从列表中删除当前元素。如果remove( )方法在next( )方法或previous( )方法调用之前被调用，则引发一个IllegalStateException异常 void set(Object obj) 将obj赋给当前元素。这是上一次调用next( )方法或previous( )方法最后返回的元素 使用迭代器遍历一个元素，可以使用迭代器来完成,有两种使用方式 通过hasnext()和next()方法进行遍历 通过for-earch循环来完成 1234567891011Collection&lt;String&gt; aCollection = ...;Iterator&lt;String&gt; iter = aCollection.iterator();// 遍历迭代器，逐个访问元素while(iter.hasnext())&#123; String element = iter.next(); //do something with element&#125;// 使用for-each循环遍历for(String element : aCollection)&#123; //do something with element&#125; for-each 循环可以与任何实现了 Iterable 接口的对象一起工作，而 Collction 接口扩展了 Iterable 接口，这就意味着所有集合都可以使用 for-each 循环 此外，在Java SE 8,可以通过调用 forEachRemaining() 方法来完成查看所有元素,它将会对迭代器里的每个元素调用lambda表达式，直到没有为止。 1iter.forEachRemaining(element -&gt; do something with element) Map接口Map是一个存储关键字(key)/值(value)对的对象 接口 描述 void clear( ) 从调用映射中删除所有的关键字/值对 boolean containsKey(Object k) 如果调用映射中包含了作为关键字的k，则返回true；否则返回false boolean containsValue(Object v) 如果映射中包含了作为值的v，则返回true；否则返回false Set entrySet( ) 返回包含了映射中的项的集合（Set）。该集合包含了类型Map.Entry的对象。这个方法为调用映射提供了一个集合“视图” Boolean equals(Object obj) 如果obj是一个Map并包含相同的输入，则返回true；否则返回false Object get(Object k) 返回与关键字k相关联的值 int hashCode( ) 返回调用映射的散列码 boolean isEmpty( ) 如果调用映射是空的，则返回true；否则返回false Set keySet( ) 返回一个包含调用映射中关键字的集合（Set）。这个方法为调用映射的关键字提供了一个集合“视图” Object put(Object k, Object v) 将一个输入加入调用映射，覆盖原先与该关键字相关联的值。关键字和值分别为k和v。如果关键字已经不存在了，则返回null；否则，返回原先与关键字相关联的值 void putAll(Map m) 将所有来自m的输入加入调用映射 Object remove(Object k) 删除关键字等于k的输入 int size( ) 返回映射中关键字/值对的个数 Collection values( ) 返回一个包含了映射中的值的类集。这个方法为映射中的值提供了一个类集“视图” SortedMap 接口SortedMap接口扩展了Map，它确保了各项按关键字升序排序 方法 描述 Comparator comparator( ) 返回调用排序映射的比较函数。如果调用映射使用的是自然顺序的话，则返回null Object firstKey( ) 返回调用映射的第一个关键字 SortedMap headMap(Object end) 返回一个排序映射，该映射包含了那些关键字小于end的映射输入 Object lastKey( ) 返回调用映射的最后一个关键字 SortedMap subMap(Object start, Object end) 返回一个映射，该映射包含了那些关键字大于等于start同时小于end的输入 SortedMap tailMap(Object start) 返回一个映射，该映射包含了那些关键字大于等于start的输入 Map.Entry 接口Map.Entry描述映射中的元素（关键字/值对）。这是Map的一个内部接口，可以操作映射的输入 方法 描述 boolean equals(Object obj) 如果obj是一个关键字和值都与调用对象相等的Map.Entry，则返回true Object getKey( ) 返回该映射项的关键字 Object getValue( ) 返回该映射项的值 int hashCode( ) 返回该映射项的散列值 Object setValue(Object v) 将这个映射输入的值赋给v。如果v不是映射的正确类型，则引发一个lassCastException 异 常 。 如 果 v 存 在 问 题 ， 则 引 发 一 个IllegalArgumentException异常。如果v是null而映射又不允许null关键字，则引发一个NullPointerException异常。如果映射不能被改变，则引发一个UnsupportedOperationException异常 HashMap 类HashMap类 使用散列表实现Map接口。这允许一些基本操作如get( )和put( )的运行时间保持恒定 构造函数 12345HashMap( )HashMap(Map m)HashMap(int capacity)//fillRatio : 负载因子,默认0.75,值在0.0~1.0之间HashMap(int capacity, float fillRatio) LinkHashMap类LinkHashMap类： HashMap的子类，可以记录插入顺序 使用Iterator遍历LinkedHashMap时，先得到的先插入的元素，也可以在构造函时带参数，按照访问次序排序 参考 1：http://www.importnew.com/28263.html参考 2：http://www.importnew.com/20386.html#comment-648123 TreeMap 类TreeMap实现SortedMap并且扩展AbstractMap。TreeMap提供了按排序顺序存储关键字/值对的有效手段，同时允许快速检索;树映射保证它的元素按照关键字升序排序 构造函数 1234TreeMap( )TreeMap(Comparator comp)TreeMap(Map m)TreeMap(SortedMap sm) Comparator接口构造集合或映射时，可以指定一个Comparator对象，使用不同的方法对元素进行排序。Comparator接口定义了两个方法 12int compare(Object obj1, Object obj2)boolean equals(Object obj) 版本遗留下来的类和接口遗留下来的类都是同步的，jave util 遗留下的类有：Dictionary 、Hashtable、 Properties、 Stack 、Vector、Enumeration Enumeration接口Enumeration接口定义了可以对一个对象的类集中的元素进行枚举（一次获得一个）的方法，被Iterator所替代 Vector与ArrayList相似，但Vector是同步的，该类被重新设计来扩展AbstractList和实现List接口，因此现在它与类集是完全兼容的 构造函数 12345Vector( )Vector(int size)//incr: 扩容时的增量，默认增长一倍Vector(int size, int incr)Vector(Collection c) 成员属性 123int capacityIncrement; //增量值int elementCount; //当前元素的个数Object elementData[ ]; //保存元素的数组 StackStack是Vector的一个子类，它实现标准的后进先出堆栈 HashtableDictionary的一个具体实现，与HashMap相似，但它是同步的 构造函数 1234Hashtable( )Hashtable(int size)Hashtable(int size, float fillRatio)Hashtable(Map m) Properties属性（Properties）是Hashtable的一个子类.用来保持值的列表，在其中关键字和值都是字符串（String） 构造函数 12Properties( )Properties(Properties propDefault) 使用store( )和load( )Properties的一个最有用的方面是可以利用store( )和load( )方法包含在Properties对象中的信息进行存储或从盘中装入信息 123void store(OutputStream streamOut, String description)void load(InputStream streamIn) throws IOException Java复制所谓的java复制，就是将一个对象的引用复制给另一个对象，一共有三种方式 第一种：最常见的，直接赋值 第二种：浅拷贝 第三种：深拷贝 直接赋值复制也就是我们最常用的那种 123//将original的引用复制给了copy,一个改变，另一个也会跟着变化Employee original = new Employee("liisyu", 1000);Employee copy= original; 浅拷贝浅拷贝：它会创建一个新的对象，然后将当前对象的非静态字段复制到新的对象中;根据字段的类型，会有以下两种复制情况 字段是值类型：直接对该字段执行复制 字段是引用类型，只复制引用，但不复制引用的对象 12Employee original = new Employee("liisyu", 1000);Employee copy= original.clone(); 如何实现浅拷贝 实现Cloneable接口,Cloneable只是个标记接口,真正继承的clone()方法来自Object 重写clone()方法,并指定public 访问修饰符(Object类中的clone()方法声明为protected) 1234567891011class Employee implements Cloneable&#123; //在Java SE 1.4 之前clone只返回Object，之后可指定证器返回类型[协变返回类型] public Employee clone() &#123; try &#123; return (Employee)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; //在没有实现Cloneable接口时，会返回CloneNotSupportedException异常 e.printStackTrace(); return null; &#125; &#125;&#125; 深拷贝深拷贝，不仅复制对象本身，同时复制对象包含的引用指向的所有对象 12Employee original = new Employee("liisyu", 1000);Employee copy= original.clone(); 如何实现深拷贝 实现Cloneable接口,Cloneable只是个标记接口,真正继承的clone()方法来自Object 重写clone()方法,并指定public 访问修饰符(Object类中的clone()方法声明为protected) 克隆对象中的引用类型字段 12345678910111213class Employee implements Cloneable&#123; //在Java SE 1.4 之前clone只返回Object，之后可指定证器返回类型[协变返回类型] public Employee clone() &#123; try &#123; Employee copy = (Employee)super.clone(); copy.hireDay = (Date) hireDay.clone();//克隆对象中的引用类型字段 return copy; &#125; catch (CloneNotSupportedException e) &#123; //在没有实现Cloneable接口时，会返回CloneNotSupportedException异常 e.printStackTrace(); return null; &#125; &#125;&#125; 序列化（深拷贝的一种实现）原理：实际上是把对象写到流中，再从流中读取，重建新的对象； Java 流与序列化Java中与流相关的抽象类 InputStream: 字节输入流，字节流 OutputStream: 字节输出流，字节流 Reader：处理Unicode字符的输入流（两字节），字符流 Writer： 处理Unicode字符的输出流（两字节），字符流 InputStreamJDK1.8中的InputStream 子类 FileInputStream：文件的输入流 FilterInputStream：抽象类，用于封装其他输入流，提供更多的功能 ​ a. BufferedInputStream：提供缓冲区功能的输入流 ​ b. DataInputSrtream：提供从底层输入流中读取基本Java类型功能的输入流 ​ c. PushBackInputStream：提供回推缓冲区功能的输入流 SequenceInputStream：合并输入流，将多个输入流合并成一个流对象 ObjectInputStream：用于读取对象的输入流，与对象序列化相关 PipedInputStream：用于多线程中的管道输入流 ByteArrayInputStream：字节数组的输入流，在内存中会创建一个字节数组缓冲区 InputStream 结构 InputStream 方法介绍 方法 描述 abstract int read() 从数据中读入一个字节，并返回该字节。遇到流的结尾时返回-1 int read(byte[] b) 读入一个字节数组，并返回实际的读入字节数或遇到流的结尾时返回-1。最多读入b.length个字节 int read(byte[]) b, int off , int len) 读入一个字节数组，并返回实际的读入字节数或遇到流的结尾时返回-1。最多读入b.length个字节 off ：第一个读入字节应该被放置的位置 len：读入的字节的最大数量 long skip(long n) 在输入流中跳过n个字节，返回实际跳过的字节数（如果碰到流的结尾，则可能小于n） int available() 返回在不阻塞的情况下可获取的字节数 void close() 关闭这个输入流 void mark(int readlimit) 在输入流中的当前位置打一个标记（非所有流支持）。如果输入流中已经读入多余readlimit个字节，则忽略这个标记 void reset() 返回到最后一个标记，然后对read的调用将重新读入这些字节。如果当前没有任何标记，则这个流不会被重置 boolean markSupported() 判断这个流是否支持打标记 OutputStreamOutputStream子类 FilterOutputStream：抽象类，用于封装其他输出流，提供更多的功能 ​ a. DataOutputSteam：提供将Java基本类型写到底层输出流功能的输出流 ​ b. BufferedInputStream：提供缓冲区功能的输出流 ​ c. PrintStream：提供各种打印数据值表示形式功能的输出流 FileOutputStream：文件的输出流 ByteAarryOutputStream：字节数组的输出流，在内存中会创建一个字节数组缓冲区 ObjectOutputStream：用于写入对象的输出流，与对象序列化相关 PipedOutputStream：用于多线程中的管道输出流 OutputStream结构图 OutputStream方法介绍 方法 描述 abstract void wirte(int n) 写出一个字节的数据 void write(byte[] b) 写出所有字节到数组b中 void write(byte[] b, int off, int len) 写出某个范围的字节到数组b中 off：第一个写出字节在b中的位置 len：写出字节的最大数量 void close() 冲刷并关闭输出流 void flush() 冲刷数据流，即将所有缓冲的数据发送到目的地 ReadRead子类 BufferedReader：为其他字符输入流提供缓冲功能的字符输入流 ​ a. LineNumberReader：跟踪行号的缓冲字符输入流 PipedReader：用于多线程的管道字符输入流 StringReader：源为String字符串的字符输入流 InputStreamReader：用于将字节流转换成字符输入流 ​ a. FileReader：用于将File类型转换成字符输入流 FilterReader：抽象类，用于装饰其他字符输入流 ​ a. PushbackReader：提供回推缓冲区功能的字符输入流 CharArrayReader：用于将字节数组转换成字符输入流，读入的数据保存在数组缓冲区中 Read结构图 Read方法介绍： 与InputStream类似，可查看InputStream的方法介绍 WriterWriter 子类 OutputStreamWriter：用于将字节输出流转换成字符输出流 ​ a. FileWriter：用于将文件转换成字符输出流 StringWriter：在字符串缓冲区收集其输出的字符流，可用于构造字符串 FilterWriter：抽象类，用于装饰其他字符输出流 CharArrayWriter：带字符缓冲区的字符输出流。将数据写入时，缓冲区会自动增长 PipedWriter：用于多线程的 PrintWriter：用于多线程的管道字符输出流 BufferedWriter：提供缓冲区功能的字符输出流 Writer结构 Writer方法介绍：与OutputStream类似，可以查看OutputStream的方法介绍 流附加接口Closeable接口Closeable接口 扩展类java.lang.AutoCloseable接口，所以任何实现该接口的类，都可以使用try-with-resource语句 Closeable接口的close方法之抛出IOException，而AutoCloseable.close()方法抛出任何异常 123456789101112//Closeable接口源码public interface Closeable extends AutoCloseable &#123; //关闭流，可能抛出IOException public void close() throws IOException;&#125;//AutoCloseable接口源码public interface AutoCloseable &#123; //关闭流，可能抛出Exception void close() throws Exception;&#125; Flushable接口123456//Flushable接口源码public interface Flushable &#123; //冲刷流 void flush() throws IOException;&#125; Readable接口12345//Readable源码public interface Readable &#123; //CharBuffer类：表示一个内存中的缓冲区或者一个内存映像的文件 public int read(java.nio.CharBuffer cb) throws IOException;&#125; Appendable接口123456789public interface Appendable &#123; //添加字符序列 Appendable append(CharSequence csq) throws IOException; Appendable append(CharSequence csq, int start, int end) throws IOException; //添加字符 Appendable append(char c) throws IOException;&#125; CharSequence接口：用于描述一个char序列的基本属性 12345678910111213141516171819//CharSequence源码public interface CharSequence &#123; int length(); char charAt(int index); CharSequence subSequence(int start, int end); public String toString(); public default IntStream chars() &#123; ...... &#125; public default IntStream codePoints() &#123; ..... &#125;&#125; Java 序列化对象序列化： 即将任何对象写出到流中，并且可以从流中读回 对象必须要实现Serializable接口 可以用于对象的克隆 序列化对象是以字节数组保存，且只保存它的成员变量。对于静态成员，并不会保存 序列化示例对象 1public class Employee implements Serializable &#123;...&#125; 保存对象 1234567//构造输出流ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("employee.dat"));//创建对象，并将对象序列化写入employee.dat文件中Employee employee = new Employee(1, 23);out.writeObject(employee); 读取对象 123456//构造employee.dat文件的输入流ObjectInputStream in = new ObjectInputStream(new FileInputStream("employee.dat"));// 读取并创建对象Employee employee1 = (Employee) in.readObject();System.out.println(employee.toString()); 阻止序列化在变量声明上加上transient关键字，可以防止该变量被序列化到文件中。在被反序列化后，treansient变量的值会被设为初始值. Java NIOJava NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式 Java NIO 由以下几个核心部分组成： Channels：类似于流，数据可以从Channel读到Buffer中，也可以从Buffer写到Channel Buffers：缓存 Selectors：允许单线程处理多个 Channel Channels（通道）Java NIO的通道类似流，但又有些不同： 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。 通道可以异步地读写。 通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。 Channel的四个最重要的实现 类 描述 FileChannel 从文件中读写数据 DatagramChannel 能通过UDP读写网络中的数据 SocketChannel 能通过TCP读写网络中的数据 ServerSocketChannel 监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel SocketSocket通信连接Socket通信连接相关方法 123456789101112//创建一个未被连接的Socketpublic Socket()// 通过address和端口数来创建Socketpublic Socket(InetAddress address, int port)// 给定地址连接void connect(SocketAddress endpoint)//超时连接public void connect(SocketAddress endpoint, int timeout) throws IOException //判断当前Socket是否已经连接public boolean isConnected() // 判断当前Socket是否关闭public boolean isClosed() 当拦截失败时，会抛出UnkonwnHostException异常（属于IOExcpetion子类），其他问题抛出IOExcpetion异常 通信流的获取当从Socket读取信息时，读操作将会被阻塞直到数据可访问 12345678//java.net.Scoket//获取读取流InputStream getInputStream()//获取输入流OutputStream getOutputStream()//该方法用于设置读请求的阻塞时间public synchronized void setSoTimeout(int timeout) 因特网地址因特网地址由一串数字组成，如192.168.123.1，即IP地址。 想要获取IP地址，Java提供了InetAddress对象。此外，一个主机(host)可以对应多个IP地址。 1234567891011121314//java.net.InetAddress// 静态方法，通过主机名返回InetAddress对象public static InetAddress getByName(String host)// 获取所有主机的IP地址public static InetAddress[] getAllByName(String host)// 获取IP地址字节（注意，字节可能超出范围）public byte[] getAddress()// 获取IP地址的十进制字符串，用原点隔开，如"192.168.123.1"public String getHostAddress()// 获取本地主机的InetAddresspublic static InetAddress getLocalHost（） //返回主机名public String getHostName() 服务器通过ServerSocket来实现一个服务器 12345678//java.net.SercerSocket//创建一个监听port端口的ServerSocketpublic ServerSocket(int port) //等待连接，该方法会阻塞当前线程直到与客户端建立连接，并返回一个Socket对象 public Socket accept()//关闭 public void close() 半关闭半关闭：Socket连接的一端可以终止其输出，但可以接受来自另一端的数据 12345678910//java.net.Socket//将输入流设置为流结束，即关闭输入流public void shutdownInput()//将输出流设置为流结束，即关闭输出流public void shutdownOutput()//判断输出流是否关闭 public boolean isOutputShutdown() //判断输入流是否关闭 public boolean isInputShutdown() 可中断的Socket考虑一种情况，当连接到Socket时，会对当前线程发生阻塞，如果不设置超时，那么当前线程会因为Socket无法响应而一直发生阻塞，且无法解除阻塞。 java.nio包提供了ScoketChannel类，该类可以实现Socket的中断 todo 获取WEB参数URI、URN、URL在Java中队URI和URL有了明显的区分 URI：用于解析 URL：用于打开一个资源 1234//java.net.URL//打开一个用于读取资源数据的输入流public final InputStream openStream() 解析相对URL 1234567//URI1:http://www.liisyu.com/api/java/net/demo.html//URI2:../../java/net/demo.html#Scoket() //解析相对URL后http://www.liisyu.com/api/java/net/demo.html#Scoket() 相对化 123456//URI1:http://www.liisyu.com/api/java/net/demo.html//URI2:http://www.liisyu.com/api//相对化后java/net/demo.html 从WEB服务器中读取数据URLConnection类用于获取WEB资源信息，操作时必须按如下步骤进行 获取URLConnection：使用url.openConnection()方法获取 设置请求属性：如setDoInput()、setDoOutput()等方法 连接远程资源：调用connect()方法 建立连接后，可以查询头信息：如getContentType()、getHeaderFildKey()等 访问资源数据：使用getInputStream方法获取输入流（该流域RUL类中openStream()返回的流相同） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//java.net.URL//返回一个URLConnectionpublic URLConnection openConnection() //java.net.URLConnection //设置doInput，如果设置为true，则用户可以接受来自该URLConnection的输入 public void setDoInput(boolean doinput) public boolean getDoInput() //ifmodifiedsince属性：用于配置URLConnection对象，使其只获取自从某个时间依赖被修改的数据，从格林尼治时间开始计算 public void setIfModifiedSince(long ifmodifiedsince) public long getIfModifiedSince() //useCaches为true，数据可以从本地缓存中得到。（缓存由浏览器之类的外部程序提供） public void setUseCaches(boolean usecaches) public boolean getUseCaches() //allowuserinteraction为true，则可以查询用户口令。（查询由浏览器或浏览器插件之类的外部程序实现） public void setAllowUserInteraction(boolean allowuserinteraction) public boolean getAllowUserInteraction() // timeout：读取数据超时时限（单位：毫秒），超时时抛出SocketTimeoutExcpetion public int getConnectTimeout() public void setConnectTimeout(int timeout) //设置请求头的一个字段public void setRequestProperty(String key, String value) //返回请求头属性的一个映射表 public Map&lt;String,List&lt;String&gt;&gt; getRequestProperties()//描述:连接远程资源并获取响应头信息 abstract public void connect() //返回响应的一个映射表public Map&lt;String,List&lt;String&gt;&gt; getHeaderFields() //得到响应头第n个字段的键。n等于0或大于响应头字段总数，返回null public String getHeaderFieldKey(int n) //得到响应头第n个字段的值，n等于0或大于响应头字段总数，返回null public String getHeaderField(int n)//r如果内容长度可获取，则返回该长度，否则返回-1public int getContentLength()//获取内容的类型，如text/plain、image/gifpublic String getContentType()//获取内容的编码机制，如gzip(不常用，因为默认的identity编码机制并不是用Content-Encoding头来决定的)public String getContentEncoding() //获取创建日期public long getDate() //获取过期日期 public long getExpiration()//获取最后一个被修改的日期public long getLastModified() //获取资源输入输出流 public InputStream getInputStream() public OutputStream getOutputStream() //读取内容，如text/plain、image/gif，可用自定义内容处理器处理public Object getContent() 向WEB服务器发送数据1234567891011121314/**java.net.HttpURLConnection**///返回可以读取Web服务器错误信息的流public InputStream getErrorStream() /**java.net.URLEncoder**/ //采用指定的字符编码模式对字符串进行编码public static String encode(String s, String enc) /**java.net.URLDecoder**/ //采用指定的字符编码模式对已编码字符串进行解码public static String decode(String s, String enc) Java工具类集合工具类Collections类集框架定义了几种能用于类集和映射的算法。在Collections类中（注意Collections是一个工具类，不是接口），这些算法被定义为静态方法 synchronized*方法被用来获得各种类集的同步（安全线程）拷贝 unmodifiable*方法返回不能被改变的各种类集“视图”。这些方法当将一些进程对类集设为只读形式时很有用的 Collections定义了三个静态变量：EMPTY_SET，EMPTY_LIST和EMPTY_MAP 数组工具类Arrays返回List集合 1static List asList(Object[ ] array) 使用二进制搜索寻找指定的值,以下只是示例，Arrays根据不同数据类型重载了多个binarySearch() 12static int binarySearch(byte[ ] array, byte value) static int binarySearch(Object[ ] array, Object value, Comparator c) 比较方法 1static boolean equals(boolean array1[ ], boolean array2[ ]) 填充数组 1234// 将value值赋值给array[ ]的每一个元素static void fill(Object array[ ], Object value)//将value值赋值给array[ ]的一个子集static void fill(Object array[ ], int start, int end, Object value) 排序 1234567// 对整个数组进行排序static void sort(Object array[ ])static void sort(Object array[ ], Comparator c)//对数组子集进行排序 static void sort(Object array[ ], int start, int end)static void sort(Object array[ ], int start, int end, Comparator c) 字符串标记类StringTokenizer日期类Date构造函数 123Date( )//millisec : 该参数等于从1970年1月1日午夜起至今的毫秒数的大小Date(long millisec) 其他方法 方法 描述 boolean after(Date date) 如果调用Date对象所包含的日期迟于由date指定的日期，则返回true；否则返回false boolean before(Date date) 如果调用Date对象所包含的日期早于由date指定的日期，则返回true；否则返回false Object clone( ) 复制调用Date对象 int compareTo(Date date) 将调用对象的值与date的值进行比较。如果这两者数值相等，则返回0；如果调用对象的值早于date的值，则返回一个负值；如果调用对象的值晚于date的值，则返回一个正值（在Java 2中新增加的） int compareTo(Object obj) 如果obj属于类Date，其操作与compareTo(Date)相同；否则，引发一个ClassCastException异常（在Java 2中新增加的） boolean equals(Object date) 如果调用Date对象包含的时间和日期与由date指定的时间和日期相同，则返回true；否则，返回false long getTime( ) 返回自1970年1月1日起至今的毫秒数的大小 int hashCode( ) 返回调用对象的散列值 void setTime(long time) 按time的指定，设置时间和日期，表示自1970年1月1日午夜至今的以毫秒为单位的时间值 String toString( ) 将调用Date对象转换成字符串并且返回结果 日历类Calendar抽象Calendar类提供了一组方法，这些方法允许将以毫秒为单位的时间转换为一组有用的分量 GregorianCalendar（标准阳历）Calendar的实现类 构造函数 123456789101112//year: 从1900年起的年数//month: 以0表示一月GregorianCalendar(int year, int month, int dayOfMonth)GregorianCalendar(int year, int month, int dayOfMonth, int hours,int minutes)GregorianCalendar(int year, int month, int dayOfMonth, int hours,int minutes, int seconds) //用指定的时区和/或地区的当前日期和当前时间来初始化的对象GregorianCalendar(Locale locale)GregorianCalendar(TimeZone timeZone)GregorianCalendar(TimeZone timeZone, Locale locale) 时区类TimeZoneTimeZone类允许给出相对于格林威治时间（GMT），也称为世界时间（UTC）的时区差 SimpleTimeZoneSimpleTimeZone类是TimeZone的一个子类，允许对公历进行时区操作。它也计算夏令时 构造函数 12345678910111213141516171819202122232425//与格林威治标准时间（GMT）的偏移量SimpleTimeZone(int timeDelta, String tzName) SimpleTimeZone(int timeDelta , String tzId , int dstMonth0 //-----夏令时的开始参数 START----- , int dstDayInMonth0 , int dstDay0 , int time0 //-----夏令时的开始参数 END----- , int dstMonth1 //-----夏令时的结束参数 START----- , int dstDayInMonth1 , int dstDay1 , int time1) //-----夏令时的结束参数 END----- SimpleTimeZone(int timeDelta , String tzId , int dstMonth0 , int dstDayInMonth0 , int dstDay0 , int time0 , int dstMonth1 , int dstDayInMonth1 , int dstDay1 , int time1 , int dstDelta) //在夏令时期间保存的毫秒数 地区类 LocaleLocale类被实例化以生成其中每一个描述一个地理或文化区域的对象。它是提供了编写在不同的国际环境下都能运行的程序的几个类之一 Locale类定义的常数，用于处理最常见的地区 1234567CANADA GERMAN KOREANCANADA_FRENCH GERMANY PRCCHINA ITALIAN SIMPLIFIED_CHINESECHINESE ITALY TAIWANENGLISH JAPAN TRADITIONAL_CHINESEFRANCE JAPANESE UKFRENCH KOREA US 构造函数 12Locale(String language, String country)Locale(String language, String country, String data) 随机函数类Random构造函数 123Random( )//seed : 人为指定一个初值Random(long seed) Timer和TimerTask提供了提前安排将来某时间要执行任务的能力。使用这些类可以创建一个工作于后台的线程，该线程等待一段指定的时间。当指定的时间到来时，与该线程相连的任务被执行 TimerTimer是一个用于安排一个将来执行的任务的类。被安排的任务必须是TimerTask的一个实例 构造函数 12Timer( )Timer(boolean DThread) 方法 描述 void cancel( ) 终止定时器线程 void schedule(TimerTask TTask, long wait) TTask被安排在由参数wait传递的周期之后执行wait参数的单位是毫秒 void schedule(TimerTask TTask, long wait,long repeat) void schedule(TimerTask TTask, long wait,long repeat) void schedule(TimerTask TTask, Date targetTime) TTask被安排在由targetTime指定的时间执行 void schedule(TimerTask TTask,Date targetTime, long repeat) TTask被安排在由targetTime指定的时间执行。接&gt;着任务在由repeat传递的时间间隔重复执行。repeat参数的单位是毫秒 void scheduleAtFixedRate(TimerTask TTask,long wait, long repeat) TTask被安排在经过由参数wait传递的周期之后执行。任务随后在由repeat指定的时间间隔重复执行。参数wait和repeat的单位都是毫秒。每一次重复的时间是和第一次执行，而不是和前一次执行的时间有关。因此执行的总速度是固定的 void scheduleAtFixedRate(TimerTask TTask,Date targetTime, long repeat) TTask被安排在由targetTime指定的时间执行。任务随后在由repeat指定的时间间隔重复执行。参数repeat的单位是毫秒。每一次重复的时间是和第一次执行，而不是和前一次执行的时间有关。因此执行的总速度是固定的 TimerTaskTimerTask实现了Runnable接口；因此它可以被用于创建一个执行线程 构造函数 1TimerTask( ) 方法 描述 boolean cancel( ) 终止任务。如果任务的执行被阻止了，则返回true；否则返回false abstract void run( ) 包含了定时器任务的代码 long scheduledExecutionTime( ) 返回被安排最后执行的任务的时间 数学函数类Math 函数 说明 Math.sin sin Math.cos Math.tan Math.atan(x) 返回一个 - π/2 到 π/2 弧度之间的数值 Math.atan2(y,x) 返回一个 -π 到 π 之间的数值，表示点 (x, y) 对应的偏移角度 Math.exp Math.log Math.log10 Math.PI π Math.E e Math.sqrt 算数平方根 Math.pow(x,a) 幂运算，计算x^a(double参数，返回double类型) Math.round(x) 四舍五入,返回long类型]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
