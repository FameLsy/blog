<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/blog/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="我只是一个兴趣使然的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="Liisyu Blog">
<meta property="og:url" content="https://masol.gitee.io/blog/index.html">
<meta property="og:site_name" content="Liisyu Blog">
<meta property="og:description" content="我只是一个兴趣使然的程序员">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Liisyu Blog">
<meta name="twitter:description" content="我只是一个兴趣使然的程序员">





  
  
  <link rel="canonical" href="https://masol.gitee.io/blog/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Liisyu Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liisyu Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/blog/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-navigation">

    
    
    
      
    

    

    <a href="/blog/navigation/" rel="section"><i class="menu-item-icon fa fa-fw fa-diamond"></i> <br>导航</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2019/04/09/java.16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2019/04/09/java.16/" class="post-title-link" itemprop="url">未命名</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-09 08:53:34" itemprop="dateCreated datePublished" datetime="2019-04-09T08:53:34-04:00">2019-04-09</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- ---
title: java基础：集合
date: 2018-02-02 00:00:16
tags: 
- java集合
categories: 
- JavaSe教程
--- -->
<p>Java集合类库是接口与实现分离的;此外，在<em>Java　API</em> 文档中，有一组以Abstract开头的类，如”AbstractQueue”,这些类是为类库实现者设计的。（想要实现自己的队列，扩展AbstractQueue比实现Ｑueue轻松的多）</p>
<h1 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h1><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/collection2.png" alt="collection2"></p>
<h1 id="集合结构结合泛型"><a href="#集合结构结合泛型" class="headerlink" title="集合结构结合泛型"></a>集合结构结合泛型</h1><p>Ｃollection和Iterator都是泛型接口，这意味着可以编写任何集合类型的使用方法<br>如下方法就可以检测任意集合是否包含指定元素的泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">comtains</span><span class="params">(Collection&lt;E&gt; c, Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(E element : c)&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.equals(obj)) <span class="keyword">return</span> ture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Collection 已经声明了很多有用的抽象方法　　<br><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/collection.png" alt="collection"></p>
<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>集合的最基本接口就是Ｃollection接口,且有两个基本方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;  <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 向集合添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="comment">// 返回迭代器</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器虽然不是集合，但是他能作用于任何继承Iterable的集合上，而Collection正是继承了这个类。</p>
<p>Iterator是一个接口，包含４个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 返回集合的下一个元素，集合末尾抛出NoSuchElementException</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 判断集合是否还有下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasnext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 删除上次调用ｎｅｘｔ方法返回的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Java　ＳＥ 8 加入的方法，可以对每个迭代器内的元素调用传入的ｌａｍbda表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h2><p>遍历一个元素，可以使用迭代器来完成,有两种使用方式</p>
<ol>
<li>通过hasnext()和next()方法进行遍历</li>
<li>通过for-earch循环来完成<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; aCollection = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = aCollection.iterator();</span><br><span class="line"><span class="comment">// 遍历迭代器，逐个访问元素</span></span><br><span class="line"><span class="keyword">while</span>(iter.hasnext())&#123;</span><br><span class="line">    String element = iter.next();</span><br><span class="line">    <span class="comment">//do something with element</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用for-each循环遍历</span></span><br><span class="line"><span class="keyword">for</span>(String element : aCollection)&#123;</span><br><span class="line">     <span class="comment">//do something with element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><em>for-each</em> 循环可以与任何实现了 <em>Iterable</em> 接口的对象一起工作，而 <em>Collction</em> 接口扩展了 <em>Iterable</em> 接口，这就意味着所有集合都可以使用 <em>for-each</em> 循环</p>
<p>此外，在Java SE 8,可以通过调用 <em>forEachRemaining()</em> 方法来完成查看所有元素,它将会对迭代器里的每个元素调用lambda表达式，直到没有为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iter.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element)</span><br></pre></td></tr></table></figure>
<h2 id="迭代器删除"><a href="#迭代器删除" class="headerlink" title="迭代器删除"></a>迭代器删除</h2><p>对于使用remove()方法，必须先使用一次next()方法(删除上一个next的返回值),这点要额外注意</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iter.next();</span><br><span class="line">iter.remove(); <span class="comment">//ok</span></span><br><span class="line">iter.remove();<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<h1 id="List、Set、Queue"><a href="#List、Set、Queue" class="headerlink" title="List、Set、Queue"></a>List、Set、Queue</h1><p>List接口是一个有序集合，元素会添加到容器中的特定位置，可采用迭代器访问和整数索引访问(又被称为 <em>随机访问</em> )</p>
<p>Set接口类似与Connection,但是对方法的行为更为严谨。容器不能添加重复元素，需要定义equals方法和hashCode()方法</p>
<p>Queue: 队列结构</p>
<h1 id="Collection-具体集合"><a href="#Collection-具体集合" class="headerlink" title="Collection 具体集合"></a>Collection 具体集合</h1><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/collection3.png" alt="collection3"></p>
<p>说明</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/collection4.png" alt="collection4"></p>
<h2 id="LinkedList-源码解析"><a href="#LinkedList-源码解析" class="headerlink" title="LinkedList 源码解析"></a>LinkedList 源码解析</h2><p>todo</p>
<h2 id="AarrayList-源码解析"><a href="#AarrayList-源码解析" class="headerlink" title="AarrayList 源码解析"></a>AarrayList 源码解析</h2><p>从类的定义可以看出，该类继承于AbstractList，可以随机访问、克隆、序列化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p>
<p>再来看它的属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始化大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个空的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于默认大小的空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储ArrayList元素的数组缓冲区。</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></p>
<p>添加方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2018/02/02/java.17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2018/02/02/java.17/" class="post-title-link" itemprop="url">java基础：多线程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-02 00:00:17" itemprop="dateCreated datePublished" datetime="2018-02-02T00:00:17-05:00">2018-02-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-09 08:53:34" itemprop="dateModified" datetime="2019-04-09T08:53:34-04:00">2019-04-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/JavaSe教程/" itemprop="url" rel="index"><span itemprop="name">JavaSe教程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2018/02/02/java.15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2018/02/02/java.15/" class="post-title-link" itemprop="url">java基础：泛型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-02 00:00:15" itemprop="dateCreated datePublished" datetime="2018-02-02T00:00:15-05:00">2018-02-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-09 08:53:34" itemprop="dateModified" datetime="2019-04-09T08:53:34-04:00">2019-04-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/JavaSe教程/" itemprop="url" rel="index"><span itemprop="name">JavaSe教程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>指定保存元素的对象类型，使用一对尖括号。<br>如 <em>ArrayList</em>是一个泛型类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;C&gt; staff = <span class="keyword">new</span> ArrayList&lt;C&gt;();</span><br></pre></td></tr></table></figure></p>
<p>java7.0后可以省略右边的类型参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;C&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<h2 id="类型化与原始数据的兼容性"><a href="#类型化与原始数据的兼容性" class="headerlink" title="类型化与原始数据的兼容性"></a>类型化与原始数据的兼容性</h2><p>以ArrayList为例,<br>有如下方法,属于没有使用到类型化的设置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span> <span class="params">(ArrayList list)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList <span class="title">find</span><span class="params">(String query)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>将类型化的ArrayList传递给update作为参数,是不会有任何警告的(尽管并不安全)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;C&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">update(staff)</span><br></pre></td></tr></table></figure></p>
<p>但如果是将一个原始的ArrayList赋给一个类型化的ArrayList,会出现警告<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList(E) result = find(query);<span class="comment">//yields warning</span></span><br></pre></td></tr></table></figure></p>
<p>即使强转，也会出现另一个警告<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList(E) result = (ArrayList(E))find(query);<span class="comment">//yields warning</span></span><br></pre></td></tr></table></figure></p>
<p>解释：<br>其实编译器在对类型进行转换时，没发现违规现象，会将所有类型化数据转换成原始数据，也就是说在虚拟机中没有类型参数。只要确保不会造成严重的后果即可.<br>可以使用@SuppressWamings(“unchecked”) 标注来标记 这个变量能够接受类型转换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuperessWarnings</span>(<span class="string">"unchecked"</span>)  ArrayList(E) result = (ArrayList(E))find(query);<span class="comment">//yields warning</span></span><br></pre></td></tr></table></figure></p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>类型变量使用大写形式，在Java中</p>
<ol>
<li>E表示集合的元素类型</li>
<li>K和V表示关键字与值类型</li>
<li>T(需要时还可以使用临近字母U,S)表示任意类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCLass</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>类型变量放在修饰符后面，返回值前面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(T... a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>泛型方法可以定义在普通类中，也可以定义在泛型类中</p>
<p>注意以下的不同<br>这是另一种包含类型变量的写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(T... a()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两种写法的区别在于</p>
<blockquote>
<p>对于<t> T,可以在调用方法时指定Ｔ的类型，如MyClass.<string> get()，获取的返回值就是String类<br>而对于T,只能使用普通的MyClass.get(),至于返回值类型，会根据ＭyClass<t>类型变量决定。</t></string></t></p>
</blockquote>
<p>　　<br><strong>调用泛型方法</strong><br>在方法名前的尖括号中放入具体类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass.&lt;String&gt;get(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"><span class="comment">//或,返回值根据类型自动选择</span></span><br><span class="line">MyClass.get(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>泛型方法可能出错</strong><br>如下，编译器会自动打包一个Double类和两个Integer类，而后寻找他们的共同超类。<br>事实上会找到Number和Comparable接口，其本身也是个泛型类。<br>这样会导致解释代码有两种方法，且都合法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass.method(<span class="number">3.14</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="类型变量限定"><a href="#类型变量限定" class="headerlink" title="　类型变量限定"></a>　类型变量限定</h2><p>如下，Ｔ可以是任意类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但如果我们需要限制Ｔ必须实现Comparable接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：<br>可以看到，在上面例子中实现接口用的是extends而不是implements<br>原因：其实&lt; T extends Compatable &gt;应该是&lt; T extends BoundingType &gt;,即代表的含义是Ｔ是 BoundingType的子类型。而不是Ｔ继承或实现BoundingType。（Java设计者不打算添加新的关键字，而extends更接近子类的意思）</p>
</blockquote>
<p><strong>多个限定</strong>　　<br>使用 <em>&amp;</em> 来分隔限定类型,使用 “,” 来分隔类型变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Comparable &amp; Serializable, U&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型与虚拟机"><a href="#泛型与虚拟机" class="headerlink" title="泛型与虚拟机"></a>泛型与虚拟机</h2><p>首先要知道，虚拟机只有普通类，没有泛型类这个概念。也就是说，泛型类最终还是会被解析成普通类</p>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>泛型类都会被提供一个原始类型。<br>如，没有限定类型的泛型类替换方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类型擦除后,T没有限定类型，会被替换成 Object</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是有限定类型的话<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pair</span>&lt;<span class="title">T</span>  <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//擦除后,会替换为第一个限定类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable first;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是 &lt;T  extends  Serializable&amp; Comparable&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Serializable first;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上代码所示，T会替换为第一个限定类型，而编译器在必要时会向另一个限定类型插入强制类型转换。<br>所以，为了提高效率，一般把标签接口(即没有方法的接口)放在末尾</p>
<h2 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable 〉 <span class="function">T <span class="title">min</span> <span class="params">( T[] a )</span></span></span><br><span class="line"><span class="function"><span class="comment">//擦除类型后</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Comparable a)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h2><p>假设有如下泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Pair</span><span class="params">(T first)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFirst</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> first&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如我们调用如下方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ...;</span><br><span class="line">Employee buddy = buddies.getFirst();</span><br><span class="line">``` </span><br><span class="line">编译器会把这个方法翻译为两条虚拟机指令</span><br><span class="line"><span class="number">1</span>. 第一步：对原始getFirst()的调用((T 擦除后替换成Object，方法返回Object))</span><br><span class="line"><span class="number">2</span>. 第二步：将Object强制转换为Employee</span><br><span class="line"></span><br><span class="line">相当于变为原始的方法，再对泛型部分进行强转</span><br><span class="line"></span><br><span class="line">即geteFirst方法会变成</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再进行强转</span></span><br><span class="line">(Employee)buddies.getFirst();</span><br></pre></td></tr></table></figure></p>
<p>如果是setFirst方法的话会变成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object first)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first = (Employe)first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以在本质上可以说，泛型是将各种类型变量还原成原始数据，在强转。<br>如下例子,虽然不是很好的编程风格，但也是进行了强制转换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ...;</span><br><span class="line">Employee buddy = buddies.first;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法擦除带来的问题"><a href="#方法擦除带来的问题" class="headerlink" title="方法擦除带来的问题"></a>方法擦除带来的问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span>&lt;<span class="title">LocalDate</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDate second;`</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ChildClass aChild = <span class="keyword">new</span> ChildClass();</span><br><span class="line">ParentClass&lt;LocalDate&gt; aParent = aChild; <span class="comment">//多态</span></span><br><span class="line">aParent.setSecond(aLocalDate);</span><br></pre></td></tr></table></figure></p>
<p>按照泛型的特点,擦除后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时可以看到，有两个不同的setSecond()方法 ,而不是完成子类方法覆盖父类方法(很显然，擦除带来的效果与多态的冲突)  </p>
<p>泛型是如何解决多态？<br>答：编译器会在ChildClass自动生成一个桥方法，达到类似于多态的效果。<br>桥方法类似于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">    setSecond((LocalDate)second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理，如果有如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span>&lt;<span class="title">LocalDate</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>擦除后ＣhildClass会有两个getSecond()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span></span>&#123;</span><br><span class="line">    <span class="comment">// 自己定义的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//桥方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没错，是真的有两个getSecond方法，在java中可能不合法，在虚拟机中是合法的。</p>
<h2 id="调用遗留代码"><a href="#调用遗留代码" class="headerlink" title="调用遗留代码"></a>调用遗留代码</h2><p>对于较早期的代码，当时没有泛型这个概念<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(MyClass class)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> MyClass <span class="title">get</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果将一个泛型参数传入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass&lt;String&gt; aClss = ...;</span><br><span class="line">set(aClass);</span><br></pre></td></tr></table></figure></p>
<p>或者将一个原始类型赋值给泛型变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass&lt;Class&gt; aClass = get();</span><br></pre></td></tr></table></figure></p>
<p>都会方法一个警告，最差的情况就是抛出一个类型转换错误<br>可以使用注解忽略警告<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(MyClass class)</span></span>;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> MyClass <span class="title">get</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="泛型约束与局限性"><a href="#泛型约束与局限性" class="headerlink" title="泛型约束与局限性"></a>泛型约束与局限性</h1><h2 id="不能使用基本数据类型实例化类型参数"><a href="#不能使用基本数据类型实例化类型参数" class="headerlink" title="不能使用基本数据类型实例化类型参数"></a>不能使用基本数据类型实例化类型参数</h2><p>没有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">double</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>只有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Double&gt;</span><br></pre></td></tr></table></figure></p>
<p>原因，类型擦除后含有Object域，而Object不能存储double</p>
<h2 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h2><p>因为虚拟机里是没有泛型类型的，所以类型查询只生产原始类型  </p>
<p>视图查询一个对象是否属于某个泛型类型时，会得到一个编译器错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;) <span class="comment">//error</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;T&gt;)  <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>而使用强制转换类型，会得到一个警告<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; aPair = (Pair&lt;String&gt;)a;<span class="comment">//warning</span></span><br></pre></td></tr></table></figure></p>
<p>getClass()方法也只返回原始类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; aPairString = ...;</span><br><span class="line">Pair&lt;Double&gt; aPairDouble = ...;</span><br><span class="line"><span class="keyword">if</span>(aPairString.getClass() == aPairDouble.getClass()) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="不能实例化参数化类型的数组"><a href="#不能实例化参数化类型的数组" class="headerlink" title="不能实例化参数化类型的数组"></a>不能实例化参数化类型的数组</h2><p>如,可以定义Pair&lt; String&gt;[] table 变量，但不能使用new Pair&lt; String&gt;[10]实例化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; [] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>] <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>原因:<br>假设可以创建，那擦除后代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair[] table = <span class="keyword">new</span> Pair[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>会发现，擦除过后，泛型机制将会无效,只要是一个Pair类就可以传入数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Double&gt;();</span><br></pre></td></tr></table></figure></p>
<p>那么我们在原有的定义Pair&lt; String&gt;下使用数据，肯定会出现类型错误</p>
<blockquote>
<p>注<br>如果真的需要保存参数类型化对象，可以使用ArrayList&lt;Pair&lt; String&gt;&gt;</p>
</blockquote>
<h2 id="Varargs-可变参数-警告"><a href="#Varargs-可变参数-警告" class="headerlink" title="Varargs(可变参数) 警告"></a>Varargs(可变参数) 警告</h2><p>如下方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; aCollection, T... ts)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要是传入多个参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; aPair1 = ...;</span><br><span class="line">Pair&lt;String&gt; aPair2 = ...;</span><br><span class="line">addAll(aCollection, aPair1, aPair2);</span><br></pre></td></tr></table></figure></p>
<p>对于aPair1、aPair2，虚拟机必须建立一个Pair<string>[]数组。而java是不能实例化参数化类型的数组。<br>这种情况下，规则会有所放松，只会得到一个警告，而不是错误。<br>想要忽视这个警告，由以下两种方式：</string></p>
<ol>
<li>@SuppressWarning(“unchecked’)注释</li>
<li>@SafeVarargs 注释(Java SE 7.0)</li>
</ol>
<h2 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h2><p>不能使用以下表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> T(...);<span class="comment">//error</span></span><br><span class="line"><span class="keyword">new</span> T[...]<span class="comment">//error</span></span><br><span class="line">T.class; <span class="comment">//eror</span></span><br></pre></td></tr></table></figure></p>
<p>如下构造器也是不合法的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123;</span><br><span class="line">    first = <span class="keyword">new</span> T();</span><br><span class="line">    second = <span class="keyword">new</span> T();</span><br><span class="line">&#125; <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>对于构造器，Java SE 8后，最好的解决办法是让调用者提供一个构造器表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">//Supplier&lt;T&gt;是一个函数接口，表示一个无参而且返回值类型为T的函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span></span>&#123;</span><br><span class="line">    rerturn <span class="keyword">new</span> Pair&lt;&gt;(constr.get(), constr.get())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传统的解决方法，是通过反射调用Class.newInstance方法来构造泛型对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：Class&lt;T&gt;本身也是泛型，String.class就是Class&lt;String&gt;</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; aClass)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(aClass.newInstance(), aClass.newInstance());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h2><h2 id="泛型类的静态上下文种类型变量无效"><a href="#泛型类的静态上下文种类型变量无效" class="headerlink" title="泛型类的静态上下文种类型变量无效"></a>泛型类的静态上下文种类型变量无效</h2><p>禁止使用带有类型变量的静态域和静态方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClSS</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T field;<span class="comment">//error</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  T <span class="title">get</span><span class="params">()</span></span>&#123;...&#125;;<span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h2><p>泛型类不能被抛出，也不能被捕获，甚至无法扩展Throwable类(Throwable可以被抛出捕获)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;...&#125;<span class="comment">//error,编译不通过</span></span><br></pre></td></tr></table></figure></p>
<p>catch子句不能使用类型变量(即不能被捕获)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(T t)&#123;...&#125;<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>不过，在异常规范中使用类型变量是被允许的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">dowork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T</span>&#123;<span class="comment">//OK</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        dowork</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable realCasue)&#123;<span class="comment">//catch(T e) 还是错的</span></span><br><span class="line">        t.initCause(realCasue);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释泛型类不能被抛出和捕获:  </p>
<ol>
<li>泛型类不能被抛出和捕获，而泛型是可以抛出</li>
<li>确切的讲就是我们不能使用泛型类来设计一个自定义异常</li>
<li>如，当我们对于参数为String和参数为Double，要抛出MyException&lt; String&gt;、MyException&lt; Double&gt;两个自定义异常，但是在虚拟机中都是抛出MyExcpetion异常，而捕获这两个异常也是捕获MyExcpetion类，无法做到分别处理，也无法根据情况分别抛出。</li>
<li>但对于T extends Throwable, T类本身不是泛型类，只是对类进行了泛型限定，所以是可以正常抛出的。</li>
<li>而对于catch(T t),T的不确定，导致不同的T应该有不同的方法，显然不应该把T放在这里。</li>
</ol>
<h2 id="可以消除对受检查异常的检查"><a href="#可以消除对受检查异常的检查" class="headerlink" title="可以消除对受检查异常的检查"></a>可以消除对受检查异常的检查</h2><p>Java异常处理机制的基本原则是：为所有受检查异常提供一个处理器<br>如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span></span>&#123;</span><br><span class="line">    <span class="meta">@SupressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> (T)e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么通过以下方法,所有传入的异常t，都会被转换成RuntimExcpetion<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Block.&lt;RuntimeException&gt;throwAs(t);</span><br></pre></td></tr></table></figure></p>
<p>通过以下实例，可以将一个受查异常转成一个非受查异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">toThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    body();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">                    Block.&lt;RuntimeException&gt;throwAs(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> (T)t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Block()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"asdsa"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行后，因为根本没有”asdsa”这个文件，所以会有一个FileNotFindExcpetion<br>正常情况下，需要在run方法种不过这个异常，在包装到非受查异常中。(run方法不抛出任何异常)<br>而本例，只是抛出异常（同时消除非受查异常警告），让编译器认为不是受查异常。</p>
<h2 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h2><p>？？？？？？？？？？？？</p>
<h1 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h1><p>通配符类型中，允许类型参数变化<br>示例：<br>如下代码,只能传递Pair&lt; Employee&gt;,而不能传递Pair&lt; Manager&gt;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;Employee&gt;  aPair&gt;)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于这样的限制，就可以使用泛型通配符<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;? extend Employee&gt; aPair)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样传入的类型，就是所有的Employee的子类都可以</p>
<h2 id="通配符超类限定"><a href="#通配符超类限定" class="headerlink" title="通配符超类限定"></a>通配符超类限定</h2><p>如下通配符限制为Managerd的所有超类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? <span class="keyword">super</span> Mananger</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2018/02/02/java.14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2018/02/02/java.14/" class="post-title-link" itemprop="url">java基础：代理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-02 00:00:14" itemprop="dateCreated datePublished" datetime="2018-02-02T00:00:14-05:00">2018-02-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-09 08:53:34" itemprop="dateModified" datetime="2019-04-09T08:53:34-04:00">2019-04-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/JavaSe教程/" itemprop="url" rel="index"><span itemprop="name">JavaSe教程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2018/02/02/java.13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2018/02/02/java.13/" class="post-title-link" itemprop="url">java基础：lambda表达式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-02 00:00:13" itemprop="dateCreated datePublished" datetime="2018-02-02T00:00:13-05:00">2018-02-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-09 08:53:34" itemprop="dateModified" datetime="2019-04-09T08:53:34-04:00">2019-04-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/JavaSe教程/" itemprop="url" rel="index"><span itemprop="name">JavaSe教程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>lambda表达式：可传递的代码块<br>语法：参数、-&gt;、表达式(无需指定返回类型)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line">    -&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure></p>
<p><strong>Lambda表达式省略</strong>  </p>
<p>没有参数时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">()-&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以推导出参数类型时，可省略参数类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(first, second)-&gt;&#123;</span><br><span class="line">    first.length() - second.length()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有一个参数，且可以推导类型，可省略 <em>()</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event </span><br><span class="line">    -&gt; System.out.print(<span class="string">"This time is"</span> + <span class="keyword">new</span> Date())</span><br></pre></td></tr></table></figure></p>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>函数式接口：只有一个抽象方法的接口,需要这种接口的对象时，可以提供lambda表达式。<br>如:<br>Arrays.sort()这个方法，它的第二个参数是一个Comparator接口.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span><br></pre></td></tr></table></figure></p>
<p>然而在Comparator接口中，发现了两个抽象方法和一个注释<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">//表明其为函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原因：函数式接口还可以定义Object的方法，即equals属于Object方法，所以Comparator属于函数式接口</p>
<p>实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words, </span><br><span class="line">    (first, second)-&gt;first.length() - second.length());</span><br></pre></td></tr></table></figure></p>
<p>在底层，Arrays.sort接受的是Comparator&lt; String &gt;这个对象,在这个对象调用compare方法时会执行lambda表达式。</p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>将现成的方法传递到其他代码中<br>如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, event -&gt; System.out.println(event));</span><br></pre></td></tr></table></figure></p>
<p>可以直接将println方法传递到Timer构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//System.out::println等同于 x -&gt; System.out.println(x)</span></span><br><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>,System.out::println);</span><br></pre></td></tr></table></figure></p>
<p>对于使用 <em>::</em> ，一共有三种情况  </p>
<ol>
<li>object::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class::instanceMethod</li>
</ol>
<p>前2种情况中,方法引用等价于提供方法参数的lambda 表达式(Math::pow等价于(x,y)-&gt;Math.pow(x,y))<br>第3种情况 , 第 1 个参数会成为方法的目标 。(String::compareTolgnoreCase等价于(x,y)-&gt;x.compareTOlgnoreCase(y))</p>
<blockquote>
<p>注<br>因为是将现有的方法传递到代码中，有可能出现重载方法。如Math.max有两个版本，一个用于整数，一个用于double<br>选择哪一个版本取决于Math::max转换成哪一个函数式接口的方法参数</p>
</blockquote>
<p>可以在方法中引用this和super<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>::equals</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">x -&gt; <span class="keyword">this</span>.equals(x)</span><br></pre></td></tr></table></figure></p>
<h1 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h1><p>类似于方法引用，但方法名为new(可以理解为特殊的方法引用)<br>调用的构造器取决于上下文<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[]::<span class="keyword">new</span> </span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">x -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[x]</span><br></pre></td></tr></table></figure></p>
<p><strong>一个构造器的应用</strong>：<br>在泛型中，是无法构造泛型数组的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> T[n] <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>利用构造器引用，可以解决这个问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在流中，可以使用toArray传入想要的数据类型来获取想要的数组（以获取Peron[]数组为例）</span></span><br><span class="line">Person[] people = aStream.toArray(Person[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="lambda变量作用域"><a href="#lambda变量作用域" class="headerlink" title="lambda变量作用域"></a>lambda变量作用域</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActionListener 是一个函数是接口，所以lambda表达式可以赋值给它</span></span><br><span class="line"><span class="function">pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> delay)</span></span>&#123;</span><br><span class="line">    ActionListener aListener = event -&gt;&#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> Timer(delay, aListener).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">repeatMessage(<span class="string">"hello"</span>, <span class="number">1000</span>);<span class="comment">//print hello</span></span><br></pre></td></tr></table></figure>
<p>如上代码，lambda表达式使用了外部的变量text,而真正执行lambda，可能要等到定时器运行为止，此时：text变量可能已经不存在了。</p>
<p>那么lambda是如何保存变量的呢？<br>答：首先看lambda表达式的组成</p>
<ol>
<li>一个代码块</li>
<li>参数</li>
<li>自有变量（即非参数且不在代码块中定义的，这里就是text）</li>
</ol>
<p>自有变量的值，可以被lambda表达式捕获。具体细节为：lambda表达式最终会变为一个包含方法的实例对象，而自由变量的值会复制到这个对象的实例变量中</p>
<blockquote>
<p>注:<br>代码块和自有变量值有一个术语：闭包</p>
</blockquote>
<h2 id="lambda捕获的限制"><a href="#lambda捕获的限制" class="headerlink" title="lambda捕获的限制"></a>lambda捕获的限制</h2><p>限制一：不能在lambda表达式中改变捕获的自由变量的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">countDonw</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    ActionListener aListener = event -&gt;&#123;</span><br><span class="line">        start--;</span><br><span class="line">        System.out.println(start);<span class="comment">//Error，不能改变捕获的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> Timer(delay, aListener).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>限制二：不能捕获一个改变的变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">repeat</span><span class="params">(String text, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++)&#123;</span><br><span class="line">          ActionListener aListener = event -&gt;&#123;</span><br><span class="line">            System.out.println(i);<span class="comment">//Error，不能引用一个改变的变量</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用this"><a href="#使用this" class="headerlink" title="使用this"></a>使用this</h2><p>在一个 lambda 表达式中使用 this 关键字时, 是指创建这个 lambda 表达式的方法的 this参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Application</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ACtionListener aLinstener = event -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.toString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上代码，调用的toString 会是Application的toString方法</p>
<h1 id="处理Lambda表达式"><a href="#处理Lambda表达式" class="headerlink" title="处理Lambda表达式"></a>处理Lambda表达式</h1><p>使用 lambda 表达式的重点是延迟执行,如果想耍立即执行代码 , 完全可以直接执行 , 而无需把它包装在一个lambda 表达式中  </p>
<p>需要延迟执行的情况</p>
<ol>
<li>在一个单独的线程中运行代码</li>
<li>多次运行代码</li>
<li>在算法的适当位置运行代码 (例如,排序中的比较操作）</li>
<li>发生某种情况时执行代码 (如,点击了一个按钮,数据到达,等等;）</li>
<li>只在必要时才运行代码 。</li>
</ol>
<p>例：重复n遍动作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runnable是一个JAVA Api中提供的接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n, Runnable action)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) action.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当执行action.run()时，就会执行lambda主体</span></span><br><span class="line">repeat(<span class="number">10</span>, () -&gt; System.out.println(<span class="string">"Hellp world"</span>));</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/基本数据类型的函数接口.png" alt="基本数据类型的函数接口"></p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/基本数据类型的函数接口.png" alt="常用函数接口"></p>
<h1 id="设计函数接口"><a href="#设计函数接口" class="headerlink" title="设计函数接口"></a>设计函数接口</h1><p>接口设计：</p>
<ol>
<li>设计一个接口，其中只有一个抽象方法</li>
<li>可以用 @ FunctionalInterface 注解来标记这个接口</li>
</ol>
<p>使用标记的好处</p>
<ol>
<li>如果不小心添加了一个抽象方法，编译器会产生错误消息</li>
<li>javadoc会指出该接口是函数接口</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2018/02/02/java.12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2018/02/02/java.12/" class="post-title-link" itemprop="url">java基础：异常</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-02 00:00:12" itemprop="dateCreated datePublished" datetime="2018-02-02T00:00:12-05:00">2018-02-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-09 08:53:34" itemprop="dateModified" datetime="2019-04-09T08:53:34-04:00">2019-04-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/JavaSe教程/" itemprop="url" rel="index"><span itemprop="name">JavaSe教程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java异常处理通过5个关键字控制:try、catch、throw、throws和 finally</p>
<h1 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h1><p>异常对象都是派生于 Throwable 类的一个实例,但在下一层立即分解为两个分<br>支 : Error 和 Exception</p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Java 运行时系统的内部错误和资源耗尽错误</p>
<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>真正需要关心的异常，分解为两个分支 :</p>
<ol>
<li>RuntimeException :程序错误导致的异常属于 RuntimeException</li>
<li>其他异常 :程序本身没有问题,但由于像I/O错误这类问题导致的异常属于其他异常（ＩＯException）</li>
</ol>
<p><strong>RuntimeException包含情况</strong>  </p>
<ol>
<li>错误的类型转换</li>
<li>数组访问越界</li>
<li>访问到null指针</li>
</ol>
<p><strong>其他异常包含情况</strong>  </p>
<ol>
<li>试图在文件尾部后面读取数据</li>
<li>试图打开一个不存在的文件</li>
<li>试图根据给定的字符串查找 Class 对象, 而这个字符串表示的类并不存在</li>
</ol>
<h1 id="受查异常和非受查异常"><a href="#受查异常和非受查异常" class="headerlink" title="受查异常和非受查异常"></a>受查异常和非受查异常</h1><p>非受查异常: 派生于Error类或RuntimeException类的所有异常称为非受查( unchecked)异常  </p>
<p>受查异常：其他的异常称为受查 ( checked ) 异常</p>
<h1 id="声明受查异常（htrows）"><a href="#声明受查异常（htrows）" class="headerlink" title="声明受查异常（htrows）"></a>声明受查异常（htrows）</h1><p>如果是受查异常，应该在方法首部声明所有可能抛出的异常(通过关键字throws)  </p>
<p>如下是Java类库中的一个类的构造器方法的声明<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FilelnputStream</span> <span class="params">( String name )</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br></pre></td></tr></table></figure></p>
<p>什么时候应该声明异常？</p>
<ol>
<li>调用一个抛出受査异常的方法</li>
<li>程序运行过程中发现错误 , 并且利用 throw 语句抛出一个受查异常</li>
<li>对于Java 的内部错误（Error），不必声明</li>
<li>RuntimeException,不必声明</li>
<li>总结：方法必须抛出所有可能抛出的受查异常，非受查异常要么不可控制(Error)要么就应该避免发生(RuntimeException)</li>
</ol>
<h2 id="子类异常和父类异常"><a href="#子类异常和父类异常" class="headerlink" title="子类异常和父类异常"></a>子类异常和父类异常</h2><ol>
<li>在子类中覆盖了父类的一个方法 ,子类方法中声明的受查异常不能比父类方法中声明的异常更通用(子类方法中可以抛出更特定的异常, 或者根本不抛出任何异常)</li>
<li>父类类方法没有抛出任何受查异常, 子类也不能抛出任何受查异常</li>
</ol>
<h1 id="抛出异常-throw"><a href="#抛出异常-throw" class="headerlink" title="抛出异常(throw)"></a>抛出异常(throw)</h1><p>如抛出一个EOFException异常(IOException子类)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> EOFException();</span><br></pre></td></tr></table></figure></p>
<p>别忘记在方法首部声明抛出的受查异常</p>
<h1 id="捕获异常-try-catch"><a href="#捕获异常-try-catch" class="headerlink" title="捕获异常(try/catch)"></a>捕获异常(try/catch)</h1><p>使用try/catch 块<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    more code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( ExceptionType e )</span><br><span class="line">&#123;</span><br><span class="line">    handler <span class="keyword">for</span> <span class="keyword">this</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果子类覆盖了父类的方法，但父类没有声明任何异常抛出，那么子类必须捕获每一个抛出的受查异常（父类方法没抛出异常，子类也不能抛出异常）</p>
<h2 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( FileNotFoundException e )&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( UnknownHostException e )&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( IOException e )&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并catch"><a href="#合并catch" class="headerlink" title="合并catch"></a>合并catch</h2><p>如果两个或多个异常的处理动作相同的情况下使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( FileNotFoundException | nknownHostException e )&#123;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：<br>捕获多个异常时, 异常变量隐含为 final 变量。即不能为e赋值不同的值</p>
</blockquote>
<h2 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h2><p>在catch中抛出异常,目的是为了改变异常类型  </p>
<p>方式一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">access the database</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( SQLException e )&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException (<span class="string">" database error: "</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方式二：更好的处理，并将原始异常设置成新异常的原因（推荐） </p>
<p>Throwable.initCause(Throwable cause) : 将Throwable的cause初始化为指定的值（不能是它本身）  </p>
<p>Throwable.getCause():获取cause值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( SQLException e )&#123;</span><br><span class="line">    Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error"</span>);</span><br><span class="line">    <span class="comment">// 	Throwable.initCause(Throwable cause) </span></span><br><span class="line">    se.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> se;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取原始异常Throwable.getCause() </span></span><br><span class="line">Throwabl e = se.getCasue();</span><br></pre></td></tr></table></figure>
<h1 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h1><p>可以这样使用,有异常抛出就直接执行finally中的语句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="建议解耦try-catch和try-finally"><a href="#建议解耦try-catch和try-finally" class="headerlink" title="建议解耦try/catch和try/finally"></a>建议解耦try/catch和try/finally</h2><p>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InputStrean in = ...;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        in.closed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOExcpetion o)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好处：  </p>
<ol>
<li>内层try/finally只有一个职责，确保关闭流</li>
<li>外层try/catch也只有一个职责，报告异常</li>
<li>这样设计不仅清楚，还能报告finally中的异常</li>
</ol>
<h2 id="finally与return"><a href="#finally与return" class="headerlink" title="finally与return"></a>finally与return</h2><p>finally 中包含return,会覆盖原始方法中的return值  </p>
<p>如,执行ｆ(2),将会返回０<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = n * n;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="finally抛出异常带来的麻烦"><a href="#finally抛出异常带来的麻烦" class="headerlink" title="finally抛出异常带来的麻烦"></a>finally抛出异常带来的麻烦</h2><p>如,假设在try中抛出了一些非IOException, 而finally中的closed()方法也有可能抛出异常，这时，原始异常丢失，抛出closed方法的异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        in.closed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解决也十分繁琐<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = ...;</span><br><span class="line">Exception ex = <span class="keyword">null</span> ;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        code that might <span class="keyword">throw</span> exceptions</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        ex = e;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        in.closed();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ex == <span class="keyword">null</span>) <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更好的解决办法:<br>Java SE 7 新增的资源关闭处理.</p>
<h1 id="带资源的try语句-Java-SE-7"><a href="#带资源的try语句-Java-SE-7" class="headerlink" title="带资源的try语句(Java SE 7)"></a>带资源的try语句(Java SE 7)</h1><p>try-with-resource最简形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Resource res = ...；Ｒesource res2 = ...)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当try块退出时，自动执行res.closed()。  </p>
<p>对于colosed()可能抛出的异常，原来的异常会被抛出，而closed()异常会被自动捕获,并由Throwable.addSuppressed()添加到原来的异常中。（可以使用Throwableget.Suppressed()获取。）</p>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>继承Exception 或　Exception子类<br>一般异常有两个构造函数：</p>
<ol>
<li>一个无参构造器</li>
<li>一个记录详细描述信息(超类Throwable.toString可以打印这些信息)</li>
</ol>
<p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyExcpetion extends IOexception&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyExcpetion</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyExcpetion</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Throwable-定义的方法"><a href="#Throwable-定义的方法" class="headerlink" title="Throwable 定义的方法"></a>Throwable 定义的方法</h2><p>Exception类自己没有定义任何方法。,它继承了Throwable提供的一些方法  </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Throwable fillInStackTrace( )</td>
<td>返回一个包含完整堆栈轨迹的Throwable对象,该对象可能被再次引发</td>
</tr>
<tr>
<td>String getLocalizedMessage( )</td>
<td>返回一个异常的局部描述</td>
</tr>
<tr>
<td>String getMessage( )</td>
<td>返回一个异常的描述</td>
</tr>
<tr>
<td>void printStackTrace( )</td>
<td>显示堆栈轨迹</td>
</tr>
<tr>
<td>void printStackTrace(PrintStreamstream)</td>
<td>把堆栈轨迹送到指定的流</td>
</tr>
<tr>
<td>void printStackTrace(PrintWriterstream)</td>
<td>把堆栈轨迹送到指定的流</td>
</tr>
<tr>
<td>String toString( )</td>
<td>返回一个包含异常描述的String对象。当输出一个Throwable对象时,该方法被println( )调用</td>
</tr>
</tbody>
</table>
<h1 id="Java的内置异常"><a href="#Java的内置异常" class="headerlink" title="Java的内置异常"></a>Java的内置异常</h1><p>Java 的 java.lang 中定义的未检查异常子类:</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArithmeticException</td>
<td>算术错误,如被0除</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundsException</td>
<td>数组下标出界</td>
</tr>
<tr>
<td>ArrayStoreException</td>
<td>数组元素赋值类型不兼容</td>
</tr>
<tr>
<td>ClassCastException</td>
<td>非法强制转换类型</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>调用方法的参数非法</td>
</tr>
<tr>
<td>IllegalMonitorStateException</td>
<td>非法监控操作,如等待一个未锁定线程</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>环境或应用状态不正确</td>
</tr>
<tr>
<td>IllegalThreadStateException</td>
<td>请求操作与当前线程状态不兼容</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>某些类型索引越界</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>非法使用空引用</td>
</tr>
<tr>
<td>NumberFormatException</td>
<td>字符串到数字格式非法转换</td>
</tr>
<tr>
<td>SecurityException</td>
<td>试图违反安全性</td>
</tr>
<tr>
<td>StringIndexOutOfBounds</td>
<td>试图在字符串边界之外索引</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>遇到不支持的操作</td>
</tr>
</tbody>
</table>
<p>java.lang 中定义的检查异常:</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClassNotFoundException</td>
<td>找不到类</td>
</tr>
<tr>
<td>CloneNotSupportedException</td>
<td>试图克隆一个不能实现Cloneable接口的对象</td>
</tr>
<tr>
<td>IllegalAccessException</td>
<td>对一个类的访问被拒绝</td>
</tr>
<tr>
<td>InstantiationException</td>
<td>试图创建一个抽象类或者抽象接口的对象</td>
</tr>
<tr>
<td>InterruptedException</td>
<td>一个线程被另一个线程中断</td>
</tr>
<tr>
<td>NoSuchFieldException</td>
<td>请求的字段不存在</td>
</tr>
<tr>
<td>NoSuchMethodException</td>
<td>请求的方法不存在</td>
</tr>
</tbody>
</table>
<h1 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h1><p>堆栈轨迹 ( stack trace ) 是一个方法调用过程的列表 , 它包含了程序执行过程中方法调用的特定位置，在java正常终止，无捕获异常时显示该列表。</p>
<p>对于获取堆栈信息有以下几种方法：</p>
<ol>
<li>Throwable.printStackTrace()方法</li>
<li>Throwable.getStackTrace()方法</li>
<li>静态Tread.getAllStackTrace()方法（产生所有线程的堆栈轨迹）</li>
</ol>
<p>如下是打印递归函数facorial的堆栈情况<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTrace</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用了throwable.getStackTrace()来获取StackTraceElement数组</span></span><br><span class="line"><span class="comment">     * StackTraceElement 类含有能够获取文件名，和当前执行代码号的方法，同时还有获取类名和方法名的方法</span></span><br><span class="line"><span class="comment">     * 本例如果输入n=3时，输出结果如下;</span></span><br><span class="line"><span class="comment">     * ---------------------------</span></span><br><span class="line"><span class="comment">     * factorial(3):</span></span><br><span class="line"><span class="comment">     * StackTrace.facorial(StackTrace.java:14)</span></span><br><span class="line"><span class="comment">     * StackTrace.main(StackTrace.java:30)</span></span><br><span class="line"><span class="comment">     * factorial(2):</span></span><br><span class="line"><span class="comment">     * StackTrace.facorial(StackTrace.java:14)</span></span><br><span class="line"><span class="comment">     * StackTrace.facorial(StackTrace.java:21)</span></span><br><span class="line"><span class="comment">     * StackTrace.main(StackTrace.java:30)</span></span><br><span class="line"><span class="comment">     * factorial(1):</span></span><br><span class="line"><span class="comment">     * StackTrace.facorial(StackTrace.java:14)</span></span><br><span class="line"><span class="comment">     * StackTrace.facorial(StackTrace.java:21)</span></span><br><span class="line"><span class="comment">     * StackTrace.facorial(StackTrace.java:21)</span></span><br><span class="line"><span class="comment">     * StackTrace.main(StackTrace.java:30)</span></span><br><span class="line"><span class="comment">     * return1</span></span><br><span class="line"><span class="comment">     * return2</span></span><br><span class="line"><span class="comment">     * return6</span></span><br><span class="line"><span class="comment">     * -----------------------------</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">facorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"factorial("</span> + n + <span class="string">"):"</span>);</span><br><span class="line">        Throwable throwable = <span class="keyword">new</span> Throwable();</span><br><span class="line">        StackTraceElement[] stackTraces = throwable.getStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTraces)&#123;</span><br><span class="line">            System.out.println(stackTraceElement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> result = n * facorial(n-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"return"</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"Enter n: "</span>);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        facorial(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/throwable1.png" alt="throwable1"><br><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/throwable2.png" alt="throwable2"><br><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/Exception.png" alt="Exception"></p>
<h1 id="使用异常机制技巧"><a href="#使用异常机制技巧" class="headerlink" title="使用异常机制技巧"></a>使用异常机制技巧</h1><ol>
<li>异常处理不能代替简单的测试</li>
<li>不要过分地细化异常</li>
<li>利用异常层次结构<br> 不要只抛出 RuntimeException 异常 。 应该寻找更加适当的子类或创建自己的异常类 。<br> 不要只捕获 Thowable 异常</li>
<li>不要压制异常</li>
<li>在检测错误时, “ 苛刻 ” 要比放任更好<br> 在用无效的参数调用一个方法时 , 返回一个虚拟的数值, 还是抛出一个异常 , 哪种处理方式更好<br> 如,当栈空时, Stack.pop() 是返回一个 null , 还是抛出一个异常?<br> 在出错的地方抛出一个 EmptyStackException异常要比在后面抛出一g个NullPointerException 异常更好</li>
<li>不要羞于传递异常</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2018/02/02/java.11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2018/02/02/java.11/" class="post-title-link" itemprop="url">java 基础:包和接口</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-02 00:00:11" itemprop="dateCreated datePublished" datetime="2018-02-02T00:00:11-05:00">2018-02-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-09 08:53:34" itemprop="dateModified" datetime="2019-04-09T08:53:34-04:00">2019-04-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/JavaSe教程/" itemprop="url" rel="index"><span itemprop="name">JavaSe教程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包既是命名机制也是可见度控制机制  </p>
<p>对于包的访问控制，可以查看（7）修饰符  </p>
<h2 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg;</span><br></pre></td></tr></table></figure>
<p>如果省略package 语句,类名被输入一个默认的没有名称的包</p>
<h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2><p>Java编译器考虑的特定位置作为包层次的根被类路径(CLASSPATH)控制</p>
<p>将类路径设置顶层类层次</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口方法都是public,可以不写。但是实现接口的时候必须写（实现类不写是default）</p>
<h2 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h2><ol>
<li>无法实例化</li>
<li>能声明接口的变量</li>
<li>可以使用 instanceof 检查类是否属于某个特定的接口</li>
<li>接口可以继承接口</li>
<li>接口不能包含实例域和静态方法(java 8.0后可以添加静态方法)</li>
<li>接口可以包含常量（共享，因为是public static final）</li>
<li>接口方法自动设置为public abstract,接口域自动设置为public static final</li>
</ol>
<h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>为什么要引入接口？<br>接口可以多实现，而抽象类只能单继承</p>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>可以为接口方法提供一个默认方法,使用default 修饰符标记<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下没什么用(实现Comparable接口时会覆盖这个方法),但可以在如下环境使用：</p>
<p>这样，把所有方法都设置为默认，程序员只需覆盖关心的方法即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认方法的另一个重要用途： <em>接口演化</em>  </p>
<p>假设我们现在有一个接口 A, Mas是其的一个实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;...&#125;</span><br><span class="line">publiic Class Max implements A&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>后来，我们为A添加了一个新方法 newMethod<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可能会出现以下情况  </p>
<ol>
<li>Mas类编译将会失败（没有重写newMethod）</li>
<li>不重新编译Mas类，在Mas调用newMethod时抛出AbstractMethodError</li>
</ol>
<p>如果变为defalut方法，以上两个问题都会解决  </p>
<ol>
<li>Mas成功编译</li>
<li>不重新编译Mas,调用时会向上调用A接口的newMethod</li>
</ol>
<h2 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h2><p>　<br>情况一：接口与父类冲突：父类优先<br>如接口定义了默认方法getName(),而父类中也定义了getName()方法，默认方法被忽略  </p>
<p>情况二：接口与接口冲突： 手动覆盖<br>如接口A、Ｂ同时定义了默认的getName()方法，必需覆盖解决冲突。<br>也可以在类中选择二者其一<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Choose implements A,B&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.<span class="keyword">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>情况三：如果接口Ａ、Ｂ的方法是非默认方法，无论是否另一个有同名默认方法，必需重写</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2018/02/02/java.10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2018/02/02/java.10/" class="post-title-link" itemprop="url">java 基础:反射</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-02 00:00:10" itemprop="dateCreated datePublished" datetime="2018-02-02T00:00:10-05:00">2018-02-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-09 08:53:34" itemprop="dateModified" datetime="2019-04-09T08:53:34-04:00">2019-04-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/JavaSe教程/" itemprop="url" rel="index"><span itemprop="name">JavaSe教程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>大量应用于JavaBeans中，是Java组件的体系结构。<br>反射可以用来:</p>
<ol>
<li>在运行时分析类的能力</li>
<li>在运行时查看对象，如编写一个toSring方法供所有类使用</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象</li>
</ol>
<h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p>Class类：Java运行时系统始终为所有的对象维护一个被成为运行时的类型标识。这个信息跟踪每个对象所属的类，保存这些信息的类被称为Class。</p>
<p>获取Class对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：静态方法(应该提供一个异常处理器)</span></span><br><span class="line">Class.forName(className);</span><br><span class="line"><span class="comment">//方法2：Object的getClass()方法</span></span><br><span class="line">e.getClass();</span><br><span class="line"><span class="comment">//方法3：</span></span><br><span class="line">Class cl1 = <span class="keyword">int</span>.class;<span class="comment">//int不是类，但int.class是一个类</span></span><br><span class="line">Class cl2 = Double[].class</span><br></pre></td></tr></table></figure>
<p>返回类名：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.getClass().getName();</span><br></pre></td></tr></table></figure></p>
<p>比较：<br>虚拟机为每个类型管理一个Class对象。所以class比较只需要用==即可</p>
<p>创建实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e.getClass().newInstance();</span><br><span class="line"><span class="comment">//forName()配合使用</span></span><br><span class="line">String s = <span class="string">"java.util.Random"</span>;</span><br><span class="line">Object m = Class.forName(s).newInstance();</span><br></pre></td></tr></table></figure>
<p> <img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/反射.png" alt="反射"></p>
<h2 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h2><p><strong>检查类的结构</strong><br>java.lang.reflect中的三各类</p>
<table>
<thead>
<tr>
<th>类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Field</td>
<td>类的域</td>
</tr>
<tr>
<td>Method</td>
<td>类的方法</td>
</tr>
<tr>
<td>Constructor</td>
<td>类的构造器</td>
</tr>
</tbody>
</table>
<p>如下图<br>getFields、getMethods、getConstructors返回类提供的public的域、方法和构造器数组。<br>getDeclaredFields、getDeclaredMethods、getDeclaredConstructors返回类中所有的域、方法和构造器数组<br><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/Class.png" alt="Class"></p>
<p>如下图，出特别标注外，其他都是Field、Method、Constructor的公有方法<br><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/反射2.png" alt="反射2"></p>
<p>Modifier类可以通过返回的整数数值，进行相关判断。</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/Modifier.png" alt="Modifier"></p>
<h2 id="在运行时使用反射分析对象"><a href="#在运行时使用反射分析对象" class="headerlink" title="在运行时使用反射分析对象"></a>在运行时使用反射分析对象</h2><p>查看数据域的实际内容：<br>其中，Object obj 是一个包含该域的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field.get(Object obj)</span><br></pre></td></tr></table></figure></p>
<p>实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Employee maorl = <span class="keyword">new</span> Employee(<span class="string">"maorl"</span>, <span class="number">39999</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1994</span>);</span><br><span class="line">Class aClass = maorl.getClass();</span><br><span class="line"><span class="comment">// name域是Employee的一个私有域</span></span><br><span class="line">Field aField = aClass.getDeclareField(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//获取具体值</span></span><br><span class="line">Object value = aField.get(masorl);</span><br></pre></td></tr></table></figure></p>
<p>在这里，name是一个私有域，因为反射机制的默认是受Java访问控制的，所以get()方法会抛出一个IllegalAccessException。<br>如果一个Java程序没有受到安全管理器的控制，就可以覆盖访问控制。为了达到这个目的，可以使用Field、Method、Constructor对象的 <em>setAccessible</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aFiled.setAcessible(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure></p>
<p>此时，我们可以访问得到name域的值了。  </p>
<p><strong>get()自动打包</strong><br>对于get()方法如果域是一个String,那么返回成Object是没有问题的。但如果是一个基本数据类型，get()方法会自动将值打包成对象。</p>
<p><strong>设置域</strong><br>get()方法用来获取域的值，那么对应的，set(Obj, value)方法用来设置域值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aFiled.set(maosrl, <span class="string">"newName"</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/反射3.png" alt="反射3"></p>
<h2 id="使用反射编写泛型数组代码"><a href="#使用反射编写泛型数组代码" class="headerlink" title="使用反射编写泛型数组代码"></a>使用反射编写泛型数组代码</h2><p>如何自己编写一个通用数组拷贝的的方法呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 数组拷贝</span></span><br><span class="line"><span class="comment">    * 主要为题：如要拷贝一个Employee数组，在执行玩方法后返回的是Object，需要能够成功强转</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 1. 解决的关键为Array.wInstance(Class&lt;?&gt; componentType, int length),它可以创建一个新的指定数组元素类型的数组</span></span><br><span class="line"><span class="comment">    * 2. 获取数组元素类型：Class.getComponentType(),该方法可以获取到数组类的元素类型</span></span><br><span class="line"><span class="comment">    * 3. 复制数组：System.arraycopy(Object src, int srcPos, Object dest, int destPos,int length)</span></span><br><span class="line"><span class="comment">    *      Object src：需要复制的源数组</span></span><br><span class="line"><span class="comment">    *      int srcPos：源数组复制起始位置</span></span><br><span class="line"><span class="comment">    *      Object dest：复制的目标数组</span></span><br><span class="line"><span class="comment">    *      int destPos：复制的目标数组的起始位置</span></span><br><span class="line"><span class="comment">    *      int length: 复制长度</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newLength</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object obj, <span class="keyword">int</span> newLength)</span></span>&#123;</span><br><span class="line">       Class&lt;?&gt; aClass = obj.getClass();</span><br><span class="line">       <span class="keyword">if</span> (!aClass.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       Class&lt;?&gt; componentType = aClass.getComponentType();</span><br><span class="line">       <span class="keyword">int</span> length = Array.getLength(aClass);</span><br><span class="line">       Object newArray = Array.newInstance(componentType, newLength);</span><br><span class="line">       System.arraycopy(obj, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(newLength, length));</span><br><span class="line">       <span class="keyword">return</span> newArray;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是Arrays.copyOf()的方法  </p>
<blockquote>
<ol>
<li>copyOf()两个参数的方法调用了三个参数的方法，把原始的数组类传了进去。  </li>
<li>通过三元运算符判断原始数据是否属于Object[]数组<br>   是Object就直接new Object[]<br>   否则需要调用Array.newInstance方法来创建新数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/Array3.png" alt="Array3"></p>
<h2 id="调用任意方法"><a href="#调用任意方法" class="headerlink" title="调用任意方法"></a>调用任意方法</h2><p>Java是没有方法指针的，即将一个方法的存储地址传给另一个方法，以便第二个方法能够调用它。</p>
<p>通过 Class.pgetMethod(String name, Class&lt;?&gt;… parameterTypes)来获取Method，需要提供方法的参数类。</p>
<p><strong>调用方法</strong>：  </p>
<ol>
<li><p>使用Method.invoke(Object obj, Object… args)进行调用<br>第一个obj为隐式参数(静态方法就传null,有点类似于feild.get()方法)<br>第二个数组对象为显示参数（在JavaSE 5.0以前必须传递，没有显示参数就传0）  </p>
</li>
<li><p>因为其返回类型为Object，所以需要进行相应的类型转换  </p>
</li>
<li>如果返回值是基本数据类型，会自动包装<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Employee maosrl = <span class="keyword">new</span> Employee(<span class="string">"maosrl"</span>, <span class="number">1000</span>);</span><br><span class="line">    Method toString = Employee.class.getMethod(<span class="string">"toString"</span>);</span><br><span class="line">    System.out.println((String)toString.invoke(maosrl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/Method.png" alt="Method"></p>
<h1 id="通过反射打印类的信息"><a href="#通过反射打印类的信息" class="headerlink" title="通过反射打印类的信息"></a>通过反射打印类的信息</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span> ) name = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">"输入Class名"</span>);</span><br><span class="line">            name = in.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过Class.forName获取类</span></span><br><span class="line"><span class="comment">         * 通过Class.getSuperclass()获取父类</span></span><br><span class="line"><span class="comment">         * 通过Modifier.toString(aClass.getModifiers()) 获取类的修饰符</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            打印类名、修饰符</span></span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(name);</span><br><span class="line">            Class&lt;?&gt; superclass = aClass.getSuperclass();</span><br><span class="line">            String modifiers = Modifier.toString(aClass.getModifiers());</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print( modifiers + <span class="string">""</span>);</span><br><span class="line">            System.out.print(<span class="string">" class "</span> + name);</span><br><span class="line"><span class="comment">//            打印父类</span></span><br><span class="line">            <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; superclass != Object.class) System.out.print(<span class="string">" extends "</span> + superclass.getName());</span><br><span class="line"><span class="comment">//            打印构造器、方法、域</span></span><br><span class="line">            System.out.print(<span class="string">"\n&#123;\n"</span>);</span><br><span class="line">            printConstructors(aClass);</span><br><span class="line">            System.out.println();</span><br><span class="line">            printMethods(aClass);</span><br><span class="line">            System.out.println();</span><br><span class="line">            printFields(aClass);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印类的所有构造器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 通过Class.getConstructors方法获取构造器数组</span></span><br><span class="line"><span class="comment">     * 通过Modifier.toString(Constructor.getModifiers()) 方法获取构造器的修饰符</span></span><br><span class="line"><span class="comment">     * 通过Constructor.getParameterTypes() 方法获取构造器参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aClass</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class aClass)</span> </span>&#123;</span><br><span class="line">        Constructor[] constructors = aClass.getConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        打印构造器名和修饰符</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            String name = constructor.getName();</span><br><span class="line">            System.out.print(<span class="string">"  "</span>);</span><br><span class="line">            String modifiers = Modifier.toString(constructor.getModifiers());</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">            System.out.print(name + <span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            打印参数类型</span></span><br><span class="line">            Class[] parameterTypes = constructor.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; parameterTypes.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) System.out.print(<span class="string">","</span>);</span><br><span class="line">                System.out.print(parameterTypes[j].getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">");"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印类的所有方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 通过Class.getDeclaredMethods()获取类的所有方法</span></span><br><span class="line"><span class="comment">     * 通过Method.getReturnType(); 获取方法的返回类型</span></span><br><span class="line"><span class="comment">     * 通过Modifier.toString(Method.getModifiers()) 方法获取方法的修饰符</span></span><br><span class="line"><span class="comment">     *  通过Method.getParameterTypes() 方法获取构造器参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aClass</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class aClass)</span></span>&#123;</span><br><span class="line">            Method[] methods = aClass.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">//            打印类方法名、修饰符、返回类型</span></span><br><span class="line">            <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">                Class&lt;?&gt; type = method.getReturnType();</span><br><span class="line">                String name = method.getName();</span><br><span class="line">                System.out.print(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">int</span> modifiers1 = method.getModifiers();</span><br><span class="line">                String modifiers = Modifier.toString(modifiers1);</span><br><span class="line">                <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">                System.out.print(type.getName() + <span class="string">" "</span> + name + <span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印参数类型</span></span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; parameterTypes.length; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) System.out.print(<span class="string">","</span>);</span><br><span class="line">                    System.out.print(parameterTypes[j].getName());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过Class.getDeclaredFields()获取类的所有域</span></span><br><span class="line"><span class="comment">     * 通过Field.getType()获取域的类型</span></span><br><span class="line"><span class="comment">     * 通过Modifier.toString(field.getModifiers()) 获取域的修饰符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aClass</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class aClass)</span></span>&#123;</span><br><span class="line">        Field[] fields = aClass.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields)&#123;</span><br><span class="line">            Class&lt;?&gt; type = field.getType();</span><br><span class="line">            String name = field.getName();</span><br><span class="line">            System.out.print(<span class="string">" "</span>);</span><br><span class="line">            String modifiers = Modifier.toString(field.getModifiers());</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">""</span>);</span><br><span class="line">            System.out.println(type.getName() + <span class="string">" "</span> + name + <span class="string">";"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="利用反射编写通用toString，打印对象的域值"><a href="#利用反射编写通用toString，打印对象的域值" class="headerlink" title="利用反射编写通用toString，打印对象的域值"></a>利用反射编写通用toString，打印对象的域值</h1><p>ObjectAnalyzer类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.AccessibleObject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnalyzer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Object&gt; visited = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印对象域的值</span></span><br><span class="line"><span class="comment">     * 1. Null 值：直接返回"null"</span></span><br><span class="line"><span class="comment">     * 2. ArrayList visited：防止无限递归</span></span><br><span class="line"><span class="comment">     * 3. 获取对象的类</span></span><br><span class="line"><span class="comment">     * 4. 如果是String类，直接返回数值即可</span></span><br><span class="line"><span class="comment">     * 5. 如果是数组类</span></span><br><span class="line"><span class="comment">     *       获取数组的组件类：Class.getComponentType()方(如 int[]对象，返回int.class, Integer[] 返回 Integer.class)</span></span><br><span class="line"><span class="comment">     *       遍历数组，分两种情况</span></span><br><span class="line"><span class="comment">     *       1）对于基本类型数组：Class.isPrimitive()判断是否属于基本类型的类,可以直接处理值</span></span><br><span class="line"><span class="comment">     *       2) 对于对象数组：则需要递归使用toString()来处理其中的域值</span></span><br><span class="line"><span class="comment">     * 6. 如果是对象类，先要获取它的域值：</span></span><br><span class="line"><span class="comment">     *       1）获取所有域：Class.getDeclaredFields()；</span></span><br><span class="line"><span class="comment">     *       2）要获取值，使用AccessibleObject.setAccessible(Field[] field, true); 来批量接解除的访问控制</span></span><br><span class="line"><span class="comment">     *       3）遍历域：</span></span><br><span class="line"><span class="comment">     *          I：获取域的类型，对于基础类型，可以直接处理值；对于对象类型，需要再次toString来递归处理域值</span></span><br><span class="line"><span class="comment">     *          II：除了当前对象的域值外，还需要处理它的父类，Class.getSuperclass()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains((obj))) <span class="keyword">return</span> <span class="string">"..."</span>;</span><br><span class="line">        visited.add(obj);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = obj.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理String类</span></span><br><span class="line">        <span class="keyword">if</span>(aClass == String.class) <span class="keyword">return</span> (String) obj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理数组</span></span><br><span class="line">        <span class="keyword">if</span> (aClass.isArray())&#123;</span><br><span class="line">            String result = aClass.getComponentType() + <span class="string">"[]&#123;"</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Array.getLength(obj); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) result += <span class="string">","</span>;</span><br><span class="line">                Object val = Array.get(obj, i);</span><br><span class="line">                <span class="comment">//isPrimitive 判断该类是否是一个基本类型(即int、double...)</span></span><br><span class="line">                <span class="keyword">if</span> (aClass.getComponentType().isPrimitive()) result += val;</span><br><span class="line">                <span class="keyword">else</span> result += toString(val); <span class="comment">//不是基础类型还需要再次调用toString方法进行转换</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result + <span class="string">"&#125;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String result = aClass.getName();</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            Field[] fields = aClass.getDeclaredFields();</span><br><span class="line">            AccessibleObject.setAccessible(fields, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Field field : fields)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!Modifier.isStatic(field.getModifiers()))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!result.endsWith(<span class="string">"["</span>)) result += <span class="string">","</span>;</span><br><span class="line">                    result += field.getName() + <span class="string">"="</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Class&lt;?&gt; type = field.getType();</span><br><span class="line">                        Object val = field.get(obj);</span><br><span class="line">                        <span class="keyword">if</span> (type.isPrimitive()) result += val;</span><br><span class="line">                        <span class="keyword">else</span> result += toString(val);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result += <span class="string">"]"</span>;</span><br><span class="line">            aClass = aClass.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (aClass != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnalyzerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; squares = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) squares.add(i * i);</span><br><span class="line">        <span class="keyword">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ObjectAnalyzer().toString(squares));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ObjectAnalyzer().toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2018/02/02/java.9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2018/02/02/java.9/" class="post-title-link" itemprop="url">java 基础:Object类</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-02 00:00:09" itemprop="dateCreated datePublished" datetime="2018-02-02T00:00:09-05:00">2018-02-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-09 08:53:34" itemprop="dateModified" datetime="2019-04-09T08:53:34-04:00">2019-04-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/JavaSe教程/" itemprop="url" rel="index"><span itemprop="name">JavaSe教程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Object 类是 Java 中所有类的始祖， 在 Java 中每个类都是由它扩展而来的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            timeout++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Java 中，只有基本类型 （ primitive types) 不是对象， 例如，数值、 字符和布尔类型的 值都不是对象。</p>
<h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h2><p>Object 类的equals方法判断两个对象是否具有相同的引用。  </p>
<p><strong>Java语言规范下的equals</strong></p>
<ol>
<li>自反性：对于任何非空引用x，x.equals(x)应该返回true</li>
<li>对称性：对于任何引用x和y，当且仅当y.equals(x)返回true，x.equals(y)也应该返回true</li>
<li>传递性：对于任何引用x、y、z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true</li>
<li>一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果</li>
<li>对于任何非空引用x，x.equals(null)应该返回true</li>
</ol>
<p><strong>完美equals建议</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先判断地址相同</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果传入参数为null，无需比较</span></span><br><span class="line">        <span class="keyword">if</span>(otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//类不同，肯定不同</span></span><br><span class="line">        <span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">        <span class="comment">//此时可知参数是非null 的E类了</span></span><br><span class="line">        E other = (E)otherObject;</span><br><span class="line">        <span class="comment">//比较直，对象用equals比较，防止null值;数值用==比较</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, other.name)</span><br><span class="line">        &amp;&amp; phone == other.phone</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2><p>散列码（ hash code ) 是由对象导出的一个整型值，其值为对象的 <em>存储地址</em><br>如果重新定义 equals方法，就必须重新定义 hashCode 方法， 以便用户可以将对象插入到散列表中<br>如：这是一个由name、salary、hireDay组成的hashCode编码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, salary, hireDay)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javase/hashcode.png" alt="hashcode"></p>
<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p>强烈建议为自定义的每一个类增加toString方法。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2018/02/02/java.8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2018/02/02/java.8/" class="post-title-link" itemprop="url">java 基础:修饰符</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-02 00:00:08" itemprop="dateCreated datePublished" datetime="2018-02-02T00:00:08-05:00">2018-02-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-09 08:53:34" itemprop="dateModified" datetime="2019-04-09T08:53:34-04:00">2019-04-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/JavaSe教程/" itemprop="url" rel="index"><span itemprop="name">JavaSe教程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>声明为static的变量实质上就是全局变量</p>
<p>声明为static的方法有以下几条限制</p>
<ol>
<li>它们仅能调用其他的static方法。</li>
<li>它们只能访问static数据。</li>
<li>它们不能以任何方式引用this或super</li>
</ol>
<h2 id="静态域和静态方法"><a href="#静态域和静态方法" class="headerlink" title="静态域和静态方法"></a>静态域和静态方法</h2><p>静态域（类域）：属于类，而不属于任何独立的对象，所有对象共享。　　</p>
<p>静态方法：一种不能向对象实施操作的方法，没有隐式参数  </p>
<p>静态常量: static final修饰</p>
<h2 id="使用静态方法的情况"><a href="#使用静态方法的情况" class="headerlink" title="使用静态方法的情况"></a>使用静态方法的情况</h2><ol>
<li>方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow（））</li>
<li>一个方法只需要访问类的静态域</li>
</ol>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="作用一：定义常量"><a href="#作用一：定义常量" class="headerlink" title="作用一：定义常量"></a>作用一：定义常量</h2><p>变量可以声明为final,这样做的目的是阻止它的内容被修改  </p>
<p>final域：构建对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改</p>
<h2 id="作用二和三"><a href="#作用二和三" class="headerlink" title="作用二和三"></a>作用二和三</h2><p>用于继承中，详细请看（7）继承：继承中使用final</p>
<h1 id="访问控制（作用域）"><a href="#访问控制（作用域）" class="headerlink" title="访问控制（作用域）"></a>访问控制（作用域）</h1><table>
<thead>
<tr>
<th>作用域</th>
<th>当前类</th>
<th>同一package</th>
<th>子孙类</th>
<th>其他package</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>对所有类可见</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>对本包和所有子类可见</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>对本包可见,默认</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>仅对本类可见</td>
</tr>
</tbody>
</table>
<p>对于类来说，只有默认和public两种访问级别</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/toux.jpg" alt="Liisyu">
            
              <p class="site-author-name" itemprop="name">Liisyu</p>
              <div class="site-description motion-element" itemprop="description">我只是一个兴趣使然的程序员</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/blog/archives/">
                
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/blog/categories/">
                    
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/blog/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/FameLsy" title="GitHub &rarr; https://github.com/FameLsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:575600714@qq.com.com" title="E-Mail(QQ) &rarr; mailto:575600714@qq.com.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>E-Mail(QQ)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:swordmaster2014@gmail.com" title="E-Mail(Google) &rarr; mailto:swordmaster2014@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>E-Mail(Google)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/masorl" title="CSDN &rarr; https://blog.csdn.net/masorl" rel="noopener" target="_blank"><i class="fa fa-fw fa-tree"></i>CSDN</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="tencent://message/?uin=575600714&Site=qq&Menu=yes" title="QQ &rarr; tencent://message/?uin=575600714&Site=qq&Menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-QQ"></i>QQ</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liisyu</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/blog/js/utils.js?v=7.1.0"></script>

  <script src="/blog/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/blog/js/schemes/muse.js?v=7.1.0"></script>



  

  


  <script src="/blog/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
