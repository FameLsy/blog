<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/blog/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="java 并发">
<meta property="og:type" content="article">
<meta property="og:title" content="Liisyu Blog">
<meta property="og:url" content="https://masol.gitee.io/blog/2018/02/02/java-thread.all/index.html">
<meta property="og:site_name" content="Liisyu Blog">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389510.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/locks%E5%8C%85.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread10.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/locksupport.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/concurrentHashMap.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/concurrentLinkedQueue.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/BlockingQueue.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/xcc.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/scc2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/executor.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/executor2.png">
<meta property="og:updated_time" content="2019-04-26T07:10:36.875Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Liisyu Blog">
<meta name="twitter:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389510.jpg">





  
  
  <link rel="canonical" href="https://masol.gitee.io/blog/2018/02/02/java-thread.all/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title> | Liisyu Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liisyu Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/blog/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-navigation">

    
    
    
      
    

    

    <a href="/blog/navigation/" rel="section"><i class="menu-item-icon fa fa-fw fa-diamond"></i> <br>导航</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2018/02/02/java-thread.all/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-03 00:00:01" itemprop="dateCreated datePublished" datetime="2018-02-03T00:00:01+08:00">2018-02-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-26 15:10:36" itemprop="dateModified" datetime="2019-04-26T15:10:36+08:00">2019-04-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389510.jpg" alt></p>
<a id="more"></a>
<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><p>现代操作系统在运行一个程序时，会为其创建一个<code>进程</code> 。而<code>线程</code>，是现代操作系统调度的最小单元，也叫<code>轻量级进程</code>；</p>
<p>线程好处</p>
<ol>
<li>更好的利用处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ol>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p> 既然要运行线程，必然需要创建线程对象，java有三种创建线程的方式</p>
<ol>
<li>通过java.lang.Runnable接口(推荐)</li>
<li>继承java.lang.Thread类</li>
<li>使用线程池获取线程对象(详细看<strong>《Excutor框架》</strong>)</li>
</ol>
<h3 id="通过java-lang-Runnable接口-推荐"><a href="#通过java-lang-Runnable接口-推荐" class="headerlink" title="通过java.lang.Runnable接口(推荐)"></a>通过java.lang.Runnable接口(推荐)</h3><p> Runnable接口只有一个run()方法，是一个函数式接口，所以可以运用lambda表达式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Runnable接口源码</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 具体实现方式为</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lambda表达式，省去了实现Runnable接口</span></span><br><span class="line"><span class="comment">//task code 写run()方法的实际逻辑处理</span></span><br><span class="line">Runnable runnable = () -&gt;&#123;task code&#125;</span><br><span class="line">Thread threadA = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">Thread threadB = <span class="keyword">new</span> Thread(runnable);</span><br></pre></td></tr></table></figure></div>
<h3 id="继承java-lang-Thread"><a href="#继承java-lang-Thread" class="headerlink" title="继承java.lang.Thread"></a>继承java.lang.Thread</h3><p> 具体实现方式为</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承Thread并重写run()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h3><p> 为什么要选择通过java.lang.Runnable接口的方式创建线程？</p>
<ol>
<li>将运行机制和任务进行分开解耦,Thread类负责运行机制，Runnable接口负责任务方法</li>
<li>减少线程开销，如果使用方式二，对于每个任务都需要创建一个线程；而方式一可以通过传入不同的Runnable,来实现一个线程执行不同任务</li>
</ol>
<h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><p> 线程对象在初始化完成之后,调用如下方法启动线程</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aThread.start()</span><br></pre></td></tr></table></figure></div>
<p> <strong>aThread.run()并不是启动线程，只是运行了run()方法</strong>  </p>
<h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>线程有多种终止线程的方式. 分为主动、被动</p>
<ul>
<li><p>被动：</p>
<p>a. run方法执行到最后一句，并且return返回</p>
<p>b. 出现了方法中没有捕获的异常</p>
</li>
<li><p>主动</p>
<p>a. 使用stop()，已经废弃</p>
<p>b. 通过Thread类提供的<code>interrupt()</code>方法请求中断线程</p>
<p>c. 使用boolean变量控制</p>
</li>
</ul>
<h3 id="interrupt-中断线程"><a href="#interrupt-中断线程" class="headerlink" title="interrupt() 中断线程"></a>interrupt() 中断线程</h3><p> 线程通过一标识位属性，来表示该线程是否被中断；中断某个线程，实际就是设置这个标识位</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中断某个线程</span></span><br><span class="line">aThread.interrupt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程是否中断</span></span><br><span class="line"><span class="comment">//如果线程中断，则返回true；但如果线程已经终止，那么无论是否被中断过，都会返回false</span></span><br><span class="line">aThread.isInterrupted();</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法，对当前线程的中断标识位进行复位</span></span><br><span class="line">Thread.interrupted();</span><br></pre></td></tr></table></figure></div>
<p> 此外，许多声明抛出<code>InterruptedException</code>的方法在抛出<code>InterruptedException</code>之前，Java虚拟机会先将该线程的中断标识位清除</p>
<h3 id="使用boolean变量中断"><a href="#使用boolean变量中断" class="headerlink" title="使用boolean变量中断"></a>使用boolean变量中断</h3><p>通过一个symbol变量，来控制线程的中断</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runner runner = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);<span class="comment">//线睡眠5秒</span></span><br><span class="line">        runner.cancel();<span class="comment">//中断</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="comment">//定义标志位</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> symbol = <span class="keyword">true</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//只要symbol 为true 或者 线程没有中断，则run方法就就一直进行下去</span></span><br><span class="line">            <span class="keyword">while</span> (symbol &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                <span class="comment">//something to do</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将symbol置为false，以终止线程</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">            symbol = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread1.png" alt="thread1"></p>
<p> 获取线程状态    </p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java 5新增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div>
<p> Thread在内部定义了一个枚举类</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line"></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="NEW（新创建）状态"><a href="#NEW（新创建）状态" class="headerlink" title="NEW（新创建）状态"></a>NEW（新创建）状态</h3><p> 创建了线程但没有执行start()方法，此时处于新创建状态</p>
<h3 id="RUNNABLE-可运行-状态"><a href="#RUNNABLE-可运行-状态" class="headerlink" title="RUNNABLE (可运行) 状态"></a>RUNNABLE (可运行) 状态</h3><p> 调用了start()方法的线程就处于RUNNABLE状态，需要注意的是，该状态下的线程可能正在运行，也可能没有运行，所以是<em>运行</em>态</p>
<h3 id="BLOCKED-（阻塞）状态"><a href="#BLOCKED-（阻塞）状态" class="headerlink" title="BLOCKED （阻塞）状态"></a>BLOCKED （阻塞）状态</h3><p> 当系统试图获取一个内部的对象锁（注意，不是java.util.concurrent库中的锁），但该锁已被其他锁持有，当前线程就会进入阻塞状态</p>
<h3 id="WAITING-等待-状态"><a href="#WAITING-等待-状态" class="headerlink" title="WAITING (等待)状态"></a>WAITING (等待)状态</h3><p> 调用Object.wait方法、Thread.join方法，或者等待java.util.concurrent库中的Lock或Condition时,会进入等待状态</p>
<h3 id="TIME-WAITING-计时等待-状态"><a href="#TIME-WAITING-计时等待-状态" class="headerlink" title="TIME_WAITING (计时等待)状态"></a>TIME_WAITING (计时等待)状态</h3><p> 线程因调用了某些带超时参数的方法时，会计入该状态。该状态会持续到超时期满或者接收到适当的通知</p>
<h3 id="TERMINATER-终止-状态"><a href="#TERMINATER-终止-状态" class="headerlink" title="TERMINATER (终止)状态"></a>TERMINATER (终止)状态</h3><p> 线程终止时的状态</p>
<h3 id="线程状态的变迁"><a href="#线程状态的变迁" class="headerlink" title="线程状态的变迁"></a>线程状态的变迁</h3><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread2.png" alt="thread2"></p>
<p> Java将操作系统中的<code>运行</code>和<code>就绪</code>两个状态合并称为可运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在<code>java.concurrent</code>包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了<code>LockSupport</code>类中的相关方法</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p> <code>Thread</code>类定义了三个<code>优先级常量</code>和一个<code>成员变量 *priority*</code> ，利用该成员变量来控制优先级;优先级的范围: 1~10,默认5</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>
<p> 设置优先级  (需要注意的是，优先级收操作系统的影响，如在ubuntu下会忽略线程优先级)</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aThread.setPriority(<span class="keyword">int</span> level)</span><br></pre></td></tr></table></figure></div>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p><code>守护线程</code>是一种支持型线程,它主要被用作程序中后台调度以及支持性工作，当只有守护线程时，Java虚拟机会退出 </p>
<p> <code>Thread</code>类定义了一个<code>成员变量 daemon</code> 来标识该线程是否为<code>守护线程</code>,</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Whether or not the thread is a daemon thread. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> daemon = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></div>
<p> 将线程设置成守护线程</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aThread.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></div>
<p> 需要注意的是</p>
<ol>
<li>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置</li>
<li>Daemon中的finally块并不一定执行(JVM提前退出)</li>
</ol>
<h2 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h2><p> <code>Thread</code>类中定义了两个处理器，用来处理run()方法可能出现的异常。run()方法不能抛出受查异常，而非受查异常会导致线程终止，但在线程终止之前，异常会被传到处理器中。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不设置，则未捕获异常处理器为空</span></span><br><span class="line"><span class="comment">// null unless explicitly set</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// null unless explicitly set</span></span><br><span class="line"><span class="comment">//静态的默认处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br></pre></td></tr></table></figure></div>
<p> 设置未捕获异常处理器</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 静态方法为每一个线程设置一个默认的处理器</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span></span></span><br></pre></td></tr></table></figure></div>
<p> 如果没有设置未捕获异常处理器的话，那么默认的异常处理器为<code>java.lang.ThreadGroup</code>类,该类是<code>UncaughtExceptionHandler</code>的实现类，其处理异常方式如下</p>
<ol>
<li>该线程有父线程，则执行父线程的<code>uncaughtException()</code>方法;没有，则进入2</li>
<li>调用<code>Thread.getDefaultUncaughtExceptionHandler()</code>,调用静态的默认处理器；如果返回null,则进入3</li>
<li>如果异常(Throwable)是<code>TreadDeath</code>的一个实例，则什么都不做；否则，进入4</li>
<li>线程名字一集<code>Throwable</code>的栈轨迹输出到<code>System.err</code>上</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">"Exception in thread \""</span></span><br><span class="line">                             + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h1><p>如果线程只是独立运行，那将毫无意义。当多个线程相互配合完成工作时，才会发挥巨大的价值。</p>
<h2 id="线程的安全性"><a href="#线程的安全性" class="headerlink" title="线程的安全性"></a>线程的安全性</h2><p>多线程在再带来巨大的性能的同时，也引发了安全问题</p>
<p>想要编写线程安全的代码，<strong>核心</strong>在于要对<code>对象状态</code><a href="【对象状态】本质上就是定义在状态变量上的值，该值可能影响其外部可见行为，可能包含其他以来对象的域。">^3</a>访问操作进行管理，特别是对<code>共享</code><a href="【共享(Shared)】变量可以由多个线程同时访问">^1</a>的和<code>可变</code><a href="【可变(Mutable)】变量的值在其生命周期内发生变化">^2</a>的状态的访问。当多个线程对一个对象的可变状态变量进行访问时，就可能引发线程安全性问题；所以<strong>必须得采用同步机制</strong>来协同这些线程对状态变量的访问；</p>
<p>java主要的同步机制有</p>
<ol>
<li>synchronized 关键字</li>
<li>volatile </li>
<li>Lock</li>
<li>原子变量</li>
</ol>
<h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>在线程的通信过程中，往往会出现：一个线程修改了对象的值，另一个线程感知变化，进行相应的操作。那系统需要保证一个线程改变时另一个线程能及时做出反应。而等待/通知机制，可以在确保及时性的同时，降低开销。</p>
<h3 id="等待-通知机制核心思想"><a href="#等待-通知机制核心思想" class="headerlink" title="等待/通知机制核心思想"></a>等待/通知机制核心思想</h3><ol>
<li>线程A调用对象O的wait()进入等待状态</li>
<li>线程B执行完程序后，调用对象O的notify()/notifyAll()方法</li>
<li>线程A收到通知从wait()方法返回，执行它的操作</li>
</ol>
<h3 id="等待-通知机制相关方法"><a href="#等待-通知机制相关方法" class="headerlink" title="等待/通知机制相关方法"></a>等待/通知机制相关方法</h3><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread3.png" alt="thread3"></p>
<p>调用<code>wait()、notify()</code>以及<code>notifyAll()</code>时需要注意的细节</p>
<ol>
<li>使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</li>
<li>调用wait()方法后,线程状态由RUNNING变为WAITING,并将当前线程放置到对象的等待队列。</li>
<li>notify()或notifyAll()方法调用后,等待线程依旧不会从wait()返回,需要调用notify()或notifAll()的线程释放锁之后,等待线程才有机会从wait()返回。</li>
<li>notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中,而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列,被移动的线程状态由WAITING变为BLOCKED。</li>
<li>从wait()方法返回的前提是获得了调用对象的锁</li>
</ol>
<h3 id="等待-通知经典范式"><a href="#等待-通知经典范式" class="headerlink" title="等待/通知经典范式"></a>等待/通知经典范式</h3><p>通过任务的不同，可以将线程分为</p>
<ol>
<li>等待方（消费者线程,感知变化，进行相应的操作）</li>
<li>通知方(生产者线程,修改某个对象的值)  </li>
</ol>
<p>等待方规则:</p>
<ol>
<li>获取锁对象</li>
<li>如果条件不满足,那么调用对象的wait()方法,被通知后仍要检查条件。</li>
<li>条件满足则执行对应的逻辑。</li>
</ol>
<p>伪代码:</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(aObject.class) &#123;</span><br><span class="line">    <span class="keyword">while</span>(condition) &#123;</span><br><span class="line">        aObject.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    doSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>通知方规则：</p>
<ol>
<li>获取所对象</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程。</li>
</ol>
<p>伪代码：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(aObject.class) &#123;</span><br><span class="line">    change condition to <span class="keyword">true</span>;</span><br><span class="line">    aObject.notifyAll();`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h2><p>管道流主要用于线程通信时的数据传输，而<strong>传输的媒介为内存</strong>。<code>Java.io</code>一共提供了四种具体的管道流实现</p>
<ul>
<li><p>PipedOutputStream：字节输出流</p>
</li>
<li><p>PipedInputStream：字节输入流</p>
</li>
<li><p>PipedReader：字符输入流</p>
</li>
<li><p>PipedWriter：字节输出流</p>
<p>对于管道流，<strong>输入/输出流必须绑定起来</strong>,也就是调用<code>connect()</code>方法,否则会抛出异常</p>
</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将输出流和输入流进行连接,否则在使用时会抛出IOException</span></span><br><span class="line">aPipedWriter.connect(aPipedReader);</span><br></pre></td></tr></table></figure></div>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        PipedWriter pipedWriter = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader pipedReader = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">//连接输入输出流</span></span><br><span class="line">        pipedReader.connect(pipedWriter);</span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(pipedReader), <span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 输出流将数据写入receive</span></span><br><span class="line">            <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                pipedWriter.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pipedWriter.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//读入数据并输出</span></span><br><span class="line">                <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="顺序执行，join-方法"><a href="#顺序执行，join-方法" class="headerlink" title="顺序执行，join()方法"></a>顺序执行，join()方法</h2><p>如果需要让线程A必须再另一个线程B执行完后再执行，可以在线程A中调用线程B的<code>join()</code>方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//超时等待，如果指定时间内线程没有执行完，直接返回</span></span></span><br><span class="line"><span class="function"><span class="comment">//millis： 微秒</span></span></span><br><span class="line"><span class="function"><span class="comment">//nanos： 额外的纳秒</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span></span></span><br></pre></td></tr></table></figure></div>
<p> join()的部分源码，可以看出，join()使用了通知/等待经典范式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁当前线程对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 条件不满足,继续等待</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 条件符合,方法返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="线程变量ThreadLocal"><a href="#线程变量ThreadLocal" class="headerlink" title="线程变量ThreadLocal"></a>线程变量ThreadLocal</h2><p>ThreadLocal,即<strong>线程变量(泛型)</strong>,是一个以<code>ThreadLocal</code>对象为键、任意对象为值的存储结构；一个线程可以根据一个<code>ThreadLocal</code>对象查询到绑定在这个线程上的一个值</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">ThreadLocal&lt;T&gt; aThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;T&gt;();</span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获取值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></div>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>以下是常用Profiler类，用于计算时间差</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="comment">// initialValue()方法用于设置get()方法的初始值</span></span><br><span class="line">        <span class="comment">//如果在调用get()方法前没有调用set()方法，那么get()会在第一次调用时会调用initialValu()方法来获取并设置初始值</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//返回初始值</span></span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="Java1-5之前的线程安全"><a href="#Java1-5之前的线程安全" class="headerlink" title="Java1.5之前的线程安全"></a>Java1.5之前的线程安全</h1><h2 id="锁对象和条件对象"><a href="#锁对象和条件对象" class="headerlink" title="锁对象和条件对象"></a>锁对象和条件对象</h2><h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p> 如下代码，一旦一个线程封锁了锁对象，其他任何线程都无法通过<code>lock()</code>语句，<strong>会被阻塞</strong>，直到第一个线程释放锁对象</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    myLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="条件对象Condition"><a href="#条件对象Condition" class="headerlink" title="条件对象Condition"></a>条件对象Condition</h3><p><code>Condition</code>用于管理那些获得锁但无法执行有用工作的线程，当条件不满足时，<strong>先主动释放掉锁，进入等待状态</strong>，等到条件满足在进行操作。一个锁对象，可以对应对各条件对象</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadA</span></span><br><span class="line">myLcok.lock();<span class="comment">//锁定</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//获取一个条件对象</span></span><br><span class="line">    aCondtion = myLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当条件不满足时，通过条件对象让线程阻塞，并释放锁</span></span><br><span class="line">    <span class="comment">//该线程很一直处于阻塞状态，直到其他线程aCondition.signal()，唤醒等待的线程</span></span><br><span class="line">    <span class="comment">//被唤醒后如果条件满足，则可以退出循环，继续操作了</span></span><br><span class="line">    <span class="keyword">while</span>(!(ok to proceed))&#123;</span><br><span class="line">        aCondition.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 条件对象需要设置几个方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让线程阻塞并释放锁</span></span><br><span class="line">await();</span><br><span class="line"><span class="comment">//唤醒单个被await()阻塞的队列</span></span><br><span class="line">signal();</span><br><span class="line"><span class="comment">//唤醒所有被await()阻塞的队列</span></span><br><span class="line">signalAll()</span><br></pre></td></tr></table></figure></div>
<p> 在Object中，已经定义了三个类似的方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让线程阻塞并释放锁</span></span><br><span class="line">wait();</span><br><span class="line"><span class="comment">//唤醒单个被await()阻塞的队列</span></span><br><span class="line">notify();</span><br><span class="line"><span class="comment">//唤醒所有被await()阻塞的队列</span></span><br><span class="line">notifyAll();</span><br></pre></td></tr></table></figure></div>
<p>为什么要设置两套唤醒方法？</p>
<ul>
<li>其实在java1.5 前，只能通过关键字synchronized关键字来隐式获取锁对象和条件对象,或者传入显式的对象，即所有方法都可以锁对象，而且，并不能直接获取条件对象，所以，在Object中设置了三个关于唤醒等待的方法</li>
<li>而java1.5之后，有了专门的显式锁，同时可以显式获取到对应的条件对象，为了区分两者，所以就有了两套</li>
</ul>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p> java是支持多个线程访问同一个对象或者对象的成员变量，但每个线程，拥有的是它们的<strong>拷贝</strong>.因此，这个拷贝的对象<strong>可能不是最新</strong>的。当然，如果使用<code>锁机制</code>的话肯定没问题，但如果仅仅为了读写一两个实例域而使用锁，<strong>开销就显得有点大</strong>了。volatile关键字就是为<code>实例域</code>提供了一种免锁的机制。</p>
<h3 id="Volatile工作方式"><a href="#Volatile工作方式" class="headerlink" title="Volatile工作方式"></a>Volatile工作方式</h3><ol>
<li>访问数据时，告知程序需要从共享内存中获取</li>
<li>改变数据时，告知程序需要同步刷新回共享内存。</li>
<li>保证所有线程对变量访问的可见性，但不保证其原子性</li>
</ol>
<h3 id="Volatile使用条件"><a href="#Volatile使用条件" class="headerlink" title="Volatile使用条件"></a>Volatile使用条件</h3><p> 如果想要使用volatile来达到到线程安全，必须同时满足下面两个条件</p>
<ol>
<li><p>对变量的写操作不依赖于当前值(如x++,其操作其实是读-&gt;添加-&gt;赋值三个操作，需要保证原子性，所以不能使用volatile)</p>
</li>
<li><p>该变量没有包含在具有其他变量的不变式中</p>
</li>
</ol>
<h3 id="正确使用-volatile-示例"><a href="#正确使用-volatile-示例" class="headerlink" title="正确使用 volatile 示例"></a>正确使用 volatile 示例</h3><h4 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h4><p> 实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; shutdownRequested = <span class="keyword">true</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//每次循环，都会读取最新的shutdownRequested值，如果使用synchronized,就需要加锁，阻塞、唤醒等一些列操作</span></span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="一次性安全发布"><a href="#一次性安全发布" class="headerlink" title="一次性安全发布"></a>一次性安全发布</h4><p>对于以下语句，实际上又三个步骤</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>对象指向内存空间</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theFlooble = <span class="keyword">new</span> Flooble();</span><br></pre></td></tr></table></figure></div>
<p> 但实际上，2，3可能重排，变为</p>
<ol>
<li>分配内存空间</li>
<li>对象指向内存空间</li>
<li><p>初始化对象</p>
<p>再看如下代码</p>
</li>
<li><p>Thread A进行initInBackground()时，到达第二步，对象指向内存空间</p>
</li>
<li>Thread B在此时读取theFlooble,不为空，但对象却还没初始化</li>
<li>使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundFloobleLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do lots of stuff</span></span><br><span class="line">        theFlooble = <span class="keyword">new</span> Flooble();  <span class="comment">// this is the only write to theFlooble</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Thread B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="comment">// do some stuff...</span></span><br><span class="line">            <span class="comment">// use the Flooble, but only if it is ready</span></span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="keyword">null</span>) </span><br><span class="line">                doSomething(floobleLoader.theFlooble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p> java从1.0开始，每个对象都有一个<code>内部的对象锁</code>，关键字<code>synchronized</code>可以修饰<code>方法</code>或者<code>方法块</code>所使用的就是该对象的内部对象锁和相关的条件</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span> something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以把它看成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//this.intrinsicLock相当于内部对象锁</span></span><br><span class="line">    <span class="keyword">this</span>.intrinsicLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">do</span> something;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intrinsicLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 不同的是，内部对象只有一个条件对象(毕竟，不能显式的<code>newCondition</code>来获取条件对象)</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.intrinsiCondition.await();</span><br><span class="line"><span class="keyword">this</span>.intrinsiCondition.signal();</span><br><span class="line"><span class="keyword">this</span>.intrinsiCondition.signalAll();</span><br></pre></td></tr></table></figure></div>
<p> 事实上，<code>synchronized</code>关键字锁的是<code>this</code>,可以通过如下代码来验证</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种synchronized(obj)的方式通过一个对象来实现额外的原子操作，被称为客户端锁定，但并不推荐使用</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 此外，可以通过如下代码来验证关键字也可以使用在<strong>静态方法</strong>上，此时锁的是对象的<code>class文件</code>,可以通过如下代码来验证</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(aObject.class)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> synchronized带来便捷的同时，也存在了一些局限性</p>
<ol>
<li>不能中断一个试图获取锁的程序</li>
<li>试图获取锁不能设置超时</li>
<li>只能单一条件</li>
</ol>
<hr>
<h3 id="JVM中的synchronized"><a href="#JVM中的synchronized" class="headerlink" title="JVM中的synchronized"></a>JVM中的synchronized</h3><p>对于<code>同步块</code>的实现使用了<code>monitorenter</code>和<code>monitorexit</code>指令；<code>同步方法</code>则是依靠方法修饰符上的<code>ACC_SYNCHRONIZED</code>。本质是对一个对象的<code>监视器（monitor）</code>进行获取，而这个获取过程是排他的。</p>
<p>监视器</p>
<ol>
<li>任意一个对象都拥有自己的监视器</li>
<li>同步块或同步方法执行时必须获取该对象的监视器，才能进入；</li>
<li>没有获取到监视的线程将会被阻塞在同步块和同步方法的入口处，线程进入同步队列，状态变为BLOCKED状态。</li>
</ol>
<p>名词解释： </p>
<ol>
<li>可见性：一个线程对共享变量值的修改，能够及实地被其他线程看到 </li>
<li><p>排他性：即线程对块或方法的独立占有　</p>
<p>当两个或两个以上线程同时对同一数据进行访问修改，可能会出现错误。这种情况被称为<code>竞争条件(race condition)</code></p>
</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码会执行以下几个步骤</span></span><br><span class="line"><span class="comment">//1. 将account[1]加载到寄存器</span></span><br><span class="line"><span class="comment">//2. i +1</span></span><br><span class="line"><span class="comment">//3. 将结果写回account[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果线程A执行了第1、2步，被抢夺了运行权。线程B夺过并修改了i的值，此时再回到线程A执行第3步，就会发生错误。</span></span><br><span class="line">account[<span class="number">1</span>] = i++;</span><br></pre></td></tr></table></figure></div>
<h1 id="Locks包"><a href="#Locks包" class="headerlink" title="Locks包"></a>Locks包</h1><p>Java 1.5 之后添加了Locks包，在这之前，Java程序是靠synchronized来保障实现锁的功能。而Locks包的加入，使得对于锁的操作性更高</p>
<h2 id="Locks包结构"><a href="#Locks包结构" class="headerlink" title="Locks包结构"></a>Locks包结构</h2><p>UML图</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/locks%E5%8C%85.png" alt="locks"></p>
<p>主要的类</p>
<table>
<thead>
<tr>
<th>类/接口名</th>
<th>描述</th>
<th>Since</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbstractQueuedSynchronizer</td>
<td>队列同步器，是实现同步组件或锁的基本</td>
<td>1.5</td>
</tr>
<tr>
<td>Lock</td>
<td>锁接口</td>
<td>1.5</td>
</tr>
<tr>
<td>ReadWriteLock</td>
<td>读写锁接口</td>
<td>1.5</td>
</tr>
<tr>
<td>ReentrantLock</td>
<td>重入锁</td>
<td>1.5</td>
</tr>
<tr>
<td>ReentrantReadWriteLock</td>
<td>重入读写锁</td>
<td>1.5</td>
</tr>
<tr>
<td>Condition</td>
<td>用于支持Lock的等待/通知机制</td>
<td>1.5</td>
</tr>
<tr>
<td>LockSupport</td>
<td>提供对线程的阻塞和唤醒的方法</td>
<td>1.5</td>
</tr>
</tbody>
</table>
<p>后期添加的类</p>
<table>
<thead>
<tr>
<th>类/接口名</th>
<th>描述</th>
<th>Since</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbstractOwnableSynchronizer</td>
<td></td>
<td>1.6</td>
</tr>
<tr>
<td>AbstractQueuedLongSynchronizer</td>
<td></td>
<td>1.6</td>
</tr>
<tr>
<td>StampedLock</td>
<td></td>
<td>1.8</td>
</tr>
</tbody>
</table>
<h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><p> Java SE 5之后，并发包中新增了Lock接口,在使用时需要显式地获取和释放锁。 Lock接口提供的synchronized关键字不具备的主要特性</p>
<h2 id="Lock特性"><a href="#Lock特性" class="headerlink" title="Lock特性"></a>Lock特性</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread4.png" alt="thread4"></p>
<h2 id="Lock的API"><a href="#Lock的API" class="headerlink" title="Lock的API"></a>Lock的API</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread5.png" alt="thread5"></p>
<h2 id="Lock的使用"><a href="#Lock的使用" class="headerlink" title="Lock的使用"></a>Lock的使用</h2><p>Lock的使用非常简单,但需要注意：</p>
<ul>
<li>不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="队列同步器-AbstractQueuedSynchronizer"><a href="#队列同步器-AbstractQueuedSynchronizer" class="headerlink" title="队列同步器(AbstractQueuedSynchronizer)"></a>队列同步器(AbstractQueuedSynchronizer)</h1><p>队列同步器</p>
<ul>
<li>简称<strong>AQS</strong>，是一个抽象类，是用来构建锁或者其他同步组件的基础框架,<strong>是实现锁或同步组件的关键</strong></li>
<li>设计：基于模板方法模式，使用了一个<strong>int成员变量表示同步状态</strong>，通过内置的<strong>FIFO队列</strong>来完成资源获取线程的排队工作。</li>
<li>子类通过继承它（推荐定义成静态内部类），<strong>来进行管理同步状态</strong></li>
</ul>
<h2 id="AQS管理同步状态"><a href="#AQS管理同步状态" class="headerlink" title="AQS管理同步状态"></a>AQS管理同步状态</h2><p>AQS主要提供三个方法来改变或访问同步状态</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前同步状态。</span></span><br><span class="line">getState()</span><br><span class="line"><span class="comment">//设置当前同步状态。</span></span><br><span class="line">setState(<span class="keyword">int</span> newState)：</span><br><span class="line"><span class="comment">//使用CAS设置当前状态，该方法能够保证状态设置的原子性</span></span><br><span class="line">compareAndSetState(<span class="keyword">int</span> expect,<span class="keyword">int</span> update)：</span><br></pre></td></tr></table></figure></div>
<h2 id="AQS可重写的方法"><a href="#AQS可重写的方法" class="headerlink" title="AQS可重写的方法"></a>AQS可重写的方法</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread6.png" alt="thread6"></p>
<h2 id="AQS提供的模板方法"><a href="#AQS提供的模板方法" class="headerlink" title="AQS提供的模板方法"></a>AQS提供的模板方法</h2><p> 实现自定义同步组件时，将会调用同步器提供的模板方法，而模板方法就会调用AQS可重写的那些个方法。同步器提供的模板方法如下,其大致分为三类</p>
<ol>
<li>独占式获取与释放同步状态</li>
<li>共享式获取与释放同步状态</li>
<li>查询同步队列中的等待线程情况</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread7.png" alt="thread7"></p>
<h2 id="AQS的使用"><a href="#AQS的使用" class="headerlink" title="AQS的使用"></a>AQS的使用</h2><p>想要实现一个锁或者组件，步骤如下</p>
<ul>
<li><p>在锁或组件类内部创建一个继承于AQS的静态内部类</p>
</li>
<li><p>确定是独占式还是共享式，然后选择相应的AQS方法进行重写</p>
<p>a. 独占式：重写<code>tryAcquire()</code>和<code>tryRelease()</code>方法</p>
<p>b. 共享式：重写<code>tryAcquireShared()</code>和<code>tryReleaseShared()</code>方法</p>
</li>
<li><p>重写<code>isHeldExclusively()</code>方法，用于判断当前线程是否被独占</p>
</li>
<li><p>维护一个AQS子类成员，将所有的操作委托给该成员。可以直接使用重写过的方法，也可以使用AQS提供的模板方法（模板方法会调用重写过的方法）</p>
</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同步器子类Sync，推荐定义为内部静态类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为是独占锁，所以需要重写独占式获取和释放同步状态的方法，即tryAcquire()和tryRelease()</span></span><br><span class="line"><span class="comment">         * 以及isHeldExclusively()方法：判断当前同步器是否在独占式模式下被占用</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//独占式的话。state == 1为占用，0表示没有占用</span></span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取锁，将状态设置为1，并设置当前线程为独占模式所有者</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//使用CAS方式来设置状态，只有成功设置状态，才进入方法体中，而其他线程都会因为设置失败而获取锁失败</span></span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//setExclusiveOwnerThread继承与AQS，它会将传入的值赋值给一个成员变量exclusiveOwnerThread</span></span><br><span class="line">                <span class="comment">// 该变量为Thread类型，表示独占模式同步的当前所有者，该变量可用于重入锁的判断</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 释放锁，将状态设置为0，清除独占模式的所有者</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果状态为0，说明没有锁可以释放，则抛出异常</span></span><br><span class="line">           <span class="keyword">if</span>(getState() == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//清除独占模式的所有者</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//将状态设置为0</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来将所有锁有关的操作代理到Sync</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="comment">// 获取锁,acquire为AQS的模板方法，意为独占式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="队列同步器的实现分析"><a href="#队列同步器的实现分析" class="headerlink" title="队列同步器的实现分析"></a>队列同步器的实现分析</h2><p> 实现一个队列同步器，主要包括以下四个部分</p>
<ol>
<li>同步队列</li>
<li>提供独占式同步状态获取与释放方法</li>
<li>提供共享式同步状态获取与释放方法</li>
<li>提供超时获取同步状态等同步器的核心数据结构与模板方法</li>
</ol>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p> 同步队列是为了将没有获取同步状态的线程先保存，然后通过<strong>FIFO双向队</strong>列完成 <strong>*`同步状态</strong>`* 的管理,其处理逻辑如下</p>
<ul>
<li>线程A和线程B同时获取同步状态，A获取成功，相当于获取到了锁；B获取失败后进入线程中断，将B打包成节点放入到队列尾部</li>
<li>线程A执行完毕，释放同步状态（释放锁），因为FIFO的原则，获取到队列的首节点，从节点获取到相应的线程信息，唤醒该线程，线程被唤醒后，再次尝试获取同步状态；</li>
</ul>
<h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>同步队列一版包含头节点和尾节点</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure></div>
<p>每一个节点的属性如下：</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread8.png" alt="thread8"></p>
<p> 以下是同步队列的基本结构</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread9.png" alt="thread9"></p>
<h4 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h4><p> 对于入列操作，因为可能又多个线程同时操作入列，所以需要保证其安全性，同步器提供了一个基于CAS的设置尾节点的方法<code>compareAndSetTail()</code></p>
<p> 入队的完整操作需要实现三个操作</p>
<ol>
<li>node.prev指向原tail节点</li>
<li>将node设置成tail节点</li>
<li>原tail节点的后继节点指向node</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node t = tail;</span><br><span class="line"><span class="comment">//node为需要入列的节点</span></span><br><span class="line"><span class="comment">//先将node的前驱节点设置为原tail节点</span></span><br><span class="line">node.prev = t;</span><br><span class="line"><span class="comment">// 通过CAS方法，判断tail是否于当前对象的tail一致（如果其他线程已经更改了tail，就会不一致）</span></span><br><span class="line"><span class="comment">//如果一致，那就将当前对象的tail更新为node(注意更新的是tail而不是t！！！)</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">    t.next = node;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>关于<code>compareAndSetTail()</code>,方法内使用了Unsafe工具类，该类提供了硬件级别的<strong>原子操作</strong></p>
<p>它一共由内存值（或者说偏移量）、期望值、更新值</p>
<ul>
<li>它会先判断内存值与期望值是否一致，一致才将内存值更新为更新值</li>
<li>this：需要更新的对象，结合<code>tailOffse</code>t计算出内存值</li>
<li>expect：期望值，该值用于比较</li>
<li>update：更新值，成功后更新的内存值（注意不是更新期望值）</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h4><p>设置首节点是通过获取同步状态成功的线程来完成的，能设置首节点的线程必定已经获取到了同步状态，所以不需要CAS，只需要将首系欸但设置为原首节点的后继结点并断开原首节点的next引用即可</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h3><h4 id="独占式同步状态获取释放流程"><a href="#独占式同步状态获取释放流程" class="headerlink" title="独占式同步状态获取释放流程"></a>独占式同步状态获取释放流程</h4><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread10.png" alt="thread10"></p>
<h4 id="获取流程"><a href="#获取流程" class="headerlink" title="获取流程"></a>获取流程</h4><p> AQS通过模板方法<code>acquire()</code>方法来进行独占式的同步状态获取</p>
<p>它会先使用<code>tryAcquire()</code>方法尝试获取同步状态，则由该方法返回；(详细看 《AQS工作原理》，对其进行重写)</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS源码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>如果获取失败，会调用addWaiter方法，将当前的线程构造成一个同步节点，加入到AQS的同步队列尾部</p>
<ul>
<li>首先它会尝试一次快速将节点加入到AQS同步队列</li>
<li>如果加入失败，那么就要调用<code>enq()</code>,以死循环的方式不断尝试将节点加入到同步队列，直到成功</li>
<li>最后方法会返回这个节点</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//尾节点</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试快速添加，可能由于多个请求并发进行而添加失败</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//尾节点设置为新节点的前驱节点</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">//使用compareAndSetTail,确保节点能够被线程安全添加列尾</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//快速添加失败，进入死循环添加，将并发添加节点的请求通过CAS变得“串行化”</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//通过“死循环”来保证节点的正确添加，CAS</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>成功创建节点并加入同步队列后，<code>acquireQueued()</code>会拿着这个节点，以死循环的方式获取同步状态，而获取同步状态的具体实现依旧是利用了<code>tryAcquire()</code>方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS</span></span><br><span class="line"><span class="comment">//在“死循环”中尝试获取同步状态，而只有 前驱节点 是头节点才能够尝试获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置中断标记</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//判断结点的前驱节点是否为头节点，因为头节点是获取成功状态的节点，如果当前节点的前驱节点是头节点的话，那么下一个获取同步状态的就是这个节点了</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p> 对于<code>selfInterrupt()</code>，它是当两种方式获取状态都失败后，让线程中断</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="释放流程"><a href="#释放流程" class="headerlink" title="释放流程"></a>释放流程</h4><p> 当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，唤醒其后继节点能够继续获取同步状态。因为独占式的释放并定时已经获取到同步状态的线程，所以不需要保证CAS</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//unparkSuccessor()使用LockSupport来唤醒处于等待状态的线程</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h3><p> 与独占式的区别在于:<strong>同一时刻能否有多个线程同时获取到同步状态</strong></p>
<h4 id="获取流程-1"><a href="#获取流程-1" class="headerlink" title="获取流程"></a>获取流程</h4><p>利用AQS的<code>acquireShared()</code>来共享式获取同步状态</p>
<ul>
<li><p>共享式获取同步状态与独占式实现的不同点在于</p>
<p>a. 独占式尝试获取同步状态返回的是布尔值</p>
<p>b. 共享式尝试获取同步状态返回的值是Int类型,只要int 大于等于0，就可以获取同步状态</p>
</li>
<li><p>共享式获取流程类似于独占式</p>
<p>a. 先通过<code>tryAcquireShared()</code>尝试获取</p>
<p>b. 获取失败进入<code>doAcquireShared()</code>以死循环方式获取</p>
</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryAcquireShared(int arg)方法会返回一个int，如果int大于0，说明能够获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="comment">//doAcquireShared()在当前节点的前驱节点为头节点时，会尝试获取同步状态，如果返回值大于等于0，表示获取成功</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="释放流程-1"><a href="#释放流程-1" class="headerlink" title="释放流程"></a>释放流程</h4><p> 通过调用<code>releaseShared(int arg)</code>方法释放同步状态，因为共享式的释放可以同步进行，所以需要使用 <code>doReleaseShared()</code>方法以死循环和CAS方式保证安全释放</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryReleaseShared:必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证,，因为释放同步状态的操作会同时来自多个线程。(独占式则不需要，因为是一个线程释放)</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h3><h4 id="独占式超时同步状态获取流程"><a href="#独占式超时同步状态获取流程" class="headerlink" title="独占式超时同步状态获取流程"></a>独占式超时同步状态获取流程</h4><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread11.png" alt="thread11"></p>
<h4 id="获取流程-2"><a href="#获取流程-2" class="headerlink" title="获取流程"></a>获取流程</h4><p>同步器通过调用<code>doAcquireNanos()</code>方法可以超时获取同步状态，即在指定的时间段内获取同步状态，其逻辑如下</p>
<ol>
<li>主要需要计算出需要睡眠的时间间隔<code>nanosTimeout</code>，公式为：<code>nanosTimeout-=now-lastTime</code>（其中now为当前唤醒时间，lastTime为上次唤醒时间）</li>
<li>如果<code>nanosTimeout</code>大于0则表示超时时间未到，需要重新计算超时间隔<code>nanosTimeout</code>，继续睡眠<code>nanosTimeout</code>纳秒，反之，表示已经超时</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上次唤醒时间</span></span><br><span class="line">        <span class="keyword">long</span> lastTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//-----------------重点-----------------------------</span></span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)</span><br><span class="line">                        &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">                <span class="comment">//计算时间，当前时间now减去睡眠之前的时间lastTime得到已经睡眠的时间delta，然后被原有超时时间nanosTimeout减去，得到了还应该睡眠的时间.当然如果小于0了，说明已经超时了</span></span><br><span class="line">                nanosTimeout -= now - lastTime;</span><br><span class="line">                lastTime = now;</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p> 如果<code>nanosTimeout</code>小于等于<code>spinForTimeoutThreshold</code>（1000纳秒）时，将不会使该线程进行超时等待，而是进入快速的<strong>自旋过程</strong>(非常短的超时等待无法做到十分精确)</p>
<h3 id="阻塞与唤醒"><a href="#阻塞与唤醒" class="headerlink" title="阻塞与唤醒"></a>阻塞与唤醒</h3><p>当线程获取同步状态失败后，系统会将其打包成node节点放入同步队列，然后在死循环中不断尝试获取同步状态。这里靠考虑一个问题，如果每个线程都在进行死循环获取，那么必定会导致性能下降。所以应当利用阻塞和唤醒机制，来避免这个问题。</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>在获取流程中，往往还存在这样一段代码，就是用来阻塞线程的</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt())&#123;</span><br><span class="line">       interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但是，当线程获取同步状态失败后，它不会立即阻塞，而是先通过<code>shouldParkAfterFailedAcquire()</code>方法来判断是否需要阻塞，它其流程为</p>
<ul>
<li>如果当前线程的前驱节点状态为<code>SINNAL</code>，则表明当前线程需要被阻塞（注意判断的是节点的状态，不是线程的状态）</li>
<li>如果当前线程的前驱节点状态为<code>CANCELLED</code>（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li>
<li>如果前驱节点非<code>SINNAL</code>，非<code>CANCELLED</code>，则通过<code>CAS</code>的方式将其前驱节点设置为<code>SINNAL</code>，返回false</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取前驱节点等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//如果前驱节点为等待状态，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果<code>shouldParkAfterFailedAcquire()</code>返回true了，就会执行<code>parkAndCheckInterrupt()</code>方法,将线程阻塞，同时返回中断状态</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">//调用LcokSupport 阻塞线程</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 返回中断状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>在唤醒节点的时候，可能发生后继节点为空或者被中断的情况，此时需要跳过该后继节点然后寻找合适的节点。而通常会从tail开始找起，原因在于node.next仍然可能会存在null或者取消了，所以采用tail回溯办法找第一个可用的线程</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前节点的状态</span></span><br><span class="line">       <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">//如果状态小于0，则设置为0</span></span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//后继节点</span></span><br><span class="line">       Node s = node.next;</span><br><span class="line">     <span class="comment">//后继节点为null或者其状态 &gt; 0 (超时或者被中断了)，则需要跳过后继节点，然后选择一个合适的节点</span></span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//从tail节点来找可用节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">           LockSupport.unpark(s.thread);<span class="comment">//通过LcokSupport来唤醒线程</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="重入锁-ReentrantLock"><a href="#重入锁-ReentrantLock" class="headerlink" title="重入锁(ReentrantLock)"></a>重入锁(ReentrantLock)</h1><p> 支持重进入的锁，它表示该锁能够支持<strong>同一个线程对资源的重复加锁</strong>，synchronized关键字是隐式支持重入的</p>
<p> 为什么要用到重入锁，如下场景</p>
<ol>
<li>线程A通过aLock.lock()获取了锁</li>
<li>锁未被释放，线程A再次aLock.lock()获取锁，此时将无法获取，导致自己被自己阻塞</li>
</ol>
<h2 id="实现重进入"><a href="#实现重进入" class="headerlink" title="实现重进入"></a>实现重进入</h2><p> 线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞,需要解决两个问题</p>
<ol>
<li><strong>线程再次获取锁</strong>：判断当前线程是否为锁的占有者，是，则获取成功</li>
<li><strong>锁的最终释放</strong>：利用计数器记录锁获取的次数，每次释放时计数器自减，当为0时表示锁成功释放</li>
</ol>
<h2 id="获取流程-3"><a href="#获取流程-3" class="headerlink" title="获取流程"></a>获取流程</h2><p> ReentrantLock支持获取锁时的公平和非公平性选择</p>
<ol>
<li>公平性：锁获取是顺序的，先请求锁的先获取锁</li>
<li>非公平性: 效率比公平性锁高，默认</li>
</ol>
<h3 id="ReentrantLock非公平性实现"><a href="#ReentrantLock非公平性实现" class="headerlink" title="ReentrantLock非公平性实现"></a>ReentrantLock非公平性实现</h3><p>非公平性的实现，主要是</p>
<ul>
<li>利用AQS的<code>exclusiveOwnerThread</code>变量（Thread类，用于记录获取锁的线程），判断判断当前线程是否跟获取锁的线程是同一个线程</li>
<li>是同一个锁的话，增加同步状态的值</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁</span></span><br><span class="line"><span class="comment">//判断当前线程是否为获取锁的线程来决定获取操作是否成功</span></span><br><span class="line"><span class="comment">//重复获取只是添加了同步状态值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//通过判断当前线程是否跟获取锁的线程是同一个线程</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//则将同步状态值进行增加并返回true,表示获取成功,相当于成功获取锁的线程再次获取锁，只是增加了同步状态值</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="ReentrantLock公平性实现"><a href="#ReentrantLock公平性实现" class="headerlink" title="ReentrantLock公平性实现"></a>ReentrantLock公平性实现</h3><p>比起非公平实现，区别在于判断条件多了<code>hasQueuedPredecessors()</code>,判断当前线程所对应的节点是否有前驱节点，如果有，该方法返回true。也就是说，只有前驱线程获取并释放锁之后才能继续获取锁</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 多了条件判断,如果有前驱节点，!hasQueuedPredecessors() 会返回flase，无法获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node t = tail; </span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">//判断头节点和尾节点是否是同一节点，如果h == t,说明同步队列没有节点，肯定没有前驱节点</span></span><br><span class="line">        <span class="comment">// 第二步判断，如果头节点的后继节点为空(只有一个节点，自然没有前驱节点) 或者 有后继节点但判断后继节点对应的线程是否是当前线程</span></span><br><span class="line">        <span class="comment">//通过三个判断来判断出当前线程的是否是下一个需要执行的</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="释放流程-2"><a href="#释放流程-2" class="headerlink" title="释放流程"></a>释放流程</h2><p>释放流程：前n-1次方法必定返回false，只有同步状态为0时，才返回true</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="线程“饥饿”"><a href="#线程“饥饿”" class="headerlink" title="线程“饥饿”"></a>线程“饥饿”</h2><p>线程饥饿变现为 一个线程<strong>连续获取非公平性锁</strong>的情况  ，原因为刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待,从而造成线程饥饿（使得其他线程只能在同步队列中等待）</p>
<p> 有线程饥饿为什么非公平锁还是默认？</p>
<ul>
<li>公平锁锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</li>
</ul>
<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p> 读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞;读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升</p>
<p> java 5.0之前是如何做的?</p>
<ul>
<li>使用Java的等待通知机制</li>
<li><p>写操作开始，其他读操作等待，直到通知(防止幻读)</p>
<p>有了读写锁后怎么做？</p>
</li>
<li><p>读操作，获取读锁，允许多个线程获取读锁进行访问，后继无法获取写锁</p>
</li>
<li>写操作，获取写锁,后续其他线程读写操作均被阻塞，但本线程可以获取读锁</li>
</ul>
<h2 id="ReadWriteLock接口"><a href="#ReadWriteLock接口" class="headerlink" title="ReadWriteLock接口"></a>ReadWriteLock接口</h2><p>读写锁的接口,仅定义了获取读锁和写锁的两个方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;<span class="comment">//获取读锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;<span class="comment">//获取写锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p><code>ReentrantReadWriteLock</code>是<code>ReadWriteLock</code>的具体实现</p>
<p>它包含了特性</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock.png" alt="lock"></p>
<p>除此之外，它还提供了其它方法</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock2.png" alt="lock2"></p>
<h2 id="读写锁的实现分析"><a href="#读写锁的实现分析" class="headerlink" title="读写锁的实现分析"></a>读写锁的实现分析</h2><p> ReentrantReadWriteLock的实现，主要包括：</p>
<ol>
<li>读写状态的设计</li>
<li>写锁的获取与释放</li>
<li>读锁的获取与释放</li>
<li>锁降级</li>
</ol>
<h3 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h3><p> 读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态.写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态</p>
<p> 如何在一个变量上维护多种状态？</p>
<ul>
<li>使用“按位切割”</li>
<li>高16位表示读，低16位表示写</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock3.png" alt="lock3"></p>
<p> 如何确定状态?</p>
<ul>
<li>通过位运算</li>
<li>写状态：status_value&amp;0x0000FFFF(高16位全部抹去)</li>
<li>写状态+1：status_value +1</li>
<li>读状态：status_value&gt;&gt;&gt;16(无符号补0右移16位)</li>
<li>读状态+1：status_value+(1&lt;&lt;16)，也就是status_value+0x00010000</li>
</ul>
<h3 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h3><h4 id="获取流程-4"><a href="#获取流程-4" class="headerlink" title="获取流程"></a>获取流程</h4><p> 写锁是一个支持重进入的排它锁</p>
<ul>
<li>如果当前线程已经获取了写锁，则增加写状态</li>
<li>如果当前线程在获取写锁时，读锁已经被获取其他或当前线程获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写锁获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//获取写锁状态</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//从c != 0-&gt;当前线程存在锁，w == 0,没有写锁，说明存在的是读锁</span></span><br><span class="line">        <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程时，写锁无法获取</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="释放流程-3"><a href="#释放流程-3" class="headerlink" title="释放流程"></a>释放流程</h4><p>写锁释放与ReentrantLock类似</p>
<h3 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h3><h4 id="获取流程-5"><a href="#获取流程-5" class="headerlink" title="获取流程"></a>获取流程</h4><p> 读锁是一个支持重进入的共享锁，它能够被多个线程同时获取</p>
<ul>
<li>在没有其他<em>写线程</em>访问（或者写状态为0）时，读锁总会被成功地获取;</li>
<li><p>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态</p>
<p>逻辑如下：</p>
</li>
</ul>
<ol>
<li>如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</li>
<li>如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 这一步判断是否状态值已满</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">//如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//增加读状态，成功获取读锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="释放流程-4"><a href="#释放流程-4" class="headerlink" title="释放流程"></a>释放流程</h4><p>读锁释放，每次减少读状态(线程安全的，可能有多个读线程同时释放读锁)，减少的值是（1&lt;&lt;16）</p>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>锁降级指的是写锁降级成为读锁，以如下代码为例</p>
<ol>
<li>当数据变化，update变为false(布尔类型且volatile修饰),所有访问该方法的线程，感知变化，但只有一个线程能获取到写锁，进行修改数据</li>
<li>写锁修改完数据后，先获取读锁，再释放写锁，这样的<strong>获取写锁-&gt;获取读锁-&gt;释放写锁</strong>的过程，就是锁降级</li>
<li>如果不在释放写锁前，获取锁</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读锁会被写锁阻塞</span></span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 必须先释放读锁</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">// 锁降级从写锁获取到开始</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 准备数据的流程（略）</span></span><br><span class="line">                update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再次获取读锁</span></span><br><span class="line">            readLock.lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//step_join</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用数据的流程（略）</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 为什么要用到锁降级（即释放写锁前线获取读锁）？</p>
<ul>
<li>假设线程A释放写锁后不获取读锁，运行到了<code>step_join</code>这个位置</li>
<li>此时线程B获取了写锁并修改了数据，但此时的线程A无法获取到线程B更新的数据,继续使用数据就会不一致（注意此时setp_join位置线程A是没有任何锁的）</li>
<li><p>但如果加了读锁呢，线程A拥有读锁，线程B因为线程A持有读锁，就算获取了写锁也只能进入等待状态，直到线程A释放读锁，才能进行数据修改</p>
<p>问题1：其实不用锁降级，单单依靠volatile和写锁，也能保证数据的安全性，那么为什么要用锁降级呢？</p>
<p>个人猜想：写锁会导致其他线程完全堵塞，而读锁是可以多线程访问的。比方说除了写锁锁定的代码外，其他代码是可以线程共享的，那么写锁降级读锁可以充分利用读锁的共享机制</p>
</li>
</ul>
<p>问题2：为什么不支持锁升级（获取读锁-&gt;获取写锁-&gt;释放读锁）</p>
<p>在《深入理解JVM》一书中提到，这是为了保证数据的可见性，当读锁已经被多个线程获取，其中任意线程成功修改获取了写锁并修改了数据，则其更新对其他获取到读锁的线程是不可见的。</p>
<p>个人认为：当获取到读锁时，写锁根本获取不到啊！！！</p>
<h1 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h1><p><code>LockSupport</code>工具被用于阻塞或唤醒一个线程，是构建同步组件的基础工具,它提供了一组公共的静态方法</p>
<ol>
<li>park* ()方法：用于阻塞当前线程</li>
<li>unPark(Thread thread)方法：用于唤醒被阻塞的线程</li>
</ol>
<h2 id="LockSupport提供的方法"><a href="#LockSupport提供的方法" class="headerlink" title="LockSupport提供的方法"></a>LockSupport提供的方法</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/locksupport.png" alt="locksupport"></p>
<p>在java 1.6后，LockSupport添加了以下3个方法,不难发现，其实这三个方法是基于原先方法的重载，多了一个blocker参数。,blocker是用来标识当前线程在等待的对象(阻塞对象),该对象主要用于问题排查和系统监控(能传递更多的信息)，可以通过dump 线程来对比</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span></span></span><br></pre></td></tr></table></figure></div>
<h1 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h1><p> 任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括<code>wait()、wait(long timeout)、notify()</code>以及<code>notifyAll()</code>方法，这些方法与<code>synchronized</code>同步关键字配合，可以实现<strong>等待/通知模式</strong>；而Condition接口也提供了类似Object的监视器方法，<strong>与Lock配合可以实现等待/通知模式</strong></p>
<p> Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁,Condition依赖Lock对象</p>
<h2 id="Condition的（部分）方法以及描述"><a href="#Condition的（部分）方法以及描述" class="headerlink" title="Condition的（部分）方法以及描述"></a>Condition的（部分）方法以及描述</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition2.png" alt="condition2"></p>
<h2 id="condition对比Object"><a href="#condition对比Object" class="headerlink" title="condition对比Object"></a>condition对比Object</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition.png" alt="condition"></p>
<h2 id="Condition的实现分析"><a href="#Condition的实现分析" class="headerlink" title="Condition的实现分析"></a>Condition的实现分析</h2><p> <code>ConditionObject</code><strong>是AQS的内部类</strong>,每个<code>Condition</code>对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。</p>
<p> Condition的实现，主要包括：</p>
<ol>
<li>等待队列</li>
<li>等待</li>
<li>通知</li>
</ol>
<h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><ul>
<li>FIFO的队列</li>
<li>节点包含了一个线程引用（在Condition对象上等待的线程），复用了同步器中节点的定义</li>
<li>拥有首节点（firstWaiter）和尾节点（lastWaiter）</li>
<li><p>节点更新无需CAS,因为await()方法必然是获取了锁的线程</p>
<p>同步器拥有一个同步队列和多个等待队列</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition3.png" alt="condition3"></p>
<h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><p> 调用了Condition.await()方法，该线程将会释放锁、构造成节点加入等待队列并进入等待状态</p>
<p> 逻辑如下</p>
<ol>
<li>当前线程必定是获取到锁的线程,即同步队列的首节点</li>
<li>该方法会将当前线程构造成节点并加入等待队列</li>
<li>释放同步状态,也就是释放锁</li>
<li>阻塞当前队列</li>
<li>调用acquireQueued()方法加入到获取同步状态的竞争中，为的是唤醒后重写抢回锁，并从await()返回</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 被唤醒的程序将从循环中退出，isOnSyncQueue(node)判断当前节点是否已经在同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用同步器的acquireQueued()方法加入到获取同步状态的竞争中</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 注意:</p>
<ol>
<li>释放锁之后，线程只有被唤醒才能从LockSupport.park(this)返回</li>
<li>返回之后，只有抢到锁才能从await()方法中返回,所以需要通过acquireQueued()来重写抢回锁</li>
</ol>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p> 调用<code>Condition</code>的<code>signal()</code>方法,将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中</p>
<p> 逻辑如下</p>
<ol>
<li>当前线程必须是获取了到锁的线程（通过isHeldExclusively()检查）</li>
<li>移动等待队列首节点到同步队列并使用LockSupport唤醒节点中的线程</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前线程获取到了锁的线程</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 获取等待队列的首节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 移动到同步队列并使用LockSupport唤醒节点中的线程</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition4.png" alt="condition4"></p>
<p> <code>Condition</code>的signalAll()<code>方法</code>，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p> 为什么要使用ConcurrentHashMap？</p>
<ol>
<li>线程不安全的HashMap会引起死循环（查看文章-&gt;<a href="https://juejin.im/post/5a66a08d5188253dc3321da0" target="_blank" rel="noopener">  HashMap会引起死循环</a>）</li>
<li>用线程安全的HashTable效率又非常低下（线程都竞争同一把锁）</li>
<li>java 1.8中的CurrentHashMap有了较大的不同（以下介绍的是java 7 的版本）</li>
</ol>
<p> ConcurrentHashMap的锁分段技术</p>
<ul>
<li>数据分段存储，并为每段数据配锁</li>
<li>当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</li>
</ul>
<h2 id="Java-1-7中的ConcurrentHashMap"><a href="#Java-1-7中的ConcurrentHashMap" class="headerlink" title="Java 1.7中的ConcurrentHashMap"></a>Java 1.7中的ConcurrentHashMap</h2><h3 id="ConcurrentHashMa结构"><a href="#ConcurrentHashMa结构" class="headerlink" title="ConcurrentHashMa结构"></a>ConcurrentHashMa结构</h3><ol>
<li>由<code>Segment</code>数组结构和<code>HashEntry</code>数组结构组成</li>
<li><code>Segment</code>是一种<strong>可重入锁</strong>（ReentrantLock）,包含一个<code>HashEntry</code>数组</li>
<li><code>HashEntry</code>则用于存储键值对数据</li>
<li>当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/concurrentHashMap.png" alt="concurrentHashMap"></p>
<h3 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h3><h4 id="初始化segments数组"><a href="#初始化segments数组" class="headerlink" title="初始化segments数组"></a>初始化segments数组</h4><p>参数</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>concurrencyLevel</td>
<td>用于计算ssize，最大值65535，即16位</td>
</tr>
<tr>
<td>ssize</td>
<td>segments数组的长度，值必须为2的N次方，目的是方便位运算</td>
</tr>
<tr>
<td>sshift</td>
<td>ssize从1向左移位的次数</td>
</tr>
<tr>
<td>segmentShift</td>
<td>用于定位参与散列运算的位数，等于32-sshift（之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的）</td>
</tr>
<tr>
<td>segmentMask</td>
<td>散列运算的掩码（掩码的二进制各个位的值都是1）</td>
</tr>
</tbody>
</table>
<p>初始化</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;<span class="comment">////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度 (为了能通过按位与的散列算法来定位segments数组的索引)</span></span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure></div>
<h4 id="初始化每个segment"><a href="#初始化每个segment" class="headerlink" title="初始化每个segment"></a>初始化每个segment</h4><p>参数</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>initialCapacity</td>
<td>ConcurrentHashMap的初始化容量，默认16</td>
</tr>
<tr>
<td>loadfactor</td>
<td>m每个segment的负载因子</td>
</tr>
</tbody>
</table>
<p>初始化</p>
<p> segment的容量 threshold = （int）cap*loadFactor</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initialCapacity是ConcurrentHashMap的初始化容量,默认16 </span></span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;<span class="comment">//变量cap就是segment里HashEntry数组的长度,大小为2^c [c∈(0,n)]</span></span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line">    <span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);<span class="comment">//，loadfactor是每个segment的负载因子，默认0.75</span></span><br></pre></td></tr></table></figure></div>
<h4 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h4><ul>
<li>ConcurrentHashMap在插入和获取元素的时候，必须先通过散列算法定位到Segment,才能使用不同段的数据。</li>
<li>ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再散列，目的是减少散列冲突，使元素能够均匀地分布在不同的Segment上，从而提高容器的存取效率</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> ConcurrentHashMap通过以下散列算法定位segment</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到散列运算中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 此外，定位HashEntry所使用的hash算法如下</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>
<h3 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h3><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><p> get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先进行一次再散列</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="comment">//再使用使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素</span></span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 为什么get方法不用加锁？</p>
<ul>
<li>是它的get方法里将要使用的共享变量都定义成了volatile类型</li>
<li>根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作</li>
</ul>
<h4 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h4><p> put方法里需要对共享变量进行写入操作，在操作共享变量时必须加锁，其逻辑如下</p>
<ol>
<li>首先定位到Segment，然后在Segment里进行插入操作</li>
<li>第一步判断是否需要对Segment里的HashEntry数组进行扩容(在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold）)</li>
<li><p>第二步定位添加元素的位置，然后将其放在HashEntry数组里</p>
<p>如何扩容?</p>
</li>
</ol>
<ul>
<li>创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里(对Segment的扩容)</li>
</ul>
<h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p> 要计算CurrentHashMap的大小，需要将Segment里的全局变量count累计相加，count是一个volatile变量，在获取时将得到最新的数据，但在计算相加前可能发生改变。</p>
<p> ConcurrentHashMap的做法如下</p>
<ul>
<li>先尝试2次通过不锁住Segment的方式来统计各个Segment大小</li>
<li>如果果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小</li>
<li>通过使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化</li>
</ul>
<h1 id="Java并发中的队列"><a href="#Java并发中的队列" class="headerlink" title="Java并发中的队列"></a>Java并发中的队列</h1><p> 实现一个线程安全的队列有两种方式：</p>
<ul>
<li><p>使用阻塞算法（可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现）</p>
</li>
<li><p>使用非阻塞算法(用循环CAS的方式来实现)</p>
</li>
</ul>
<h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p> ConcurrentLinkedQueue</p>
<ul>
<li>基于链接节点的无界线程安全队列</li>
<li>FIFO规则排序</li>
<li><p>采用了“wait-free”算法（即CAS算法）来实现</p>
<p>concurrentLinkedQueue类图</p>
</li>
<li><p>由head节点和tail节点组成</p>
</li>
<li>每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成</li>
<li>默认情况下head节点存储的元素为空，tail节点等于head节点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/concurrentLinkedQueue.png" alt="concurrentLinkedQueue"></p>
<h4 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h4><p> 首先要理解入队操作(java入队操作与数据结构算法中的有些不同)</p>
<ol>
<li>一个空的队列，插入节点A，Head.next设置为节点A，tail默认与head节点相同，也指向A</li>
<li>添加第二个节点B,节点A.next设置为节点B，同时更新tail指向节点B</li>
<li>添加第三个节点C，节点B.next设置为节点C</li>
<li>添加第四个节点D，节点C.next设置为节点D，同时更新tail指向节点D</li>
<li><p>可以看出，tail节点有可能不是尾节点(重点)</p>
<p>个入队过程逻辑如下</p>
</li>
<li><p>定位出尾节点(tail节点或者tail.next是尾节点)</p>
</li>
<li>使用CAS算法将入队节点设置成尾节点的next节点，如不成功则重试</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">        Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        retry:</span><br><span class="line">        <span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">            Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">            Node&lt;E&gt; p = t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">        <span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">                Node&lt;E&gt; next = succ(p);</span><br><span class="line">        <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">                    <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                    p = next;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;</span><br><span class="line">        <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class="line">                    <span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">                        casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p = succ(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p> 为什么ConcurrentLinkedQueue入队不是每次都变化tail节点?</p>
<ol>
<li>减少CAS更新tail节点的次数，能提高入队的效率</li>
<li>ConcurrentLinkedQueue使用hops变量来控制并减少tail节点的更新频率</li>
<li>hops变量相当于tail与尾节点的长度，如果大于等于HOPS(默认1)，才更新节点</li>
<li>tail与尾节点越长，那么更新tail节点操作就越少，但是相对的每次定位到尾节点需要读取更多的节点（相当于通过添加对volatile变量的读操作减少写操作，而读操作开销要远远小于写操作，从而得到提升）</li>
</ol>
<p> 入队方法永远返回true，所以不能靠返回值判断是否入队成功</p>
<h4 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h4><p> 逻辑如下</p>
<ol>
<li>与入队列相同，通过hops来减少更新head节点操作</li>
<li>head 节点内有元素，则弹出元素</li>
<li>head节点为空，弹出head.next,更新head节点</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line"><span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">        Node&lt;E&gt; p = h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line"><span class="comment">// 获取p节点的元素</span></span><br><span class="line">            E item = p.getItem();</span><br><span class="line"><span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</span></span><br><span class="line"><span class="comment">// 如果成功则返回p节点的元素。</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS) &#123;</span><br><span class="line"><span class="comment">// 将p节点下一个节点设置成head节点</span></span><br><span class="line">                    Node&lt;E&gt; q = p.getNext();</span><br><span class="line">                    updateHead(h, (q != <span class="keyword">null</span>)q :p);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</span></span><br><span class="line"><span class="comment">// 一个线程修改了。那么获取p节点的下一个节点</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line"><span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 更新头节点。</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="阻塞队列（BlockingQueue）"><a href="#阻塞队列（BlockingQueue）" class="headerlink" title="阻塞队列（BlockingQueue）"></a>阻塞队列（BlockingQueue）</h2><p> 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞<br>的插入和移除方法。</p>
<ol>
<li>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满</li>
<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空</li>
<li>常用于生产者和消费者的场景</li>
</ol>
<p> 在阻塞队列不可用时，这两个附加操作提供了4种处理方式</p>
<ol>
<li>抛出异常：队列满，再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常；队列空，当队列空时，从队列里获取元素会抛出NoSuchElementException异常</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null</li>
<li>一直阻塞：队列满，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空</li>
<li>·超时退出：队列满，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出；队列空，抛出元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/BlockingQueue.png" alt="BlockingQueue"></p>
<p> 如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true。</p>
<p> JDK 7提供了7个阻塞队列</p>
<ol>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ol>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p> ArrayBlockingQueue:</p>
<ul>
<li>由数组结构组成的有界阻塞队列</li>
<li>此队列按照先进先出（FIFO）的原则对元素进行排序</li>
<li><p>默认不保证线程公平的访问队列</p>
<p>创建一个公平的阻塞队列(即先阻塞先访问)</p>
</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></div>
<p> 访问者的公平性是使用可重入锁实现的</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p> LinkedBlockingQueue</p>
<ul>
<li>用链表实现的有界阻塞队列</li>
<li>默认和最大长度为Integer.MAX_VALUE</li>
<li>FIFO</li>
</ul>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>  PriorityBlockingQueue</p>
<ul>
<li>支持优先级的无界阻塞队列</li>
<li>默认情况下元素采取自然顺序升序排列</li>
<li>可以自定义类实现compareTo()方法来指定元素排序规则;也可以初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序</li>
<li>但不能保证同优先级元素的顺序</li>
</ul>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p> DelayQueue</p>
<ul>
<li>支持延时获取元素的无界阻塞队列</li>
<li>使用PriorityQueue来实现，</li>
<li>队列中的元素必须实现Delayed接口</li>
<li><p>在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p>
<p>应用场景</p>
</li>
<li><p>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</p>
</li>
<li>定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</li>
</ul>
<h4 id="实现Delayed接口"><a href="#实现Delayed接口" class="headerlink" title="实现Delayed接口"></a>实现Delayed接口</h4><p> 第一步，在对象创建的时候，初始化基本数据</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;<span class="comment">//time记录当前对象延迟到什么时候可以使用</span></span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();<span class="comment">//sequenceNumber来标识元素在队列中的先后顺序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 第二步，实现getDelay方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法返回当前元素还需要延时多长时间，单位是纳秒(注意当time小于当前时间时，getDelay会返回负数)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 第三步，实现compareTo方法来指定元素的顺序</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="keyword">this</span>)　　<span class="comment">// compare zero ONLY if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">            ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other;</span><br><span class="line">            <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) -</span><br><span class="line">                other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">        <span class="keyword">return</span> (d == <span class="number">0</span>) <span class="number">0</span> : ((d &lt; <span class="number">0</span>) -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="实现延时阻塞队列"><a href="#实现延时阻塞队列" class="headerlink" title="实现延时阻塞队列"></a>实现延时阻塞队列</h4><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> q.poll();</span><br><span class="line"><span class="comment">//leader：等待获取队列头部元素的线程</span></span><br><span class="line"><span class="comment">//如果leader不等于空，表示已经有线程在等待获取队列的头元素,使用await()方法让当前线程等待信号</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">    available.await();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间</span></span><br><span class="line">    Thread thisThread = Thread.currentThread();</span><br><span class="line">    leader = thisThread;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        available.awaitNanos(delay);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p> SynchronousQueue</p>
<ul>
<li>不存储元素的阻塞队列</li>
<li>每一个put操作必须等待一个take操作，否则不能继续添加元素</li>
<li>支持公平访问队列,默认非公平访问</li>
<li>非常适合传递性场景</li>
<li><p>吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue</p>
<p>创建公平性访问的SynchronousQueue</p>
</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fair == true -&gt; 公平访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p> LinkedTransferQueue</p>
<ul>
<li>由链表结构组成的无界阻塞TransferQueue队列</li>
<li>相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</li>
</ul>
<h4 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h4><p> transfer方法</p>
<ul>
<li>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者;。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试把存放当前元素的s节点作为tail节点</span></span><br><span class="line">Node pred = tryAppend(s, haveData);</span><br><span class="line"><span class="comment">//让CPU自旋等待消费者消费元素（自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。）</span></span><br><span class="line"><span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br></pre></td></tr></table></figure></div>
<h4 id="tryTransfer方法"><a href="#tryTransfer方法" class="headerlink" title="tryTransfer方法"></a>tryTransfer方法</h4><p> 用来试探生产者传入的元素是否能直接传给消费者</p>
<ul>
<li>如果没有消费者等待接收元素，则返回false</li>
<li>如果消费了元素，则返回true</li>
<li><p>该方法无论消费者是否接收，方法立即返回；，而transfer方法是必须等到消费者消费了才返回</p>
<p>此外还有带有时间限制的tryTransfer（E e，long timeout，TimeUnit unit）方法</p>
</li>
<li><p>试图把生产者传入的元素直接传给消费者</p>
</li>
<li>如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false</li>
<li>如果在超时时间内消费了元素，则返回true。</li>
</ul>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p> LinkedBlockingDeque</p>
<ul>
<li>由链表结构组成的双向阻塞队列</li>
<li>因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争</li>
<li>相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法</li>
<li>在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。</li>
<li>双向阻塞队列可以  运用在“工作窃取”模式中。</li>
</ul>
<h2 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h2><p> 在JDK中，使用通知模式实现;所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用</p>
<p>todo</p>
<h1 id="Java中的13个原子操作类"><a href="#Java中的13个原子操作类" class="headerlink" title="Java中的13个原子操作类"></a>Java中的13个原子操作类</h1><p> Java从JDK 1.5开始提供了<code>java.util.concurrent.atomic</code>包,一共包含13个类，属于4种类型的原子更新方式，分别是</p>
<ol>
<li>原子基本类型</li>
<li>原子数组</li>
<li>原子引用</li>
<li>属性（字段）的原子更新器</li>
</ol>
<p>PS：个人喜欢将1-3划分为用于代替普通类型的原子类。而4则是为普通类型提供原子操作的功能类</p>
<p> 事实上，原子类原理</p>
<ul>
<li>内置一个<strong>私有的</strong>相对应的变量(如原子布尔类型，内置了一个volatitle的boolean变量)</li>
<li>内置一个Unsafe变量，通过该变量来进行相应的原子操作</li>
</ul>
<p>而原子更新器，则是将其他非原子类的字段修改操作变为原子操作</p>
<p>PS：原子类虽然可以基于实例进行初始化，但是由于其内置变量的私有化，所以只能靠原子类提供的方法注入参数</p>
<ul>
<li>对于基本类型，值传递，原子类的操作不会影响原始的实例</li>
<li>对于数组，采用了clone()方法，所以原子类的操作还是不会影响原始的实例</li>
</ul>
<h2 id="原子基本类型类"><a href="#原子基本类型类" class="headerlink" title="原子基本类型类"></a>原子基本类型类</h2><p> Atomic包提供了以下3个类</p>
<ol>
<li>AtomicBoolean：原子更新布尔类型。</li>
<li>AtomicInteger：原子更新整型。</li>
<li><p>AtomicLong：原子更新长整</p>
<p>以上三种的方法类似以AtomicIntege为例,常用方法如下</p>
</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</span></span><br><span class="line"><span class="keyword">int</span> addAndGet（<span class="keyword">int</span> delta）</span><br><span class="line"><span class="comment">//update）：如果内存中的值等于预期值，则以原子方式将该内存中的值设置为输入的值。</span></span><br><span class="line"><span class="keyword">boolean</span> compareAndSet（<span class="keyword">int</span> expect，<span class="keyword">int</span> update）</span><br><span class="line"><span class="comment">//以原子方式将当前值加1，注意，这里返回的是自增前的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> lazySet（<span class="keyword">int</span> newValue）</span></span><br><span class="line"><span class="function"><span class="comment">//以原子方式设置为newValue的值，并返回旧值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> getAndSet（<span class="keyword">int</span> newValue）</span></span><br></pre></td></tr></table></figure></div>
<p>使用示例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger ai = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">System.out.println(ai.getAndIncrement());</span><br><span class="line">System.out.println(ai.get());</span><br></pre></td></tr></table></figure></div>
<h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><p> Atomic包提供了以下3个类</p>
<ol>
<li>AtomicIntegerArray：原子更新整型数组里的元素。</li>
<li>AtomicLongArray：原子更新长整型数组里的元素。</li>
<li><p>AtomicReferenceArray：原子更新引用类型数组里的元素。</p>
<p>以AtomicIntegerArray为例，其主要是提供原子的方式更新数组里的整型，常用方法如下</p>
</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以原子方式将输入值与数组中索引i的元素相加。</span></span><br><span class="line"><span class="keyword">int</span> addAndGet（<span class="keyword">int</span> i，<span class="keyword">int</span> delta）：</span><br><span class="line"><span class="comment">//如果内存中的值等于预期值，则以原子方式将数组位置i的元素设置成update值。</span></span><br><span class="line"><span class="keyword">boolean</span> compareAndSet（<span class="keyword">int</span> i，<span class="keyword">int</span> expect，<span class="keyword">int</span> update）</span><br></pre></td></tr></table></figure></div>
<p>使用示例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">AtomicIntegerArray ai = <span class="keyword">new</span> AtomicIntegerArray(value);</span><br><span class="line">ai.getAndSet(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(ai.get(<span class="number">0</span>));</span><br><span class="line">System.out.println(value[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></div>
<h2 id="原子引用类型"><a href="#原子引用类型" class="headerlink" title="原子引用类型"></a>原子引用类型</h2><p>引用类型可以指向并更改任何对象.但其本身没有对引用对象数据进行修改的方法，只能修改引用的对象</p>
<p> Atomic包提供了以下3个类</p>
<ol>
<li>AtomicReference：原子更新引用类型。</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;User&gt; atomicReference =</span><br><span class="line">    <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//修改User的name和Old两个字段，使用原子更新引用类型</span></span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"liisyu"</span>, <span class="number">18</span>);</span><br><span class="line">    atomicReference.set(user);</span><br><span class="line">    User updateUser = <span class="keyword">new</span> User(<span class="string">"wang"</span>, <span class="number">81</span>);</span><br><span class="line">    atomicReference.compareAndSet(user, updateUser);<span class="comment">//安全的将引用指向updateUser</span></span><br><span class="line">    System.out.println(atomicReference.get().getName());</span><br><span class="line">    System.out.println(atomicReference.get().getOld());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="字段类的原子更新器"><a href="#字段类的原子更新器" class="headerlink" title="字段类的原子更新器"></a>字段类的原子更新器</h2><p>原子操作类是唯一一个可以对原始变量发生改变的类，所以如果相对原始实例变量进行修改，可以使用该类</p>
<p> Atomic包提供了以下3个类,<strong>都是抽象类</strong></p>
<ol>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类,该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现ABA问题</li>
</ol>
<p>使用示例</p>
<ul>
<li>第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性</li>
<li>第二步，更新类的字段（属性）<strong>必须使用public volatile修饰符</strong></li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a =</span><br><span class="line">    AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">"old"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"liisyu"</span>, <span class="number">18</span>);</span><br><span class="line">    a.getAndIncrement(user)； <span class="comment">//对user对象的old字段+1操作</span></span><br><span class="line">    System.out.println(a.get(user));<span class="comment">// print 19;</span></span><br><span class="line">     System.out.println(user.getOld());<span class="comment">// print 19;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 必须public volatile修饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.old = old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="Java并发中的工具类"><a href="#Java并发中的工具类" class="headerlink" title="Java并发中的工具类"></a>Java并发中的工具类</h1><p>在JDK的并发包里提供了几个非常有用的并发工具类</p>
<ol>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>Exchanger</li>
</ol>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p>
<p>假设我们在主线程开启了多个线程，而主线程需要在等待这些线程完成后再进行操作，那么通常做法为</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirngp[] args)</span></span>&#123;</span><br><span class="line">    threadA.start();</span><br><span class="line">    threadB.start();</span><br><span class="line">    <span class="comment">// 利用join()方法，只有当线程完成时才会返回</span></span><br><span class="line">    threadA.join();</span><br><span class="line">    threadB.join();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//线程A、B完成后主线程继续运作</span></span><br><span class="line">   <span class="comment">//main thread do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但是，join的实现原理是通过不停检查join线程是否存活，来使线程等待</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// join部分代码片段，wait(0)：表示永远等待</span></span><br><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>再来看看<code>CountDownLatch</code>的做法</p>
<ul>
<li><p>通过计数器、countDown()、await()方法的组合使用，比起join()方法功能更为强大</p>
<p>a. run()方法中，根据countDown()插入的位置不同，可以在特定步骤完成下返回</p>
<p>b. <code>CountDownLatch</code>还提供了超时的await(long time，TimeUnit unit)方法</p>
</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入int类型参数，代表计数器，也就是等待2个线程完成</span></span><br><span class="line"><span class="keyword">static</span> CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在run()方法中使用countDown(),该方法会让计数器值-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//doSomething</span></span><br><span class="line">            c.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(runnable, <span class="string">"ThrEadA"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(runnable, <span class="string">"ThrEadB"</span>).start();</span><br><span class="line">    <span class="comment">// await()会阻塞当前线程知道计数器的值为0</span></span><br><span class="line">    c.await();</span><br><span class="line">    System.out.println(<span class="string">"回来了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意，CountDownLatch的计数器只能使用一次</p>
<h2 id="CyclicBarrier同步屏障"><a href="#CyclicBarrier同步屏障" class="headerlink" title="CyclicBarrier同步屏障"></a>CyclicBarrier同步屏障</h2><p><code>CyclicBarrier</code>：，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<p>使用示例</p>
<ul>
<li><p>CyclicBarrier(int parties): 会设置一个计数器，表示屏障拦截的线程数目</p>
</li>
<li><p>通过await()方法，来告知CyclicBarrier已经达到屏障，并阻塞当前线程</p>
</li>
<li><p>只有当达到屏障数量时，线程才会被唤醒</p>
</li>
<li><p>如下代码</p>
<p>a. 设置了拦截的线程数目为4个</p>
<p>b. 实际只有3个await()方法，也就是说，主线程和子线程将会永远等待</p>
</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int参数代表屏障拦截的线程数</span></span><br><span class="line">   <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在run()方法中使用countDown(),该方法会让计数器值-1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">//通过await(),告知CyclicBarrier线程已经到达屏障，并且阻塞当前线程</span></span><br><span class="line">               <span class="keyword">try</span>&#123;</span><br><span class="line">                   System.out.println(<span class="string">"到达屏障"</span>);</span><br><span class="line">                   c.await();</span><br><span class="line">               &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(runnable, <span class="string">"ThrEadA"</span>).start();</span><br><span class="line">       <span class="keyword">new</span> Thread(runnable, <span class="string">"ThrEadB"</span>).start();</span><br><span class="line">       c.await();</span><br><span class="line">       System.out.println(<span class="string">"回来了"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p>CyclicBarrier的计数器可以使用多次</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重置计数器</span></span><br><span class="line">c. reset()</span><br></pre></td></tr></table></figure></div>
<p>CyclicBarrier适用于多线程计算数据，最后合并计算结果的场景</p>
<h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><p><code>Semaphore（信号量）</code>是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源</p>
<p>todo</p>
<h2 id="Exchanger-线程间的数据交换"><a href="#Exchanger-线程间的数据交换" class="headerlink" title="Exchanger 线程间的数据交换"></a>Exchanger 线程间的数据交换</h2><p>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。具体为</p>
<ul>
<li>线程A先执行exchange()方法,等待线程B</li>
<li>线程B执行exchange()方法后，表示到达同步点，可以进行数据交换</li>
</ul>
<p>todo</p>
<h1 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h1><p>线程池能够带来3个好处</p>
<ol>
<li>降低资源消耗:通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>提高响应速度:当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>提高线程的可管理性:线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>
</ol>
<h2 id="线程池的处理逻辑"><a href="#线程池的处理逻辑" class="headerlink" title="线程池的处理逻辑"></a>线程池的处理逻辑</h2><ol>
<li>判断核心线程池里的线程是否都在执行任务；否，则创建新的线程来执行任务；是，则进入2</li>
<li>判断工作队列是否已经满；否，则将新提交的任务存储在这个工作队列里；是，则进入3</li>
<li>判断线程池的线程是否都处于工作状态;否，则创建一个新的工作线程来执行任务；是，则交给饱和策略来处理这个任务</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/xcc.png" alt="xcc"></p>
<h2 id="线程池的初始化"><a href="#线程池的初始化" class="headerlink" title="线程池的初始化"></a>线程池的初始化</h2><p>ThreadPoolExecutor是Java提供的一个核心的线程池,通过它来创建一个线程池</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(     <span class="keyword">int</span> corePoolSize,</span><br><span class="line">                            <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                            <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                            TimeUnit unit,</span><br><span class="line">                            BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                            ThreadFactory threadFactory,</span><br><span class="line">                            RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure></div>
<p>其参数定义如下</p>
<p>corePoolSize</p>
<ul>
<li>线程池的基本大小</li>
<li>任务数在小于它时每提交一个任务就会创建一个新的线程（无论其他线程是否空闲）</li>
<li>当任务数大于它时，不会再创建线程</li>
<li>可以使用prestartAllCoreThreads()方法提前创建并开启所有基本线程</li>
</ul>
<p>maximumPoolSize</p>
<ul>
<li>线程池最大数量</li>
<li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务</li>
<li>使用了无界的任务队列此参数失效</li>
</ul>
<p>keepAliveTime</p>
<ul>
<li>线程活动保持时间</li>
<li>线程池的工作线程空闲后，保持存活的时间</li>
<li>任务多时且执行时间短，可以调大它提高线程利用率</li>
</ul>
<p>TimeUnit</p>
<ul>
<li>线程活动保持时间的单位</li>
<li>可选单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）</li>
</ul>
<p>BlockingQueue</p>
<ul>
<li>任务队列</li>
<li>用于保存等待执行的任务的阻塞队列</li>
<li>可以选择阻塞队列的有：ArrayBlockingQueue、SynchronousQueue、LinkedBlockingQueue、PriorityBlockingQueue</li>
</ul>
<p>ThreadFactory</p>
<ul>
<li>创建线程的工厂</li>
<li>可以通过线程工厂给每个创建出来的线程设  置更有意义的名字</li>
<li>(使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字)</li>
</ul>
<p>RejectedExecutionHandler</p>
<ul>
<li>饱和策略</li>
<li>在队列和线程池都满情况下使用，可选策略有</li>
<li>AbortPolicy，表示无法处理新任务时抛出异常,默认</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</li>
<li>DiscardPolicy：不处理，丢弃掉</li>
<li>也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略</li>
</ul>
<h2 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h2><p>可以使用两个方法向线程池提交任务</p>
<ol>
<li>execute()：提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功</li>
<li>submit()：提交需要返回值的任务，线程池会返回一个Future类型的对象，</li>
</ol>
<p>Future：</p>
<ul>
<li>通过该对象可以判断任务是否执行成功</li>
<li>可以通过future的get()方法来获取返回值，get()方法造成阻塞</li>
<li>可以使用超时方法get（long timeout，TimeUnit unit）</li>
</ul>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>可以通过调用线程池提供的两个方法来关闭线程池</p>
<ol>
<li>shutdown：只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程（通常使用）</li>
<li>shutdownNow：将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表（如果任务无需执行完成，则可以使用）</li>
<li>原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程(无法响应中断的任务可能永远无法终止)</li>
</ol>
<p>判断是否关闭</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行shutdown()和shutdownNow后就会返回true</span></span><br><span class="line">aThreadPoolExecutor.isShutdown()</span><br><span class="line"><span class="comment">//执行shutdown()和shutdownNow后,且任务全部关闭才返回true</span></span><br><span class="line">aThreadPoolExecutor.isTerminaed()</span><br></pre></td></tr></table></figure></div>
<h2 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h2><p>要想合理地配置线程池，就必须首先分析任务特性</p>
<ol>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</li>
<li>任务的优先级：高、中和低。</li>
<li>任务的执行时间：长、中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接</li>
</ol>
<p>建议使用有界队列</p>
<h2 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h2><p>监控线程池的时候可以使用以下属性</p>
<ol>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li>
<li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li>
<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li>
<li>getActiveCount：获取活动的线程数。</li>
</ol>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>线程池的处理逻辑</p>
<ol>
<li><p>执行过程(ThreadPoolExecutor为例)</p>
</li>
<li><p>判断：如果当前运行的线程数n与corePoolSize<br>如果n &lt; corePoolSize 则创建新线程来执行任务（执行这一步骤需要获取全局锁）;结束；<br>如果n &gt;= corePoolSize,则将任务加入BlockingQueue,进行下一步判断</p>
</li>
<li>判断：BlockingQueue是否已满<br>否则，则将任务加入队列中;结束；<br>如果队列已满，则需要创建新的线程来处理任务（需要获取全局锁）;继续判断</li>
<li>判断：创建新进程后进程数是否超出maximumPoolSize<br>是，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法<br>否，则创建线程，结束</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/scc2.png" alt="scc2"> </p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务</span></span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            <span class="comment">// 抛出RejectedExecutionException异常</span></span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Woker类的run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable task = firstTask;</span><br><span class="line">            firstTask = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                runTask(task);</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerDone(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>线程池中的线程执行任务分两种情况</p>
<ol>
<li>在execute()方法中创建一个线程时，会让这个线程执行当前任务</li>
<li>线程执行完任务后，会反复从BlockingQueue获取任务来执行。</li>
</ol>
<h1 id="Java框架"><a href="#Java框架" class="headerlink" title="Java框架"></a>Java框架</h1><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p> Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p> 工作窃取（work-stealing）算法</p>
<ul>
<li>指某个线程从其他队列里窃取任务来执行.</li>
<li>通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行</li>
<li>窃取任务的线程永远从双端队列的尾部拿任务执行</li>
<li>优点:充分利用线程进行并行计算，减少了线程间的竞争</li>
<li>缺点:在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列</li>
</ul>
<h3 id="Fork-Join框架的设计"><a href="#Fork-Join框架的设计" class="headerlink" title="Fork/Join框架的设计"></a>Fork/Join框架的设计</h3><p> 步骤</p>
<ol>
<li>分割任务，通过fork类将任务切割成足够小的子任务</li>
<li><p>执行任务并合并结果，子任务放入双端队列中，多个线程从队列中获取；子任务执行结果放在同一个队列里，启动一个线程合并结果</p>
<p>Fork/Join使用两个类完成任务</p>
</li>
<li><p>ForkJoinTask,创建ForkJoin任务，提供fork()和join()方法,一般继承它的子类<br>RecursiveAction：用于没有返回结果的任务。<br>RecursiveTask：用于有返回结果的任</p>
</li>
<li><p>ForkJoinPool,ForkJoinTask需要通过ForkJoinPool来执行</p>
<p>任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p>
</li>
</ol>
<h3 id="使用Fork-Join框架"><a href="#使用Fork-Join框架" class="headerlink" title="使用Fork/Join框架"></a>使用Fork/Join框架</h3><p> 以计算1+2+3+4的结果为例</p>
<ol>
<li>假设每个子任务最多执行两个数的相加，则设置分割的阈值是2</li>
<li>因为是有结果的任务，所以必须继承RecursiveTask</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;　　<span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line"><span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"><span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult=leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult=rightTask.join();</span><br><span class="line"><span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"><span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="Fork-Join框架的异常处理"><a href="#Fork-Join框架的异常处理" class="headerlink" title="Fork/Join框架的异常处理"></a>Fork/Join框架的异常处理</h3><p> 检查任务是否已经抛出异常或已经被取消</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aForkJoinTask.isCompletedAbnormally()</span><br></pre></td></tr></table></figure></div>
<p> 获取异常</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回Throwable对象，如果任务被取消了则返回CancellationException;任务没有完成或者没有抛出异常则返回null</span></span><br><span class="line">aForkJoinTask.getException()</span><br></pre></td></tr></table></figure></div>
<h3 id="Fork-Join框架的实现原理"><a href="#Fork-Join框架的实现原理" class="headerlink" title="Fork/Join框架的实现原理"></a>Fork/Join框架的实现原理</h3><h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><p> 在JDK 5之前，java线程既是工作单元，也是执行机制，JDK 5之后把<strong>工作单元与执行机制分离开来</strong>。工作单元包括<code>Runnable</code>和<code>Callable</code>，而执行机制由Executor框架提供,其内部使用了线程池机制,通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作</p>
<h3 id="Executor框架的两级调度模型"><a href="#Executor框架的两级调度模型" class="headerlink" title="Executor框架的两级调度模型"></a>Executor框架的两级调度模型</h3><p> 在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。</p>
<p> 如图所示</p>
<ul>
<li>上层：java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程</li>
<li>底层：操作系统内核将这些线程映射到硬件处理器CPU上</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/executor.png" alt="executor"></p>
<h3 id="Executor框架的成员"><a href="#Executor框架的成员" class="headerlink" title="Executor框架的成员"></a>Executor框架的成员</h3><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p> ThreadPoolExecutor：</p>
<ul>
<li>线程池的核心实现类</li>
<li>用来执行被提交的任务。</li>
<li><p>通常使用工厂类Executors来创建</p>
<p>ThreadPoolExecutor主要由下列4个组件构成。</p>
</li>
</ul>
<ol>
<li>corePool：核心线程池的大小。</li>
<li>maximumPool：最大线程池的大小。</li>
<li>BlockingQueue：用来暂时保存任务的工作队列</li>
<li><p>RejectedExecutionHandler：当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已经饱和时（达到了最大线程池大小且工作队列已满），execute()方法将要调用的Handler</p>
<p>Executors可以创建3种类型的ThreadPoolExecutor</p>
</li>
<li><p>FixedThreadPool：创建使用固定线程数的FixedThreadPool(适用于负载比较重的服务器)</p>
</li>
<li>SingleThreadExecutor：创建使用单个线程的SingleThreadExecutor（适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。）</li>
<li>CachedThreadPoo：创建一个会根据需要创建新线程的CachedThreadPool（大小无界线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。）</li>
</ol>
<h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                nThreads, </span><br><span class="line">                nThreads,</span><br><span class="line">                <span class="number">0L</span>, <span class="comment">//keepAliveTime设置为0L，意味着多余的空闲线程会被立即终止</span></span><br><span class="line">                TimeUnit.MILLISECONDS, </span><br><span class="line">                <span class="keyword">new</span> inkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p> ScheduledThreadPoolExecutor</p>
<ul>
<li>线程池实现类</li>
<li>可以在给定的延迟后运行命令，或者定期执行命令</li>
<li><p>通常使用工厂类Executors来创建</p>
<p>Executors可以创建2种类型的ScheduledThreadPoolExecutor</p>
</li>
</ul>
<ol>
<li>ScheduledThreadPoolExecutor：，创建固定个数线程的ScheduledThreadPoolExecutor(适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景)</li>
<li>SingleThreadScheduledExecutor：创建单个线程的ScheduledThreadPoolExecutor(适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。)</li>
</ol>
<h2 id="Future接口和实现Future接口的FutureTask类"><a href="#Future接口和实现Future接口的FutureTask类" class="headerlink" title="Future接口和实现Future接口的FutureTask类"></a>Future接口和实现Future接口的FutureTask类</h2><p> Future接口和实现Future接口的FutureTask类</p>
<ul>
<li>表示异步计算的结果</li>
<li>通过sumbit()提交给线程池后返回该类型的数据</li>
</ul>
<h2 id="Runnable接口和Callable接口"><a href="#Runnable接口和Callable接口" class="headerlink" title="Runnable接口和Callable接口"></a>Runnable接口和Callable接口</h2><p> Runnable接口和Callable接口</p>
<ul>
<li>可以被ThreadPoolExecutor或Scheduled-ThreadPoolExecutor执行</li>
<li>Runnable不会返回结果</li>
<li>Callable可以返回结果</li>
<li>工具类Executors可以把一个Runnable对象封装为一个Callable对象</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Runnable-&gt;Callable</span></span><br><span class="line"><span class="comment">// sumbit后返回null</span></span><br><span class="line">Executors.callable（Runnable task）</span><br><span class="line"><span class="comment">// sumbit 后返回result</span></span><br><span class="line">Executors.callable（Runnable task，Object result）</span><br></pre></td></tr></table></figure></div>
<p>任务的执行：  </p>
<h2 id="Executor框架的使用"><a href="#Executor框架的使用" class="headerlink" title="Executor框架的使用"></a>Executor框架的使用</h2><p>示意图</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/executor2.png" alt="executor2"></p>
<p> 执行流程</p>
<ol>
<li>主线程创建实现Runnable或者Callable接口的任务对象</li>
<li>Runnable对象直接交给ExecutorService执行;或者把Runnable对象或Callable对象提交给ExecutorService执行</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接执行</span></span><br><span class="line">ExecutorService.execute（Runnablecommand）;</span><br><span class="line"><span class="comment">//提交,会返回实现Future接口的对象（一般是FutureTask对象）</span></span><br><span class="line"><span class="comment">//FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。</span></span><br><span class="line">Executor-Service.submit（Runnable task）</span><br><span class="line">ExecutorService.submit（Callable&lt;T&gt;task）</span><br></pre></td></tr></table></figure></div>
<ol start="3">
<li>主线程可以执行FutureTask.get()方法来等待任务执行完成。主也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</li>
</ol>
<h2 id="Thread-join-的使用"><a href="#Thread-join-的使用" class="headerlink" title="Thread.join()的使用"></a>Thread.join()的使用</h2><p> 含义：</p>
<ol>
<li>线程A拥有线程B的索引，并再内部方法调用了线程B的threadB.join()</li>
<li>线程A必须等待线程B终止，才能从threadB.join()方法返回</li>
<li>join()内部利用了通知/等待机制</li>
</ol>
<h2 id="线程其他方法"><a href="#线程其他方法" class="headerlink" title="线程其他方法"></a>线程其他方法</h2><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使线程休	眠</span></span><br><span class="line"><span class="comment">//单位毫秒。抛出InterruptedException异常</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回代表当前执行线程的对象，静态方法</span></span><br><span class="line">Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="comment">//过期方法,原因是无法保证能释放占有的资源，容易引发死锁</span></span><br><span class="line">suspend()：暂停  </span><br><span class="line">resume()：恢复  </span><br><span class="line">stop()：停止</span><br></pre></td></tr></table></figure></div>
<h1 id="相关脚注"><a href="#相关脚注" class="headerlink" title="相关脚注"></a>相关脚注</h1>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/java-并发/" rel="tag"># java 并发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2018/02/01/java.all/" rel="next" title="java 基础">
                <i class="fa fa-chevron-left"></i> java 基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2018/02/03/jvm.all/" rel="prev" title="JVM">
                JVM <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/toux.jpg" alt="Liisyu">
            
              <p class="site-author-name" itemprop="name">Liisyu</p>
              <div class="site-description motion-element" itemprop="description">我只是一个兴趣使然的程序员</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/blog/archives/">
                
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/blog/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/blog/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://liisyu.gitee.io/cv/" title="简历 &rarr; http://liisyu.gitee.io/cv/" rel="noopener" target="_blank"><i class="fa fa-fw fa-user-o"></i>简历</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:575600714@qq.com.com" title="E-Mail(QQ) &rarr; mailto:575600714@qq.com.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail(QQ)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:swordmaster2014@gmail.com" title="E-Mail(Google) &rarr; mailto:swordmaster2014@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>E-Mail(Google)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/FameLsy" title="GitHub &rarr; https://github.com/FameLsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://gitee.com/liisyu" title="Gitee &rarr; https://gitee.com/liisyu" rel="noopener" target="_blank"><i class="fa fa-fw fa-git-square"></i>Gitee</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/masorl" title="CSDN &rarr; https://blog.csdn.net/masorl" rel="noopener" target="_blank"><i class="fa fa-fw fa-tree"></i>CSDN</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="tencent://message/?uin=575600714&Site=qq&Menu=yes" title="QQ &rarr; tencent://message/?uin=575600714&Site=qq&Menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QQ</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://messilessblog.com/" title="https://messilessblog.com/" rel="noopener" target="_blank">汪酱 BLOG</a>
                  </li>
                
              </ul>
			   
            </div>
          

          
            
          
          

    <div class="wechat-box">
      <div class="weixin-description">微信扫一扫，联系我</div>
	  <img src="/blog/images/wechat.jpg" alt="wechat">
    </div>


        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#线程基础"><span class="nav-number">1.</span> <span class="nav-text">线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建线程"><span class="nav-number">1.1.</span> <span class="nav-text">创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过java-lang-Runnable接口-推荐"><span class="nav-number">1.1.1.</span> <span class="nav-text">通过java.lang.Runnable接口(推荐)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承java-lang-Thread"><span class="nav-number">1.1.2.</span> <span class="nav-text">继承java.lang.Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种方式的区别"><span class="nav-number">1.1.3.</span> <span class="nav-text">两种方式的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动线程"><span class="nav-number">1.2.</span> <span class="nav-text">启动线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终止线程"><span class="nav-number">1.3.</span> <span class="nav-text">终止线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#interrupt-中断线程"><span class="nav-number">1.3.1.</span> <span class="nav-text">interrupt() 中断线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用boolean变量中断"><span class="nav-number">1.3.2.</span> <span class="nav-text">使用boolean变量中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程状态"><span class="nav-number">1.4.</span> <span class="nav-text">线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NEW（新创建）状态"><span class="nav-number">1.4.1.</span> <span class="nav-text">NEW（新创建）状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RUNNABLE-可运行-状态"><span class="nav-number">1.4.2.</span> <span class="nav-text">RUNNABLE (可运行) 状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BLOCKED-（阻塞）状态"><span class="nav-number">1.4.3.</span> <span class="nav-text">BLOCKED （阻塞）状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WAITING-等待-状态"><span class="nav-number">1.4.4.</span> <span class="nav-text">WAITING (等待)状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TIME-WAITING-计时等待-状态"><span class="nav-number">1.4.5.</span> <span class="nav-text">TIME_WAITING (计时等待)状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TERMINATER-终止-状态"><span class="nav-number">1.4.6.</span> <span class="nav-text">TERMINATER (终止)状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程状态的变迁"><span class="nav-number">1.4.7.</span> <span class="nav-text">线程状态的变迁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程优先级"><span class="nav-number">1.5.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#守护线程"><span class="nav-number">1.6.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未捕获异常处理器"><span class="nav-number">1.7.</span> <span class="nav-text">未捕获异常处理器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程间的通信"><span class="nav-number">2.</span> <span class="nav-text">线程间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的安全性"><span class="nav-number">2.1.</span> <span class="nav-text">线程的安全性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等待-通知机制"><span class="nav-number">2.2.</span> <span class="nav-text">等待/通知机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#等待-通知机制核心思想"><span class="nav-number">2.2.1.</span> <span class="nav-text">等待/通知机制核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待-通知机制相关方法"><span class="nav-number">2.2.2.</span> <span class="nav-text">等待/通知机制相关方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待-通知经典范式"><span class="nav-number">2.2.3.</span> <span class="nav-text">等待/通知经典范式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道流"><span class="nav-number">2.3.</span> <span class="nav-text">管道流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#示例"><span class="nav-number">2.3.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序执行，join-方法"><span class="nav-number">2.4.</span> <span class="nav-text">顺序执行，join()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程变量ThreadLocal"><span class="nav-number">2.5.</span> <span class="nav-text">线程变量ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#示例-1"><span class="nav-number">2.5.1.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java1-5之前的线程安全"><span class="nav-number">3.</span> <span class="nav-text">Java1.5之前的线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#锁对象和条件对象"><span class="nav-number">3.1.</span> <span class="nav-text">锁对象和条件对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#锁对象"><span class="nav-number">3.1.1.</span> <span class="nav-text">锁对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件对象Condition"><span class="nav-number">3.1.2.</span> <span class="nav-text">条件对象Condition</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile关键字"><span class="nav-number">3.2.</span> <span class="nav-text">volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Volatile工作方式"><span class="nav-number">3.2.1.</span> <span class="nav-text">Volatile工作方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Volatile使用条件"><span class="nav-number">3.2.2.</span> <span class="nav-text">Volatile使用条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正确使用-volatile-示例"><span class="nav-number">3.2.3.</span> <span class="nav-text">正确使用 volatile 示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#状态标志"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">状态标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一次性安全发布"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">一次性安全发布</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized关键字"><span class="nav-number">3.3.</span> <span class="nav-text">synchronized关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM中的synchronized"><span class="nav-number">3.3.1.</span> <span class="nav-text">JVM中的synchronized</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Locks包"><span class="nav-number">4.</span> <span class="nav-text">Locks包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Locks包结构"><span class="nav-number">4.1.</span> <span class="nav-text">Locks包结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lock-接口"><span class="nav-number">5.</span> <span class="nav-text">Lock 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock特性"><span class="nav-number">5.1.</span> <span class="nav-text">Lock特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock的API"><span class="nav-number">5.2.</span> <span class="nav-text">Lock的API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock的使用"><span class="nav-number">5.3.</span> <span class="nav-text">Lock的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#队列同步器-AbstractQueuedSynchronizer"><span class="nav-number">6.</span> <span class="nav-text">队列同步器(AbstractQueuedSynchronizer)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS管理同步状态"><span class="nav-number">6.1.</span> <span class="nav-text">AQS管理同步状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS可重写的方法"><span class="nav-number">6.2.</span> <span class="nav-text">AQS可重写的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS提供的模板方法"><span class="nav-number">6.3.</span> <span class="nav-text">AQS提供的模板方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS的使用"><span class="nav-number">6.4.</span> <span class="nav-text">AQS的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列同步器的实现分析"><span class="nav-number">6.5.</span> <span class="nav-text">队列同步器的实现分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步队列"><span class="nav-number">6.5.1.</span> <span class="nav-text">同步队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#节点"><span class="nav-number">6.5.1.1.</span> <span class="nav-text">节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#入队操作"><span class="nav-number">6.5.1.2.</span> <span class="nav-text">入队操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#出队操作"><span class="nav-number">6.5.1.3.</span> <span class="nav-text">出队操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#独占式同步状态获取与释放"><span class="nav-number">6.5.2.</span> <span class="nav-text">独占式同步状态获取与释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#独占式同步状态获取释放流程"><span class="nav-number">6.5.2.1.</span> <span class="nav-text">独占式同步状态获取释放流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取流程"><span class="nav-number">6.5.2.2.</span> <span class="nav-text">获取流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放流程"><span class="nav-number">6.5.2.3.</span> <span class="nav-text">释放流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享式同步状态获取与释放"><span class="nav-number">6.5.3.</span> <span class="nav-text">共享式同步状态获取与释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取流程-1"><span class="nav-number">6.5.3.1.</span> <span class="nav-text">获取流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放流程-1"><span class="nav-number">6.5.3.2.</span> <span class="nav-text">释放流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#独占式超时获取同步状态"><span class="nav-number">6.5.4.</span> <span class="nav-text">独占式超时获取同步状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#独占式超时同步状态获取流程"><span class="nav-number">6.5.4.1.</span> <span class="nav-text">独占式超时同步状态获取流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取流程-2"><span class="nav-number">6.5.4.2.</span> <span class="nav-text">获取流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞与唤醒"><span class="nav-number">6.5.5.</span> <span class="nav-text">阻塞与唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞"><span class="nav-number">6.5.5.1.</span> <span class="nav-text">阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#唤醒"><span class="nav-number">6.5.5.2.</span> <span class="nav-text">唤醒</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重入锁-ReentrantLock"><span class="nav-number">7.</span> <span class="nav-text">重入锁(ReentrantLock)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现重进入"><span class="nav-number">7.1.</span> <span class="nav-text">实现重进入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取流程-3"><span class="nav-number">7.2.</span> <span class="nav-text">获取流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock非公平性实现"><span class="nav-number">7.2.1.</span> <span class="nav-text">ReentrantLock非公平性实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock公平性实现"><span class="nav-number">7.2.2.</span> <span class="nav-text">ReentrantLock公平性实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#释放流程-2"><span class="nav-number">7.3.</span> <span class="nav-text">释放流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程“饥饿”"><span class="nav-number">7.4.</span> <span class="nav-text">线程“饥饿”</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#读写锁"><span class="nav-number">8.</span> <span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ReadWriteLock接口"><span class="nav-number">8.1.</span> <span class="nav-text">ReadWriteLock接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-number">8.2.</span> <span class="nav-text">ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写锁的实现分析"><span class="nav-number">8.3.</span> <span class="nav-text">读写锁的实现分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读写状态的设计"><span class="nav-number">8.3.1.</span> <span class="nav-text">读写状态的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写锁的获取与释放"><span class="nav-number">8.3.2.</span> <span class="nav-text">写锁的获取与释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取流程-4"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">获取流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放流程-3"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">释放流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读锁的获取与释放"><span class="nav-number">8.3.3.</span> <span class="nav-text">读锁的获取与释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取流程-5"><span class="nav-number">8.3.3.1.</span> <span class="nav-text">获取流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放流程-4"><span class="nav-number">8.3.3.2.</span> <span class="nav-text">释放流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁降级"><span class="nav-number">8.3.4.</span> <span class="nav-text">锁降级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LockSupport工具"><span class="nav-number">9.</span> <span class="nav-text">LockSupport工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LockSupport提供的方法"><span class="nav-number">9.1.</span> <span class="nav-text">LockSupport提供的方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Condition接口"><span class="nav-number">10.</span> <span class="nav-text">Condition接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition的（部分）方法以及描述"><span class="nav-number">10.1.</span> <span class="nav-text">Condition的（部分）方法以及描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#condition对比Object"><span class="nav-number">10.2.</span> <span class="nav-text">condition对比Object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition的实现分析"><span class="nav-number">10.3.</span> <span class="nav-text">Condition的实现分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#等待队列"><span class="nav-number">10.3.1.</span> <span class="nav-text">等待队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待"><span class="nav-number">10.3.2.</span> <span class="nav-text">等待</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通知"><span class="nav-number">10.3.3.</span> <span class="nav-text">通知</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">11.</span> <span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-1-7中的ConcurrentHashMap"><span class="nav-number">11.1.</span> <span class="nav-text">Java 1.7中的ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMa结构"><span class="nav-number">11.1.1.</span> <span class="nav-text">ConcurrentHashMa结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap的初始化"><span class="nav-number">11.1.2.</span> <span class="nav-text">ConcurrentHashMap的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化segments数组"><span class="nav-number">11.1.2.1.</span> <span class="nav-text">初始化segments数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化每个segment"><span class="nav-number">11.1.2.2.</span> <span class="nav-text">初始化每个segment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定位Segment"><span class="nav-number">11.1.2.3.</span> <span class="nav-text">定位Segment</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap的操作"><span class="nav-number">11.1.3.</span> <span class="nav-text">ConcurrentHashMap的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#get操作"><span class="nav-number">11.1.3.1.</span> <span class="nav-text">get操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put-操作"><span class="nav-number">11.1.3.2.</span> <span class="nav-text">put 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#size操作"><span class="nav-number">11.1.3.3.</span> <span class="nav-text">size操作</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java并发中的队列"><span class="nav-number">12.</span> <span class="nav-text">Java并发中的队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#非阻塞队列"><span class="nav-number">12.1.</span> <span class="nav-text">非阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-number">12.1.1.</span> <span class="nav-text">ConcurrentLinkedQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#入队列"><span class="nav-number">12.1.1.1.</span> <span class="nav-text">入队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#出队列"><span class="nav-number">12.1.1.2.</span> <span class="nav-text">出队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞队列（BlockingQueue）"><span class="nav-number">12.2.</span> <span class="nav-text">阻塞队列（BlockingQueue）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">12.2.1.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">12.2.2.</span> <span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityBlockingQueue"><span class="nav-number">12.2.3.</span> <span class="nav-text">PriorityBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DelayQueue"><span class="nav-number">12.2.4.</span> <span class="nav-text">DelayQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现Delayed接口"><span class="nav-number">12.2.4.1.</span> <span class="nav-text">实现Delayed接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现延时阻塞队列"><span class="nav-number">12.2.4.2.</span> <span class="nav-text">实现延时阻塞队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SynchronousQueue"><span class="nav-number">12.2.5.</span> <span class="nav-text">SynchronousQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedTransferQueue"><span class="nav-number">12.2.6.</span> <span class="nav-text">LinkedTransferQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#transfer方法"><span class="nav-number">12.2.6.1.</span> <span class="nav-text">transfer方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tryTransfer方法"><span class="nav-number">12.2.6.2.</span> <span class="nav-text">tryTransfer方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedBlockingDeque"><span class="nav-number">12.2.7.</span> <span class="nav-text">LinkedBlockingDeque</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞队列的实现原理"><span class="nav-number">12.3.</span> <span class="nav-text">阻塞队列的实现原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java中的13个原子操作类"><span class="nav-number">13.</span> <span class="nav-text">Java中的13个原子操作类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原子基本类型类"><span class="nav-number">13.1.</span> <span class="nav-text">原子基本类型类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子数组"><span class="nav-number">13.2.</span> <span class="nav-text">原子数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子引用类型"><span class="nav-number">13.3.</span> <span class="nav-text">原子引用类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字段类的原子更新器"><span class="nav-number">13.4.</span> <span class="nav-text">字段类的原子更新器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java并发中的工具类"><span class="nav-number">14.</span> <span class="nav-text">Java并发中的工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">14.1.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier同步屏障"><span class="nav-number">14.2.</span> <span class="nav-text">CyclicBarrier同步屏障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore-信号量"><span class="nav-number">14.3.</span> <span class="nav-text">Semaphore 信号量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exchanger-线程间的数据交换"><span class="nav-number">14.4.</span> <span class="nav-text">Exchanger 线程间的数据交换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java中的线程池"><span class="nav-number">15.</span> <span class="nav-text">Java中的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的处理逻辑"><span class="nav-number">15.1.</span> <span class="nav-text">线程池的处理逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的初始化"><span class="nav-number">15.2.</span> <span class="nav-text">线程池的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向线程池提交任务"><span class="nav-number">15.3.</span> <span class="nav-text">向线程池提交任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关闭线程池"><span class="nav-number">15.4.</span> <span class="nav-text">关闭线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合理地配置线程池"><span class="nav-number">15.5.</span> <span class="nav-text">合理地配置线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的监控"><span class="nav-number">15.6.</span> <span class="nav-text">线程池的监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的实现原理"><span class="nav-number">15.7.</span> <span class="nav-text">线程池的实现原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java框架"><span class="nav-number">16.</span> <span class="nav-text">Java框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Fork-Join框架"><span class="nav-number">16.1.</span> <span class="nav-text">Fork/Join框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工作窃取算法"><span class="nav-number">16.1.1.</span> <span class="nav-text">工作窃取算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join框架的设计"><span class="nav-number">16.1.2.</span> <span class="nav-text">Fork/Join框架的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Fork-Join框架"><span class="nav-number">16.1.3.</span> <span class="nav-text">使用Fork/Join框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join框架的异常处理"><span class="nav-number">16.1.4.</span> <span class="nav-text">Fork/Join框架的异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join框架的实现原理"><span class="nav-number">16.1.5.</span> <span class="nav-text">Fork/Join框架的实现原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Executor框架"><span class="nav-number">17.</span> <span class="nav-text">Executor框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor框架的两级调度模型"><span class="nav-number">17.0.1.</span> <span class="nav-text">Executor框架的两级调度模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor框架的成员"><span class="nav-number">17.0.2.</span> <span class="nav-text">Executor框架的成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">17.0.2.1.</span> <span class="nav-text">ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FixedThreadPool"><span class="nav-number">17.0.2.2.</span> <span class="nav-text">FixedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SingleThreadExecutor"><span class="nav-number">17.0.2.3.</span> <span class="nav-text">SingleThreadExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CachedThreadPool"><span class="nav-number">17.0.2.4.</span> <span class="nav-text">CachedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledThreadPoolExecutor"><span class="nav-number">17.0.2.5.</span> <span class="nav-text">ScheduledThreadPoolExecutor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Future接口和实现Future接口的FutureTask类"><span class="nav-number">17.1.</span> <span class="nav-text">Future接口和实现Future接口的FutureTask类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runnable接口和Callable接口"><span class="nav-number">17.2.</span> <span class="nav-text">Runnable接口和Callable接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor框架的使用"><span class="nav-number">17.3.</span> <span class="nav-text">Executor框架的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-join-的使用"><span class="nav-number">17.4.</span> <span class="nav-text">Thread.join()的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程其他方法"><span class="nav-number">17.5.</span> <span class="nav-text">线程其他方法</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#相关脚注"><span class="nav-number">18.</span> <span class="nav-text">相关脚注</span></a></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liisyu</span>

  

  
</div>






        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/blog/js/utils.js?v=7.1.0"></script>

  <script src="/blog/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/blog/js/schemes/muse.js?v=7.1.0"></script>



  
  <script src="/blog/js/scrollspy.js?v=7.1.0"></script>
<script src="/blog/js/post-details.js?v=7.1.0"></script>



  


  <script src="/blog/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/blog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

  <script type="text/javascript" src="/blog/js/clipboard.min.js"></script>  
  <script type="text/javascript" src="/blog/js/clipboard-use.js"></script>
</body>
</html>
