<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="https://bestgakki.com/2018/02/03/jvm.all/index.html">
<meta property="og:site_name" content="Liisyu Blog">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389513.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/mode.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/缓存一致性.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/java内存模型.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/VisualVM/Profiler.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/VisualVM/VisualVM-MBeans.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/VisualVM/VisualVM-Glassfish.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/VisualVM/Visual-GC.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/javac-flow.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/javac-flow.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/方法调用计数器.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/回边计数器.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/ClientCompiler.png">
<meta property="og:updated_time" content="2019-05-28T08:26:06.099Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM">
<meta name="twitter:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389513.jpg">





  
  
  <link rel="canonical" href="https://bestgakki.com/2018/02/03/jvm.all/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JVM | Liisyu Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liisyu Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-navigation">

    
    
    
      
    

    

    <a href="/navigation/" rel="section"><i class="menu-item-icon fa fa-fw fa-diamond"></i> <br>导航</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bestgakki.com/2018/02/03/jvm.all/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JVM

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-04 00:00:01" itemprop="dateCreated datePublished" datetime="2018-02-04T00:00:01+08:00">2018-02-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-28 16:26:06" itemprop="dateModified" datetime="2019-05-28T16:26:06+08:00">2019-05-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389513.jpg" alt></p>
<a id="more"></a>
<h1 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h1><p>java将内存的管理权力全部交给了虚拟机，如下是JVM所管理的内存区域图</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/mode.png" alt="mode"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p> 程序计数器（Progtam Counter Register）</p>
<ul>
<li>是一块较小的内存空间，属于<strong>线程私有的内存</strong></li>
<li><strong>可以看成是当前线程所指向的字节码的行号指示器</strong>，<code>字节码解释器</code>依靠计数器的值来选取下一个要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能也需要以来于计数器</li>
<li>由于java是多线程的切换的方式实现的，为了保证切换回后有恢复到正确的位置，所以<strong>每一条线程都有一个计数器</strong></li>
<li>如果线程执行的是<code>java</code>代码，则计数器记录正在执行的虚拟机字节码指令的地址；如果是<code>Native</code>方法，计数器为<code>Undefined</code></li>
<li>唯一一个没有规定任何<code>OutOfMemoryError</code>情况的区域，原因是它是一个可以预见大小的值（一个指向下一条命令的地址）</li>
</ul>
<h2 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h2><p>JVM将栈细分为面向Java方法的Java虚拟机栈和面向本地方法的本地方法栈。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p> Java虚拟机栈(Java Virtual Machine Stacks)</p>
<ul>
<li><strong>线程私有的内存</strong>，为<strong>Java方法</strong>服务,生命周期与线程相同</li>
<li>虚拟机栈用来描述Java方法的<code>内存模型</code>，即每个方法在执行的同时会创建一个<code>栈帧</code>,用于存储局部变量表、操作数栈、动态链接、方法出口等信息;每一个方法调用直到完成的过程，对应一个栈帧在虚拟机栈中的入栈到出栈的过程</li>
<li>虚拟机栈中存在一个<code>局部变量表</code></li>
<li>规定了两种异常状态：  <code>StackOverflowError</code>和<code>OutOfMemoryError</code></li>
</ul>
<p> 局部变量表</p>
<ul>
<li><p>存放了编译期可知的<strong>基本数据类型</strong>、<strong>对象引用</strong>、<strong>returnAddress类型</strong></p>
<p>  <code>对象引用</code>：<code>reference</code>类型，可能是执行对象起始地址的引用指针，可以能是指向代表对象的句柄或其他与此对象相关的位置</p>
<p>  <code>returnAddress</code>类型:  指向一条字节码指令的地址</p>
</li>
<li><p><code>局部变量空间(Solt)</code>：基本数据类型的long和double会占据两个局部变量空间(Slot),其余数据类型占据一个</p>
</li>
<li><p><strong>局部变量表在编译期就已经完成了内存空间的分配,运行期间不会改变</strong></p>
</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p> 本地方法栈（Native Method Stack）</p>
<ul>
<li>与虚拟机栈类似，<strong>线程私有的内存</strong>，为<strong>Native方法</strong>服务</li>
<li>规定了两种异常状态：  <code>StackOverflowError</code>和<code>OutOfMemoryError</code></li>
</ul>
<p><strong>HotSpot VM中，直接将本地方法栈和虚拟机栈合二为一</strong></p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p> Java堆：</p>
<ul>
<li><strong>JVM内存最大的一块,被线程共享，在虚拟机启动时创建,用于存放对象示例和数组，GC的最要区域</strong></li>
<li>Java堆在物理空间上可以不连续，只要逻辑上连续即可</li>
<li>如果没有内存完成示例分配，会抛出<code>OutOfMemoryError</code>异常</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p> 方法区(Method Area)</p>
<ul>
<li><strong>线程间共享</strong>内存，别名<code>Non-Heap</code>(非堆);又被称为<code>永久代</code></li>
<li>用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据</li>
<li>虚拟机加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区的代码。</li>
<li>当方法区无法满足内存分配需求时，抛出<code>OutOfMemoryError</code>异常</li>
</ul>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池(Runtime Constant Pool)</p>
<ul>
<li><strong>用于存放编译期</strong>生成的各种<strong>字面量和符号引用</strong></li>
<li>无法申请到内存时抛出<code>OutOfMemoryError</code>异常</li>
<li>运行时常量池具备动态性，即常量的产生可以在编译期和运行期</li>
<li>在JDK1.6之前，属于方法区；JDK1.7后，移动至Java堆中</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p> 直接内存：</p>
<ul>
<li>并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中的内存区域</li>
<li>;在JDK1.4后加入了NIO类，引入了基于通道与缓冲区的I/O方式，该类可以使用<code>Native</code>函数库<strong>直接分配堆外内存</strong>，然后通过一个存储在 <code>java</code>堆 中的 <code>DirectByteBuffer</code>对象作为这块内存存的引用进行操作;</li>
<li>会受到本机总内存以及处理器寻址空间的限制。会抛出<code>OutOfMemoryError</code>异常</li>
</ul>
<h1 id="垃圾回收与算法"><a href="#垃圾回收与算法" class="headerlink" title="垃圾回收与算法"></a>垃圾回收与算法</h1><h2 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h2><p>Java 虚拟机想要通过垃圾回收器回收，必需要先判定哪些对象需要回收，通常有两种判定方式</p>
<ol>
<li><p>引用计数法</p>
</li>
<li><p>可达性分析算法</p>
</li>
</ol>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p> 算法步骤</p>
<ol>
<li>给对象添加一个引用计数器</li>
<li>每当有地方引用它，计数器+1</li>
<li>引用失效，计数器-1</li>
<li>计数器为0则表示没有任何地方使用这个对象</li>
</ol>
<p>算法优点：</p>
<ol>
<li>实现简单</li>
<li>判定效率高</li>
</ol>
<p>算法缺点：难以解决对象之间相互循环引用，如下示例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br><span class="line"><span class="comment">//即使objeA,objB都为null了，但它们的Instance字段互相引用对方，使这两个对象的计数器永远不为0，GC收集器永远无法回收</span></span><br><span class="line">objA = <span class="keyword">null</span>;</span><br><span class="line">objB = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></div>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p> 算法步骤</p>
<ol>
<li>通过一系列 <code>GC Roots</code>作为对象的<strong>起始点</strong>    </li>
<li>从这些起始节点向下搜索，搜索走过的路径被称为 <code>引用链</code></li>
<li>如果一个对象没有任何引用链，证明此对象不可用</li>
</ol>
<p>如图</p>
<ul>
<li><p>Object1、Object2、Object3都存在与<code>GC Roots</code>联通的 <code>引用链</code>,所以仍然存活</p>
</li>
<li><p>虽然object 5、6、7之间相互关联，但它们与 <code>GC Roots</code>无关联，所以会被判定为可回收对象</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm11.png" alt="jvm3"></p>
<p>在Java语言中，可作为 <code>GC Roots</code> 的对象包括</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法去区中常量引用的对象</li>
<li>本地方法栈中JNI(即Native方法)引用的对象</li>
</ul>
<h3 id="两次标记过程"><a href="#两次标记过程" class="headerlink" title="两次标记过程"></a>两次标记过程</h3><p>在可达性分析算法中，<strong>对于不可用的对象，并不会马上回收</strong>，它至少要经历两次标记过程</p>
<p>首先，来看一下<code>Object.finalize()</code>方法，该方法只是一个空的方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure></div>
<p>以下是它的注释</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 当垃圾收集确定没有对该对象的更多引用时，由对象上的垃圾收集器调用</span><br><span class="line"><span class="number">2</span>. 子类重写该方法以处置系统资源或执行其他清理</span><br><span class="line"><span class="number">3</span>. finalize的一般规定是，如果Java™虚拟机确定不再有任何方法可以通过任何尚未死亡的线程访问此对象，则调用它。</span><br><span class="line"><span class="number">4</span>. finalize方法可以采取任何操作，包括使该对象再次可用于其他线程; 但是，finalize的通常目的是在对象被不可撤销地丢弃之前执行清理操作。 例如，表示输入/输出连接的对象的finalize方法可能会执行显式I / O事务以在永久丢弃对象之前中断连接</span><br><span class="line"><span class="number">5</span>. 类Object的finalize方法不执行任何特殊操作; 它只是正常返回。 Object的子类可以覆盖此定义。</span><br><span class="line"><span class="number">6</span>. Java编程语言不保证哪个线程将为任何给定对象调用finalize方法。 但是，可以保证，调用finalize时，调用finalize的线程不会持有任何用户可见的同步锁。</span><br><span class="line"><span class="number">7</span>.在为对象调用finalize方法之后，在Java虚拟机再次确定不再有任何方法可以通过任何尚未死亡的线程访问此对象之前，不会采取进一步操作。之后，便可以丢弃该对象</span><br><span class="line"><span class="number">8</span>.对于任何给定对象，Java虚拟机永远不会多次调用finalize方法。</span><br><span class="line"><span class="number">9</span>. finalize方法抛出的任何异常都会导致暂停此对象的终结，但会被忽略。</span><br></pre></td></tr></table></figure></div>
<p>然后根据<code>Object.finalize()</code>的描述</p>
<ol>
<li>根据第三条注释，虚拟机会进行一次确定对象是否存活，即使用前面讲的<code>可达性分析</code>判活（<strong>第一次标记</strong>），然后对于可回收的对象，会执行<code>finalize()</code>方法</li>
<li>根据第七条注释，虚拟机会在调用<code>finalize()</code>方法之后，会对对象再一次进行<code>可达性分析</code>判活（<strong>第二次标记</strong>），此时对于没有任何引用的对象，就会被回收</li>
<li>根据第四条注释，<code>finalize</code>方法可以使对象再次用于其他线程，避免回收，也就使说，这是一次让对象救活的机会。</li>
<li>根据第五条注释和第八条注释可知，如果该对象不重写finalize()方法，或者已经调用了finalize()方法，那么必定会被回收</li>
<li>（补充：再第二次标记前，虚拟机会把对象放入到<code>F-Queue</code>队列中，并自动建立一个优先级低的<code>Finalizer</code>线程去执行该对象的<code>finalize()</code>，但需要注意的是<strong>虚拟机不保证finalize()方法一定会执行结束</strong>，原因是finalize()可能过慢或者甚至发生死循环，会让其他对象处于永久等待或者整个内存回收系统崩溃）</li>
<li>（补充2：关于第四条注释，说该方法适合做I/O中断等操作，不建议这么做，应该使用try-finally更好）</li>
</ol>
<p>测试示例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveMyself</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SaveMyself SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写finalize，并重新建立引用链</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed"</span>);</span><br><span class="line">        SaveMyself.SAVE_HOOK  = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> SaveMyself();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次回收，拯救成功</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"SAVE_HOOK被回收"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次回收，拯救失败被回收</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"SAVE_HOOK被回收"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h3><p> 算法分为 <code>标记</code> 和 <code>清除</code>两个阶段</p>
<ol>
<li><p>标记处所有需要回收的对象(标记过程看 ”可达性分析算法” 这一章的内容)</p>
</li>
<li><p>标记完成后统一回收</p>
</li>
</ol>
<p> 该算法有两处不足</p>
<ol>
<li>效率低，无论是标记还是清除效率都不高</li>
<li>空间问题，清除后会产生大量不连续内存碎片</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm4.png" alt="jvm4"></p>
<h3 id="复制收集算法-Copying"><a href="#复制收集算法-Copying" class="headerlink" title="复制收集算法(Copying)"></a>复制收集算法(Copying)</h3><p> 算法步骤</p>
<ol>
<li>将内存分为大小相等的两块</li>
<li>每次使用其中一块，当被使用的内存块用玩了，则将该内存块中存货对象复制到另一块上，然后一次性清空该块。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm5.png" alt="jvm5"></p>
<p>算法不足之处：有一半空间是没有使用的</p>
<h3 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h3><p>标记整理法是<strong>针对老年代</strong>的算法，它的步骤与 <code>标记清除法</code> 类似</p>
<ol>
<li>标记处所有需要回收的对象(标记过程看 ”可达性分析算法” 这一章的内容)</li>
<li>所有存活对象移动到一端，然后直接清理端边界意外的内存</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm6.png" alt="jvm6"></p>
<h3 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h3><p>该算法是根据对象存货周期的不同将内存划几块，一般将Java堆分为 <code>新生代(Young Generation)</code>和<code>老年代(Tenured/Old Generation)</code>,然后根据各个年代的特点选择不同的算法</p>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>特点：</p>
<ul>
<li>新生代对象存活较少，每次需要回收大量对象，所以复制操作较少，通常使用复制算法</li>
<li>新生代一般以1:1:8 的比例划分为两个<code>Survivor</code>（SurvivorFrom,SurvivorTo）和一个<code>Eden</code>空间，每次使用<code>Eden</code>空间和其中一个<code>Survivor</code>，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中</li>
</ul>
<p>MajorGC步骤：</p>
<ol>
<li>复制：将 <code>Eden</code>和 <code>SurvivorFrom</code> 复制到另一块<code>SurvivorTo</code>中(复制过程中可能出现晋升老年代、空间不足等情况，具体处理详细看<strong>《内存分配与回收策略》</strong>)</li>
<li>清空：将 <code>Eden</code>和 <code>SurvivorFrom</code>内容清空 </li>
<li>互换：将 <code>SurvivorFrom</code> 与<code>SurvivorTo</code>互换，即原<code>SurvivorTo</code>成为下一次GC的<code>SurvivorFrom</code> </li>
</ol>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>特点</p>
<ul>
<li>老年代对象存活率大，回收数量少，没有额外空间对它进行分配担保，则必须使用 <strong>标记清除法</strong> 或 <strong>标记整理法</strong></li>
<li>新生代的对象在一定条件下，就会晋升为老年代对象(详细看《内存分配与回收策略》)</li>
</ul>
<h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><p>​    永久代即方法区，主要存放Class和Meta(元数据)，Class会在被加载时候放入该区域，因为GC不会在主程序运行期对方法区进行清理，所以该区域会随着加载的Class增多而最终导致抛出OOM。为了清理方法区，HotSpot VM将GC分代算法扩展至方法区，即使用Java堆的永久代来实现方法区, 这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器。<strong>不过收益一般很小</strong></p>
<p>​    在Java8中，永久代已经被移除，被<code>元数据区（元空间）</code>取代，它们的区别在于元空间大小受本地内存限制。类的元数据放入<code>native memoery</code>,字符串池和类的静态变量放入java队中，好处是加载多少类的元数据就不再由MaxPermSize控制，而是由系统的实际可用空间控制</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>HotSpot 提供的收集器，收集器的连线表示它们可以配合使用</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm7.png" alt="jvm7"></p>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial收集器</p>
<ul>
<li><p><code>新生代收集器</code>，<strong>单线程</strong></p>
</li>
<li><p>JVM运行在 <strong>Client模式</strong> 下的默认 <code>新生代收集器</code></p>
</li>
<li><p>它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（有一种叫法，叫 <code>Stop The World</code> ），直到它收集结束;</p>
</li>
</ul>
<p>Serial收集器优点：<br>    简单高效，尤其是单个CPU环境。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率；只需要控制好能接受的停顿时间，那还是一个很好的选择</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm8.png" alt="jvm8"></p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p> ParNew收集器</p>
<ul>
<li><code>新生代收集器</code>,Serial收集器的<strong>并行[^4]多线程</strong>版本,其余行为与Serial收集器相同；</li>
<li>是运行在Server模式下的JVM的首选<code>新生代收集器</code></li>
<li><strong>唯一一个</strong>可以配合<code>CMS</code>的收集器</li>
<li>在单CPU下由于存在线程交互开销，性能可能低于Serial收集器</li>
<li>默认开启的线程数与CPU数量相同</li>
</ul>
<p> ParNew收集器优点：多线程、高效</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm9.png" alt="jvm9"></p>
<h3 id="Parallel-Scsvenge收集器"><a href="#Parallel-Scsvenge收集器" class="headerlink" title="Parallel Scsvenge收集器"></a>Parallel Scsvenge收集器</h3><p>Parallel Scsvenge</p>
<ul>
<li><p><code>新生代收集器</code>，,同时也是<strong>并行[^4]的多线程收集器</strong>,与<strong>ParNew</strong> 收集器几乎一致</p>
</li>
<li><p>Parallel Scsvenge与其他收集器的区别：<strong>关注点与其他收集器不同</strong> </p>
<p>​    a. 其他浏览器关注点：尽可能缩短垃圾收集时用户线程的停顿时间</p>
<p>​    b. <code>Parallel Scsvenge</code>关注点：控制吞吐量</p>
</li>
<li><p>适用于后台运算而不需要太多交互的任务</p>
</li>
</ul>
<p>Parallel Scsvenge优点：在高吞吐量下最高效率利用CPU时间，尽快完成程序的运算任务</p>
<p>Parallel Scsvenge提供了两个参数用于精确控制吞吐量</p>
<ol>
<li><code>-XX:MaxGCPauseMillis</code> : <strong>控制最大垃圾收集停顿时间</strong>(大于0的毫秒数)，收集器尽可能保证内存回收花费时间不超过设定值，时间缩短靠的是牺牲吞吐量和新生代空间换取的</li>
<li><code>-XX:GCTimeRatio</code> : <strong>直接设置大小</strong>（大于0小于100，垃圾手机时间占总时间的比率，即吞吐量的倒数）,如设置成19，那么GC时间就是 1/(1+19)= 5%,默认值99，即GC时间1%(1/(1+99))</li>
</ol>
<p>Parallel Scsvenge其他参数</p>
<ul>
<li><code>XX:+UserAdaptiveSizePolicy</code>: 开关参数，用于打开GC自适应的调节策略, 打开后，无需手工指定新生代大小、Eden与Survior的比例等细节参数，JVM会自动调节。</li>
</ul>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial Old</p>
<ul>
<li><p><code>Serial</code> 老年代版本，单线程收集器，使用<code>标记-整理</code>算法</p>
</li>
<li><p>主要用于<code>Client</code>模式下的虚拟机，与Serial 收集器搭配使用</p>
</li>
<li><p>在<code>Server</code>模式下，有两大用途</p>
<p>a. 与<code>Parallel Scsvenge</code>收集器搭配使用</p>
<p>b. 作为<code>CMS</code>收集器的后备预案，在并发收集发生<code>Concurrent Mode Failure</code>时使用</p>
</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old</p>
<ul>
<li><code>Parallel Scsvenge</code>老年代版本，多线程收集器，使用<code>标记-整理</code>算法</li>
<li><code>Parallel Old</code> + <code>Parallel Scsvenge</code> 组合，适用于注重吞吐量以及CPU资源敏感的场合</li>
</ul>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p> CMS收集器（Coucurrent mark swrrp）</p>
<ul>
<li><p>老年代收集器，基于 <code>标记清除算法</code>实现</p>
</li>
<li><p>是以<strong>获取最短回收停顿时间</strong>为目标的收集器</p>
</li>
</ul>
<p>它的运作过程如下</p>
<ul>
<li><code>初始标记</code>： 暂停所有的其他线程，只是记录下直接与<code>GC Roots</code>相连的对象，速度很快 ；需要<code>Stop The World</code></li>
<li><code>并发标记</code>： 进行<code>GC Roots Tracing</code>(GC Root 追踪过程),同时开启GC和用户线程</li>
<li><code>重新标记</code>： 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要<code>Stop The World</code></li>
<li><code>并发清除</code>： 开启用户线程，同时GC线程开始对为标记的区域做清扫</li>
</ul>
<p>CMS优点：对交互比较高的程序提升较大，总体上，CMS收集器的内存回收与用户线程并发进行</p>
<p> CMD也被称为 <strong>并发低停顿收集器</strong>，但存在3个缺点：</p>
<ul>
<li><p>CMS对CPU敏感</p>
<p>默认启动的回收线程数为(CPU数量+3)/4，比如CPU数是2个，那么开启的线程数为1，占了50%的CPU资源，这样很可能导致用户程序的执行速度降低50%。</p>
</li>
<li><p>CMS收集器无法处理<code>浮动垃圾</code>[^3]</p>
</li>
<li><p>CMS式基于<code>标记清除算法</code>实现，所以会产生大量空间碎片</p>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>  G1收集器</p>
<ul>
<li><p>面向服务端应用的多线程垃圾收集器，基于<code>标记-整理算法</code>实现</p>
</li>
<li><p>它将整个Java堆划分成大小相等的独立区域(Region),虽然保留新生代和老年代概念，但新生代和老年代不再物理隔离，都属于Region(不需要连续)的集合；</p>
</li>
<li><p>空间整合：</p>
<p>a. 从整体看，G1是基于 <code>标记整理算法</code>实现的；</p>
<p>b. 从局部(Region)来看，G1是基于 <code>复制算法</code>实现的；这两种算法都不会产生内存空间碎片</p>
</li>
<li><p>可预测的停顿：相对于CMS的大优势，G1可以建立可预测的停顿时间模型，让使用者明确指定一个长度为M毫秒的时间片段，消耗在垃圾收集上的时间不得超过M秒</p>
</li>
</ul>
<p>G1收集器优点：</p>
<ul>
<li>并发执行GC，缩短<code>Stop The World</code> 停顿时间</li>
<li><p>避免在整个Java堆中进行垃圾收集</p>
</li>
<li><p>可控停顿时间</p>
</li>
<li>不产生内存碎片</li>
<li>不需要其他收集器配合，独立完成新生代和老年代的回收</li>
</ul>
<p>G1可预测的停顿原因</p>
<p>​    由于划分成了多个<code>Region</code>，G1会根据Region的价值大小(回收所获取的空间大小和回收所需时间的经验值)，在后台维护一个优先级列表，优先回收最大的<code>Region</code>,从而保证在有限时间内获得更高的回收小路</p>
<p> G1收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><p>初始标记：</p>
<p>a. 标记 GC Roots能直接关联的对象,需要<code>Stop The World</code></p>
<p>b. 修改TAMS（Next Top at Mark Start）的值，目的是让一下阶段用户程序并发运行时，能正确在Region中创建新对象</p>
</li>
<li><p>并发标记： 进行可达性分析，找出存活对象，耗时长</p>
</li>
<li><p>最终标记：</p>
<p>a. 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要<code>Stop The World</code></p>
<p>b.  将这段时间对象变化记录在线程<code>Remebered Set Logs</code>里，然后将其合并到<code>Remebered Set</code>中</p>
</li>
<li><p>筛选回收： 对各个<code>Region</code>的回收价值和成本进行排序，根据用户希望的GC停顿时间来指定回收计划</p>
</li>
</ul>
<h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UseSerialGC</td>
<td>虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParNewGC</td>
<td>打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseConcMarkSweepGC</td>
<td>打开此开关后，使用ParNew+ CMS + Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用</td>
</tr>
<tr>
<td>UseParallelGC</td>
<td>虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old (PS Mark Sweep)的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UserParallelOldGC</td>
<td>打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>SurvivorRatio</td>
<td>新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Survivor = 8:1</td>
</tr>
<tr>
<td>PretenureSizeThreshold</td>
<td>直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td>
</tr>
<tr>
<td>MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代</td>
</tr>
<tr>
<td>UseAdaptiveSizePolicy</td>
<td>动态调整Java堆中各个区域的大小以及进入老年代的年龄</td>
</tr>
<tr>
<td>HandlePromotionFailure</td>
<td>是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况</td>
</tr>
<tr>
<td>ParallelGCThreads</td>
<td>设置并行GC时进行内存回收的线程数</td>
</tr>
<tr>
<td>GCTimeRatio</td>
<td>GC时间占总时间的比率，默认值是99， 即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>MaxGCPauseMillis</td>
<td>设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>CMSInitiatingOccupancyFraction</td>
<td>设置CMS收集器在老年代时间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效</td>
</tr>
<tr>
<td>UseCMSCompactAtFullCollection</td>
<td>设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效</td>
</tr>
<tr>
<td>CMSFullGCsBeforeCompaction</td>
<td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用CMS收集器时生效</td>
</tr>
</tbody>
</table>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>规则一：对象优先在Eden分配</p>
<p>​    大多数情况下，对象在新生代的Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次<code>Minor GC</code>，即从年轻代空间（包括Eden和Survivor区域）回收内存</p>
<p>规则二：<code>大对象</code>（需要大量连续空间的Java对象）直接进入老年代</p>
<ul>
<li><p>经常出现大对象容易导致内存还有不少空间时就<strong>提前触发垃圾收集器以获取足够的连续空间</strong>来存储它们</p>
</li>
<li><p><code>PretenureSizeThreshold</code>参数：令大于这个值的对象直接在老年代分配    </p>
</li>
</ul>
<p>规则三：长期存活的对象进入老年代<br>    虚拟机通过<code>对象年龄计数器</code>来识别对象应该放置在新生代还是老年代</p>
<p>对象年龄计数器</p>
<ul>
<li>如果对象在<code>Eden</code>出生并经过第一次<code>Minor GC</code>后能存活，并能被<code>Survivor</code>容纳，那么该对象会被移动到<code>Survivor</code>空间中，且对象年龄为1；</li>
<li>之后，每进行一次<code>Minor GC</code>，对象没有被回收的化，年龄+1；</li>
<li>年龄到达一定值（默认15），就会晋升到老年代中。</li>
<li><code>MaxTenuringThreshold</code>参数：设置对象晋升老年代的阈值</li>
</ul>
<p>规则四：动态对象年龄判断</p>
<ul>
<li>虚拟机为了更好的适应不同程序的内存状况，并不是要求对象必须年龄到达阈值才晋升为老年代</li>
<li>当Survivor空间中相同年龄所有对象的大小的总和大于Survivor空间的一半，那么年龄大于等于该值年龄的对象直接晋升到老年代</li>
</ul>
<p>​    </p>
<p>规则五：空间分配担保</p>
<p>在<code>Minor GC</code>之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</p>
<ul>
<li><p>是，则可以确保<code>Minor GC</code>，是安全的,进行一次<code>Minor GC</code></p>
</li>
<li><p>否，则还需要查看<code>HandlePromotionFailure</code>设置值是否允许担保失败</p>
<p>​    a. 允许，检查老年代最大可用连续空间是否大于<strong>历次</strong>晋升老年代对象的平均大小</p>
</li>
</ul>
<p>​            大于：则再一次尝试<code>Minor GC</code></p>
<p>​            小于：则进行一次<code>Full GC</code></p>
<p>​        b. 不允许，则进行一次<code>Full GC</code></p>
<p>为什么需要空间担保分配</p>
<ul>
<li><p>新生代采用的是复制收集算法，按照8:1:1的分配方式，只有一个Survivor空间来进行轮换备份，如果在<code>Minor GC</code>[^1]后依旧还有大量对象存活，导致Survivor不够用时，就需要老年代进行分配担保，将无法容纳的对象直接存入老年代</p>
</li>
<li><p>老年代要进行担保，必须是它本身还有多余的能容纳这些对象的空间。而到底有多少对象存活在<code>Minor GC</code>[^1]无法得知，所以只能通过以前的回收晋升到老年代的对象的评价大小来作为经验值。</p>
<p>​    a. 老年代剩余空间大于经验值，那么就可以尝试<code>Minor GC</code>[^1]，这仅仅只是一次尝试，依旧会导致担保失败(Handle Promition Failure),不得不进行一次<code>Full GC</code>[^2]来获取更多的空间；</p>
<p>​    b. 小于经验值的话，也需要进行<code>Full GC</code>[^2]来获取更多的空间。</p>
</li>
<li><p><code>HandlePromotionFailure</code>参数：开关参数，建议打开，避免<code>Full GC</code>[^2]关于频繁</p>
</li>
</ul>
<h2 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h2><p> 方法区（即永久代）垃圾回收率较低，主要回收的时废弃常量和无用的类。废如字符串”abc”在常量池但没有任何对象引用用它，则该字符串就是废弃常量；而判断无用的类，则必须满足以下三个条件</p>
<ol>
<li>该类实例都已经被回收</li>
<li>加载该类的ClassLoader已被回收</li>
<li>该类的java.lang.Class对象没有被引用，无法在任何地方通过反射访问该类方法</li>
</ol>
<p>满足三个条件，只能说是可以回收，是否要回收，HotSpot提供了 <code>-Xnoclassgc</code> 参数对齐进行控制;还可以使用 <code>-verbose:class</code>(Product版虚拟机中使用) 和 <code>-XX:+TraceClassLoadd</code>(Product版虚拟机中使用) 、 <code>-XX:+TraceClassUnLoading</code>(FastDebug版虚拟机中使用) 查看加载和卸载信息;</p>
<h2 id="引用reference"><a href="#引用reference" class="headerlink" title="引用reference"></a>引用reference</h2><p> 什么是引用?</p>
<ul>
<li>在JDK1.2 以前，引用被定义为：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用</li>
<li>在JDK1.2之后，引用被分为了四种: <code>强引用</code>、<code>软引用</code>、<code>弱引用</code>、<code>虚引用</code>,四种引用强度依次减弱</li>
</ul>
<p><code>强引用</code>: 指在程序代码之中普遍存在的，类似”Object obj = new Object()”这类引用，只要强引用还在，垃圾收集器不会回收被引用的对象</p>
<p><code>软引用</code>：软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果还没有足够的内存，则抛出内存溢出异常。在JKD1.2后使用 <code>SoftReference</code> 类 来实现软引用</p>
<p> <code>弱引用</code>：弱引用关联的对象，在垃圾收集器工作时，无论是否内存足够，都会被回收。在JKD1.2后使用 <code>WeakReference</code> 类来实现软引用</p>
<p><code>虚引用</code>：又被称为<code>幽灵引用</code>或者<code>幻影引用</code>。对象被虚引用关联，完全不会对其生存时间造成任何影响，也无法通过虚引用来获取对象实例。该引用的唯一作用是在被关联对象回收后收到一个系统通知；在JKD1.2后使用 <code>PhantomReference</code> 类来实现软引用</p>
<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>类的整个生命周期：加载、验证、准备、解析、初始化、使用、卸载</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机主要功能</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>在验证阶段，目的是<strong>确保Class文件的字节路中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的 安全</strong>，在验证阶段主要完成以下四个阶段的校验动作</p>
<ol>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>在准备阶段，虚拟机主要功能：正式为<strong>类变量</strong>分配内存并<strong>设置变量初始值</strong>，但需要注意</p>
<ol>
<li><p>仅为类变量分配内存，不包括实例变量</p>
</li>
<li><p>初始值指数据类型的零值，而不是代码中赋值的初始值（真正赋值操作要在初始化阶段）. </p>
</li>
<li><p>存在一个例外，如果字段存在ConstantValue属性，就会直接进行赋值操作</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>；<span class="comment">// 将会设置为0值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value=<span class="number">123</span>；<span class="comment">//将会直接设置为123</span></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>在Class文件被加载到Java虚拟机之前，这个类是无法知道其他类、方法、字段对应的具体地址，甚至连自己的方法、字段地址都不知道。所以，Java编译器在引用这些成员时，会生成一个符号引用。比方说对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的<code>符号引用</code>，来指代所要调用的方法。然后在实际的解析阶段，这些符号引用就会指向具体的目标上。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>在解析阶段，虚拟机主要功能：将常量池内的<code>符号引用</code>替换为<code>直接引用</code></p>
<ol>
<li>符号引用:以一组符号来描述引用的目标，可以是任何形式的字面量。如CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info等（具体看Class类结构）。符号引用与虚拟机实现的内存布局无关。如果符号引用指向了一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化）</li>
<li>直接引用：可以是直接指向目标的 指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机的内存布局相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。引用的目标必定存在于内存</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段就是执行类构造器（<strong>并不是实例构造器</strong>）＜clinit＞（）方法的过程。该方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。此外，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。需要注意的是，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        i=<span class="number">0</span>；<span class="comment">//给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print（i）；<span class="comment">//这句编译器会提示"非法向前引用"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>虚拟机严格规定了<strong>有且只有</strong>的五种情况必须立即对类进行初始化</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，类没有初始化则必须初始化(也就是new关键字对象、读取或设置类的静态字段(常量除外)、调用类静态方法)</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时</li>
<li>当初始化一个类时，发现其父类没初始化，则先触发父类的初始化</li>
<li>当虚拟机启动时，用户指定要执行的主类（main方法），虚拟机会先初始化这个类</li>
<li>使用JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实力最后解析结果为REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄，如果这个方法句柄对应的类没有初始化，则线初始化</li>
</ol>
<h4 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h4><p>所有引用类的方式都不会触发初始化，称为<code>被动引用</code></p>
<ol>
<li>通过子类引用父类的静态字段，不会导致子类初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化</li>
<li>其他类中的常量会在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触<br>发定义常量所在的类。如下例所示，在编译阶段，常量HELLOWORLD的值经过传播优化，早已存储到了NotInitialization类的常量池中，看似对ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用。因此不会触发ConstClass的初始化</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">    	System.out.println（<span class="string">"ConstClass init！"</span>）；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD=<span class="string">"hello world"</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line">    	System.out.println（ConstClass.HELLOWORLD）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="接口的初始化"><a href="#接口的初始化" class="headerlink" title="接口的初始化"></a>接口的初始化</h4><p>接口的加载过程与类时一致的，编译器会为接口生成”&lt; Clinit &gt;()”类构造器，主要用于初始化接口中所定义的成员变量，与类初始化不同的是，接口不需要先完成初始化，只有在真正使用到父接口时（如引用接口中定义的常量）才会初始化</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>在类加载阶段，虚拟机需要<strong>通过一个类的全限定名来获取定义此类的二进制字节流</strong>，而这个动作，被放到了Java虚拟机的外部实现，这个实现的模块就是<code>类加载器</code>。但需要注意的是，对于数组类来说，它并没有对应的字节流，而是由Java虚拟机直接生成的。</p>
<p><strong>类加载器与类共同确定类在Java虚拟机中的唯一性</strong>，也就是说，比较两个类的相等的前提是在同一个类加载器下才有意义，不然肯定不相同</p>
<p>类加载分类</p>
<ul>
<li><code>启动类加载器(Bootstrap ClassLoader)</code>： 负责加载 <code>JAVA_HOME\lib</code> 目录中的类，或通过<code>-Xbootclasspath</code> 参数指定路径中的，且被虚拟机认可（仅按文件名识别，如 rt.jar）的类，开发者无法直接使用</li>
<li><code>扩展类加载器(Extension ClassLoader)</code>：负责加载 <code>JAVA_HOME\lib\ext</code> 目录中的类，或通过 <code>java.ext.dirs</code> 系统变量指定路径中的类库，开发者可直接使用</li>
<li><code>应用程序类加载器(Application ClassLoader)</code>:又加系统加载器，应用程序默认类加载器，负责加载用户路径（classpath）上的类库。开发者可以直接使用</li>
<li>自定义类加载器：用于实现特殊的加载方式，如对class文件进行加密，加载时使用自定义的加载器解密</li>
</ul>
<p>在Java9中，引入了模块系统，扩展类加载器被改名为平台类加载器（platform class loader）。除了少数几个模块（如java.base）,其他模块均由平台类加载器加载。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>如图所示的类加载器之间的层次关系，被称为类的<code>双亲委派模型（Parents Delegation Model）</code>。要求除了顶层的启动类加载器外，其他的类加载器必须由父类加载器。</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt></p>
<p>双亲委派模型工作流程</p>
<ol>
<li>如果一个类加载器收到了类加载请求，它会先把这个请求委派给父类加载器区完成，每一个层次的类加载器都是如此（所以加载请求最终传送到启动类加载器中）</li>
<li>当父类加载器反馈无法完成这个加载请求（它的范围内没有找到所需的类），子类加载器才会尝试自己加载</li>
</ol>
<p>双亲委派模型优点：</p>
<ul>
<li>可以让Java类随着它的类加载器一起具备了带有优先级的层次关系，即优先加载父类范围内的类。如类Java.lang.Object,存放于rt.jar之中，由启动类加载器进行加载。在该模型下，只会优先加载Java.lang.Object,从而保证Object类的唯一性。</li>
<li>如果没有使用双亲委派模型，自定义一个Java.lang.Object,并把它放在ClassPath下，然后每一个类加载器都加载了自己的Object，使得一个系统中出现多个Object类，导致Java类型体系中最基础的行为也无法保证</li>
</ul>
<h3 id="OSGI：模块热部署"><a href="#OSGI：模块热部署" class="headerlink" title="OSGI：模块热部署"></a>OSGI：模块热部署</h3><p>OSGI 环境下，类加载器不在世双亲委派模型的树状结构，而是进一步发展为更为复杂的网状接口；它实现了模块化热部署。当收到类加载请求时，OSGI将按照一下的顺序进行类搜索</p>
<ol>
<li>将以java.*开头的类委派给父类加载器</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载</li>
<li>否则，将<code>Import</code>列表中的类委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载</li>
<li>否则，查找当前<code>Bundle</code>的<code>ClassPath</code>,使用自己的类加载器加载</li>
<li>否则，查找类是否在自己的<code>Fragment Bundle</code>中，如果在，则委派个<code>Fragment Bundle</code>的类加载器加载</li>
<li>否则，查找<code>Dynamic Import</code> 列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载</li>
<li>否则，类查找失败</li>
</ol>
<p>除了1、2两点符合双亲委派外，其余的类查找都是在平级类加载器中进行的</p>
<h1 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h1><h2 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2><p>对象的创建过程如下</p>
<ol>
<li>通过类加载机制加载类</li>
<li>为对象分配内存</li>
<li>对对象进行初始化零值（不包括对象头），使用TLAB可提前至TLAB分配时进行</li>
<li>对对象进行必要设置</li>
<li>执行&lt; init &gt;方法</li>
</ol>
<h2 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h2><p>为对象分配内存，需要有两步操作</p>
<ol>
<li>把一块确定大小的内存从Java堆中划分出来</li>
<li>将对象分配到内存中（考虑线程安全）</li>
</ol>
<h3 id="空间的划分"><a href="#空间的划分" class="headerlink" title="空间的划分"></a>空间的划分</h3><p>根据Java堆内存是否规整，分为两种方式划分</p>
<ol>
<li><code>指针碰撞</code>（Bump the Pointer）：如果<strong>内存规整</strong>，用过的和没用过的各自一边。那么只需要往中间放置一个指针作为<code>分界点指示器</code>，分配内存仅仅就是移动指针而已。</li>
<li><code>空闲列表(Free List)</code>： 如果<strong>内存不规整</strong>，即用过的和没用过的互相交错，那么就需要虚拟机来维护一个列表，该列表上记录了可用的内存，内存分配时就从列表中找到一块足够大的空间划分给对象实例</li>
</ol>
<p>而内存是否规整，<strong>取决于所采用的垃圾收集器</strong>,例如Serial、ParNew这样的基于<code>复制收集</code>算法，采用的是指针碰撞。而CMS这样的基于<code>标记-清除</code>算法，采用空闲列表</p>
<h3 id="分配对象"><a href="#分配对象" class="headerlink" title="分配对象"></a>分配对象</h3><p>考虑到创建对象可能实在并发的情况下进行，为了确保线程安全性，有以下两种方案</p>
<ol>
<li>使用同步方式进行分配对象，虚拟机一般采用CAS和失败重试的方法保证更新操作原子性</li>
<li>将内存分配的操作按线程划分在不同的空间进行，即每个线程再Java队中先分配一小块内存，称为<code>本地线程分配缓存</code>（TLAB，Thread Local Allocation Buffer）,然后将内存分配到TLAB中即可。如果TLAB容量不够时，再重新从Eden区域申请一块即可（申请操作为原子操作），开启TLAB操作的参数<code>-XX:+/UseTLAB</code></li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p> 在HotSpot虚拟机中，对象在内存中存储布局分三块区域</p>
<ol>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充</li>
</ol>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p> 对象头包括两部分信息</p>
<ul>
<li><p>第一部分：存储对象自身的<strong>运行时数据 </strong> </p>
<p>这部分数据被称为 <code>Mark Word</code>， 如HashCode,GC分代年龄，锁状态标志，线程持有锁，偏向线程id，偏向时间戳等；在32位和64位虚拟机中长度分别为32bit和64bit。它是一个非固定的数据结构，以便于尽量在极小的空间内存储更多的信息。 </p>
</li>
</ul>
<p>Mark Word在32bit空间中的分布</p>
<table border="1" cellspacing="0"><tbody><tr><td rowspan="2"><br>            &lt;p “&gt;锁状态<p></p><br>            </td><br>            <td colspan="2"><br>            &lt;p “&gt;25bit<p></p><br>            </td><br>            <td rowspan="2"><br>            <p ">4bit</p>
            </td>
            <td>
            <p ">1bit</p><br>            </td><br>            <td><br>            <p ">2bit</p>
            </td>
        </tr><tr><td>
            <p ">23bit</p><br>            </td><br>            <td><br>            <p ">2bit</p>
            </td>
            <td>
            <p ">是否偏向锁</p><br>            </td><br>            <td><br>            <p ">锁标志位</p>
            </td>
        </tr><tr><td>
            <p ">无锁</p><br>            </td><br>            <td colspan="2"><br>            <p ">对象的HashCode</p>
            </td>
            <td>
            <p ">分代年龄</p><br>            </td><br>            <td><br>            <p ">0</p>
            </td>
            <td>
            <p ">01</p><br>            </td><br>        </tr><tr><td><br>            <p ">偏向锁</p>
            </td>
            <td>
            <p ">线程ID</p><br>            </td><br>            <td><br>            <p ">Epoch</p>
            </td>
            <td>
            <p ">分代年龄</p><br>            </td><br>            <td><br>            <p ">1</p>
            </td>
            <td>
            <p ">01</p><br>            </td><br>        </tr><tr><td><br>            &lt;p “&gt;轻量级锁<p></p><br>            </td><br>            <td colspan="4" ">
            <p ">指向栈中锁记录的指针</p><br>            </td><br>            <td><br>            <p ">00</p>
            </td>
        </tr><tr><td>
            <p ">重量级锁</p><br>            </td><br>            <td colspan="4" ">
            <p ">指向重量级锁的指针</p><br>            </td><br>            <td><br>            <p ">10</p>
            </td>
        </tr><tr><td>
            <p ">GC标记</p><br>            </td><br>            <td colspan="4" ">
            <p ">空</p><br>            </td><br>            <td><br>            &lt;p “&gt;11<p></p><br>            </td><br>        </tr></tbody></table>



<ul>
<li><p>第二部分: <code>类型指针</code></p>
<p>虚拟机通过该指针确定对象是哪个类的实例，但并不是所有对象数据必须保留类型指针，即查找对象的元数据并不一定要经过对象本身    </p>
<p>如果是数组，对象头还需要一个额外的数据记录数组长度。(虚拟机可以通过元数据确定Java对象大小，而从数组的元数据是不可能知道数组大小的)  </p>
</li>
</ul>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p> 实例数据存储程序代码中定义的各种类型的字段内容，包括父类继承和子类本身定义。这部分的存储顺序受到<code>虚拟机分配策略</code>参数和字段在java源码中定义的顺序影响。</p>
<p>HotSpot默认分配策略: <code>longs/doubles</code>、<code>ints</code>、<code>shorts/chars</code>、<code>bytes/booleans</code>、<code>oops(Ordinary Object Pointers)</code>,可以明显看出，相同宽度的字段会被分配在一起。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充<strong>不是必须存在</strong>的，仅仅起到占位符的作用，因为HotSpot要求对象起始地址必须是8的倍数（即对象大小必须是8的整数倍），如果对象实例数据部分没有对齐，那么就需要通过对齐填充来补全</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>为了使用对象，必须从栈上的<code>renference</code>数据来操作对上的具体对象。而<code>renference</code>只规定了一个指向对象的引用，并没有定义访问方式。所以，对于对象的访问方式，取决于虚拟机，目前主流方式有使用<code>句柄</code>和<code>直接指针</code>两种。</p>
<h3 id="使用句柄访问"><a href="#使用句柄访问" class="headerlink" title="使用句柄访问"></a>使用句柄访问</h3><p>步骤：</p>
<ul>
<li>java会在堆中划分出一块内存来当<code>句柄池</code></li>
<li>reference中存储的对象就是<code>句柄地址</code></li>
<li>句柄中包含了对象的实例数据与类型数据的具体地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm.png" alt="jvm"></p>
<p>优势：使用句柄访问最大好处就是reference稳定，对象移动时无需更改reference,只会改变j句柄中的实例数据指针</p>
<h3 id="使用直接指针"><a href="#使用直接指针" class="headerlink" title="使用直接指针"></a>使用直接指针</h3><p>reference中存储的对象就是对象实例数据的地址</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm2.png" alt="jvm2"></p>
<p>优势：使用直接指针好处就是速度快，少一层指针定位的时间开销(HotSpot使用这种方式)</p>
<h1 id="虚拟机字节码指令表"><a href="#虚拟机字节码指令表" class="headerlink" title="虚拟机字节码指令表"></a>虚拟机字节码指令表</h1><hr>
<table>
<thead>
<tr>
<th>字节码</th>
<th>助记符</th>
<th>指令含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>nop</td>
<td>None</td>
</tr>
<tr>
<td>0x01</td>
<td>aconst_null</td>
<td>将null推送至栈顶</td>
</tr>
<tr>
<td>0x02</td>
<td>iconst_m1</td>
<td>将int型-1推送至栈顶</td>
</tr>
<tr>
<td>0x03</td>
<td>iconst_0</td>
<td>将int型0推送至栈顶</td>
</tr>
<tr>
<td>0x04</td>
<td>iconst_1</td>
<td>将int型1推送至栈顶</td>
</tr>
<tr>
<td>0x05</td>
<td>iconst_2</td>
<td>将int型2推送至栈顶</td>
</tr>
<tr>
<td>0x06</td>
<td>iconst_3</td>
<td>将int型3推送至栈顶</td>
</tr>
<tr>
<td>0x07</td>
<td>iconst_4</td>
<td>将int型4推送至栈顶</td>
</tr>
<tr>
<td>0x08</td>
<td>iconst_5</td>
<td>将int型5推送至栈顶</td>
</tr>
<tr>
<td>0x09</td>
<td>lconst_0</td>
<td>将long型0推送至栈顶</td>
</tr>
<tr>
<td>0x0a</td>
<td>lconst_1</td>
<td>将long型1推送至栈顶</td>
</tr>
<tr>
<td>0x0b</td>
<td>fconst_0</td>
<td>将float型0推送至栈顶</td>
</tr>
<tr>
<td>0x0c</td>
<td>fconst_1</td>
<td>将float型1推送至栈顶</td>
</tr>
<tr>
<td>0x0d</td>
<td>fconst_2</td>
<td>将float型2推送至栈顶</td>
</tr>
<tr>
<td>0x0e</td>
<td>dconst_0</td>
<td>将double型0推送至栈顶</td>
</tr>
<tr>
<td>0x0f</td>
<td>dconst_1</td>
<td>将double型1推送至栈顶</td>
</tr>
<tr>
<td>0x10</td>
<td>bipush</td>
<td>将单字节的常量值(-128~127)推送至栈顶</td>
</tr>
<tr>
<td>0x11</td>
<td>sipush</td>
<td>将一个短整型常量(-32768~32767)推送至栈顶</td>
</tr>
<tr>
<td>0x12</td>
<td>ldc</td>
<td>将int,float或String型常量值从常量池中推送至栈顶</td>
</tr>
<tr>
<td>0x13</td>
<td>ldc_w</td>
<td>将int,float或String型常量值从常量池中推送至栈顶(宽索引)</td>
</tr>
<tr>
<td>0x14</td>
<td>ldc2_w</td>
<td>将long或double型常量值从常量池中推送至栈顶(宽索引)</td>
</tr>
<tr>
<td>0x15</td>
<td>iload</td>
<td>将指定的int型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x16</td>
<td>lload</td>
<td>将指定的long型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x17</td>
<td>fload</td>
<td>将指定的float型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x18</td>
<td>dload</td>
<td>将指定的double型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x19</td>
<td>aload</td>
<td>将指定的引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1a</td>
<td>iload_0</td>
<td>将第一个int型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1b</td>
<td>iload_1</td>
<td>将第二个int型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1c</td>
<td>iload_2</td>
<td>将第三个int型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1d</td>
<td>iload_3</td>
<td>将第四个int型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1e</td>
<td>lload_0</td>
<td>将第一个long型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1f</td>
<td>lload_1</td>
<td>将第二个long型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x20</td>
<td>lload_2</td>
<td>将第三个long型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x21</td>
<td>lload_3</td>
<td>将第四个long型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x22</td>
<td>fload_0</td>
<td>将第一个float型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x23</td>
<td>fload_1</td>
<td>将第二个float型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x24</td>
<td>fload_2</td>
<td>将第三个float型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x25</td>
<td>fload_3</td>
<td>将第四个float型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x26</td>
<td>dload_0</td>
<td>将第一个double型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x27</td>
<td>dload_1</td>
<td>将第二个double型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x28</td>
<td>dload_2</td>
<td>将第三个double型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x29</td>
<td>dload_3</td>
<td>将第四个double型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x2a</td>
<td>aload_0</td>
<td>将第一个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x2b</td>
<td>aload_1</td>
<td>将第二个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x2c</td>
<td>aload_2</td>
<td>将第三个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x2d</td>
<td>aload_3</td>
<td>将第四个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x2e</td>
<td>iaload</td>
<td>将int型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x2f</td>
<td>laload</td>
<td>将long型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x30</td>
<td>faload</td>
<td>将float型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x31</td>
<td>daload</td>
<td>将double型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x32</td>
<td>aaload</td>
<td>将引用类型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x33</td>
<td>baload</td>
<td>将boolean或byte型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x34</td>
<td>caload</td>
<td>将char型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x35</td>
<td>saload</td>
<td>将short型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x36</td>
<td>istore</td>
<td>将栈顶int型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x37</td>
<td>lstore</td>
<td>将栈顶long型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x38</td>
<td>fstore</td>
<td>将栈顶float型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x39</td>
<td>dstore</td>
<td>将栈顶double型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x3a</td>
<td>astore</td>
<td>将栈顶引用类型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x3b</td>
<td>istore_0</td>
<td>将栈顶int型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x3c</td>
<td>istore_1</td>
<td>将栈顶int型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x3d</td>
<td>istore_2</td>
<td>将栈顶int型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x3e</td>
<td>istore_3</td>
<td>将栈顶int型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x3f</td>
<td>lstore_0</td>
<td>将栈顶long型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x40</td>
<td>lstore_1</td>
<td>将栈顶long型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x41</td>
<td>lstore_2</td>
<td>将栈顶long型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x42</td>
<td>lstore_3</td>
<td>将栈顶long型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x43</td>
<td>fstore_0</td>
<td>将栈顶float型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x44</td>
<td>fstore_1</td>
<td>将栈顶float型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x45</td>
<td>fstore_2</td>
<td>将栈顶float型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x46</td>
<td>fstore_3</td>
<td>将栈顶float型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x47</td>
<td>dstore_0</td>
<td>将栈顶double型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x48</td>
<td>dstore_1</td>
<td>将栈顶double型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x49</td>
<td>dstore_2</td>
<td>将栈顶double型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x4a</td>
<td>dstore_3</td>
<td>将栈顶double型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x4b</td>
<td>astore_0</td>
<td>将栈顶引用型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x4c</td>
<td>astore_1</td>
<td>将栈顶引用型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x4d</td>
<td>astore_2</td>
<td>将栈顶引用型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x4e</td>
<td>astore_3</td>
<td>将栈顶引用型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x4f</td>
<td>iastore</td>
<td>将栈顶int型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x50</td>
<td>lastore</td>
<td>将栈顶long型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x51</td>
<td>fastore</td>
<td>将栈顶float型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x52</td>
<td>dastore</td>
<td>将栈顶double型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x53</td>
<td>aastore</td>
<td>将栈顶引用型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x54</td>
<td>bastore</td>
<td>将栈顶boolean或byte型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x55</td>
<td>castore</td>
<td>将栈顶char型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x56</td>
<td>sastore</td>
<td>将栈顶short型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x57</td>
<td>pop</td>
<td>将栈顶数值弹出(数值不能是long或double类型的)</td>
</tr>
<tr>
<td>0x58</td>
<td>pop2</td>
<td>将栈顶的一个(对于非long或double类型)或两个数值(对于非long或double的其他类型)弹出</td>
</tr>
<tr>
<td>0x59</td>
<td>dup</td>
<td>复制栈顶数值并将复制值压入栈顶</td>
</tr>
<tr>
<td>0x5a</td>
<td>dup_x1</td>
<td>复制栈顶数值并将两个复制值压入栈顶</td>
</tr>
<tr>
<td>0x5b</td>
<td>dup_x2</td>
<td>复制栈顶数值并将三个(或两个)复制值压入栈顶</td>
</tr>
<tr>
<td>0x5c</td>
<td>dup2</td>
<td>复制栈顶一个(对于long或double类型)或两个(对于非long或double的其他类型)数值并将复制值压入栈顶</td>
</tr>
<tr>
<td>0x5d</td>
<td>dup2_x1</td>
<td>dup_x1指令的双倍版本</td>
</tr>
<tr>
<td>0x5e</td>
<td>dup2_x2</td>
<td>dup_x2指令的双倍版本</td>
</tr>
<tr>
<td>0x5f</td>
<td>swap</td>
<td>将栈顶最顶端的两个数值互换(数值不能是long或double类型)</td>
</tr>
<tr>
<td>0x60</td>
<td>iadd</td>
<td>将栈顶两int型数值相加并将结果压入栈顶</td>
</tr>
<tr>
<td>0x61</td>
<td>ladd</td>
<td>将栈顶两long型数值相加并将结果压入栈顶</td>
</tr>
<tr>
<td>0x62</td>
<td>fadd</td>
<td>将栈顶两float型数值相加并将结果压入栈顶</td>
</tr>
<tr>
<td>0x63</td>
<td>dadd</td>
<td>将栈顶两double型数值相加并将结果压入栈顶</td>
</tr>
<tr>
<td>0x64</td>
<td>isub</td>
<td>将栈顶两int型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>0x65</td>
<td>lsub</td>
<td>将栈顶两long型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>0x66</td>
<td>fsub</td>
<td>将栈顶两float型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>0x67</td>
<td>dsub</td>
<td>将栈顶两double型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>0x68</td>
<td>imul</td>
<td>将栈顶两int型数值相乘并将结果压入栈顶</td>
</tr>
<tr>
<td>0x69</td>
<td>lmul</td>
<td>将栈顶两long型数值相乘并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6a</td>
<td>fmul</td>
<td>将栈顶两float型数值相乘并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6b</td>
<td>dmul</td>
<td>将栈顶两double型数值相乘并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6c</td>
<td>idiv</td>
<td>将栈顶两int型数值相除并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6d</td>
<td>ldiv</td>
<td>将栈顶两long型数值相除并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6e</td>
<td>fdiv</td>
<td>将栈顶两float型数值相除并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6f</td>
<td>ddiv</td>
<td>将栈顶两double型数值相除并将结果压入栈顶</td>
</tr>
<tr>
<td>0x70</td>
<td>irem</td>
<td>将栈顶两int型数值作取模运算并将结果压入栈顶</td>
</tr>
<tr>
<td>0x71</td>
<td>lrem</td>
<td>将栈顶两long型数值作取模运算并将结果压入栈顶</td>
</tr>
<tr>
<td>0x72</td>
<td>frem</td>
<td>将栈顶两float型数值作取模运算并将结果压入栈顶</td>
</tr>
<tr>
<td>0x73</td>
<td>drem</td>
<td>将栈顶两double型数值作取模运算并将结果压入栈顶</td>
</tr>
<tr>
<td>0x74</td>
<td>ineg</td>
<td>将栈顶int型数值取负并将结果压入栈顶</td>
</tr>
<tr>
<td>0x75</td>
<td>lneg</td>
<td>将栈顶long型数值取负并将结果压入栈顶</td>
</tr>
<tr>
<td>0x76</td>
<td>fneg</td>
<td>将栈顶float型数值取负并将结果压入栈顶</td>
</tr>
<tr>
<td>0x77</td>
<td>dneg</td>
<td>将栈顶double型数值取负并将结果压入栈顶</td>
</tr>
<tr>
<td>0x78</td>
<td>ishl</td>
<td>将int型数值左移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x79</td>
<td>lshl</td>
<td>将long型数值左移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7a</td>
<td>ishr</td>
<td>将int型数值右(带符号)移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7b</td>
<td>lshr</td>
<td>将long型数值右(带符号)移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7c</td>
<td>iushr</td>
<td>将int型数值右(无符号)移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7d</td>
<td>lushr</td>
<td>将long型数值右(无符号)移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7e</td>
<td>iand</td>
<td>将栈顶两int型数值”按位与”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7f</td>
<td>land</td>
<td>将栈顶两long型数值”按位与”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x80</td>
<td>ior</td>
<td>将栈顶两int型数值”按位或”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x81</td>
<td>lor</td>
<td>将栈顶两long型数值”按位或”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x82</td>
<td>ixor</td>
<td>将栈顶两int型数值”按位异或”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x83</td>
<td>lxor</td>
<td>将栈顶两long型数值”按位异或”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x84</td>
<td>iinc</td>
<td>将指定int型变量增加指定值(如i++, i–, i+=2等)</td>
</tr>
<tr>
<td>0x85</td>
<td>i2l</td>
<td>将栈顶int型数值强制转换为long型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x86</td>
<td>i2f</td>
<td>将栈顶int型数值强制转换为float型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x87</td>
<td>i2d</td>
<td>将栈顶int型数值强制转换为double型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x88</td>
<td>l2i</td>
<td>将栈顶long型数值强制转换为int型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x89</td>
<td>l2f</td>
<td>将栈顶long型数值强制转换为float型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8a</td>
<td>l2d</td>
<td>将栈顶long型数值强制转换为double型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8b</td>
<td>f2i</td>
<td>将栈顶float型数值强制转换为int型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8c</td>
<td>f2l</td>
<td>将栈顶float型数值强制转换为long型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8d</td>
<td>f2d</td>
<td>将栈顶float型数值强制转换为double型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8e</td>
<td>d2i</td>
<td>将栈顶double型数值强制转换为int型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8f</td>
<td>d2l</td>
<td>将栈顶double型数值强制转换为long型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x90</td>
<td>d2f</td>
<td>将栈顶double型数值强制转换为float型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x91</td>
<td>i2b</td>
<td>将栈顶int型数值强制转换为byte型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x92</td>
<td>i2c</td>
<td>将栈顶int型数值强制转换为char型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x93</td>
<td>i2s</td>
<td>将栈顶int型数值强制转换为short型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x94</td>
<td>lcmp</td>
<td>比较栈顶两long型数值大小, 并将结果(1, 0或-1)压入栈顶</td>
</tr>
<tr>
<td>0x95</td>
<td>fcmpl</td>
<td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将-1压入栈顶</td>
</tr>
<tr>
<td>0x96</td>
<td>fcmpg</td>
<td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将1压入栈顶</td>
</tr>
<tr>
<td>0x97</td>
<td>dcmpl</td>
<td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将-1压入栈顶</td>
</tr>
<tr>
<td>0x98</td>
<td>dcmpg</td>
<td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将1压入栈顶</td>
</tr>
<tr>
<td>0x99</td>
<td>ifeq</td>
<td>当栈顶int型数值等于0时跳转</td>
</tr>
<tr>
<td>0x9a</td>
<td>ifne</td>
<td>当栈顶int型数值不等于0时跳转</td>
</tr>
<tr>
<td>0x9b</td>
<td>iflt</td>
<td>当栈顶int型数值小于0时跳转</td>
</tr>
<tr>
<td>0x9c</td>
<td>ifge</td>
<td>当栈顶int型数值大于等于0时跳转</td>
</tr>
<tr>
<td>0x9d</td>
<td>ifgt</td>
<td>当栈顶int型数值大于0时跳转</td>
</tr>
<tr>
<td>0x9e</td>
<td>ifle</td>
<td>当栈顶int型数值小于等于0时跳转</td>
</tr>
<tr>
<td>0x9f</td>
<td>if_icmpeq</td>
<td>比较栈顶两int型数值大小, 当结果等于0时跳转</td>
</tr>
<tr>
<td>0xa0</td>
<td>if_icmpne</td>
<td>比较栈顶两int型数值大小, 当结果不等于0时跳转</td>
</tr>
<tr>
<td>0xa1</td>
<td>if_icmplt</td>
<td>比较栈顶两int型数值大小, 当结果小于0时跳转</td>
</tr>
<tr>
<td>0xa2</td>
<td>if_icmpge</td>
<td>比较栈顶两int型数值大小, 当结果大于等于0时跳转</td>
</tr>
<tr>
<td>0xa3</td>
<td>if_icmpgt</td>
<td>比较栈顶两int型数值大小, 当结果大于0时跳转</td>
</tr>
<tr>
<td>0xa4</td>
<td>if_icmple</td>
<td>比较栈顶两int型数值大小, 当结果小于等于0时跳转</td>
</tr>
<tr>
<td>0xa5</td>
<td>if_acmpeq</td>
<td>比较栈顶两引用型数值, 当结果相等时跳转</td>
</tr>
<tr>
<td>0xa6</td>
<td>if_acmpne</td>
<td>比较栈顶两引用型数值, 当结果不相等时跳转</td>
</tr>
<tr>
<td>0xa7</td>
<td>goto</td>
<td>无条件跳转</td>
</tr>
<tr>
<td>0xa8</td>
<td>jsr</td>
<td>跳转至指定的16位offset位置, 并将jsr的下一条指令地址压入栈顶</td>
</tr>
<tr>
<td>0xa9</td>
<td>ret</td>
<td>返回至本地变量指定的index的指令位置(一般与jsr或jsr_w联合使用)</td>
</tr>
<tr>
<td>0xaa</td>
<td>tableswitch</td>
<td>用于switch条件跳转, case值连续(可变长度指令)</td>
</tr>
<tr>
<td>0xab</td>
<td>lookupswitch</td>
<td>用于switch条件跳转, case值不连续(可变长度指令)</td>
</tr>
<tr>
<td>0xac</td>
<td>ireturn</td>
<td>从当前方法返回int</td>
</tr>
<tr>
<td>0xad</td>
<td>lreturn</td>
<td>从当前方法返回long</td>
</tr>
<tr>
<td>0xae</td>
<td>freturn</td>
<td>从当前方法返回float</td>
</tr>
<tr>
<td>0xaf</td>
<td>dreturn</td>
<td>从当前方法返回double</td>
</tr>
<tr>
<td>0xb0</td>
<td>areturn</td>
<td>从当前方法返回对象引用</td>
</tr>
<tr>
<td>0xb1</td>
<td>return</td>
<td>从当前方法返回void</td>
</tr>
<tr>
<td>0xb2</td>
<td>getstatic</td>
<td>获取指定类的静态域, 并将其压入栈顶</td>
</tr>
<tr>
<td>0xb3</td>
<td>putstatic</td>
<td>为指定类的静态域赋值</td>
</tr>
<tr>
<td>0xb4</td>
<td>getfield</td>
<td>获取指定类的实例域, 并将其压入栈顶</td>
</tr>
<tr>
<td>0xb5</td>
<td>putfield</td>
<td>为指定类的实例域赋值</td>
</tr>
<tr>
<td>0xb6</td>
<td>invokevirtual</td>
<td>调用实例方法</td>
</tr>
<tr>
<td>0xb7</td>
<td>invokespecial</td>
<td>调用超类构建方法, 实例初始化方法, 私有方法</td>
</tr>
<tr>
<td>0xb8</td>
<td>invokestatic</td>
<td>调用静态方法</td>
</tr>
<tr>
<td>0xb9</td>
<td>invokeinterface</td>
<td>调用接口方法</td>
</tr>
<tr>
<td>0xba</td>
<td>invokedynamic</td>
<td>调用动态方法</td>
</tr>
<tr>
<td>0xbb</td>
<td>new</td>
<td>创建一个对象, 并将其引用引用值压入栈顶</td>
</tr>
<tr>
<td>0xbc</td>
<td>newarray</td>
<td>创建一个指定的原始类型(如int, float, char等)的数组, 并将其引用值压入栈顶</td>
</tr>
<tr>
<td>0xbd</td>
<td>anewarray</td>
<td>创建一个引用型(如类, 接口, 数组)的数组, 并将其引用值压入栈顶</td>
</tr>
<tr>
<td>0xbe</td>
<td>arraylength</td>
<td>获取数组的长度值并压入栈顶</td>
</tr>
<tr>
<td>0xbf</td>
<td>athrow</td>
<td>将栈顶的异常抛出</td>
</tr>
<tr>
<td>0xc0</td>
<td>checkcast</td>
<td>检验类型转换, 检验未通过将抛出 ClassCastException</td>
</tr>
<tr>
<td>0xc1</td>
<td>instanceof</td>
<td>检验对象是否是指定类的实际, 如果是将1压入栈顶, 否则将0压入栈顶</td>
</tr>
<tr>
<td>0xc2</td>
<td>monitorenter</td>
<td>获得对象的锁, 用于同步方法或同步块</td>
</tr>
<tr>
<td>0xc3</td>
<td>monitorexit</td>
<td>释放对象的锁, 用于同步方法或同步块</td>
</tr>
<tr>
<td>0xc4</td>
<td>wide</td>
<td>扩展本地变量的宽度</td>
</tr>
<tr>
<td>0xc5</td>
<td>multianewarray</td>
<td>创建指定类型和指定维度的多维数组(执行该指令时, 操作栈中必须包含各维度的长度值), 并将其引用压入栈顶</td>
</tr>
<tr>
<td>0xc6</td>
<td>ifnull</td>
<td>为null时跳转</td>
</tr>
<tr>
<td>0xc7</td>
<td>ifnonnull</td>
<td>不为null时跳转</td>
</tr>
<tr>
<td>0xc8</td>
<td>goto_w</td>
<td>无条件跳转(宽索引)</td>
</tr>
<tr>
<td>0xc9</td>
<td>jsr_w</td>
<td>跳转至指定的32位offset位置, 并将jsr_w的下一条指令地址压入栈顶</td>
</tr>
</tbody>
</table>
<h1 id="Hotspot-虚拟机参数表"><a href="#Hotspot-虚拟机参数表" class="headerlink" title="Hotspot 虚拟机参数表"></a>Hotspot 虚拟机参数表</h1><p>官网查询地址: <a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html?ssSourceSiteId=otncn" target="_blank" rel="noopener">Hotspot 虚拟机参数表</a></p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p><code>TPS（每秒事务处理数 Transactions Per Second）</code>：衡量一个服务器性能的高低好坏的一个重要指标：表示一秒内服务端评价能响应的请求总数</p>
<p><code>Java内存模型(Java Memory Model, JMM)</code>：用于屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致性的内存访问效果</p>
<h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>​    <strong>并发执行计算任务</strong>和<strong>充分利用处理器</strong>，是提升性能的关键。但事实上，想要更好的执行运算任务，光靠处理器是不够的。因为处理器在处理数据时会与内存进行交互，必然会存在IO操作，然而处理器与存储设备之间的运算速度之间差距太大，所以现在的计算机系统加入了一层高速缓存来作为内存与处理器之间的缓冲，使其京可能接近处理器运算速度。它的运作流程为：将运算需要使用到的数据复制到缓存中，让运算快速运行，运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。</p>
<p>​    高速缓存虽然解决了处理器与内存的速度矛盾，但也带来了一个新的问题：<code>缓存一致性（Cache Coherence）</code>。在处理系统中，每个处理器都有独立的高速缓存，但同时又共享同一<code>主内存（Main Memory）</code>,当多个处理器的运算任务都设计同一块主内存的时候，可能会导致缓存数据的不一致。为了解决这个问题，在处理器访问缓存时，会遵循一些协议（不同物理机器协议也会不同），使得缓存数据一致。在这个基础上，<strong>所谓的内存模型，就可以理解为在特定操作协议下，对特定内存或高速缓存进行读写访问的过程抽象</strong></p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/缓存一致性.png" alt="缓存一致性"></p>
<p>​    除了高速缓存外，<code>乱序执行优化(Out-Of-Order Execution)</code>也是使处理器内部的运算单元能尽量被利用的方法，也就是说，在处理过程中，计算的先后顺序可能与输入代码中的顺序不一致，只保证最后的结果一致。Java虚拟机的即时编译器也有类似的<code>指令重排序(Instruction Reorder)</code>优化</p>
<h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>​    <strong>Java内存模型主要是用于定义程序中各个共享变量（包括实例字段、静态字段、构成数组对象的元素）的访问规则</strong>，即变量在内存和存储设备之间的读写。而对于局部变量、方法参数这些线程私有变量，因其不存在竞争问题，所以并不在Java内存模型中。</p>
<p>​    Java内存模型规定所有变量都存储在主内存中，每条线程拥有自己的<code>工作内存（Working Memroy）</code>,作为高速缓存的角色。工作内存会保存该线程所用到的从主内存拷贝而来的变量（但并不会拷贝整个变量），然后在其中进行操作。不同线程之间的工作内存相互独立，想要传递数值则必须通过主内存进行</p>
<p>​    可以看到，java内存模型与上一节的高速缓存模型结构类似</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/java内存模型.png" alt="java内存模型"></p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>如何从主内存拷贝变量到工作内存，又如何从工作内存将数据同步到主内存，且保证操作为原子性，Java内存模型共定义了8中操作完成</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
<th>作用位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock（锁定）</td>
<td>把一个变量标识为一条线程独占状态</td>
<td>主内存</td>
</tr>
<tr>
<td>unlock（解锁）</td>
<td>把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</td>
<td>主内存</td>
</tr>
<tr>
<td>read（读取）</td>
<td>把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</td>
<td>工作内存</td>
</tr>
<tr>
<td>load（载入）</td>
<td>把通过read操作从主内存中得到的变量值放入工作内存的变量副本中</td>
<td>工作内存</td>
</tr>
<tr>
<td>use（使用）</td>
<td>把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作</td>
<td>工作内存</td>
</tr>
<tr>
<td>assign（赋值）</td>
<td>把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td>
<td>工作内存</td>
</tr>
<tr>
<td>store（存储）</td>
<td>把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作使用</td>
<td>工作内存</td>
</tr>
<tr>
<td>write（写入）</td>
<td>把通过store操作从工作内存中得到的变量的值放入主内存的变量中</td>
<td>工作内存</td>
</tr>
</tbody>
</table>
<p>​    例如，如果要执行变量从主内存复制到工作内存，就需要顺序执行read和load操作；如果需要把工作内存同步到主内存，就需要顺序执行store和write操作。类似于这样的操作，Java内存模型只要求保证执行顺序即可，允许在其中插入其他命令。</p>
<p>​    Java内存模型对8中操作的定制了一些必须满足的规定</p>
<ol>
<li>不允许read和load、store和write操作之一单独出现。</li>
<li>不允许线程丢弃它的最近的assign操作，即变量在工作内存中改变之后，必须同步回主内存。</li>
<li>不允许线程把没有经过assign操作的变量，同步回主内存。</li>
<li>一个新的变量只能在主内存中诞生，即对一个变量进行use、store操作之前，必须先执行过load、assign操作。</li>
<li>一个变量在同一时刻只能被一条线程执行lock操作，一旦lock成功，可以被同一线程重复lock多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>对一个变量执行lock操作，将会清空工作内存中该变量的值，所以在执行引擎使用这个变量前，需要重新执行load或assign操作对其进行初始化。</li>
<li>对一个变量执行unlock操作之前，必须先把该变量同步回主内存(执行store、write操作)。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许unlock一个被其他线程lock的变量</li>
</ol>
<h2 id="对Volatile型变量的特殊规则"><a href="#对Volatile型变量的特殊规则" class="headerlink" title="对Volatile型变量的特殊规则"></a>对Volatile型变量的特殊规则</h2><p>Java内存模型对Volatile定义了一些特殊的访问规则，volatile是Java虚拟机提供了一个轻量级的同步机制，它能保证变量的可见性，但不能保证原子性。</p>
<p>如执行以下程序，该程序虽然使用了volatile，但其仍然是线程不安全的。<code>cool++</code> 指令在虚拟机中，实际上是由四条指令构成，可能在执行iconst_1或者iadd，其他线程完全有可能改变了cool的值（实际上，就算只有一条指令，也不能说明这条指令是原子操作，字节码指令在解释器中也是要运行多行代码）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cool;</span><br><span class="line">cool = cool ++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cool++的字节码指令</span></span><br><span class="line">0: getstatic     #3                  // Field cool:I</span><br><span class="line"><span class="number">3</span>: iconst_1</span><br><span class="line"><span class="number">4</span>: iadd</span><br><span class="line">5: putstatic     #3                  // Field cool:I</span><br></pre></td></tr></table></figure>
<p>除了保证可见性的特性外，volatile的另一个特性是<code>禁止指令重排序优化</code></p>
<p>特殊规则如下</p>
<ol>
<li>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load操作。线程T对变量V的use操作可以认为是与线程T对变量V的load和read操作相关联的，必须一起连续出现。<strong>这条规则要求在工作内存中，每次使用变量V之前都必须先从主内存刷新最新值，用于保证能看到其它线程对变量V所作的修改后的值</strong>。</li>
<li><p>只有当线程T对变量V执行的前一个动是assign的时候，线程T才能对变量V执行store操作；并且，只有当线程T对变量V执行的后一个动作是store操作的时候，线程T才能对变量V执行assign操作。线程T对变量V的assign操作可以认为是与线程T对变量V的store和write操作相关联的，必须一起连续出现。<strong>这一条规则要求在工作内存中，每次修改V后都必须立即同步回主内存中，用于保证其它线程可以看到自己对变量V的修改</strong>。</p>
</li>
<li><p>假定操作A是线程T对变量V实施的use或assign动作，假定操作F是操作A相关联的load或store操作，假定操作P是与操作F相应的对变量V的read或write操作；类型地，假定动作B是线程T对变量W实施的use或assign动作，假定操作G是操作B相关联的load或store操作，假定操作Q是与操作G相应的对变量V的read或write操作。如果A先于B，那么P先于Q。<strong>这条规则要求valitile修改的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同</strong>。</p>
</li>
</ol>
<h2 id="对于long和double性变量的特殊规则"><a href="#对于long和double性变量的特殊规则" class="headerlink" title="对于long和double性变量的特殊规则"></a>对于long和double性变量的特殊规则</h2><p>​    java内存模型对于64位数据的特殊规定：运行虚拟机将<strong>没有被volatile修饰</strong>的64位数据的读写操作划分为两次32位操作（在JDK1.5后，读为原子性，写操作拆分），也就是说对<strong>这两种数据类型的操作是非原子性的</strong>，这就是所谓的非原子性协定（Nonatomic Treatment of double and long Variables）。之所以要分为两次32位操作，主要原因是受限于硬件，必须差分成32bit来处理。虽然，这么做，线程是很有可能得到一个半个变量的值，但实际上是很少见的情况。更何况，现在的虚拟机商家早就自己实现了64位数据的原子性操作，所以我们一般不需要生命volatile变量</p>
<h2 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h2><p>​    原子性（Atomicity）：即对变量的操作在完成前是完全不受干扰，要执行就执行完成，要么就不执行。Java内存除了提供的8个操作用于保证原子性，其中，lock和unlock操作没有开放给用户，但虚拟机提供了monitorenter和monitorexit两个字节码指令来隐式使用这两个操作，sysnchronized关键字便是使用了这两个字节码指令来完成原子性操作的</p>
<p>​    可见性(Visibility)：即一个线程改变共享值，所有线程都可以感知这个变化。Java内存保证可见性的机制为修改变量后同步刷新回主内存，读取变量前会先从主内存中刷新。volatile、synchronized和final，都可以实现可见性。final实现可见性的原理为：被final修饰的字段在构造器中一旦初始化完成，<strong>并且this没有引用逃逸</strong>，其他线程就能看见该字段的值</p>
<p>​    有序性(Ordering)：如果在本线程内观察，所有的操作都是有序的（体现为<code>线程内表现为串行的语义&quot;）；如果在一个线程观察另一个线程，所有的操作都是无序的(体现为</code>指令重排序<code>和</code>工作内存于主内存同步延迟`)。volatile关键字禁止指令重排序，synchronize规定持有同一个锁的两个同步快只能串行地进入</p>
<h2 id="先行发生原则-happens-before"><a href="#先行发生原则-happens-before" class="headerlink" title="先行发生原则(happens-before)"></a>先行发生原则(happens-before)</h2><p>先行发生原则十分重要，它规定了代码执行的顺序，如果没有顺序性的保障，虚拟机就有可能进行重排序。</p>
<p>以一个简单例子为例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a +b;</span><br><span class="line">a= b-<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>
<p>这段代码没有任何问题？是的，但如果没有先行发生原则的保证，那虚拟机重新排序后可能按以下顺序执行,那问题就大了</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">a= b-<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a +b;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>
<p>事实上，在先行发生原则下，保证了虚拟机会按照从上到下来执行语句（当然可能进行重排序优化，但起码保证了执行结果不会出错）</p>
<p>Java提供的具体规则如下</p>
<ol>
<li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对于同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li>
<li>volatile变量规则（Volatile Variable Rule）：对于一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间的先后顺序。</li>
<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则（Thread Interrupt Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ol>
<p><strong>需要注意的是，就算按照先行发生原则下的代码，在时间上的执行也不一定是顺序的，如“指令重排序”</strong></p>
<h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><p><code>as-if-serial</code>:意为所有操作的顺序可以为了优化而重排序，但结果保持不变。但只适用于单线程</p>
<h3 id="单线程下的重排序"><a href="#单线程下的重排序" class="headerlink" title="单线程下的重排序"></a>单线程下的重排序</h3><p>如下示例，step1和step2之间没有数据依赖关系，但stpe1、step2与step3存在数据依赖关系</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//step1</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">//step2</span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">//step3</span></span><br></pre></td></tr></table></figure></div>
<p>上述代码的happens-before关系为</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">step1 happens-before step2 <span class="comment">// 程序顺序次序规则</span></span><br><span class="line">step2 happens-before step3 <span class="comment">// 程序顺序次序规则</span></span><br><span class="line">step1 happens-before step3 <span class="comment">// 传递性</span></span><br></pre></td></tr></table></figure></div>
<p>但事实上并不一定会按照上述的顺序执行，而很有可能为了优化而改变顺序</p>
<h3 id="多线程下的重排序"><a href="#多线程下的重排序" class="headerlink" title="多线程下的重排序"></a>多线程下的重排序</h3><p><strong>多线程下的排序，将会改变执行结果</strong></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">    iboolean flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//step1 </span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//step2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;<span class="comment">//step3</span></span><br><span class="line">            <span class="keyword">int</span> b = a+a;<span class="comment">//step4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果线程A执行wirter()方法，线程B执行read()方法,可能出现以下两种情况</p>
<p>情况1：step1 、step2之间没有依赖关系，进行重排序，导致a的值没有改变的时候，step4就读取了a，导致结果错误</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="keyword">true</span>; <span class="comment">//线程A</span></span><br><span class="line"><span class="keyword">if</span>(flag)<span class="comment">//线程B</span></span><br><span class="line"><span class="keyword">int</span> b = a+a;<span class="comment">//线程B</span></span><br><span class="line">a = <span class="number">1</span><span class="comment">//线程A</span></span><br></pre></td></tr></table></figure></div>
<p>情况2：step3、step4存在<code>控制依赖关系</code>，<strong>当代码中存在控制依赖性时，会影响指令序列执行的并行度</strong>。为此，编译器和处理器会采用<code>猜测（Speculation）</code>执行来克服控制相关性对并行度的影响。在猜测执行的影响下，step的a+a操作很有可能提前读取a的值，然后把计算结果存入到一个。名为<code>重排序缓冲（reorder buffer ROB）</code>的硬件缓存中。当接下来setp3的条件判断为真时，就把该计算结果写入变量b中。但是，结果已经发生改变<br><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp = a *a;<span class="comment">//线程B,读取到了为a初始化之前的值</span></span><br><span class="line">flag = <span class="keyword">true</span>;<span class="comment">//线程A</span></span><br><span class="line"><span class="keyword">if</span>(flag)<span class="comment">//线程B</span></span><br><span class="line"><span class="keyword">int</span> b = temp;<span class="comment">//线程B</span></span><br><span class="line">a = <span class="number">1</span><span class="comment">//线程B</span></span><br></pre></td></tr></table></figure></div></p>
<h3 id="volatile、synchronize、final重排序规则"><a href="#volatile、synchronize、final重排序规则" class="headerlink" title="volatile、synchronize、final重排序规则"></a>volatile、synchronize、final重排序规则</h3><p>volatile：禁止重排序，即当执行到volatile修饰的变量时，位于其前面的语句肯定已经执行（前面语句的顺序可以重排），位于其后面的语句肯定没有执行（后面语句的顺序可以重排）</p>
<p>synchronize：规定持有同一个锁的两个同步快只能串行地进入</p>
<p>final重排序有两个规则</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;                            <span class="comment">//普通变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;                      <span class="comment">//final变量</span></span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinalExample</span> <span class="params">()</span> </span>&#123;     <span class="comment">//构造函数</span></span><br><span class="line">        i = <span class="number">1</span>;                        <span class="comment">//写普通域</span></span><br><span class="line">        j = <span class="number">2</span>;                        <span class="comment">//写final域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span> <span class="params">()</span> </span>&#123;    <span class="comment">//写线程A执行</span></span><br><span class="line">        obj = <span class="keyword">new</span> FinalExample ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;       <span class="comment">//读线程B执行</span></span><br><span class="line">        FinalExample object = obj;       <span class="comment">//读对象引用</span></span><br><span class="line">        <span class="keyword">int</span> a = object.i;                <span class="comment">//读普通域</span></span><br><span class="line">        <span class="keyword">int</span> b = object.j;                <span class="comment">//读final域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>规则1：在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序，如果再细化分解，该规则包含两个方面</p>
<ol>
<li>禁止编译器把 final 域的写重排序到构造函数之外</li>
<li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程A的执行顺序</span></span><br><span class="line">构造函数开始</span><br><span class="line">j = <span class="number">1</span> <span class="comment">// 写入final域</span></span><br><span class="line">StoreStore屏障</span><br><span class="line">构造函数结束</span><br><span class="line">把构造对象的引用赋值给变量obj<span class="comment">//引用赋值</span></span><br><span class="line">i = <span class="number">1</span>; <span class="comment">//写入普通域，随便排序</span></span><br></pre></td></tr></table></figure></div>
<p>规则2：在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程B执行顺序</span></span><br><span class="line"><span class="keyword">int</span> a = object.i;  <span class="comment">//读取普通域，随便排序</span></span><br><span class="line">FinalExample object = obj <span class="comment">//读对象引用</span></span><br><span class="line">LoadLoad屏障 <span class="comment">// 插入屏障，在读final域之前</span></span><br><span class="line"><span class="keyword">int</span> b = object.j;  <span class="comment">// 读final域</span></span><br></pre></td></tr></table></figure></div>
<p>需要注意的是，在使用final要防止<code>this的引用逃逸</code></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;                              <span class="comment">//1写final域</span></span><br><span class="line">        obj = <span class="keyword">this</span>;                          <span class="comment">//2 this引用在此“逸出”</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;   <span class="comment">//线程A执行</span></span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeExample ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reader &#123;  <span class="comment">//线程B执行</span></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                     <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> temp = obj.i;                 <span class="comment">//4 读取final域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如上代码,线程A、B的执行顺序可能如下，</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">构造函数开始 <span class="comment">//线程A</span></span><br><span class="line">obj=<span class="keyword">this</span>; <span class="comment">//线程A，引用逃逸，obj变为可见</span></span><br><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span><span class="comment">// 线程B</span></span><br><span class="line"><span class="keyword">int</span> temp = obj.i; <span class="comment">//线程B，读取final域，读取到了final域初始化之前的值</span></span><br><span class="line">i = <span class="number">1</span>; <span class="comment">//线程A，final域初始化</span></span><br><span class="line">构造函数结束</span><br></pre></td></tr></table></figure></div>
<p>可以看出，在构造函数返回前，<strong>被构造的对象的引用不能为其他线程可见</strong>，因为此时的 final 域可能还没有被初始化</p>
<h1 id="OOM异常"><a href="#OOM异常" class="headerlink" title="OOM异常"></a>OOM异常</h1><p>OOM异常，也就是OutOfMemoryError异常，除了计数器外，虚拟机内存的运行时区域均有可能发生OOM异常</p>
<h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>原因：Java堆用于保存实例对象，当实例对象的数量超出最大堆容量限制后，便会产生java堆溢出</p>
<p>异常提示：<strong>显示异常信息java.lang.OutOfMemoryError并进一步提示Java heap space</strong></p>
<p>解决办法：</p>
<ol>
<li><p>通过分析堆转储快照，确认内存中的对象是否必要，即分清楚使内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)</p>
</li>
<li><p>如果是内存泄漏，就需要进一步查看泄漏对象到GC Roots的引用链，查找泄漏对象与GC Roots使如何保持相关联导致收集器无法回收</p>
</li>
<li><p>如果是内存溢出</p>
<p>a. 考虑是否能调大堆参数(-Xmx、-Xms)</p>
<p>b. 从代码检查是否存在某些对象生命周期过长、持有状态时间过长等情况，尝试减少程序运行期的内存</p>
</li>
</ol>
<p>内存泄漏：指由于疏忽或错误造成程序未能释放已经不再使用的。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费</p>
<p>示例：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置堆大小位20m,并在溢出时dump内存堆转储快照</span></span><br><span class="line"><span class="comment">//-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid14928.hprof ...</span><br><span class="line">Heap dump file created [28112692 bytes in 0.124 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure></div>
<h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>HotSpot虚拟机不区分虚拟机栈和本地方法栈，所以<code>-Xoss</code>参数（设置本地方法栈大小）无效，直接设置<code>-Xss</code>参数（设置栈容量）即可</p>
<h3 id="栈StackOverflowError溢出"><a href="#栈StackOverflowError溢出" class="headerlink" title="栈StackOverflowError溢出"></a>栈StackOverflowError溢出</h3><p>原因：当线程请求的栈深度大于虚拟机所允许的最大深度时，将会抛出StackOverflowError异常</p>
<p>异常提示：抛出StackOverflowError</p>
<p>解决办法：</p>
<ol>
<li>提高栈的大小(<code>-Xss</code>参数)</li>
<li>大量本地遍历会增大方法帧中本地变量表的长度，考虑能否减少本地变量</li>
</ol>
<p>示例：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置栈大小位128K</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//通过无线递归，达到栈溢出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackLength ++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackSOF javaVMStackSOF = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            javaVMStackSOF.stackLeak();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(javaVMStackSOF.stackLength);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>结果：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1004</span><br><span class="line">java.lang.StackOverflowError</span><br></pre></td></tr></table></figure></div>
<h3 id="栈OutOfMemoryError溢出"><a href="#栈OutOfMemoryError溢出" class="headerlink" title="栈OutOfMemoryError溢出"></a>栈OutOfMemoryError溢出</h3><p>原因：虚拟机在扩展栈时无法申请到足够的内存空间时（多线程），则抛出OutOfMemoryError异常。</p>
<p>异常提示：抛出<code>java.lang.OutOfMemroy</code>Error并进一步提示<code>unable to create new native thread</code></p>
<p>解决办法：</p>
<ol>
<li>考虑减少线程数</li>
<li>减小最大堆，那么分配到栈的内存就会更多</li>
</ol>
<p>（如果喜欢获取更多的线程的话，可以减少栈容量）</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置较大的栈内存，然后通过不断建立线程（每个线程都会分配栈内存），产生OOM异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    go();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackOOM javaVMStackOOM = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        javaVMStackOOM.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>结果：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">失败。。。电脑卡死了。。。</span><br><span class="line">原因：当前环境使Windows，Java线程会映射到操作系统的内核线程上</span><br></pre></td></tr></table></figure></div>
<h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><h3 id="常量池溢出"><a href="#常量池溢出" class="headerlink" title="常量池溢出"></a>常量池溢出</h3><p>原因：过多的常量存储到常量池中</p>
<p>异常提示：抛出<code>java.lang.OutOfMemoryError</code>并进一步提示<code>PermGen space</code></p>
<p>解决办法：因为运行时常量池存在于方法区，可以通过调整方法区大小(<code>-XX:permSize</code>, <code>-XX:MaxPermSize</code> )</p>
<p>（在Java 1.7后，常量池移动到了堆中）</p>
<p>示例：</p>
<p>如下方法仅适用于JDK1.6及以前的版本</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过-XX:permSize = 10m -XX:MaxPermSize =10m,限制方法区大小</span></span><br><span class="line"><span class="comment">//intern()方法作用：</span></span><br><span class="line"><span class="comment">//1. 如果字符串常量池中已经包含了Stirng对象的字符串，则返回这个字符串对象</span></span><br><span class="line"><span class="comment">//2. 否则，则将String对象的字符串添加到常量池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//通过循环不断添加常量到常量池</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><p>原因：方法区用于存储类的相关信息，大量的类会导致方法区溢出</p>
<p>异常提示：抛出<code>java.lang.OutOfMemoryError</code>并进一步提示<code>PermGen space</code></p>
<p>解决办法：调整方法区大小(<code>-XX:permSize</code>, <code>-XX:MaxPermSize</code> )</p>
<p>（方法区除了常量池外，还存放在Class的描述信息，如类型、访问修饰符、字段描述等，想要使方法区溢出，那么可以使用大量的类实现溢出）</p>
<h2 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h2><p>原因：代码中申请了太多直接内存, 不过<strong>它在抛出异常时并没有真正分配到内存，而是通过计算得知内存分配不足</strong></p>
<p>异常提示：抛出<code>java.lang.OutOfMemoryError</code>，最大的特征位Heap Dump未见中不会看见明显的异常，且Dump文件很小，或者程序又直接或间接使用了NIO，那么可能是直接内存溢出</p>
<p>解决办法：使用<code>-XX:MaxDirectMemorySize</code>来限制直接内存大小，默认与Java堆最大值一样</p>
<h1 id="虚拟机性能监控和故障处理工具"><a href="#虚拟机性能监控和故障处理工具" class="headerlink" title="虚拟机性能监控和故障处理工具"></a>虚拟机性能监控和故障处理工具</h1><h2 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h2><p>工具位于<code>$JAVA_HOME/bin</code>,如比较熟悉的<code>java、javac</code></p>
<p>JDK监控和故障处理工具表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:center">主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">jps</td>
<td style="text-align:center">JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程</td>
</tr>
<tr>
<td style="text-align:left">jstat</td>
<td style="text-align:center">JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据</td>
</tr>
<tr>
<td style="text-align:left">jinfo</td>
<td style="text-align:center">Configguration Info for Java，显示虚拟机配置信息</td>
</tr>
<tr>
<td style="text-align:left">jmap</td>
<td style="text-align:center">Memory Map for Java,生成虚拟机的内存转储快照</td>
</tr>
<tr>
<td style="text-align:left">jhat</td>
<td style="text-align:center">JVM Heap Analysis Tool,用于分析heapdump（jmap内存转储）文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td>
</tr>
<tr>
<td style="text-align:left">jstack</td>
<td style="text-align:center">Stack Trace For Java,显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
<h3 id="jps-虚拟机j进程状况工具"><a href="#jps-虚拟机j进程状况工具" class="headerlink" title="jps:虚拟机j进程状况工具"></a>jps:虚拟机j进程状况工具</h3><p>jps功能：</p>
<p>​    列出正在运行的虚拟机进程,显示虚拟机执行<strong>主类名称</strong>以及这些进程的<strong>本地虚拟机唯一id</strong>(LVMID, Local Virtual Machine Identifier)</p>
<p>jps命令格式：</p>
<p>​     jps可以通过<code>RMI协议</code>[^11]查询开启了RMI服务的远程虚拟机进程状态</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hostid为RMI注册表中注册的主机名</span></span><br><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure></div>
<p>jps工具常用选项</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-q</td>
<td style="text-align:center">只输出LVMID</td>
</tr>
<tr>
<td style="text-align:left">-m</td>
<td style="text-align:center">输出虚拟机进程启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td style="text-align:left">-l</td>
<td style="text-align:center">输出主类的全名，如果进程执行的是jar包，输出Jar路径</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:center">输出虚拟机进程启动时JVM参数</td>
</tr>
</tbody>
</table>
<h3 id="jstat-：-虚拟机统计信息监视工具"><a href="#jstat-：-虚拟机统计信息监视工具" class="headerlink" title="jstat ： 虚拟机统计信息监视工具"></a>jstat ： 虚拟机统计信息监视工具</h3><p><code>jstat</code>是用于监视虚拟机各种运行状态信息的命令行工具,它可以本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</p>
<p>jstat命令格式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*	interval: 查询间隔</span><br><span class="line">*	count: 查询次数</span><br><span class="line">*	省略以上两个参数，说明值查询一次</span><br><span class="line">* 	option：要查询的虚拟机信息</span><br><span class="line">*/</span><br><span class="line">jstat [option vmid [interval] [s|ms] [count]]</span><br><span class="line"></span><br><span class="line">// vmid：</span><br><span class="line">//	1. 如果是本地虚拟机进程，vmid与lvmid一致</span><br><span class="line">//	2. 如果是远程虚拟机进程，格式如下</span><br><span class="line">[protocol:][//]lvmid[hostname[:port]/servername]</span><br></pre></td></tr></table></figure></div>
<p> <code>option</code>选项：主要<code>分类装载</code>、<code>垃圾收集</code>、<code>运行期编译状况</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-class</td>
<td style="text-align:center">监视类装载、卸载数量、总空间以及类装载所耗费的时间</td>
</tr>
<tr>
<td style="text-align:left">-gc</td>
<td style="text-align:center">监视Java堆状况，包括Eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td>
</tr>
<tr>
<td style="text-align:left">-gccapacity</td>
<td style="text-align:center">监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td style="text-align:left">-gcutil</td>
<td style="text-align:center">监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td style="text-align:left">-gccause</td>
<td style="text-align:center">与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td>
</tr>
<tr>
<td style="text-align:left">-gcnew</td>
<td style="text-align:center">监视新生代GC状况</td>
</tr>
<tr>
<td style="text-align:left">-gcnewcapacity</td>
<td style="text-align:center">监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td style="text-align:left">-gcold</td>
<td style="text-align:center">监视老年代GC状况</td>
</tr>
<tr>
<td style="text-align:left">-gcoldcapacity</td>
<td style="text-align:center">监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td style="text-align:left">-gcpermcapacity</td>
<td style="text-align:center">输出永久代使用到的最大、最小空间</td>
</tr>
<tr>
<td style="text-align:left">-compiler</td>
<td style="text-align:center">输出JIT编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td style="text-align:left">-printcompilation</td>
<td style="text-align:center">输出已经被JIT编译的方法</td>
</tr>
</tbody>
</table>
<p>示例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//250毫秒查询一次进程id为2764的垃圾收集情况，一共查询20次</span><br><span class="line">jstat -gc 2764 250 20</span><br></pre></td></tr></table></figure></div>
<p>显示列描述（部分）</p>
<table>
<thead>
<tr>
<th style="text-align:left">列名称</th>
<th style="text-align:left">详细描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Loaded</td>
<td style="text-align:left">被加载类的数量</td>
</tr>
<tr>
<td style="text-align:left">Bytes</td>
<td style="text-align:left">被加载字节数量，以“KB”为单位</td>
</tr>
<tr>
<td style="text-align:left">Unloaded</td>
<td style="text-align:left">被卸载类的数量</td>
</tr>
<tr>
<td style="text-align:left">Time</td>
<td style="text-align:left">加载和卸载类行为耗费时间</td>
</tr>
<tr>
<td style="text-align:left">Compiled</td>
<td style="text-align:left">成功编译任务数量</td>
</tr>
<tr>
<td style="text-align:left">Failed</td>
<td style="text-align:left">失败编译任务数量</td>
</tr>
<tr>
<td style="text-align:left">Invalid</td>
<td style="text-align:left">无效编译任务数量</td>
</tr>
<tr>
<td style="text-align:left">Time</td>
<td style="text-align:left">编译任务耗费时间</td>
</tr>
<tr>
<td style="text-align:left">FailedType</td>
<td style="text-align:left">最近一次失败编译任务对应的编译类型</td>
</tr>
<tr>
<td style="text-align:left">FailedMethod</td>
<td style="text-align:left">最近一次失败编译任务对应的类名和方法名</td>
</tr>
<tr>
<td style="text-align:left">S0C</td>
<td style="text-align:left">当前Survivor区0内存容量</td>
</tr>
<tr>
<td style="text-align:left">S1C</td>
<td style="text-align:left">当前Survivor区1内存容量</td>
</tr>
<tr>
<td style="text-align:left">S0U</td>
<td style="text-align:left">Survivor区0使用内存</td>
</tr>
<tr>
<td style="text-align:left">S1U</td>
<td style="text-align:left">Survivor区1使用内存</td>
</tr>
<tr>
<td style="text-align:left">EC</td>
<td style="text-align:left">当前Eden区内存容量</td>
</tr>
<tr>
<td style="text-align:left">EU</td>
<td style="text-align:left">Eden区使用内存</td>
</tr>
<tr>
<td style="text-align:left">OC</td>
<td style="text-align:left">当前老年代内存容量</td>
</tr>
<tr>
<td style="text-align:left">OU</td>
<td style="text-align:left">老年代使用内存</td>
</tr>
<tr>
<td style="text-align:left">PC</td>
<td style="text-align:left">当前永久代内存容量</td>
</tr>
<tr>
<td style="text-align:left">PU</td>
<td style="text-align:left">永久代使用内存</td>
</tr>
<tr>
<td style="text-align:left">YGC</td>
<td style="text-align:left">年轻代GC事件数量</td>
</tr>
<tr>
<td style="text-align:left">YGCT</td>
<td style="text-align:left">年轻代GC耗费时间</td>
</tr>
<tr>
<td style="text-align:left">FGC</td>
<td style="text-align:left">Full GC事件数量</td>
</tr>
<tr>
<td style="text-align:left">FGCT</td>
<td style="text-align:left">Full GC耗费时间</td>
</tr>
<tr>
<td style="text-align:left">GCT</td>
</tr>
</tbody>
</table>
<h3 id="jinfo-Java配置信息工具"><a href="#jinfo-Java配置信息工具" class="headerlink" title="jinfo: Java配置信息工具"></a>jinfo: Java配置信息工具</h3><p>jinfo功能：</p>
<p>​    实时地查看和调整虚拟机各项参数</p>
<p>jinfo 命令格式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinof  [option] pid</span><br></pre></td></tr></table></figure></div>
<p>option参数</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>查看未被指定的参数的系统默认值</td>
</tr>
<tr>
<td>-sysprops</td>
<td>将虚拟机进程的System.getProperties()的内容打印出来</td>
</tr>
<tr>
<td>-flag</td>
<td>查询参数值</td>
</tr>
<tr>
<td>-flag [+/-] name</td>
<td>查询参数值，修改一部分运行期可写的虚拟机参数</td>
</tr>
<tr>
<td>-flag name=value</td>
<td>同上</td>
</tr>
</tbody>
</table>
<p>示例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询CMSInitiatingOccupancyFraction的参数值</span></span><br><span class="line">jinfo -flag CMSInitiatingOccupancyFraction <span class="number">4578</span></span><br></pre></td></tr></table></figure></div>
<h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><p>jmap功能：</p>
<ul>
<li>用于生产堆转储快照（一般称为heapdump或dump文件）</li>
<li>查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。</li>
</ul>
<p>jmap命令格式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] vmid</span><br></pre></td></tr></table></figure></div>
<p>jmap选项表</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-dump</td>
<td>生成Java堆转储快照，格式为：-dump：[live,]format=b,file=,其中live子参数说明是否只dump出存活的对象</td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-heap</td>
<td>显示Java堆详细信息，如使用哪种回收器，参数配置，分代情况等。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-histo</td>
<td>显示堆中对象的统计信息，包括类、实例数量、合计容量</td>
</tr>
<tr>
<td>-permstat</td>
<td>以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linus/Solaris平台下有效</td>
</tr>
</tbody>
</table>
<h3 id="jhat-虚拟机堆转储快照分析工具"><a href="#jhat-虚拟机堆转储快照分析工具" class="headerlink" title="jhat: 虚拟机堆转储快照分析工具"></a>jhat: 虚拟机堆转储快照分析工具</h3><p><code>jhat</code>功能：</p>
<ul>
<li>与<code>jmap</code>搭配使用，来分析<code>jmap</code>生成的堆转储快照</li>
<li>内置了一个微型的HTTP/HTML服务器，生成<code>dump</code>文件的分析结果后，可以在浏览器中查看</li>
<li>不建议使用，有其他更好的替代，所以不想看下去了</li>
</ul>
<h3 id="jstack-Java堆栈跟踪工具"><a href="#jstack-Java堆栈跟踪工具" class="headerlink" title="jstack: Java堆栈跟踪工具"></a>jstack: Java堆栈跟踪工具</h3><p><code>jstack</code>功能：</p>
<ul>
<li>用于生成虚拟机当前时刻的<code>线程快照</code>[^12]（一般称为<code>threaddump</code>或者<code>javacore</code>文件）</li>
<li>生成线程快照的主要目的是<strong>定位线程出现长时间停顿的原因</strong>，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因</li>
</ul>
<p><code>jstack</code>命令格式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] vmid</span><br></pre></td></tr></table></figure></div>
<p>jstack工具主要选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l</td>
<td>除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m</td>
<td>如果调用本地方法的话，可以显示C/C++堆栈</td>
</tr>
</tbody>
</table>
<p>在JDk1.5中，java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能。在实际项目中可以用这个方法做管理员页面，以便随时使用浏览器来查看线程堆栈</p>
<h2 id="Java-VisualVM"><a href="#Java-VisualVM" class="headerlink" title="Java VisualVM"></a>Java VisualVM</h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果遇到未检测到本地的Java应用程序，很有可能是权限不够，解决办法为以管理员方式运行即可</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>可以查看官方插件描述<a href="https://visualvm.github.io/plugins.html" target="_blank" rel="noopener">https://visualvm.github.io/plugins.html</a></p>
<h3 id="Startup-Profiler"><a href="#Startup-Profiler" class="headerlink" title="Startup Profiler"></a>Startup Profiler</h3><p>Startup Profiler插件支持从启动时对本地Java 5+应用程序进行检测分析，并有助于分析短期运行的进程</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/VisualVM/Profiler.png" alt="Profiler"></p>
<h3 id="VisualVM-MBeans"><a href="#VisualVM-MBeans" class="headerlink" title="VisualVM-MBeans"></a>VisualVM-MBeans</h3><p>MBeans Browser插件提供类似于JConsole中MBean Browser的功能：显示应用程序的MBean，显示值，操作和通知。在VisualVM中，浏览器进一步改进，以提供更好的可用性和对最新JMX功能的支持</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/VisualVM/VisualVM-MBeans.png" alt="VisualVM-MBeans"></p>
<h3 id="VisualVM-Glassfish"><a href="#VisualVM-Glassfish" class="headerlink" title="VisualVM-Glassfish"></a>VisualVM-Glassfish</h3><p>该插件概述了VisualVM的高级监视功能。 通过添加专用概述，用于监控HTTP服务的新选项卡以及可视化选择和监控任何已部署的Web应用程序的功能，增强对GlassFish应用程序服务器的监控</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/VisualVM/VisualVM-Glassfish.png" alt="VisualVM-Glassfish"></p>
<h3 id="Visual-GC"><a href="#Visual-GC" class="headerlink" title="Visual-GC"></a>Visual-GC</h3><p>将Visual Garbage Collection监视工具集成到VisualVM中。Visual GC附加到应用程序并收集并以图形方式显示垃圾收集，类加载器和HotSpot编译器性能数据</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/VisualVM/Visual-GC.png" alt="Visual-GC"></p>
<h3 id="VisualVM-JConsole"><a href="#VisualVM-JConsole" class="headerlink" title="VisualVM-JConsole"></a>VisualVM-JConsole</h3><h3 id="VisualVM-Extensions"><a href="#VisualVM-Extensions" class="headerlink" title="VisualVM-Extensions"></a>VisualVM-Extensions</h3><h3 id="Btrace-Workbench"><a href="#Btrace-Workbench" class="headerlink" title="Btrace Workbench"></a>Btrace Workbench</h3><h3 id="VisualVM-Security"><a href="#VisualVM-Security" class="headerlink" title="VisualVM-Security"></a>VisualVM-Security</h3><h3 id="VisualVM-BufferMonitor"><a href="#VisualVM-BufferMonitor" class="headerlink" title="VisualVM-BufferMonitor"></a>VisualVM-BufferMonitor</h3><h3 id="Threads-Inspector"><a href="#Threads-Inspector" class="headerlink" title="Threads Inspector"></a>Threads Inspector</h3><h3 id="KillApplication"><a href="#KillApplication" class="headerlink" title="KillApplication"></a>KillApplication</h3><h3 id="Tracer-Jvmstat-Probes"><a href="#Tracer-Jvmstat-Probes" class="headerlink" title="Tracer-Jvmstat Probes"></a>Tracer-Jvmstat Probes</h3><h3 id="Tracer-Monitor-Probes"><a href="#Tracer-Monitor-Probes" class="headerlink" title="Tracer-Monitor Probes"></a>Tracer-Monitor Probes</h3><h3 id="Tracer-Swing-Probes"><a href="#Tracer-Swing-Probes" class="headerlink" title="Tracer-Swing  Probes"></a>Tracer-Swing  Probes</h3><h3 id="Tracer-IO-Probes"><a href="#Tracer-IO-Probes" class="headerlink" title="Tracer-IO Probes"></a>Tracer-IO Probes</h3><h3 id="Tracer-Collections-Probes"><a href="#Tracer-Collections-Probes" class="headerlink" title="Tracer-Collections Probes"></a>Tracer-Collections Probes</h3><h3 id="Tracer-JVM-Probes"><a href="#Tracer-JVM-Probes" class="headerlink" title="Tracer-JVM Probes"></a>Tracer-JVM Probes</h3><h3 id="QQL-syntax-Support"><a href="#QQL-syntax-Support" class="headerlink" title="QQL syntax Support"></a>QQL syntax Support</h3><h3 id="内存监控功能"><a href="#内存监控功能" class="headerlink" title="内存监控功能"></a>内存监控功能</h3><p>限定java堆的大小为100m,最大和最小设置为同一个值可以避免堆自动扩展</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  VM Args: -Xms100m -Xmx100m -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> *  代码作用</span></span><br><span class="line"><span class="comment"> *	以64KB/50毫秒的速度往Java堆中填充数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillHeap</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        fillHeap(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="Class类结构"><a href="#Class类结构" class="headerlink" title="Class类结构"></a>Class类结构</h1><p>一个<code>Class</code>文件对应着唯一的一个类或接口的定义信息，但要注意的是，类和接口的定义信息并不一定在文件里，因为它并不一定以磁盘文件的形式存在</p>
<p>Class文件是一组<strong>以8位字节为基础单位的二进制流</strong>，各个数据之间紧密相连。当数据高于8位时，会按照<code>高位在前</code>[^14]:的方式分割成若干个8位字节进行存储</p>
<p>Class文件结构中含有两种数据：</p>
<ul>
<li><p>无符号数：</p>
<p>属于基本类型，以u1、u2、u4、u8代表1、2、4、8个字节的无符号数，可以用来描述数字、索引引用、数量值或按照UTF-8编码构成字符串值</p>
</li>
<li><p>表：</p>
<p>表是由多个无符号数和其他表作为数据项构成的复合数据类型，习惯以<code>_info</code>结尾。<strong>整个Class文件，就是一张表</strong></p>
</li>
</ul>
<p>Class文件格式</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td style="text-align:center">magic</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">minor_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">major_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td style="text-align:center">constant_pool</td>
<td>constant_pool_count - 1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">interfaces_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">interfaces</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">fields_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td style="text-align:center">fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td style="text-align:center">methods</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">attribute_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td style="text-align:center">attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<h2 id="魔数与Class版本号"><a href="#魔数与Class版本号" class="headerlink" title="魔数与Class版本号"></a>魔数与Class版本号</h2><p>Class文件的头4个字节被称为魔数，它的唯一作用是标识这是一个可以被虚拟机接受的Class文件。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看到0~3 四个字节即为Class的魔数为：CAFEBABE，咖啡宝宝</span></span><br><span class="line"><span class="comment">//4~5字节表示次版本号</span></span><br><span class="line"><span class="comment">//6~7字节表示主版本好,0x34换成10进制就是52，JDK1.1支持45.0~45.65535的Class文件。JDK1.2的话，可以执行45.0~46.65535的Class文件。这里的52，说明使用的是JDK1.8	</span></span><br><span class="line"> Offset: <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> <span class="number">08</span> <span class="number">09</span> <span class="number">0</span>A <span class="number">0</span>B <span class="number">0</span>C <span class="number">0</span>D <span class="number">0</span>E <span class="number">0F</span> 	</span><br><span class="line"><span class="number">00000000</span>: CA FE BA BE <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">41</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>D <span class="number">00</span> <span class="number">2</span>B <span class="number">07</span>    J~:&gt;...<span class="number">4</span>.A....+.</span><br><span class="line"><span class="number">00000010</span>: <span class="number">00</span> <span class="number">2</span>C <span class="number">0</span>A <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">32</span>    .,....+........<span class="number">2</span></span><br><span class="line"><span class="number">00000020</span>: <span class="number">0</span>A <span class="number">00</span> <span class="number">2</span>D <span class="number">00</span> <span class="number">2</span>E <span class="number">07</span> <span class="number">00</span> <span class="number">2F</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">0</span>B <span class="number">00</span> <span class="number">30</span>    ..-..../....+..<span class="number">0</span></span><br><span class="line"><span class="number">00000030</span>: <span class="number">00</span> <span class="number">31</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">32</span> <span class="number">00</span> <span class="number">33</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>C <span class="number">00</span> <span class="number">34</span> <span class="number">07</span> <span class="number">00</span> <span class="number">35</span> <span class="number">07</span>    .<span class="number">1</span>..<span class="number">2.3</span>....<span class="number">4</span>..<span class="number">5</span>.</span><br><span class="line"><span class="number">00000040</span>: <span class="number">00</span> <span class="number">36</span> <span class="number">01</span> <span class="number">00</span> <span class="number">09</span> <span class="number">4F</span> <span class="number">4F</span> <span class="number">4</span>D <span class="number">4F</span> <span class="number">62</span> <span class="number">6</span>A <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">01</span> <span class="number">00</span>    .<span class="number">6</span>...OOMObject..</span><br><span class="line"><span class="number">00000050</span>: <span class="number">0</span>C <span class="number">49</span> <span class="number">6</span>E <span class="number">6</span>E <span class="number">65</span> <span class="number">72</span> <span class="number">43</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">65</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">06</span>    .InnerClasses...</span><br><span class="line"><span class="number">00000060</span>: <span class="number">3</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>E <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span>    &lt;init&gt;...()V...C</span><br><span class="line"><span class="number">00000070</span>: <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0F</span> <span class="number">4</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">65</span> <span class="number">4</span>E <span class="number">75</span> <span class="number">6</span>D <span class="number">62</span> <span class="number">65</span> <span class="number">72</span></span><br></pre></td></tr></table></figure></div>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>常量池</p>
<ul>
<li>可以理解为Class文件中的资源仓库</li>
<li>是Class文件结构中与其他项目关联最多的数据类型</li>
<li>占用Class文件空间最大的项目之一</li>
<li>Class文件中第一个出现的表类型数据项目</li>
</ul>
<p>在回顾Class文件</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8~9字节代表了常量池的的入口，是一个u2类型的数据，代表常量池容量计数值。Ox0041,换成10进制的话就是65，该数值说明常量池中有64项常量，索引范围从1~64。计数从1开始计数（除了常量池，其他计数都从0开始）</span></span><br><span class="line"><span class="comment">//剩下的第0项常量有特殊含义，表示不引用任何一个常量池项目</span></span><br><span class="line"> Offset: <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> <span class="number">08</span> <span class="number">09</span> <span class="number">0</span>A <span class="number">0</span>B <span class="number">0</span>C <span class="number">0</span>D <span class="number">0</span>E <span class="number">0F</span> 	</span><br><span class="line"><span class="number">00000000</span>: CA FE BA BE <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">41</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>D <span class="number">00</span> <span class="number">2</span>B <span class="number">07</span>    J~:&gt;...<span class="number">4</span>.A....+.</span><br><span class="line"><span class="number">00000010</span>: <span class="number">00</span> <span class="number">2</span>C <span class="number">0</span>A <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">32</span>    .,....+........<span class="number">2</span></span><br><span class="line"><span class="number">00000020</span>: <span class="number">0</span>A <span class="number">00</span> <span class="number">2</span>D <span class="number">00</span> <span class="number">2</span>E <span class="number">07</span> <span class="number">00</span> <span class="number">2F</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">0</span>B <span class="number">00</span> <span class="number">30</span>    ..-..../....+..<span class="number">0</span></span><br><span class="line"><span class="number">00000030</span>: <span class="number">00</span> <span class="number">31</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">32</span> <span class="number">00</span> <span class="number">33</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>C <span class="number">00</span> <span class="number">34</span> <span class="number">07</span> <span class="number">00</span> <span class="number">35</span> <span class="number">07</span>    .<span class="number">1</span>..<span class="number">2.3</span>....<span class="number">4</span>..<span class="number">5</span>.</span><br><span class="line"><span class="number">00000040</span>: <span class="number">00</span> <span class="number">36</span> <span class="number">01</span> <span class="number">00</span> <span class="number">09</span> <span class="number">4F</span> <span class="number">4F</span> <span class="number">4</span>D <span class="number">4F</span> <span class="number">62</span> <span class="number">6</span>A <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">01</span> <span class="number">00</span>    .<span class="number">6</span>...OOMObject..</span><br><span class="line"><span class="number">00000050</span>: <span class="number">0</span>C <span class="number">49</span> <span class="number">6</span>E <span class="number">6</span>E <span class="number">65</span> <span class="number">72</span> <span class="number">43</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">65</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">06</span>    .InnerClasses...</span><br><span class="line"><span class="number">00000060</span>: <span class="number">3</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>E <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span>    &lt;init&gt;...()V...C</span><br><span class="line"><span class="number">00000070</span>: <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0F</span> <span class="number">4</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">65</span> <span class="number">4</span>E <span class="number">75</span> <span class="number">6</span>D <span class="number">62</span> <span class="number">65</span> <span class="number">72</span></span><br></pre></td></tr></table></figure></div>
<p>常量池存放两大类常量：</p>
<ul>
<li><p>字面量(Literal):  如字符串，声明为final的常量等</p>
</li>
<li><p>符号引用(Symbolic References)：属于编译原理方面的概念，主要包含以下三类</p>
<p>a. 类和接口的全限定名（Fully Qualified Name）</p>
<p>b. 字段的名称和描述符（Descriptor）</p>
<p>c. 方法的名称和描述符</p>
</li>
</ul>
<p>每一个常量都是一张表，并且一共有14种不同结构的表，表开始的第一位是一个u1类型的标志位，代表当前常量属于那种常量类型。</p>
<h3 id="标志位值对应的具体含义"><a href="#标志位值对应的具体含义" class="headerlink" title="标志位值对应的具体含义"></a>标志位值对应的具体含义</h3><table>
<thead>
<tr>
<th>类型</th>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整形字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>５</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>６</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>７</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>８</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>９</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>１０</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>１１</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>１２</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MothodType_info</td>
<td>１６</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>１５</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>１８</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<h3 id="常量池中常量项结构总表"><a href="#常量池中常量项结构总表" class="headerlink" title="常量池中常量项结构总表"></a>常量池中常量项结构总表</h3><table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:left">选项</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CONSTANT_Utf8_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为1</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">length</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">UTF-8编码的字符串占用的字节数</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">长度为length的UTF-8编码的字符串</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Integer_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为3</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">按照高位在前存储的int值</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Float_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为4</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">按照高位在前存储的float值</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Long_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为5</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u8</td>
<td style="text-align:left">按照高位在前存储的long值</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Double_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为6</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u8</td>
<td style="text-align:left">按照高位在前存储的double值</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Class_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为7</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向全限定名常量项的索引</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_String_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为8</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向字符串字面量的索引</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Fieldref_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为9</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向声明字段的类或接口描述符CONSTANT_Class_info的索引项</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向字段描述符CONSTANT_NameAndType的索引项</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Methodref_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为10</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向声明方法的类描述符CONSTANT_Class_info的索引项</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向名称及类型描述符CONSTANT_NameAndType的索引项</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InterfaceMethodref_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为11</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向声明方法的接口描述符CONSTANT_Class_info的索引项</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向名称及类型描述符CONSTANT_NameAndType的索引项</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_NameAndType_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为12</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向该字段或方法名称常量项的索引</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向该字段或方法描述的索引</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodHandle_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为15</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">reference_kind</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">值必须在[1,9]之间，它决定了方法句柄的类型，方法句柄类型的值表示方法句柄的字节码行为</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">reference_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">值必须是对常量池的有效引用</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodType_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为16</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">descriptor_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">值必须是对常量池的有效引用,常量池在索引处的项必须是CONSTANT_Utf8_info结构,表示方法的描述符</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InvokeDynamic_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为18</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bootstrap_method_attr_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">值必须是当前Class文件中引导方法表的bootstrap methods[]数组的有效索引</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">name_and_type_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">值必须是对当前常量池的有效索引,常量池在该处的索引必须是CONSTANT_NameAndType_info结构,表示方法名和方法描述符</td>
</tr>
</tbody>
</table>
<h3 id="Javap-：Class-字节码分析工具"><a href="#Javap-：Class-字节码分析工具" class="headerlink" title="Javap ：Class 字节码分析工具"></a>Javap ：Class 字节码分析工具</h3><p>使用方式<br><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose MyClass.class</span><br></pre></td></tr></table></figure></div></p>
<p>示例</p>
<p>通过Javap分析某文件后，输出如下结果<br><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">D:\idea project\demo\out\production\demo&gt;javap -verbose HeapOOM.class</span><br><span class="line">Classfile /D:/idea project/demo/out/production/demo/HeapOOM.class</span><br><span class="line">  Last modified 2019-4-16; size 1055 bytes</span><br><span class="line">  MD5 checksum 9bb713cc4933abd1b5aa25c296c1c4c7</span><br><span class="line">  Compiled from &quot;HeapOOM.java&quot;</span><br><span class="line">public class HeapOOM</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #13.#43        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #44            // java/util/ArrayList</span><br><span class="line">   #3 = Methodref          #2.#43         // java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Long               50l</span><br><span class="line">   #6 = Methodref          #45.#46        // java/lang/Thread.sleep:(J)V</span><br><span class="line">   #7 = Class              #47            // HeapOOM$OOMObject</span><br><span class="line">   #8 = Methodref          #7.#43         // HeapOOM$OOMObject.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #9 = InterfaceMethodref #48.#49        // java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">  #10 = Methodref          #50.#51        // java/lang/System.gc:()V</span><br><span class="line">  #11 = Methodref          #12.#52        // HeapOOM.fillHeap:(I)V</span><br><span class="line">  #12 = Class              #53            // HeapOOM</span><br><span class="line">  #13 = Class              #54            // java/lang/Object</span><br><span class="line">  #14 = Utf8               OOMObject</span><br><span class="line">  #15 = Utf8               InnerClasses</span><br><span class="line">  #16 = Utf8               &lt;init&gt;</span><br><span class="line">  #17 = Utf8               ()V</span><br><span class="line">  #18 = Utf8               Code</span><br><span class="line">  #19 = Utf8               LineNumberTable</span><br><span class="line">  #20 = Utf8               LocalVariableTable</span><br><span class="line">  #21 = Utf8               this</span><br><span class="line">  #22 = Utf8               LHeapOOM;</span><br><span class="line">  #23 = Utf8               fillHeap</span><br><span class="line">  #24 = Utf8               (I)V</span><br><span class="line">  #25 = Utf8               i</span><br><span class="line">  #26 = Utf8               I</span><br><span class="line">  #27 = Utf8               num</span><br><span class="line">  #28 = Utf8               list</span><br><span class="line">  #29 = Utf8               Ljava/util/List;</span><br><span class="line">  #30 = Utf8               LocalVariableTypeTable</span><br><span class="line">  #31 = Utf8               Ljava/util/List&lt;LHeapOOM$OOMObject;&gt;;</span><br><span class="line">  #32 = Utf8               StackMapTable</span><br><span class="line">  #33 = Class              #55            // java/util/List</span><br><span class="line">  #34 = Utf8               Exceptions</span><br><span class="line">  #35 = Class              #56            // java/lang/InterruptedException</span><br><span class="line">  #36 = Utf8               main</span><br><span class="line">  #37 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #38 = Utf8               args</span><br><span class="line">  #39 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #40 = Class              #57            // java/lang/Exception</span><br><span class="line">  #41 = Utf8               SourceFile</span><br><span class="line">  #42 = Utf8               HeapOOM.java</span><br><span class="line">  #43 = NameAndType        #16:#17        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #44 = Utf8               java/util/ArrayList</span><br><span class="line">  #45 = Class              #58            // java/lang/Thread</span><br><span class="line">  #46 = NameAndType        #59:#60        // sleep:(J)V</span><br><span class="line">  #47 = Utf8               HeapOOM$OOMObject</span><br><span class="line">  #48 = Class              #55            // java/util/List</span><br><span class="line">  #49 = NameAndType        #61:#62        // add:(Ljava/lang/Object;)Z</span><br><span class="line">  #50 = Class              #63            // java/lang/System</span><br><span class="line">  #51 = NameAndType        #64:#17        // gc:()V</span><br><span class="line">  #52 = NameAndType        #23:#24        // fillHeap:(I)V</span><br><span class="line">  #53 = Utf8               HeapOOM</span><br><span class="line">  #54 = Utf8               java/lang/Object</span><br><span class="line">  #55 = Utf8               java/util/List</span><br><span class="line">  #56 = Utf8               java/lang/InterruptedException</span><br><span class="line">  #57 = Utf8               java/lang/Exception</span><br><span class="line">  #58 = Utf8               java/lang/Thread</span><br><span class="line">  #59 = Utf8               sleep</span><br><span class="line">  #60 = Utf8               (J)V</span><br><span class="line">  #61 = Utf8               add</span><br><span class="line">  #62 = Utf8               (Ljava/lang/Object;)Z</span><br><span class="line">  #63 = Utf8               java/lang/System</span><br><span class="line">  #64 = Utf8               gc</span><br></pre></td></tr></table></figure></div></p>
<p>该文件的二进制显示<br><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> Offset: <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> <span class="number">08</span> <span class="number">09</span> <span class="number">0</span>A <span class="number">0</span>B <span class="number">0</span>C <span class="number">0</span>D <span class="number">0</span>E <span class="number">0F</span> 	</span><br><span class="line"><span class="number">00000000</span>: CA FE BA BE <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">41</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>D <span class="number">00</span> <span class="number">2</span>B <span class="number">07</span>    J~:&gt;...<span class="number">4</span>.A....+.</span><br><span class="line"><span class="number">00000010</span>: <span class="number">00</span> <span class="number">2</span>C <span class="number">0</span>A <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">32</span>    .,....+........<span class="number">2</span></span><br><span class="line"><span class="number">00000020</span>: <span class="number">0</span>A <span class="number">00</span> <span class="number">2</span>D <span class="number">00</span> <span class="number">2</span>E <span class="number">07</span> <span class="number">00</span> <span class="number">2F</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">0</span>B <span class="number">00</span> <span class="number">30</span>    ..-..../....+..<span class="number">0</span></span><br><span class="line"><span class="number">00000030</span>: <span class="number">00</span> <span class="number">31</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">32</span> <span class="number">00</span> <span class="number">33</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>C <span class="number">00</span> <span class="number">34</span> <span class="number">07</span> <span class="number">00</span> <span class="number">35</span> <span class="number">07</span>    .<span class="number">1</span>..<span class="number">2.3</span>....<span class="number">4</span>..<span class="number">5</span>.</span><br><span class="line"><span class="number">00000040</span>: <span class="number">00</span> <span class="number">36</span> <span class="number">01</span> <span class="number">00</span> <span class="number">09</span> <span class="number">4F</span> <span class="number">4F</span> <span class="number">4</span>D <span class="number">4F</span> <span class="number">62</span> <span class="number">6</span>A <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">01</span> <span class="number">00</span>    .<span class="number">6</span>...OOMObject..</span><br><span class="line"><span class="number">00000050</span>: <span class="number">0</span>C <span class="number">49</span> <span class="number">6</span>E <span class="number">6</span>E <span class="number">65</span> <span class="number">72</span> <span class="number">43</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">65</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">06</span>    .InnerClasses...</span><br><span class="line"><span class="number">00000060</span>: <span class="number">3</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>E <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span>    &lt;init&gt;...()V...C</span><br><span class="line"><span class="number">00000070</span>: <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0F</span> <span class="number">4</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">65</span> <span class="number">4</span>E <span class="number">75</span> <span class="number">6</span>D <span class="number">62</span> <span class="number">65</span> <span class="number">72</span></span><br></pre></td></tr></table></figure></div></p>
<p>分析：</p>
<ol>
<li>可以看到，常量池的偏移量为(0x0000 0008),其对应的16进制值为<code>0x0041</code>,即10进制的65，与Javap显示结果相同，有64常量；</li>
<li>接下来是第一个常量，偏移量0X0000 000A是其标志位，对应值为<code>0x000A</code>,即进制的10，查阅标志位值对应的具体含义可知，标志10代表的是<code>CONSTANT_Methodref_info</code>,也就是类中方法的符号引用。查阅<code>常量项结构总表</code>,其结构如下</li>
</ol>
<table>
<thead>
<tr>
<th>CONSTANT_Methodref_info</th>
<th>tag</th>
<th>u1</th>
<th>值为10</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向声明方法的类描述符CONSTANT_Class_info的索引项</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向名称及类型描述符CONSTANT_NameAndType的索引项</td>
</tr>
</tbody>
</table>
<p>​    也就是接下来的4个字节，含义为</p>
<p>​    a. 偏移量0x0000 000B: 值0x000D(12),也就是指向了常量池的第十二项常量</p>
<p>​    b. 偏移量0x0000 0000D: 值0x002B(33),也就是指向了常量池的第四十三项常量</p>
<p>​    再来看javap的显示结果的第一个常数,确实是Methodref类型，指向了13,43号常量</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1 = Methodref          #13.#43        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></div>
<p>注意：<code>CONSTANT_Utf8_info</code>类型常量</p>
<ul>
<li>该类型的常量是用来记录<code>UTF-8编码的字符串</code>，它用<code>length</code>选项来表示字符串的大小，因为length的类型为u2，所以其长度最大为65535</li>
<li>该类型的常量会被用来描述Class文件中方法名、字段名，也就是说，这也限制了它们的大小为65535,即Java不能定义超过64K大小的方法名或变量名</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:left">选项</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CONSTANT_Utf8_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为1</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">length</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">UTF-8编码的字符串占用的字节数</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">长度为length的UTF-8编码的字符串</td>
</tr>
</tbody>
</table>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>常量池结束后，紧接着的<strong>两个字节</strong>代表<code>访问标志（access_flags）</code>,这个标志用于识别一些类或者接口层次的访问信息，包括</p>
<ul>
<li>Class是接口还是类</li>
<li>如果是类，是否被声明为final</li>
<li>是否为public</li>
<li>是否为abstract</li>
<li>……</li>
</ul>
<h3 id="访问标志含义表"><a href="#访问标志含义表" class="headerlink" title="访问标志含义表"></a>访问标志含义表</h3><p>access_flags一共有16个标志位(2字节)可以使用，当前值定义了8个，每个标志位上的值都有特殊含义，没有则都为0</p>
<table>
<thead>
<tr>
<th style="text-align:left">标志名称</th>
<th style="text-align:left">标志值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td style="text-align:left">0x0001</td>
<td style="text-align:left">是否为public类型</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td style="text-align:left">0x0010</td>
<td style="text-align:left">是否被声明为final，只有类可设置</td>
</tr>
<tr>
<td style="text-align:left">ACC_SUPER</td>
<td style="text-align:left">0x0020</td>
<td style="text-align:left">是否允许使用invokespecial字节码指令的新语义，invokespecial指令的语意在JDK 1.0.2发生过改变，为了区别这条指令使用哪种语义，JDK 1.0.2之后编译出来的类的这个标志都必须为真</td>
</tr>
<tr>
<td style="text-align:left">ACC_INTERFACE</td>
<td style="text-align:left">0x0200</td>
<td style="text-align:left">标识这是一个接口</td>
</tr>
<tr>
<td style="text-align:left">ACC_ABSTRACT</td>
<td style="text-align:left">0x0400</td>
<td style="text-align:left">是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类值为假</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td style="text-align:left">0x1000</td>
<td style="text-align:left">标识这个类并非由用户代码产生的</td>
</tr>
<tr>
<td style="text-align:left">ACC_ANNOTATION</td>
<td style="text-align:left">0x2000</td>
<td style="text-align:left">标识这是一个注解</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td style="text-align:left">0x4000</td>
<td style="text-align:left">标识这是一个枚举</td>
</tr>
</tbody>
</table>
<p>示例:假设一个类是普通java类，并不接口、枚举、注解,由用户代码产生，被public修饰，没有被声明为final，abstarct,由JDK1.8编译，那么根据表中定义，它的访问标志就是</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个0:不是枚举、注解,由用户代码产生</span></span><br><span class="line"><span class="comment">//第二个0：不是接口、abstract类型</span></span><br><span class="line"><span class="comment">//2：由JDK1.8编译</span></span><br><span class="line"><span class="comment">//1：为public类型</span></span><br><span class="line"><span class="number">0x0021</span></span><br></pre></td></tr></table></figure></div>
<h2 id="索引、父类索引和与接口索引集合"><a href="#索引、父类索引和与接口索引集合" class="headerlink" title="索引、父类索引和与接口索引集合"></a>索引、父类索引和与接口索引集合</h2><p>Class由<code>类索引、父类索引、接口索引</code>这三项数据来确定这个类的继承关系，三个索引排序在访问标志之后</p>
<p>类索引：</p>
<ul>
<li>使用两个u2类型数据的索引值表示，指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，跟据该常量找到对应的<code>CONSTANT_Utf8_info</code>类型常量中的全限定字符串    </li>
<li>用于确定该类的全限定名</li>
</ul>
<p>父类索引：</p>
<ul>
<li>使用两个u2类型数据的索引值表示，指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，跟据该常量找到对应的<code>CONSTANT_Utf8_info</code>类型常量中的全限定字符串    </li>
<li>用于确定类的父类的全限定名，父类索引只有一个</li>
<li>所有类的父类索引都不为0，当然，除了java.lang.object</li>
</ul>
<p>接口索引</p>
<ul>
<li>u2类型数据的集合</li>
<li>被实现的接口将会按照<code>implements</code>的顺序从左到右排列在索引集合中</li>
<li>入口的u2类型数据为计数器(interfaces_counts)，表示索引表的容量，该类没有索引，则计数器值为0,后面接口索引不占用字节</li>
</ul>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>字段表(field_info)</p>
<ul>
<li>用于描述接口或者类中声明的变量</li>
<li><p>包括类级变量和实例级变量，不包括在方法内部声明的局部变量</p>
</li>
<li><p>字段表不会列出从父类接口中继承的字段，但有可能列出代码之中不存在的字段</p>
</li>
</ul>
<p>字段可包含信息</p>
<ul>
<li>字段的作用域(public、private、protected)</li>
<li>是实例变量还是类变量（static）</li>
<li>可变性（final）</li>
<li>并发可见性（volatile修饰符，是否强制从内存读写）</li>
<li>可否被序列化(transient)</li>
<li>字段数据类型（基本类型、对象、数组）</li>
<li><p>字段名称</p>
</li>
<li><p>以上信息，对于修饰符，很容易用标志位来表示；而对于数据类型，字段名称，就需要引用常量池中的常量了</p>
</li>
</ul>
<h3 id="字段表结构"><a href="#字段表结构" class="headerlink" title="字段表结构"></a>字段表结构</h3><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">数量</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">access_flags</td>
<td style="text-align:center">1</td>
<td style="text-align:center">字段和方法的访问修饰符</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">name_index</td>
<td style="text-align:center">1</td>
<td style="text-align:center">常量池索引，代表字段的简单名称</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">descriptor_index</td>
<td style="text-align:center">1</td>
<td style="text-align:center">常量池索引，代表字段和方法的描述符</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">attributes_count</td>
<td style="text-align:center">1</td>
<td style="text-align:center">字段和方法的额外附加属性数量</td>
</tr>
<tr>
<td style="text-align:center">attribute_info</td>
<td style="text-align:center">attributes</td>
<td style="text-align:center">attributes_count</td>
<td style="text-align:center">字段和方法的额外的附加属性</td>
</tr>
</tbody>
</table>
<p>简单名称：没有类型和参数修饰的方法或字段名称，如<code>text()</code>的简单名称就是<code>text</code></p>
<p>字段和方法的描述符：用来描述字段的数据类型、方法和参数列表（包括数量、类型以及顺序）和返回值</p>
<h3 id="access-flags字段访问标志"><a href="#access-flags字段访问标志" class="headerlink" title="access_flags字段访问标志"></a>access_flags字段访问标志</h3><table>
<thead>
<tr>
<th style="text-align:center">标志名称</th>
<th style="text-align:center">标志值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACC_PUBLIC</td>
<td style="text-align:center">0x0001</td>
<td style="text-align:center">字段是否为public</td>
</tr>
<tr>
<td style="text-align:center">ACC_PRIVATE</td>
<td style="text-align:center">0x0002</td>
<td style="text-align:center">字段是否为private</td>
</tr>
<tr>
<td style="text-align:center">ACC_PROTECTED</td>
<td style="text-align:center">0x0004</td>
<td style="text-align:center">字段是否为protected</td>
</tr>
<tr>
<td style="text-align:center">ACC_STATIC</td>
<td style="text-align:center">0x0008</td>
<td style="text-align:center">字段是否为static</td>
</tr>
<tr>
<td style="text-align:center">ACC_FINAL</td>
<td style="text-align:center">0x0010</td>
<td style="text-align:center">字段是否为final</td>
</tr>
<tr>
<td style="text-align:center">ACC_VOLATILE</td>
<td style="text-align:center">0x0040</td>
<td style="text-align:center">字段是否为volatile</td>
</tr>
<tr>
<td style="text-align:center">ACC_TRANSIENT</td>
<td style="text-align:center">0x0080</td>
<td style="text-align:center">字段是否为transient</td>
</tr>
<tr>
<td style="text-align:center">ACC_SYNTHETIC</td>
<td style="text-align:center">0x1000</td>
<td style="text-align:center">字段是否由编译器自动产生</td>
</tr>
<tr>
<td style="text-align:center">ACC_ENUM</td>
<td style="text-align:center">0x4000</td>
<td style="text-align:center">字段是否是enum类型</td>
</tr>
</tbody>
</table>
<p>使用方法可以查看<code>访问标志/访问标志含义表</code></p>
<h3 id="描述符字符含义"><a href="#描述符字符含义" class="headerlink" title="描述符字符含义"></a>描述符字符含义</h3><p>描述基本数据类型、void、对象</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>基本数据类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>基本数据类型void</td>
</tr>
<tr>
<td>L</td>
<td>对象类型,如Ljava/lang/Object</td>
</tr>
</tbody>
</table>
<p>描述数组：</p>
<p>​    使用<code>[</code> + 描述字符来表示数组，如<code>int[]</code>将会被描述为 “[I” </p>
<p>描述方法：</p>
<ul>
<li>按照先参数列表，后返回值的顺序描述,表示形式为<code>(参数列表)+返回值</code></li>
<li>如<code>void inc()</code>,描述为<code>()V</code>;</li>
<li>如<code>java.lang.String toStirng()</code>描述为<code>()Ljava/lang/String</code>;</li>
<li>如int togo(int i, char[] source);描述为<code>(I[C)I</code></li>
</ul>
<h2 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h2><p>方法表中的代码，存放于方法属性表集合中的<code>Code</code>属性中</p>
<h3 id="方法表结构"><a href="#方法表结构" class="headerlink" title="方法表结构"></a>方法表结构</h3><p>与字段表十分相似</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<h3 id="方法访问标志"><a href="#方法访问标志" class="headerlink" title="方法访问标志"></a>方法访问标志</h3><table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x00 01</td>
<td>方法是否为public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x00 02</td>
<td>方法是否为private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x00 04</td>
<td>方法是否为protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x00 08</td>
<td>方法是否为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x00 10</td>
<td>方法是否为final</td>
</tr>
<tr>
<td>ACC_SYHCHRONRIZED</td>
<td>0x00 20</td>
<td>方法是否为synchronized</td>
</tr>
<tr>
<td>ACC_BRIDGE</td>
<td>0x00 40</td>
<td>方法是否是有编译器产生的方法</td>
</tr>
<tr>
<td>ACC_VARARGS</td>
<td>0x00 80</td>
<td>方法是否接受参数</td>
</tr>
<tr>
<td>ACC_NATIVE</td>
<td>0x01 00</td>
<td>方法是否为native</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x04 00</td>
<td>方法是否为abstract</td>
</tr>
<tr>
<td>ACC_STRICTFP</td>
<td>0x08 00</td>
<td>方法是否为strictfp</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x10 00</td>
<td>方法是否是有编译器自动产生的</td>
</tr>
</tbody>
</table>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>实现重载方法，需要满足</p>
<ul>
<li>与原方法具有相同的简单名称</li>
<li>与原方法不同的特征签名</li>
</ul>
<p>特征签名：一个方法中各个参数在常量中的字段符号引用集合，也就是说返回值不包含在特征签名中，所以Java不能仅仅依靠返回值不同来重载方法。<strong>注意：在Class文件格式中特征签名范围更大，只要描述符不完全一致就可以，也就是返回值不同的两个方法也是可以共存的</strong></p>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>属性表</p>
<ul>
<li>在Class文件、字段表、方法表中，均有携带自己的属性表集合，以用于描述某些场景的专有信息</li>
<li><p>属性表对数据项目的顺序没有严格限制，只需要属性名不重复即可</p>
</li>
<li><p>每个属性的名称都是从常量值中引用一个<code>CONSTANT_Utf8_info</code>常量来表示</p>
</li>
<li>属性的结构完全自定义，只需要一个u4长度的属性去说明属性值所占用的位数</li>
</ul>
<h3 id="最简单的属性表结构"><a href="#最简单的属性表结构" class="headerlink" title="最简单的属性表结构"></a>最简单的属性表结构</h3><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
</tr>
</tbody>
</table>
<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Code</td>
<td>方法表</td>
<td>Java代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final关键字定义的常量池</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类，方法，字段表</td>
<td>被声明为deprecated的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EnclosingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td>InnerClass</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code属性</td>
<td>Java源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code属性</td>
<td>方法的局部便狼描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code属性</td>
<td>JDK1.6中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td>
</tr>
<tr>
<td>Signature</td>
<td>类，方法表，字段表</td>
<td>用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td>SourceFile</td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td>SourceDebugExtension</td>
<td>类文件</td>
<td>用于存储额外的调试信息</td>
</tr>
<tr>
<td>Synthetic</td>
<td>类，方法表，字段表</td>
<td>标志方法或字段为编译器自动生成的</td>
</tr>
<tr>
<td>LocalVariableTypeTable</td>
<td>类</td>
<td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>为动态注解提供支持</td>
</tr>
<tr>
<td>RuntimeInvisibleAnnotations</td>
<td>表，方法表，字段表</td>
<td>用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法</td>
</tr>
<tr>
<td>RuntimeInvisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与RuntimeInvisibleAnnotations属性类似，作用对象哪个为方法参数</td>
</tr>
<tr>
<td>AnnotationDefault</td>
<td>方法表</td>
<td>用于记录注解类元素的默认值</td>
</tr>
<tr>
<td>BootstrapMethods</td>
<td>类文件</td>
<td>用于保存invokeddynamic指令引用的引导方式限定符</td>
</tr>
</tbody>
</table>
<h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>java程序方法体中的代码经过编译器处理后，最终会变为字节码存储在Code属性中。接口或者抽象类中的方法，就可能不存在Code属性。如果将Java程序中的信息分为<code>代码</code>[^15]和<code>元数据</code>[^16]两部分，那么整个Class文件，Code属性用于描述代码，其他数据项目描述原数据</p>
<h4 id="Code属性结构"><a href="#Code属性结构" class="headerlink" title="Code属性结构"></a>Code属性结构</h4><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>指向CONSTANT_Utf8_info型常量的索引，默认值Code，表示属性名称</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性值长度</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>1</td>
<td>操作数栈深度的最大值，虚拟机根据这个值分配栈帧(Stack Frame)中的操作栈深度</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>1</td>
<td>局部变量表所需的存储空间，单位Slot,除了基本类型，还存放了方法参数（包括this）、显示异常处理参数（catch块定义的异常、方法体中定义的局部变量；Slot可重用，编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>1</td>
<td>编译器编译后生成的字节码指令长度（虽然u4级别长度，但虚拟机限制了一个方法不允许超过65535长度，所以实际只能使用u2的长度）</td>
</tr>
<tr>
<td>u1</td>
<td>code</td>
<td>code_length</td>
<td>c存储字节码指令的一系列字节流，每个 指令为u1类型</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td>exception_length</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<h4 id="JVM是如何使用Code属性？"><a href="#JVM是如何使用Code属性？" class="headerlink" title="JVM是如何使用Code属性？"></a>JVM是如何使用Code属性？</h4><h3 id="Exceptions-属性"><a href="#Exceptions-属性" class="headerlink" title="Exceptions 属性"></a>Exceptions 属性</h3><p>Exceptions 属性:</p>
<p>​    列举出方法中可能抛出的受查异常(Checked Exceptions),即方法描述时在throws关键字后面列举的异常</p>
<p>Exceptions 属性表结构</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">number_of_exceptions</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>抛出受查异常数量</td>
</tr>
<tr>
<td style="text-align:left">exception_index_table</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">number_of_exceptions</td>
<td>指向常量池中的CONSTANT_Class_info型常量的索引，代表该受查异常的类型</td>
</tr>
</tbody>
</table>
<h3 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h3><p>LineNumberTable属性：</p>
<ul>
<li><p>用来描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系</p>
</li>
<li><p>非运行时必需属性,但默认生成到Class文件中，可以通过<code>javac -g:none</code>或<code>javac -g:lines</code>手动取消或生成这项信息</p>
</li>
<li>主要影响为抛出异常时，显示出错的行号；在调式程序时按照源码行来设置断点</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">line_number_table_length</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">line_number_table</td>
<td style="text-align:left">line_number_info</td>
<td style="text-align:left">line_number_table_length</td>
<td>是一个line_number_table_length长度，类型为line_number_info的集合，line_number_info表包含了start_pc(字节码行号)和line_number（Java源码行号）两个u2类型数据项</td>
</tr>
</tbody>
</table>
<h3 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h3><p>LocalVariableTable属性: </p>
<ul>
<li>用于描述栈帧中局部变量表中的变量与java源码中定义的变量之间的关系</li>
<li>非运行时必需属性,但默认生成到Class文件中，可以通过<code>javac -g:none</code>或<code>javac -g:vars</code>手动取消或生成这项信息</li>
<li>主要影响为党其他人引用这个方法时，所有的参数名称丢失，导致IDE将会使用诸如arg0、arg1之类的占位符替代原有参数名，并不影响运行，但会影响代码的编写并且在调式期间无法根据参数名称从上下文中获取参数</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">local_variable_table_length</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">local_variable_table</td>
<td style="text-align:left">local_variable_info</td>
<td style="text-align:left">local_variable_table_lengt</td>
</tr>
</tbody>
</table>
<p>local_variable_info：代表了一个栈帧与源码中的局部变量的关联，其数据结构如下</p>
<ul>
<li>start_pc和length组成了局部变量在字节码之中的作用域范围</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">start_pc</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>局部变量的生命周期开始的字节码偏移</td>
</tr>
<tr>
<td style="text-align:left">length</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>局部变量作用该范围覆盖的长度</td>
</tr>
<tr>
<td style="text-align:left">name_indec</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Utf8_info，代表局部变量的名称</td>
</tr>
<tr>
<td style="text-align:left">descriptor_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Utf8_info，代表局部变量的描述符</td>
</tr>
<tr>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>局部变量在栈帧局部变量表中Slot的位置</td>
</tr>
</tbody>
</table>
<h3 id="LocalVariableTypeTable属性"><a href="#LocalVariableTypeTable属性" class="headerlink" title="LocalVariableTypeTable属性"></a>LocalVariableTypeTable属性</h3><p>在JDK1.5后引入，与<code>LocalVariableTable</code>相似，区别在于将记录描述符的<code>descriptor_index</code>替换成了字段的特征签名，目的时为了描述泛型类型 （原因时描述符中的泛型参数化类型被擦除掉后，描述符无法准确描述泛型类型）</p>
<h3 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h3><p>SourceFile属性</p>
<ul>
<li>用于记录生成这个Class文件的源码文件名，该属性长度固定</li>
<li>非运行时必需属性,但默认生成到Class文件中，可以通过<code>javac -g:none</code>或<code>javac -g:s97rce</code>手动取消或生成这项信息</li>
<li>影响在于对于内部类，其类名和类文件是不一致的，如果不生产这项属性，当抛出异常时，堆栈中将不会显示出错误代码所属的文件名</li>
</ul>
<p>SourceFile属性结构表</p>
<table>
<thead>
<tr>
<th style="text-align:left">SourceFile属性名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">sourcefile_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Utf8_info,常量值为源码文件的文件名</td>
</tr>
</tbody>
</table>
<h3 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h3><p>ConstantValue属性</p>
<ul>
<li>通知虚拟机自动为静态变量赋值，只有被static关键字修饰的变量才可以使用这项属性</li>
</ul>
<p>虚拟机在对非类变量和变量的赋值方式和时刻不同</p>
<ul>
<li><p>非static类型的变量：赋值实在实例构造器&lt; init &gt;方法中进行</p>
</li>
<li><p>对于类变量，有两种方式可以选择</p>
<p>a. 在类构造器&lt; clinit &gt;方法中赋值</p>
<p>b. 使用ConstanValue属性赋值</p>
</li>
<li><p>Sun Javac编译器选择方式为：</p>
<p>a. 如果同时使用final和static修饰变量，并且该变量是基础类型或者String类型，则通过ConstanValue属性进行初始化。</p>
<p>b. 如果这个变量没有被final修饰，或不是基础类型和String类型,则选择&lt; clinit &gt;方法初始化</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">constantvalue_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<h3 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h3><p>InnerClasses属性</p>
<ul>
<li>用于记录内部类和宿主类之间的关联</li>
<li>如果类中定义了内部类，编译器就会为它以及内部类生成InnerClasses属性</li>
</ul>
<p>InnerClasses属性结构表</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">number_of_class</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>内部类信息个数</td>
</tr>
<tr>
<td style="text-align:left">inner_classes</td>
<td style="text-align:left">inner_classes_info</td>
<td style="text-align:left">number_of_class</td>
<td>包含number_of_class个inner_classes_info（描述内部类信息）</td>
</tr>
</tbody>
</table>
<p>inner_classes_info表结构    </p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">inner_class_info_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Class_info，内部类符号引用</td>
</tr>
<tr>
<td style="text-align:left">outer_class_info_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Class_info，外部类符号引用</td>
</tr>
<tr>
<td style="text-align:left">inner_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Utf8_info,内部类名称，如果是匿名内部类则为0</td>
</tr>
<tr>
<td style="text-align:left">inner_class_access_flags</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>内部类访问标志</td>
</tr>
</tbody>
</table>
<p>inner_class_access_flags访问标志含义</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>内部类是否为public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>内部类是否为private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>内部类是否为protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>内部类是否为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>内部类是否为final</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0020</td>
<td>内部类是否为一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>内部类是否为abstract</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>内部类是否为编译器自动产生</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x4000</td>
<td>内部类是否是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>内部类是否是一个枚举</td>
</tr>
</tbody>
</table>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h3><p><del>Deprecated属性：用于表示某个类、字段或者方法，不推荐使用</del></p>
<h3 id="Synthetic属性"><a href="#Synthetic属性" class="headerlink" title="Synthetic属性"></a>Synthetic属性</h3><p>Synthetic属性：</p>
<ul>
<li><p>属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念</p>
</li>
<li><p>标识一个类、字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加</p>
</li>
<li><p>所有由非用户代码生成的类、方法、字段都应当至少设置Synthetic属性或者ACC_SYNTHETIC标志位，但是，是实例构造器&lt; init &gt; 和类构造器 &lt; clinit &gt;无需设置，最典型的例子： <strong>Bridge Mthod</strong></p>
</li>
</ul>
<p>Sunthetic属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>值必须为0x0000 0000,因为没有任何属性值需要设置</td>
</tr>
</tbody>
</table>
<h3 id="StackMap-Table-属性"><a href="#StackMap-Table-属性" class="headerlink" title="StackMap Table 属性"></a>StackMap Table 属性</h3><p>StackMap Table 属性</p>
<ul>
<li>会在虚拟机加载的字节码验证阶段被<code>新类型检查验证器(Type Checker)</code>使用，目的在于代替以前比较消耗性能的基于数据流分析的<code>类型推导验证器</code></li>
<li>该属性包含多个<code>栈映射帧（Stack Map Frames）</code>,每个栈映射帧都显示或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的严重类型；类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一定字节码指令是否符合逻辑约束</li>
<li>版本号大于等于50的class文件，如果没有该属性，说明它带有隐式的StackMapTable属性，作用等同于<code>number_of_entries</code>值为0的StackMapTable属性</li>
<li>一个Code属性最多只能由一个StackMapTable属性</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>number_of_entries</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>stack_map_frame entries</td>
<td>stack_map_frame</td>
<td>number_of_entries</td>
</tr>
</tbody>
</table>
<h3 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h3><p>Signature属性</p>
<ul>
<li>非运行时必须，长度固定，出现于类、属性表和方法表结构的属性表中</li>
<li>用于任何类、接口、初始化方法或者成员的泛型签名，如果它们包含了类型变量或参数化类型，则Signature属性会为它记录泛型签名信息</li>
<li>使用该属性主要原因是java语言的泛型擦除实现的伪泛型</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>signature_index</td>
<td>u2</td>
<td>1</td>
<td>值必须是一个对常量池的有效索引。常量池在该索引的项必须是CONSTANT_Utf8_info接口，表示类签名、方法签名、字段类型签名（取决于当前的Signature是谁的属性，如类的属性，则就是类签名）</td>
</tr>
</tbody>
</table>
<h3 id="BootStrapMethods属性"><a href="#BootStrapMethods属性" class="headerlink" title="BootStrapMethods属性"></a>BootStrapMethods属性</h3><p>BootStrapMethods属性</p>
<ul>
<li>可变长度属性，位于类文件的属性表中</li>
<li>用于保存<code>invokedynamic</code>指令引用的引导方法限定符</li>
<li>如果某个类文件结构的常量池中曾经出现过<code>CONSTANT_InvokeDynamic_info</code>类型常量，则必须存在一个明确的BootStrapMethods<code>属性</code></li>
<li>类文件属性表中最多只能有一个<code>BootStrapMethods</code>属性</li>
</ul>
<p>BootStrapMethods属性结构</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类 型</th>
<th>数 量</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>num_bootstrap_methods</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>bootstrap_methods</td>
<td>bootstrap_method</td>
<td>num_bootstrap_methods</td>
</tr>
</tbody>
</table>
<p>bootstrap_method属性结构</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类 型</th>
<th>数 量</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bootstrap_method_ref</td>
<td>u2</td>
<td>1</td>
<td>值必须是一个对常量池有效的索引，常量池在该索引处的值必须是一个CONSTANT_MethodHandle结构</td>
</tr>
<tr>
<td>num_bootstrap_arguments</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>bootstrap_arguments</td>
<td>u2</td>
<td>num_bootstrap_arguments</td>
<td>数组的每个成员必须是一个对常量池的有效索引，且该索引处的结构必须是CONSTANT_String_info、CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info、CONSTANT_MethodType_info</td>
</tr>
</tbody>
</table>
<h1 id="Java编译期"><a href="#Java编译期" class="headerlink" title="Java编译期"></a>Java编译期</h1><p>Java的编译可能是</p>
<ol>
<li>前端编译器把<em>.java文件转变成</em>.class文件的过程</li>
<li>虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程</li>
<li>静态提前编译器（AOT编译器，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码的过程</li>
</ol>
<p>具有代表性的编译器</p>
<ol>
<li>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ） [1] 。</li>
<li>JIT编译器：HotSpot VM的C1、C2编译器。</li>
<li>AOT编译器：GNU Compiler for the Java（GCJ） 、Excelsior JET  </li>
</ol>
<p>对于Javac编译，大致可分为3个过程</p>
<ol>
<li>解析与填充符号表过程（Parse and Enter）</li>
<li>插入式注解处理器的注解处理过程(Annotation Processing)</li>
<li>分析与字节码生成过程(Analyse and Generate)</li>
</ol>
<p>它们的关系如下</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/javac-flow.png" alt></p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>解析过程由<code>com.sun.tools.javac.main.JavaCompiler.parseFiles()</code>方法完成，解析步骤包含词法分析和语法分析两个过程.</p>
<h3 id="词法解析"><a href="#词法解析" class="headerlink" title="词法解析"></a>词法解析</h3><p>词法解析由<code>com.sun.tools.javac.parser.Scanner</code>类来实现，它会将源代码的字符流转换成<strong>标记(Token)集合</strong>,关键字、变量名、字面量、运算符都可以成为标记,如下所示</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含6个标记，分别为int、a、=、b、+、2</span></span><br><span class="line"><span class="keyword">int</span> a=b+<span class="number">2</span></span><br></pre></td></tr></table></figure></div>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析过程由<code>com.sun.tools.javac.parser.Parser</code>类实现，它会根据Token序列构造<strong>抽象语法树（Abstract Syntax Tree,AST）</strong></p>
<p>所谓的抽象语法树，由<code>com.sun.tools.javac.tree.JCTree</code>类表示，指的是一种用来描述程序代码语法结构的树形表示方式，<strong>语法树的每一个节点都代表着程序代码中的一个语法结构（Construct）</strong>，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。接下来，<strong>编译器的后续操作都会建立在抽象语法树上，而不是源码了</strong></p>
<h2 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h2><p>完成了语法分析和词法分析之后，下一步就是填充符号表的过程。符号表（Symbol Table）由<code>com.sun.tools.javac.comp.Enter</code>类实现，是<strong>一组符号地址（用于寻找符号信息）和符号信息构成的表格。符号信息会用于编译器的不同阶段</strong>。</p>
<p>最终，会得到一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p>
<h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持。在JDK 1.6中，提供了一组插入式注解处理器的标准API用于在编译期间对注解进行处理（可以看作一组编译器的插件）。</p>
<p><strong>插件可以用于读取、修改、添加抽象语法树中的任意元素</strong>。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是编译期关系图中的那个循环</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/javac-flow.png" alt></p>
<p>在Javac源码中，插入式注解处理器的<strong>初始化过程</strong>是在<code>initPorcessAnnotations（）</code>方法中完成的，而它的<strong>执行过程</strong>则是在<code>processAnnotations（）</code>方法中完成的，这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过<code>com.sun.tools.javac.processing.JavacProcessingEnvironment</code>类的<code>doProcessing（）</code>方法生成一个新的<code>com.sun.tools.javac.main.JavaCompiler</code>对象对编译的后续步骤进行处理</p>
<h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，<strong>语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的</strong>。而<strong>语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查</strong>。</p>
<p>如下由三个变量赋值</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">boolean</span> b=<span class="keyword">false</span>；</span><br><span class="line"><span class="keyword">char</span> c=<span class="number">2</span>；</span><br></pre></td></tr></table></figure></div>
<p>可能存在如下赋值运算</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d=a+c；</span><br><span class="line"><span class="keyword">int</span> d=b+c；</span><br><span class="line"><span class="keyword">char</span> d=a+c；</span><br></pre></td></tr></table></figure></div>
<p>在语法分析阶段，这三个赋值运算都能构成语法树，但实际上，除了第一种外，其他两种在Java语言中是不合法的，语义分析就是用来完成这个检查，然后决定是否能编译。</p>
<p>语义分析过程分为<strong>标注检查</strong>以及<strong>数据及控制流分析</strong>两个步骤。</p>
<h3 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h3><p>标注检查由<code>com.sun.tools.javac.main.JavaCompiler.attribute()</code>方法完成，具体的实现类为<code>com.sun.tools.javac.comp.Attr</code>类和<code>com.sun.tools.javac.comp.Check</code>类。其检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。</p>
<p>此外，在标注检查步骤中，还有一个重要的动作称为<strong>常量折叠</strong>，如下代码所示</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>+<span class="number">2</span>；</span><br></pre></td></tr></table></figure></div>
<p>在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但在经过常量折叠之后，会被折叠为字面量”3”,此时这个表达式的值在语法树上标注为（ConstantExpressionValue：3）。换句话说，因为进行了常量折叠,如下两个表达式，在运行期不会添加一条CPU指令的运算量</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>+<span class="number">2</span>;</span><br><span class="line">a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></div>
<h3 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h3><p>数据及控制流分析是<strong>对程序上下文逻辑更进一步的验证</strong>，具体操作由<code>com.sun.tools.javac.comp.Flow</code>类来完成。检查出诸如程序<strong>局部变量</strong>在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。事实上，在类加载时期的验证阶段，也进行了数据及控制流分析，只不过两者之间的校验范围有所区别，因为一些校验项只有在编译期或运行期才能进行。</p>
<p>如下代码，事实上两个foo方法在编译出来的Class文件后，是没有任何区别的。也就是说将局部变量声明为final对运行期没有影响，变量的不变性仅仅由编译器在编译期间保障。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一带有final修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> foo（<span class="keyword">final</span> <span class="keyword">int</span> arg）&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span>=<span class="number">0</span>；</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二没有final修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> foo（<span class="keyword">int</span> arg）&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">var</span>=<span class="number">0</span>；</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>语法糖指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。比如泛型、变长参数、自动装箱/拆箱等。Java虚拟机本身是不支持这些语法的，它们会在编译阶段还原回基础的语法结构，这个过程被称为解语法糖，由<code>desugar（）</code>方法触发，在<code>com.sun.tools.javac.comp.TransTypes</code><br>类和<code>com.sun.tools.javac.comp.Lower</code>类中完成</p>
<h2 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h2><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由<code>com.sun.tools.javac.jvm.Gen</code>类来完成。在此阶段，不仅仅是<strong>把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作</strong>。</p>
<p>代码添加，例如，实例构造器&lt; init &gt;()和类构造器&lt; clinit &gt;()方法就是在这个阶段添加到语法树中的。这两个构造器相当于一个代码收敛的过程，编译器会把语句块、变量初始化、调用父类的实例构造器等操作收敛到<code>＜init＞（）</code>和<code>＜clinit＞（）</code>方法之中，并保证先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，由<code>Gen.normalizeDefs（）</code>方法来实现</p>
<p>转化工作，用于优化程序的实现逻辑，比如把字符串的加操作替换为<code>StringBuffer</code>或<code>StringBuilder</code>的append（）操作等</p>
<p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给<br><code>com.sun.tools.javac.jvm.ClassWrite</code>r类，由这个类的<code>writeClass（）</code>方法输出字节码，生成最终的Class文件</p>
<h1 id="Java运行期"><a href="#Java运行期" class="headerlink" title="Java运行期"></a>Java运行期</h1><p>经过Javac编译成class文件后（字节码），加载到虚拟机中。实际上Java字节码依旧无法执行，而是由虚拟机翻译成机器码才可以执行。而翻译过程有两种形式：</p>
<ol>
<li>解释执行:利用解释器（Interpreter）逐条将字节码翻译成机器码并执行。优势在于无需等待编译</li>
<li>即时编译（Just-In-Time compilation，JIT）：提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化（非虚拟机必需）</li>
</ol>
<h2 id="HotSpot中的解释器和编译器"><a href="#HotSpot中的解释器和编译器" class="headerlink" title="HotSpot中的解释器和编译器"></a>HotSpot中的解释器和编译器</h2><p>HotSpot同时包含解释器与编译器，它们有着各自的优势</p>
<ol>
<li><p>解释器：</p>
<p>a. 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行</p>
<p>b. 解释执行可以节约内存</p>
</li>
<li><p>编译器</p>
<p>a. 程序运行后，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率</p>
<p>b. 编译执行可以来提升效率</p>
</li>
</ol>
<h3 id="编译器和解释器的共同工作"><a href="#编译器和解释器的共同工作" class="headerlink" title="编译器和解释器的共同工作"></a>编译器和解释器的共同工作</h3><p>编译器可以根据概率选择一些大多数时候都能提升运行速度的优化手段（激进优化），当激进优化失败后，可以通过逆优化（Deoptimization）退回到解释状态继续执行</p>
<h3 id="HotSpot中的编译器"><a href="#HotSpot中的编译器" class="headerlink" title="HotSpot中的编译器"></a>HotSpot中的编译器</h3><p>在HotSpot虚拟机中内置了两个即时编译器，分别称为Client Compiler（C1编译器）和Server Compiler（C2编译器，也叫Optp编译器）。默认采用解释器和其中一个编译器配合工作，采用哪个编译器，取决于虚拟机的运行模式。运行模式可以由虚拟机自动选择，也可以通过“<code>-client</code>”或“<code>-server</code>”参数去强制指定虚拟机运行在Client模式或Server模式。</p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>解释器和编译器代培使用的方式被称为”<strong>混合模式</strong>“,也是虚拟机的默认模式。编译器不参加工作，只由解释器工作执行的模式被称为解释模式(<strong>Interpreted</strong> Mode)。通过参数<code>-Xint</code>可以强制运行解释模式。此外还有<strong>编译模式</strong>（Compiled Mode），通过参数<code>-Xcomp</code>强制运行编译模式，但需要注意的是，在该模式下，解释器仍然要在编译无法进行的情况下介入执行过程。</p>
<h3 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h3><p>分层编译策略的目的是为了在程序启动响应速度与运行效率之间达到最佳平衡。概念于JKD1.6时期提出，在JDK1.7的Server模式中被设置为默认的编译策略。</p>
<p>层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p>
<ol>
<li>第0层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第1层编译。</li>
<li>第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能<br>监控的逻辑。</li>
<li>第2层（或2层以上），也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时<br>较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li>
</ol>
<h2 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h2><p>在运行过程中会被即时编译器编译的“热点代码”可以分为两类</p>
<ol>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ol>
<h3 id="热点代码编译方式"><a href="#热点代码编译方式" class="headerlink" title="热点代码编译方式"></a>热点代码编译方式</h3><p>对于被多次调用的方法，编译器理会以整个方法作为编译对象，这种编译被称为<strong>JIT编译方式</strong></p>
<p>对于被多次执行的循环体，尽管编译动作是由循环体所触发的，但编译器依然会以整个方法（而不是单独的循环体）作为编译对象。这种编译方式发生于方法执行过程之中，被称为<strong>栈上替换</strong>（On Stack Replacement，简称为OSR编译），即方法栈帧还在栈上，但方法被替换了</p>
<h2 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h2><p>热点探测（Hot Spot Detection）:即判断代码是不是热点代码，是否需要触发即时编译。目前主要的热点探测方法有两种</p>
<ol>
<li>基于采样的热点探测（Sample Based Hot Spot Detection）：通过周期性检查各个线程的栈顶，寻找出经常出现在栈顶的方法，这些方法即为热点方法。优点是简单高效，容易获取方法调用关系（将调用堆栈展开即可）。缺点是无法精确一个方法的热度，容易受线程受到线程阻塞或别的外界因素的影响。</li>
<li>基于计数器的热点探测（Counter Based Hot Spot Detection）：通过为每个方法（甚至是代码块）建立计数器，统计方法的执行次数。执行次数超过一点阈值即为热点代码。优点是精确严谨，缺点是需要为每个方法建立并维护计数器，且不能直接获取方法调用关系。</li>
</ol>
<h3 id="HotSpot中的热点探测"><a href="#HotSpot中的热点探测" class="headerlink" title="HotSpot中的热点探测"></a>HotSpot中的热点探测</h3><p>在HotSpot虚拟机中使用的是基于计数器的热点探测方法,它为每个方法准备了两类计数器：</p>
<ol>
<li>方法调用计数器（Invocation Counter）</li>
<li>回边计数器（Back Edge Counter）</li>
</ol>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>方法调用计数器<strong>用于统计方法被调用的次数</strong>，用于触发<strong>JIT编译</strong>，默认的阈值为Client模式下是1500次，在Server模式下是10000次。可以通过参数<code>-XX：CompileThreshold</code>进行设置。当一个方法被调用时的交互过程如下图所示</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/方法调用计数器.png" alt="方法调用计数器"></p>
<p>方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用<strong>计数器热度的衰减（Counter Decay）</strong>，而这段时间就称为此<strong>方法统计的半衰周期（Counter Half Life Time）</strong>。可以使用参数<code>-XX：-UseCounterDecay</code>来关闭热度衰减，关闭之后，总有一天，绝大部分代码会变成本地代码。使用<code>-X：CounterHalfLifeTime</code>参数设置半衰周期的时间</p>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>回边计数器用于统计一个方法中循环体代码执行的次数，用于触发<strong>OSR编译</strong> ，在字节码中遇到控制流向后跳转的指令称为<strong>“回边”（Back Edge）</strong>。使用<code>-XX：OnStackReplacePercentage</code>设置阈值。整个执行过程如下图所示</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/回边计数器.png" alt="回边计数器"></p>
<p>在Client模式下，回边计数器阈值计算公式为</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法调用计数器阈值（CompileThreshold）×OSR比率（OnStackReplacePercentage）/<span class="number">100</span></span><br></pre></td></tr></table></figure></div>
<p>OSR默认值933，默认情况下回边计数器阈值为13995</p>
<p>虚拟机运行在Server模式下，回边计数器阈值的计算公式为：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法调用计数器阈值（CompileThreshold）×（OSR比率（OnStackReplacePercentage）-解释器监控比率（InterpreterProfilePercentage）/100</span><br></pre></td></tr></table></figure></div>
<p>OSR默认140，解释器监控比率默认33，默认情况下回边计数器的阈值为10700</p>
<h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然将<strong>按照解释方式继续执行，而编译动作则在后台的编译线程中进行</strong>。可以通过使用参数<code>-XX：-BackgroundCompilation</code>来禁止后台编译，即达到JIT编译条件后，执行线程回等待直到编译结束。</p>
<h3 id="Client-Compiler编译过程"><a href="#Client-Compiler编译过程" class="headerlink" title="Client Compiler编译过程"></a>Client Compiler编译过程</h3><p>Client Compiler时一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。</p>
<p>第一个阶段：</p>
<p>一个平台独立的前端将字节码构造成一种高级中间代码表示（High-Level Intermediate Representaion,HIR）。HIR使用静态单分配（Static Single Assignment,SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成。</p>
<p>第二个阶段：</p>
<p>一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation,LIR），而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。</p>
<p>最后阶段：</p>
<p>在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/ClientCompiler.png" alt="Client Compiler"></p>
<h3 id="Server-Compiler编译过程"><a href="#Server-Compiler编译过程" class="headerlink" title="Server Compiler编译过程"></a>Server Compiler编译过程</h3><p>Server Compiler主要面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，是一个充分优化过的高级编译器。它会执行所有经典的优化操作，如</p>
<ol>
<li>无用代码消除（Dead Code Elimination）</li>
<li>循环展开（Loop Unrolling）</li>
<li>循环表达式外提（Loop Expression Hoisting）</li>
<li>消除公共子表达式（Common Subexpression Elimination）</li>
<li>常量传播（Constant Propagation）</li>
<li>基本块重排序（Basic Block Reordering）</li>
<li>……</li>
</ol>
<p>还会实施一些与Java语言特性密切相关的优化技术，如</p>
<ol>
<li>范围检查消除（Range Check Elimination）</li>
<li>空值检查消除（Null CheckElimination)</li>
<li>….</li>
</ol>
<p>此外还可能根据解释器或Client Compiler提供的性能监控信息，进行一些不稳定的激进优化，如</p>
<ol>
<li>守护内联（Guarded Inlining）</li>
<li>分支频率预测（Branch Frequency Prediction）</li>
<li>…</li>
</ol>
<p>Server Compiler即时编译速度缓慢，但远超传统的静态优化编译器，且相对于Client Compiler编译输出的代码质量有所提高，以减少本地代码的执行时间，从而抵消了额外的编译时间开销。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ol>
<li><a href="https://developers.redhat.com/products/openjdk/overview/" target="_blank" rel="noopener">OpenJDK下载地址</a></li>
</ol>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/02/java-thread.all/" rel="next" title="java 并发">
                <i class="fa fa-chevron-left"></i> java 并发
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/04/mysql.all/" rel="prev" title="MySQL">
                MySQL <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/toux.jpg" alt="Liisyu">
            
              <p class="site-author-name" itemprop="name">Liisyu</p>
              <div class="site-description motion-element" itemprop="description">我只是一个兴趣使然的程序员</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://liisyu.gitee.io/cv/" title="简历 &rarr; http://liisyu.gitee.io/cv/" rel="noopener" target="_blank"><i class="fa fa-fw fa-user-o"></i>简历</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:575600714@qq.com.com" title="E-Mail(QQ) &rarr; mailto:575600714@qq.com.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail(QQ)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:swordmaster2014@gmail.com" title="E-Mail(Google) &rarr; mailto:swordmaster2014@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>E-Mail(Google)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/FameLsy" title="GitHub &rarr; https://github.com/FameLsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://gitee.com/liisyu" title="Gitee &rarr; https://gitee.com/liisyu" rel="noopener" target="_blank"><i class="fa fa-fw fa-git-square"></i>Gitee</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/masorl" title="CSDN &rarr; https://blog.csdn.net/masorl" rel="noopener" target="_blank"><i class="fa fa-fw fa-tree"></i>CSDN</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="tencent://message/?uin=575600714&Site=qq&Menu=yes" title="QQ &rarr; tencent://message/?uin=575600714&Site=qq&Menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QQ</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://messilessblog.com/" title="https://messilessblog.com/" rel="noopener" target="_blank">汪酱 BLOG</a>
                  </li>
                
              </ul>
			   
            </div>
          

          
            
          
          

    <div class="wechat-box">
      <div class="weixin-description">微信扫一扫，联系我</div>
	  <img src="/images/wechat.jpg" alt="wechat">
    </div>


        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM运行时数据区"><span class="nav-number">1.</span> <span class="nav-text">JVM运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序计数器"><span class="nav-number">1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java栈"><span class="nav-number">1.2.</span> <span class="nav-text">Java栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java虚拟机栈"><span class="nav-number">1.2.1.</span> <span class="nav-text">Java虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地方法栈"><span class="nav-number">1.2.2.</span> <span class="nav-text">本地方法栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java堆"><span class="nav-number">1.3.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区"><span class="nav-number">1.4.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时常量池"><span class="nav-number">1.5.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接内存"><span class="nav-number">1.6.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾回收与算法"><span class="nav-number">2.</span> <span class="nav-text">垃圾回收与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象存活判定算法"><span class="nav-number">2.1.</span> <span class="nav-text">对象存活判定算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数法"><span class="nav-number">2.1.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可达性分析算法"><span class="nav-number">2.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两次标记过程"><span class="nav-number">2.1.3.</span> <span class="nav-text">两次标记过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收算法"><span class="nav-number">2.2.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-清除算法-Mark-Sweep"><span class="nav-number">2.2.1.</span> <span class="nav-text">标记-清除算法(Mark-Sweep)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制收集算法-Copying"><span class="nav-number">2.2.2.</span> <span class="nav-text">复制收集算法(Copying)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记整理法"><span class="nav-number">2.2.3.</span> <span class="nav-text">标记整理法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集算法（Generational-Collection）"><span class="nav-number">2.2.4.</span> <span class="nav-text">分代收集算法（Generational Collection）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新生代"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">新生代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#老年代"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#永久代"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">永久代</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">2.3.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-收集器"><span class="nav-number">2.3.1.</span> <span class="nav-text">Serial 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew-收集器"><span class="nav-number">2.3.2.</span> <span class="nav-text">ParNew 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scsvenge收集器"><span class="nav-number">2.3.3.</span> <span class="nav-text">Parallel Scsvenge收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-Old-收集器"><span class="nav-number">2.3.4.</span> <span class="nav-text">Serial Old 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Old收集器"><span class="nav-number">2.3.5.</span> <span class="nav-text">Parallel Old收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS收集器"><span class="nav-number">2.3.6.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1收集器"><span class="nav-number">2.3.7.</span> <span class="nav-text">G1收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾收集器参数总结"><span class="nav-number">2.3.8.</span> <span class="nav-text">垃圾收集器参数总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配与回收策略"><span class="nav-number">2.4.</span> <span class="nav-text">内存分配与回收策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区的回收"><span class="nav-number">2.5.</span> <span class="nav-text">方法区的回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用reference"><span class="nav-number">2.6.</span> <span class="nav-text">引用reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机类加载机制"><span class="nav-number">3.</span> <span class="nav-text">虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载过程"><span class="nav-number">3.1.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载"><span class="nav-number">3.1.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接"><span class="nav-number">3.1.2.</span> <span class="nav-text">链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#验证"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#准备"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解析"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">3.1.3.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#被动引用"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">被动引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口的初始化"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">接口的初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器"><span class="nav-number">3.2.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">3.2.1.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSGI：模块热部署"><span class="nav-number">3.2.2.</span> <span class="nav-text">OSGI：模块热部署</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HotSpot虚拟机对象"><span class="nav-number">4.</span> <span class="nav-text">HotSpot虚拟机对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的创建过程"><span class="nav-number">4.1.</span> <span class="nav-text">对象的创建过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象内存分配"><span class="nav-number">4.2.</span> <span class="nav-text">对象内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#空间的划分"><span class="nav-number">4.2.1.</span> <span class="nav-text">空间的划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配对象"><span class="nav-number">4.2.2.</span> <span class="nav-text">分配对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">4.3.</span> <span class="nav-text">对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象头"><span class="nav-number">4.3.1.</span> <span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例数据"><span class="nav-number">4.3.2.</span> <span class="nav-text">实例数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对齐填充"><span class="nav-number">4.3.3.</span> <span class="nav-text">对齐填充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的访问定位"><span class="nav-number">4.4.</span> <span class="nav-text">对象的访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用句柄访问"><span class="nav-number">4.4.1.</span> <span class="nav-text">使用句柄访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用直接指针"><span class="nav-number">4.4.2.</span> <span class="nav-text">使用直接指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机字节码指令表"><span class="nav-number">5.</span> <span class="nav-text">虚拟机字节码指令表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hotspot-虚拟机参数表"><span class="nav-number">6.</span> <span class="nav-text">Hotspot 虚拟机参数表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java内存模型"><span class="nav-number">7.</span> <span class="nav-text">Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件的效率与一致性"><span class="nav-number">7.1.</span> <span class="nav-text">硬件的效率与一致性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主内存和工作内存"><span class="nav-number">7.2.</span> <span class="nav-text">主内存和工作内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存间交互操作"><span class="nav-number">7.3.</span> <span class="nav-text">内存间交互操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对Volatile型变量的特殊规则"><span class="nav-number">7.4.</span> <span class="nav-text">对Volatile型变量的特殊规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对于long和double性变量的特殊规则"><span class="nav-number">7.5.</span> <span class="nav-text">对于long和double性变量的特殊规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性、可见性、有序性"><span class="nav-number">7.6.</span> <span class="nav-text">原子性、可见性、有序性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#先行发生原则-happens-before"><span class="nav-number">7.7.</span> <span class="nav-text">先行发生原则(happens-before)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令重排序"><span class="nav-number">7.8.</span> <span class="nav-text">指令重排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单线程下的重排序"><span class="nav-number">7.8.1.</span> <span class="nav-text">单线程下的重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程下的重排序"><span class="nav-number">7.8.2.</span> <span class="nav-text">多线程下的重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile、synchronize、final重排序规则"><span class="nav-number">7.8.3.</span> <span class="nav-text">volatile、synchronize、final重排序规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OOM异常"><span class="nav-number">8.</span> <span class="nav-text">OOM异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java堆溢出"><span class="nav-number">8.1.</span> <span class="nav-text">Java堆溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟机栈和本地方法栈溢出"><span class="nav-number">8.2.</span> <span class="nav-text">虚拟机栈和本地方法栈溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#栈StackOverflowError溢出"><span class="nav-number">8.2.1.</span> <span class="nav-text">栈StackOverflowError溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈OutOfMemoryError溢出"><span class="nav-number">8.2.2.</span> <span class="nav-text">栈OutOfMemoryError溢出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区和运行时常量池溢出"><span class="nav-number">8.3.</span> <span class="nav-text">方法区和运行时常量池溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常量池溢出"><span class="nav-number">8.3.1.</span> <span class="nav-text">常量池溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区溢出"><span class="nav-number">8.3.2.</span> <span class="nav-text">方法区溢出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接内存溢出"><span class="nav-number">8.4.</span> <span class="nav-text">直接内存溢出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机性能监控和故障处理工具"><span class="nav-number">9.</span> <span class="nav-text">虚拟机性能监控和故障处理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK命令行工具"><span class="nav-number">9.1.</span> <span class="nav-text">JDK命令行工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jps-虚拟机j进程状况工具"><span class="nav-number">9.1.1.</span> <span class="nav-text">jps:虚拟机j进程状况工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jstat-：-虚拟机统计信息监视工具"><span class="nav-number">9.1.2.</span> <span class="nav-text">jstat ： 虚拟机统计信息监视工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jinfo-Java配置信息工具"><span class="nav-number">9.1.3.</span> <span class="nav-text">jinfo: Java配置信息工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jmap：Java内存映像工具"><span class="nav-number">9.1.4.</span> <span class="nav-text">jmap：Java内存映像工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jhat-虚拟机堆转储快照分析工具"><span class="nav-number">9.1.5.</span> <span class="nav-text">jhat: 虚拟机堆转储快照分析工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jstack-Java堆栈跟踪工具"><span class="nav-number">9.1.6.</span> <span class="nav-text">jstack: Java堆栈跟踪工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-VisualVM"><span class="nav-number">9.2.</span> <span class="nav-text">Java VisualVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题"><span class="nav-number">9.3.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插件"><span class="nav-number">9.4.</span> <span class="nav-text">插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Startup-Profiler"><span class="nav-number">9.4.1.</span> <span class="nav-text">Startup Profiler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VisualVM-MBeans"><span class="nav-number">9.4.2.</span> <span class="nav-text">VisualVM-MBeans</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VisualVM-Glassfish"><span class="nav-number">9.4.3.</span> <span class="nav-text">VisualVM-Glassfish</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Visual-GC"><span class="nav-number">9.4.4.</span> <span class="nav-text">Visual-GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VisualVM-JConsole"><span class="nav-number">9.4.5.</span> <span class="nav-text">VisualVM-JConsole</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VisualVM-Extensions"><span class="nav-number">9.4.6.</span> <span class="nav-text">VisualVM-Extensions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Btrace-Workbench"><span class="nav-number">9.4.7.</span> <span class="nav-text">Btrace Workbench</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VisualVM-Security"><span class="nav-number">9.4.8.</span> <span class="nav-text">VisualVM-Security</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VisualVM-BufferMonitor"><span class="nav-number">9.4.9.</span> <span class="nav-text">VisualVM-BufferMonitor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Threads-Inspector"><span class="nav-number">9.4.10.</span> <span class="nav-text">Threads Inspector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KillApplication"><span class="nav-number">9.4.11.</span> <span class="nav-text">KillApplication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tracer-Jvmstat-Probes"><span class="nav-number">9.4.12.</span> <span class="nav-text">Tracer-Jvmstat Probes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tracer-Monitor-Probes"><span class="nav-number">9.4.13.</span> <span class="nav-text">Tracer-Monitor Probes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tracer-Swing-Probes"><span class="nav-number">9.4.14.</span> <span class="nav-text">Tracer-Swing  Probes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tracer-IO-Probes"><span class="nav-number">9.4.15.</span> <span class="nav-text">Tracer-IO Probes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tracer-Collections-Probes"><span class="nav-number">9.4.16.</span> <span class="nav-text">Tracer-Collections Probes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tracer-JVM-Probes"><span class="nav-number">9.4.17.</span> <span class="nav-text">Tracer-JVM Probes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QQL-syntax-Support"><span class="nav-number">9.4.18.</span> <span class="nav-text">QQL syntax Support</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存监控功能"><span class="nav-number">9.4.19.</span> <span class="nav-text">内存监控功能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class类结构"><span class="nav-number">10.</span> <span class="nav-text">Class类结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#魔数与Class版本号"><span class="nav-number">10.1.</span> <span class="nav-text">魔数与Class版本号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常量池"><span class="nav-number">10.2.</span> <span class="nav-text">常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标志位值对应的具体含义"><span class="nav-number">10.2.1.</span> <span class="nav-text">标志位值对应的具体含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量池中常量项结构总表"><span class="nav-number">10.2.2.</span> <span class="nav-text">常量池中常量项结构总表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Javap-：Class-字节码分析工具"><span class="nav-number">10.2.3.</span> <span class="nav-text">Javap ：Class 字节码分析工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问标志"><span class="nav-number">10.3.</span> <span class="nav-text">访问标志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#访问标志含义表"><span class="nav-number">10.3.1.</span> <span class="nav-text">访问标志含义表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引、父类索引和与接口索引集合"><span class="nav-number">10.4.</span> <span class="nav-text">索引、父类索引和与接口索引集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字段表集合"><span class="nav-number">10.5.</span> <span class="nav-text">字段表集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字段表结构"><span class="nav-number">10.5.1.</span> <span class="nav-text">字段表结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#access-flags字段访问标志"><span class="nav-number">10.5.2.</span> <span class="nav-text">access_flags字段访问标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#描述符字符含义"><span class="nav-number">10.5.3.</span> <span class="nav-text">描述符字符含义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法表"><span class="nav-number">10.6.</span> <span class="nav-text">方法表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法表结构"><span class="nav-number">10.6.1.</span> <span class="nav-text">方法表结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法访问标志"><span class="nav-number">10.6.2.</span> <span class="nav-text">方法访问标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载"><span class="nav-number">10.6.3.</span> <span class="nav-text">重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性表集合"><span class="nav-number">10.7.</span> <span class="nav-text">属性表集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最简单的属性表结构"><span class="nav-number">10.7.1.</span> <span class="nav-text">最简单的属性表结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用属性"><span class="nav-number">10.7.2.</span> <span class="nav-text">常用属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code属性"><span class="nav-number">10.7.3.</span> <span class="nav-text">Code属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Code属性结构"><span class="nav-number">10.7.3.1.</span> <span class="nav-text">Code属性结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM是如何使用Code属性？"><span class="nav-number">10.7.3.2.</span> <span class="nav-text">JVM是如何使用Code属性？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exceptions-属性"><span class="nav-number">10.7.4.</span> <span class="nav-text">Exceptions 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LineNumberTable属性"><span class="nav-number">10.7.5.</span> <span class="nav-text">LineNumberTable属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalVariableTable属性"><span class="nav-number">10.7.6.</span> <span class="nav-text">LocalVariableTable属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalVariableTypeTable属性"><span class="nav-number">10.7.7.</span> <span class="nav-text">LocalVariableTypeTable属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SourceFile属性"><span class="nav-number">10.7.8.</span> <span class="nav-text">SourceFile属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConstantValue属性"><span class="nav-number">10.7.9.</span> <span class="nav-text">ConstantValue属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnerClasses属性"><span class="nav-number">10.7.10.</span> <span class="nav-text">InnerClasses属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deprecated"><span class="nav-number">10.7.11.</span> <span class="nav-text">Deprecated</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synthetic属性"><span class="nav-number">10.7.12.</span> <span class="nav-text">Synthetic属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StackMap-Table-属性"><span class="nav-number">10.7.13.</span> <span class="nav-text">StackMap Table 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signature属性"><span class="nav-number">10.7.14.</span> <span class="nav-text">Signature属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BootStrapMethods属性"><span class="nav-number">10.7.15.</span> <span class="nav-text">BootStrapMethods属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java编译期"><span class="nav-number">11.</span> <span class="nav-text">Java编译期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解析-1"><span class="nav-number">11.1.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#词法解析"><span class="nav-number">11.1.1.</span> <span class="nav-text">词法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语法分析"><span class="nav-number">11.1.2.</span> <span class="nav-text">语法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#填充符号表"><span class="nav-number">11.2.</span> <span class="nav-text">填充符号表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注解处理器"><span class="nav-number">11.3.</span> <span class="nav-text">注解处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语义分析"><span class="nav-number">11.4.</span> <span class="nav-text">语义分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标注检查"><span class="nav-number">11.4.1.</span> <span class="nav-text">标注检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据及控制流分析"><span class="nav-number">11.4.2.</span> <span class="nav-text">数据及控制流分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语法糖"><span class="nav-number">11.4.3.</span> <span class="nav-text">语法糖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节码生成"><span class="nav-number">11.5.</span> <span class="nav-text">字节码生成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java运行期"><span class="nav-number">12.</span> <span class="nav-text">Java运行期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HotSpot中的解释器和编译器"><span class="nav-number">12.1.</span> <span class="nav-text">HotSpot中的解释器和编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器和解释器的共同工作"><span class="nav-number">12.1.1.</span> <span class="nav-text">编译器和解释器的共同工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HotSpot中的编译器"><span class="nav-number">12.1.2.</span> <span class="nav-text">HotSpot中的编译器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式"><span class="nav-number">12.1.3.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分层编译"><span class="nav-number">12.1.4.</span> <span class="nav-text">分层编译</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#热点代码"><span class="nav-number">12.2.</span> <span class="nav-text">热点代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#热点代码编译方式"><span class="nav-number">12.2.1.</span> <span class="nav-text">热点代码编译方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#热点探测"><span class="nav-number">12.3.</span> <span class="nav-text">热点探测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HotSpot中的热点探测"><span class="nav-number">12.3.1.</span> <span class="nav-text">HotSpot中的热点探测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法调用计数器"><span class="nav-number">12.3.1.1.</span> <span class="nav-text">方法调用计数器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回边计数器"><span class="nav-number">12.3.1.2.</span> <span class="nav-text">回边计数器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开始编译"><span class="nav-number">12.4.</span> <span class="nav-text">开始编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Client-Compiler编译过程"><span class="nav-number">12.4.1.</span> <span class="nav-text">Client Compiler编译过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Server-Compiler编译过程"><span class="nav-number">12.4.2.</span> <span class="nav-text">Server Compiler编译过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录"><span class="nav-number">13.</span> <span class="nav-text">附录</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liisyu</span>

  

  
</div>






        


  <script>
    var _mtac = {};
    (function() {
      var mta = document.createElement("script");
      mta.src = "https://pingjs.qq.com/h5/stats.js";
      mta.setAttribute("name", "MTAH5");
      mta.setAttribute("sid", "your-tencent-mta-id");
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(mta, s);
    })();
  </script>







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

  <script type="text/javascript" src="/blog/js/clipboard.min.js"></script>  
  <script type="text/javascript" src="/blog/js/clipboard-use.js"></script>
</body>
</html>
