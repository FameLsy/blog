<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="https://bestgakki.com/2018/02/03/jvm.all/index.html">
<meta property="og:site_name" content="Liisyu Blog">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389513.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/mode.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/缓存一致性.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/java内存模型.png">
<meta property="og:updated_time" content="2019-04-29T14:30:55.849Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM">
<meta name="twitter:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389513.jpg">





  
  
  <link rel="canonical" href="https://bestgakki.com/2018/02/03/jvm.all/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JVM | Liisyu Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liisyu Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-navigation">

    
    
    
      
    

    

    <a href="/navigation/" rel="section"><i class="menu-item-icon fa fa-fw fa-diamond"></i> <br>导航</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bestgakki.com/2018/02/03/jvm.all/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JVM

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-04 00:00:01" itemprop="dateCreated datePublished" datetime="2018-02-04T00:00:01+08:00">2018-02-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-29 22:30:55" itemprop="dateModified" datetime="2019-04-29T22:30:55+08:00">2019-04-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389513.jpg" alt></p>
<a id="more"></a>
<h1 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h1><p>java将内存的管理权力全部交给了虚拟机，如下是JVM所管理的内存区域图</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/mode.png" alt="mode"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p> 程序计数器</p>
<ul>
<li>是一块较小的内存空间，属于<strong>线程私有的内存</strong></li>
<li>可以看成是当前线程所指向的字节码的行号指示器，<code>字节码解释器</code>依靠计数器的值来选取下一个要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能也需要以来于计数器</li>
<li>由于java是多线程的切换的方式实现的，为了保证切换回后有恢复到正确的位置，所以每一条线程都有一个计数器</li>
<li>如果线程执行的是<code>java</code>代码，则计数器记录正在执行的虚拟机字节码指令的地址；如果是<code>Native</code>方法，计数器为<code>Undefined</code></li>
<li>唯一一个没有规定任何<code>OutOfMemoryError</code>情况的区域</li>
</ul>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p> Java虚拟机栈</p>
<ul>
<li><strong>线程私有的内存</strong>，为<strong>Java方法</strong>服务</li>
<li>虚拟机栈用来描述Java方法的<code>内存模型</code>，即每个方法在执行的同时会创建一个<code>栈帧</code>,用于存储局部变量表、操作数栈、动态链接、方法出口等信息;每一个方法调用直到完成的过程，对应一个栈帧在虚拟机栈中的入栈到出栈的过程</li>
<li>虚拟机栈中存在一个<code>局部变量表</code></li>
<li>规定了两种异常状态：  <code>StackOverflowError</code>和<code>OutOfMemoryError</code></li>
</ul>
<p> 局部变量表</p>
<ul>
<li><p>存放了编译期可知的<strong>基本数据类型</strong>、<strong>对象引用</strong>、<strong>returnAddress类型</strong></p>
<p>  <code>对象引用</code>：<code>reference</code>类型，可能是执行对象起始地址的引用指针，可以能是指向代表对象的句柄或其他与此对象相关的位置</p>
<p>  <code>returnAddress</code>类型:  指向一条字节码指令的地址</p>
</li>
<li><p><code>局部变量空间(Solt)</code>：基本数据类型的long和double会占据两个局部变量空间(Slot),其余数据类型占据一个</p>
</li>
<li><p><strong>局部变量表在编译期就已经完成了内存空间的分配,运行期间不会改变</strong></p>
</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p> 本地方法栈</p>
<ul>
<li>与虚拟机栈类似，<strong>线程私有的内存</strong>，为<strong>Native方法</strong>服务</li>
<li>规定了两种异常状态：  <code>StackOverflowError</code>和<code>OutOfMemoryError</code></li>
</ul>
<p>HotSpot VM中，直接将本地方法栈和虚拟机栈合二为一</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p> Java堆：</p>
<ul>
<li>JVM<strong>内存最大</strong>的一块,被<strong>线程共享</strong>，在虚拟机启动时创建</li>
<li><strong>用于存放对象示例和数组，GC的最要区域</strong></li>
<li>Java堆在物理空间上可以不连续，只要逻辑上连续即可</li>
<li>如果没有内存完成示例分配，会抛出<code>OutOfMemoryError</code>异常</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p> 方法区</p>
<ul>
<li><strong>线程间共享</strong>内存，别名<code>Non-Heap</code>(非堆);又被称为<code>永久代</code><a href="【永久代】其实是将GC分代算法扩展至方法区,HotSpot虚拟机特有。JDK1.7字符串常量池已经移除，JDK1.8完全移除永久代，原因是永久代更容易使内存溢出">^13</a></li>
<li>用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据</li>
<li>当方法区无法满足内存分配需求时，抛出<code>OutOfMemoryError</code>异常</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li>属于方法区的一部分，<strong>用于存放编译期</strong>生成的各种<strong>字面量和符号引用</strong></li>
<li>无法申请到内存时抛出<code>OutOfMemoryError</code>异常</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p> 直接内存：</p>
<ul>
<li>并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中的内存区域</li>
<li>;在JDK1.4后加入了NIO类，引入了基于通道与缓冲区的I/O方式，该类可以使用<code>Native</code>函数库<strong>直接分配堆外内存</strong>，然后通过一个存储在 <code>java</code>堆 中的 <code>DirectByteBuffer</code>对象作为这块内存存的引用进行操作;</li>
<li>会受到本机总内存以及处理器寻址空间的限制。会抛出<code>OutOfMemoryError</code>异常</li>
</ul>
<h1 id="垃圾回收与算法"><a href="#垃圾回收与算法" class="headerlink" title="垃圾回收与算法"></a>垃圾回收与算法</h1><h2 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h2><p>Java 虚拟机想要通过垃圾回收器回收，必需要先判定哪些对象需要回收，通常有两种判定方式</p>
<ol>
<li><p>引用计数法</p>
</li>
<li><p>可达性分析算法</p>
</li>
</ol>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p> 算法步骤</p>
<ol>
<li>给对象添加一个引用计数器</li>
<li>每当有地方引用它，计数器+1</li>
<li>引用失效，计数器-1</li>
<li>计数器为0则表示没有任何地方使用这个对象</li>
</ol>
<p>算法优点：</p>
<ol>
<li>实现简单</li>
<li>判定效率高</li>
</ol>
<p>算法缺点：难以解决对象之间相互循环引用，如下示例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br><span class="line">//即使objeA,objB都为null了，但它们的Instance字段互相引用对方，使这两个对象的计数器永远不为0，GC收集器永远无法回收</span><br><span class="line">objA = null;</span><br><span class="line">objB = null;</span><br></pre></td></tr></table></figure></div>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p> 算法步骤</p>
<ol>
<li>通过一系列 <code>GC Roots</code>作为对象的<strong>起始点</strong></li>
<li>从这些起始节点向下搜索，搜索走过的路径被称为 <code>引用链</code></li>
<li>如果一个对象没有任何引用链，证明此对象不可用</li>
</ol>
<p>如图</p>
<ul>
<li><p>Object1、Object2、Object3都存在与<code>GC Roots</code>联通的 <code>引用链</code>,所以仍然存活</p>
</li>
<li><p>虽然object 5、6、7之间相互关联，但它们与 <code>GC Roots</code>无关联，所以会被判定为可回收对象</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm11.png" alt="jvm3"></p>
<p>在Java语言中，可作为 <code>GC Roots</code> 的对象包括</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法去区中常量引用的对象</li>
<li>本地方法栈中JNI(即Native方法)引用的对象</li>
</ul>
<p>在可达性分析算法中，<strong>对于不可用的对象，并不会马上回收</strong>，它至少要经理两次标记过程</p>
<ol>
<li><p>第一次进行<code>可达性分析</code>后没有与<code>GC Roots</code>相连的引用链，则<strong>标记第一次</strong>；</p>
</li>
<li><p>在标记完后，进行依次筛选</p>
<p>如果当前对象没有覆盖<code>finalize()</code>方法或者<code>finalize()</code>方法已经被JVM调用过，JVM会将这两种情况视为<strong>“没必要执行”</strong>，其他的则视为有必要执行，进入下一步</p>
</li>
<li><p>对于有必要执行<code>finalize()</code>的对象，会把它放入到<code>F-Queue</code>队列中，并由一个虚拟机自动建立的，优先级低的<code>Finalizer</code>线程去执行它。GC 会对该队列进行<strong>第二次标记</strong>，如果在此时对象与引用链上的对象建立关联，则将该对象移出即将回收集合。如果第二次标记时仍然时不可达对象，那么就被真正回收</p>
</li>
</ol>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h3><p> 算法分为 <code>标记</code> 和 <code>清除</code>两个阶段</p>
<ol>
<li><p>标记处所有需要回收的对象(标记过程看 ”可达性分析算法” 这一章的内容)</p>
</li>
<li><p>标记完成后统一回收</p>
</li>
</ol>
<p> 该算法有两处不足</p>
<ol>
<li>效率低，无论是标记还是清除效率都不高</li>
<li>空间问题，清除后会产生大量不连续内存碎片</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm4.png" alt="jvm4"></p>
<h3 id="复制收集算法-Copying"><a href="#复制收集算法-Copying" class="headerlink" title="复制收集算法(Copying)"></a>复制收集算法(Copying)</h3><p> 算法步骤</p>
<ol>
<li>将内存分为大小相等的两块</li>
<li>每次使用其中一块，当被使用的内存块用玩了，则将该内存块中存货对象复制到另一块上，然后一次性清空该块。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm5.png" alt="jvm5"></p>
<p>算法不足之处：有一半空间是没有使用的</p>
<h3 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h3><p>标记整理法是<strong>针对老年代</strong>的算法，它的步骤与 <code>标记清除法</code> 类似</p>
<ol>
<li>标记处所有需要回收的对象(标记过程看 ”可达性分析算法” 这一章的内容)</li>
<li>所有存活对象移动到一端，然后直接清理端边界意外的内存</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm6.png" alt="jvm6"></p>
<h3 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h3><p>该算法是根据对象存货周期的不同将内存划几块，一般将Java堆分为 <code>新生代(Young Generation)</code>和<code>老年代(Tenured/Old Generation)</code>,然后根据各个年代的特点选择不同的算法</p>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>特点：</p>
<ul>
<li>新生代对象存活较少，每次需要回收大量对象，所以复制操作较少，通常使用复制算法</li>
<li>新生代一般以1:1:8 的比例划分为两个<code>Survivor</code>（SurvivorFrom,SurvivorTo）和一个<code>Eden</code>空间，每次使用<code>Eden</code>空间和其中一个<code>Survivor</code>，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中</li>
</ul>
<p>MajorGC步骤：</p>
<ol>
<li>复制：将 <code>Eden</code>和 <code>SurvivorFrom</code> 复制到另一块<code>SurvivorTo</code>中(复制过程中可能出现晋升老年代、空间不足等情况，具体处理详细看<strong>《内存分配与回收策略》</strong>)</li>
<li>清空：将 <code>Eden</code>和 <code>SurvivorFrom</code>内容清空 </li>
<li>互换：将 <code>SurvivorFrom</code> 与<code>SurvivorTo</code>互换，即原<code>SurvivorTo</code>成为下一次GC的<code>SurvivorFrom</code> </li>
</ol>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>特点</p>
<ul>
<li>老年代对象存活率大，回收数量少，没有额外空间对它进行分配担保，则必须使用 <strong>标记清除法</strong> 或 <strong>标记整理法</strong></li>
<li>新生代的对象在一定条件下，就会晋升为老年代对象(详细看《内存分配与回收策略》)</li>
</ul>
<h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><p>​    永久代即方法区，主要存放Class和Meta(元数据)，Class会在被加载时候放入该区域，因为GC不会在主程序运行期对方法区进行清理，所以该区域会随着加载的Class增多而最终导致抛出OOM。为了清理方法区，HotSpot VM将GC分代算法扩展至方法区，即使用Java堆的永久代来实现方法区, 这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器。<strong>不过收益一般很小</strong></p>
<p>​    在Java8中，永久代已经被一处，被<code>元数据区（元空间）</code>取代，它们的区别在于元空间大小受本地内存限制。类的元数据放入<code>native memoery</code>,字符串池和类的静态变量放入java队中，好处是加载多少类的元数据就不再由MaxPermSize控制，而是由系统的实际可用空间控制</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>HotSpot 提供的收集器，收集器的连线表示它们可以配合使用</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm7.png" alt="jvm7"></p>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial收集器</p>
<ul>
<li><p><code>新生代收集器</code>，<strong>单线程</strong></p>
</li>
<li><p>JVM运行在 <strong>Client模式</strong> 下的默认 <code>新生代收集器</code></p>
</li>
<li><p>它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（有一种叫法，叫 <code>Stop The World</code> ），直到它收集结束;</p>
</li>
</ul>
<p>Serial收集器优点：<br>    简单高效，尤其是单个CPU环境。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率；只需要控制好能接受的停顿时间，那还是一个很好的选择</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm8.png" alt="jvm8"></p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p> ParNew收集器</p>
<ul>
<li><code>新生代收集器</code>,Serial收集器的<strong>并行<a href="【并行（Parallel)】指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。">^4</a>多线程</strong>版本,其余行为与Serial收集器相同；</li>
<li>是运行在Server模式下的JVM的首选<code>新生代收集器</code></li>
<li><strong>唯一一个</strong>可以配合<code>CMS</code>的收集器</li>
<li>在单CPU下由于存在线程交互开销，性能可能低于Serial收集器</li>
<li>默认开启的线程数与CPU数量相同</li>
</ul>
<p> ParNew收集器优点：多线程、高效</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm9.png" alt="jvm9"></p>
<h3 id="Parallel-Scsvenge收集器"><a href="#Parallel-Scsvenge收集器" class="headerlink" title="Parallel Scsvenge收集器"></a>Parallel Scsvenge收集器</h3><p>Parallel Scsvenge</p>
<ul>
<li><p><code>新生代收集器</code>，,同时也是<strong>并行<a href="【并行（Parallel)】指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。">^4</a>的多线程收集器</strong>,与<strong>ParNew</strong> 收集器几乎一致</p>
</li>
<li><p>Parallel Scsvenge与其他收集器的区别：<strong>关注点与其他收集器不同</strong> </p>
<p>​    a. 其他浏览器关注点：尽可能缩短垃圾收集时用户线程的停顿时间</p>
<p>​    b. <code>Parallel Scsvenge</code>关注点：控制吞吐量</p>
</li>
<li><p>适用于后台运算而不需要太多交互的任务</p>
</li>
</ul>
<p>Parallel Scsvenge优点：在高吞吐量下最高效率利用CPU时间，尽快完成程序的运算任务</p>
<p>Parallel Scsvenge提供了两个参数用于精确控制吞吐量</p>
<ol>
<li><code>-XX:MaxGCPauseMillis</code> : <strong>控制最大垃圾收集停顿时间</strong>(大于0的毫秒数)，收集器尽可能保证内存回收花费时间不超过设定值，时间缩短靠的是牺牲吞吐量和新生代空间换取的</li>
<li><code>-XX:GCTimeRatio</code> : <strong>直接设置大小</strong>（大于0小于100，垃圾手机时间占总时间的比率，即吞吐量的倒数）,如设置成19，那么GC时间就是 1/(1+19)= 5%,默认值99，即GC时间1%(1/(1+99))</li>
</ol>
<p>Parallel Scsvenge其他参数</p>
<ul>
<li><code>XX:+UserAdaptiveSizePolicy</code>: 开关参数，用于打开GC自适应的调节策略, 打开后，无需手工指定新生代大小、Eden与Survior的比例等细节参数，JVM会自动调节。</li>
</ul>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial Old</p>
<ul>
<li><p><code>Serial</code> 老年代版本，单线程收集器，使用<code>标记-整理</code>算法</p>
</li>
<li><p>主要用于<code>Client</code>模式下的虚拟机，与Serial 收集器搭配使用</p>
</li>
<li><p>在<code>Server</code>模式下，有两大用途</p>
<p>a. 与<code>Parallel Scsvenge</code>收集器搭配使用</p>
<p>b. 作为<code>CMS</code>收集器的后备预案，在并发收集发生<code>Concurrent Mode Failure</code>时使用</p>
</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old</p>
<ul>
<li><code>Parallel Scsvenge</code>老年代版本，多线程收集器，使用<code>标记-整理</code>算法</li>
<li><code>Parallel Old</code> + <code>Parallel Scsvenge</code> 组合，适用于注重吞吐量以及CPU资源敏感的场合</li>
</ul>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p> CMS收集器（Coucurrent mark swrrp）</p>
<ul>
<li><p>老年代收集器，基于 <code>标记清除算法</code>实现</p>
</li>
<li><p>是以<strong>获取最短回收停顿时间</strong>为目标的收集器</p>
</li>
</ul>
<p>它的运作过程如下</p>
<ul>
<li><code>初始标记</code>： 暂停所有的其他线程，只是记录下直接与<code>GC Roots</code>相连的对象，速度很快 ；需要<code>Stop The World</code></li>
<li><code>并发标记</code>： 进行<code>GC Roots Tracing</code>(GC Root 追踪过程),同时开启GC和用户线程</li>
<li><code>重新标记</code>： 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要<code>Stop The World</code></li>
<li><code>并发清除</code>： 开启用户线程，同时GC线程开始对为标记的区域做清扫</li>
</ul>
<p>CMS优点：对交互比较高的程序提升较大，总体上，CMS收集器的内存回收与用户线程并发进行</p>
<p> CMD也被称为 <strong>并发低停顿收集器</strong>，但存在3个缺点：</p>
<ul>
<li><p>CMS对CPU敏感</p>
<p>默认启动的回收线程数为(CPU数量+3)/4，比如CPU数是2个，那么开启的线程数为1，占了50%的CPU资源，这样很可能导致用户程序的执行速度降低50%。</p>
</li>
<li><p>CMS收集器无法处理<code>浮动垃圾</code><a href="【浮动垃圾】在并发清除阶段，用户线程依旧在运行，那么可能产生新的垃圾，而这些垃圾已经是在标记之后了，所以这次清楚并不会清理，只能留在下次。这样的垃圾，就被成为浮动垃圾">^3</a></p>
</li>
<li><p>CMS式基于<code>标记清除算法</code>实现，所以会产生大量空间碎片</p>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>  G1收集器</p>
<ul>
<li><p>面向服务端应用的多线程垃圾收集器，基于<code>标记-整理算法</code>实现</p>
</li>
<li><p>它将整个Java堆划分成大小相等的独立区域(Region),虽然保留新生代和老年代概念，但新生代和老年代不再物理隔离，都属于Region(不需要连续)的集合；</p>
</li>
<li><p>空间整合：</p>
<p>a. 从整体看，G1是基于 <code>标记整理算法</code>实现的；</p>
<p>b. 从局部(Region)来看，G1是基于 <code>复制算法</code>实现的；这两种算法都不会产生内存空间碎片</p>
</li>
<li><p>可预测的停顿：相对于CMS的大优势，G1可以建立可预测的停顿时间模型，让使用者明确指定一个长度为M毫秒的时间片段，消耗在垃圾收集上的时间不得超过M秒</p>
</li>
</ul>
<p>G1收集器优点：</p>
<ul>
<li>并发执行GC，缩短<code>Stop The World</code> 停顿时间</li>
<li><p>避免在整个Java堆中进行垃圾收集</p>
</li>
<li><p>可控停顿时间</p>
</li>
<li>不产生内存碎片</li>
<li>不需要其他收集器配合，独立完成新生代和老年代的回收</li>
</ul>
<p>G1可预测的停顿原因</p>
<p>​    由于划分成了多个<code>Region</code>，G1会根据Region的价值大小(回收所获取的空间大小和回收所需时间的经验值)，在后台维护一个优先级列表，优先回收最大的<code>Region</code>,从而保证在有限时间内获得更高的回收小路</p>
<p> G1收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><p>初始标记：</p>
<p>a. 标记 GC Roots能直接关联的对象,需要<code>Stop The World</code></p>
<p>b. 修改TAMS（Next Top at Mark Start）的值，目的是让一下阶段用户程序并发运行时，能正确在Region中创建新对象</p>
</li>
<li><p>并发标记： 进行可达性分析，找出存活对象，耗时长</p>
</li>
<li><p>最终标记：</p>
<p>a. 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要<code>Stop The World</code></p>
<p>b.  将这段时间对象变化记录在线程<code>Remebered Set Logs</code>里，然后将其合并到<code>Remebered Set</code>中</p>
</li>
<li><p>筛选回收： 对各个<code>Region</code>的回收价值和成本进行排序，根据用户希望的GC停顿时间来指定回收计划</p>
</li>
</ul>
<h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UseSerialGC</td>
<td>虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParNewGC</td>
<td>打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseConcMarkSweepGC</td>
<td>打开此开关后，使用ParNew+ CMS + Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用</td>
</tr>
<tr>
<td>UseParallelGC</td>
<td>虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old (PS Mark Sweep)的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UserParallelOldGC</td>
<td>打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>SurvivorRatio</td>
<td>新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Survivor = 8:1</td>
</tr>
<tr>
<td>PretenureSizeThreshold</td>
<td>直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td>
</tr>
<tr>
<td>MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代</td>
</tr>
<tr>
<td>UseAdaptiveSizePolicy</td>
<td>动态调整Java堆中各个区域的大小以及进入老年代的年龄</td>
</tr>
<tr>
<td>HandlePromotionFailure</td>
<td>是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况</td>
</tr>
<tr>
<td>ParallelGCThreads</td>
<td>设置并行GC时进行内存回收的线程数</td>
</tr>
<tr>
<td>GCTimeRatio</td>
<td>GC时间占总时间的比率，默认值是99， 即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>MaxGCPauseMillis</td>
<td>设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>CMSInitiatingOccupancyFraction</td>
<td>设置CMS收集器在老年代时间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效</td>
</tr>
<tr>
<td>UseCMSCompactAtFullCollection</td>
<td>设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效</td>
</tr>
<tr>
<td>CMSFullGCsBeforeCompaction</td>
<td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用CMS收集器时生效</td>
</tr>
</tbody>
</table>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>规则一：对象优先在Eden分配</p>
<p>​    大多数情况下，对象在新生代的Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次<code>Minor GC</code><a href="【MinorGC】从年轻代空间（包括Eden和Survivor区域）回收内存">^1</a></p>
<p>规则二：<code>大对象</code><a href="【大对象】需要大量连续空间的Java对象">^9</a>直接进入老年代</p>
<ul>
<li><p>经常出现大对象容易导致内存还有不少空间时就<strong>提前触发垃圾收集器以获取足够的连续空 间</strong>来存储它们</p>
</li>
<li><p><code>PretenureSizeThreshold</code>参数：令大于这个值的对象直接在老年代分配    </p>
</li>
</ul>
<p>规则三：长期存活的对象进入老年代<br>    虚拟机通过<code>对象年龄计数器</code>来识别对象应该放置在新生代还是老年代</p>
<p>对象年龄计数器</p>
<ul>
<li>如果对象在<code>Eden</code>出生并经过第一次<code>Minor GC</code><a href="【MinorGC】从年轻代空间（包括Eden和Survivor区域）回收内存">^1</a>后能存活，并能被<code>Survivor</code>容纳，那么该对象会被移动到<code>Survivor</code>空间中，且对象年龄为1；</li>
<li>之后，每进行一次<code>Minor GC</code><a href="【MinorGC】从年轻代空间（包括Eden和Survivor区域）回收内存">^1</a>，对象没有被回收的化，年龄+1；</li>
<li>年龄到达一定值（默认15），就会晋升到老年代中。</li>
<li><code>MaxTenuringThreshold</code>参数：设置对象晋升老年代的阈值</li>
</ul>
<p>规则四：动态对象年龄判断</p>
<ul>
<li>虚拟机为了更好的适应不同程序的内存状况，并不是要求对象必须年龄到达阈值才晋升为老年代</li>
<li>当Survivor空间中相同年龄所有对象的大小的总和大于Survivor空间的一半，那么年龄大于等于该值年龄的对象直接晋升到老年代</li>
</ul>
<p>​    </p>
<p>规则五：空间分配担保</p>
<p>在<code>Minor GC</code><a href="【MinorGC】从年轻代空间（包括Eden和Survivor区域）回收内存">^1</a>之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</p>
<ul>
<li><p>是，则可以确保<code>Minor GC</code><a href="【MinorGC】从年轻代空间（包括Eden和Survivor区域）回收内存">^1</a>是安全的,进行一次<code>Minor GC</code><a href="【MinorGC】从年轻代空间（包括Eden和Survivor区域）回收内存">^1</a></p>
</li>
<li><p>否，则还需要查看<code>HandlePromotionFailure</code>设置值是否允许担保失败</p>
<p>​    a. 允许，检查老年代最大可用连续空间是否大于<strong>历次</strong>晋升老年代对象的平均大小</p>
</li>
</ul>
<p>​            大于：则再一次尝试<code>Minor GC</code><a href="【MinorGC】从年轻代空间（包括Eden和Survivor区域）回收内存">^1</a></p>
<p>​            小于：则进行一次<code>Full GC</code><a href="【FullGC】">^2</a></p>
<p>​        b. 不允许，则进行一次<code>Full GC</code><a href="【FullGC】">^2</a></p>
<p>为什么需要空间担保分配</p>
<ul>
<li><p>新生代采用的是复制收集算法，按照8:1:1的分配方式，只有一个Survivor空间来进行轮换备份，如果在<code>Minor GC</code><a href="【MinorGC】从年轻代空间（包括Eden和Survivor区域）回收内存">^1</a>后依旧还有大量对象存活，导致Survivor不够用时，就需要老年代进行分配担保，将无法容纳的对象直接存入老年代</p>
</li>
<li><p>老年代要进行担保，必须是它本身还有多余的能容纳这些对象的空间。而到底有多少对象存活在<code>Minor GC</code><a href="【MinorGC】从年轻代空间（包括Eden和Survivor区域）回收内存">^1</a>无法得知，所以只能通过以前的回收晋升到老年代的对象的评价大小来作为经验值。</p>
<p>​    a. 老年代剩余空间大于经验值，那么就可以尝试<code>Minor GC</code><a href="【MinorGC】从年轻代空间（包括Eden和Survivor区域）回收内存">^1</a>，这仅仅只是一次尝试，依旧会导致担保失败(Handle Promition Failure),不得不进行一次<code>Full GC</code><a href="【FullGC】">^2</a>来获取更多的空间；</p>
<p>​    b. 小于经验值的话，也需要进行<code>Full GC</code><a href="【FullGC】">^2</a>来获取更多的空间。</p>
</li>
<li><p><code>HandlePromotionFailure</code>参数：开关参数，建议打开，避免<code>Full GC</code><a href="【FullGC】">^2</a>关于频繁</p>
</li>
</ul>
<h2 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h2><p> 方法区（即永久代）垃圾回收率较低，主要回收的时废弃常量和无用的类。废如字符串”abc”在常量池但没有任何对象引用用它，则该字符串就是废弃常量；而判断无用的类，则必须满足以下三个条件</p>
<ol>
<li>该类实例都已经被回收</li>
<li>加载该类的ClassLoader已被回收</li>
<li>该类的java.lang.Class对象没有被引用，无法在任何地方通过反射访问该类方法</li>
</ol>
<p>满足三个条件，只能说是可以回收，是否要回收，HotSpot提供了 <code>-Xnoclassgc</code> 参数对齐进行控制;还可以使用 <code>-verbose:class</code>(Product版虚拟机中使用) 和 <code>-XX:+TraceClassLoadd</code>(Product版虚拟机中使用) 、 <code>-XX:+TraceClassUnLoading</code>(FastDebug版虚拟机中使用) 查看加载和卸载信息;</p>
<h1 id="引用reference"><a href="#引用reference" class="headerlink" title="引用reference"></a>引用reference</h1><p> 什么是引用?</p>
<ul>
<li>在JDK1.2 以前，引用被定义为：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用</li>
<li>在JDK1.2之后，引用被分为了四种: <code>强引用</code>、<code>软引用</code>、<code>弱引用</code>、<code>虚引用</code>,四种引用强度依次减弱</li>
</ul>
<p><code>强引用</code>: 指在程序代码之中普遍存在的，类似”Object obj = new Object()”这类引用，只要强引用还在，垃圾收集器不会回收被引用的对象</p>
<p><code>软引用</code>：软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果还没有足够的内存，则抛出内存溢出异常。在JKD1.2后使用 <code>SoftReference</code> 类 来实现软引用</p>
<p> <code>弱引用</code>：弱引用关联的对象，在垃圾收集器工作时，无论是否内存足够，都会被回收。在JKD1.2后使用 <code>WeakReference</code> 类来实现软引用</p>
<p><code>虚引用</code>：又被称为<code>幽灵引用</code>或者<code>幻影引用</code>。对象被虚引用关联，完全不会对其生存时间造成任何影响，也无法通过虚引用来获取对象实例。该引用的唯一作用是在被关联对象回收后收到一个系统通知；在JKD1.2后使用 <code>PhantomReference</code> 类来实现软引用</p>
<h1 id="虚拟机性能监控和故障处理工具"><a href="#虚拟机性能监控和故障处理工具" class="headerlink" title="虚拟机性能监控和故障处理工具"></a>虚拟机性能监控和故障处理工具</h1><h2 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h2><p>工具位于<code>$JAVA_HOME/bin</code>,如比较熟悉的<code>java、javac</code></p>
<p>JDK监控和故障处理工具表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:center">主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">jps</td>
<td style="text-align:center">JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程</td>
</tr>
<tr>
<td style="text-align:left">jstat</td>
<td style="text-align:center">JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据</td>
</tr>
<tr>
<td style="text-align:left">jinfo</td>
<td style="text-align:center">Configguration Info for Java，显示虚拟机配置信息</td>
</tr>
<tr>
<td style="text-align:left">jmap</td>
<td style="text-align:center">Memory Map for Java,生成虚拟机的内存转储快照</td>
</tr>
<tr>
<td style="text-align:left">jhat</td>
<td style="text-align:center">JVM Heap Analysis Tool,用于分析heapdump（jmap内存转储）文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td>
</tr>
<tr>
<td style="text-align:left">jstack</td>
<td style="text-align:center">Stack Trace For Java,显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
<h3 id="jps-虚拟机j进程状况工具"><a href="#jps-虚拟机j进程状况工具" class="headerlink" title="jps:虚拟机j进程状况工具"></a>jps:虚拟机j进程状况工具</h3><p>jps功能：</p>
<p>​    列出正在运行的虚拟机进程,显示虚拟机执行<strong>主类名称</strong>以及这些进程的<strong>本地虚拟机唯一id</strong>(LVMID, Local Virtual Machine Identifier)</p>
<p>jps命令格式：</p>
<p>​     jps可以通过<code>RMI协议</code><a href="需要远程主机提供RMI支持，可以使用Sun提供的jstatd工具简历远程RMI服务器">^11</a>查询开启了RMI服务的远程虚拟机进程状态</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hostid为RMI注册表中注册的主机名</span></span><br><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure></div>
<p>jps工具常用选项</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-q</td>
<td style="text-align:center">只输出LVMID</td>
</tr>
<tr>
<td style="text-align:left">-m</td>
<td style="text-align:center">输出虚拟机进程启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td style="text-align:left">-l</td>
<td style="text-align:center">输出主类的全名，如果进程执行的是jar包，输出Jar路径</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:center">输出虚拟机进程启动时JVM参数</td>
</tr>
</tbody>
</table>
<h3 id="jstat-：-虚拟机统计信息监视工具"><a href="#jstat-：-虚拟机统计信息监视工具" class="headerlink" title="jstat ： 虚拟机统计信息监视工具"></a>jstat ： 虚拟机统计信息监视工具</h3><p><code>jstat</code>是用于监视虚拟机各种运行状态信息的命令行工具,它可以本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</p>
<p>jstat命令格式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*	interval: 查询间隔</span><br><span class="line">*	count: 查询次数</span><br><span class="line">*	省略以上两个参数，说明值查询一次</span><br><span class="line">* 	option：要查询的虚拟机信息</span><br><span class="line">*/</span><br><span class="line">jstat [option vmid [interval] [s|ms] [count]]</span><br><span class="line"></span><br><span class="line">// vmid：</span><br><span class="line">//	1. 如果是本地虚拟机进程，vmid与lvmid一致</span><br><span class="line">//	2. 如果是远程虚拟机进程，格式如下</span><br><span class="line">[protocol:][//]lvmid[hostname[:port]/servername]</span><br></pre></td></tr></table></figure></div>
<p> <code>option</code>选项：主要<code>分类装载</code>、<code>垃圾收集</code>、<code>运行期编译状况</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-class</td>
<td style="text-align:center">监视类装载、卸载数量、总空间以及类装载所耗费的时间</td>
</tr>
<tr>
<td style="text-align:left">-gc</td>
<td style="text-align:center">监视Java堆状况，包括Eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td>
</tr>
<tr>
<td style="text-align:left">-gccapacity</td>
<td style="text-align:center">监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td style="text-align:left">-gcutil</td>
<td style="text-align:center">监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td style="text-align:left">-gccause</td>
<td style="text-align:center">与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td>
</tr>
<tr>
<td style="text-align:left">-gcnew</td>
<td style="text-align:center">监视新生代GC状况</td>
</tr>
<tr>
<td style="text-align:left">-gcnewcapacity</td>
<td style="text-align:center">监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td style="text-align:left">-gcold</td>
<td style="text-align:center">监视老年代GC状况</td>
</tr>
<tr>
<td style="text-align:left">-gcoldcapacity</td>
<td style="text-align:center">监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td style="text-align:left">-gcpermcapacity</td>
<td style="text-align:center">输出永久代使用到的最大、最小空间</td>
</tr>
<tr>
<td style="text-align:left">-compiler</td>
<td style="text-align:center">输出JIT编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td style="text-align:left">-printcompilation</td>
<td style="text-align:center">输出已经被JIT编译的方法</td>
</tr>
</tbody>
</table>
<p>示例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//250毫秒查询一次进程id为2764的垃圾收集情况，一共查询20次</span><br><span class="line">jstat -gc 2764 250 20</span><br></pre></td></tr></table></figure></div>
<p>显示列描述（部分）</p>
<table>
<thead>
<tr>
<th style="text-align:left">列名称</th>
<th style="text-align:left">详细描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Loaded</td>
<td style="text-align:left">被加载类的数量</td>
</tr>
<tr>
<td style="text-align:left">Bytes</td>
<td style="text-align:left">被加载字节数量，以“KB”为单位</td>
</tr>
<tr>
<td style="text-align:left">Unloaded</td>
<td style="text-align:left">被卸载类的数量</td>
</tr>
<tr>
<td style="text-align:left">Time</td>
<td style="text-align:left">加载和卸载类行为耗费时间</td>
</tr>
<tr>
<td style="text-align:left">Compiled</td>
<td style="text-align:left">成功编译任务数量</td>
</tr>
<tr>
<td style="text-align:left">Failed</td>
<td style="text-align:left">失败编译任务数量</td>
</tr>
<tr>
<td style="text-align:left">Invalid</td>
<td style="text-align:left">无效编译任务数量</td>
</tr>
<tr>
<td style="text-align:left">Time</td>
<td style="text-align:left">编译任务耗费时间</td>
</tr>
<tr>
<td style="text-align:left">FailedType</td>
<td style="text-align:left">最近一次失败编译任务对应的编译类型</td>
</tr>
<tr>
<td style="text-align:left">FailedMethod</td>
<td style="text-align:left">最近一次失败编译任务对应的类名和方法名</td>
</tr>
<tr>
<td style="text-align:left">S0C</td>
<td style="text-align:left">当前Survivor区0内存容量</td>
</tr>
<tr>
<td style="text-align:left">S1C</td>
<td style="text-align:left">当前Survivor区1内存容量</td>
</tr>
<tr>
<td style="text-align:left">S0U</td>
<td style="text-align:left">Survivor区0使用内存</td>
</tr>
<tr>
<td style="text-align:left">S1U</td>
<td style="text-align:left">Survivor区1使用内存</td>
</tr>
<tr>
<td style="text-align:left">EC</td>
<td style="text-align:left">当前Eden区内存容量</td>
</tr>
<tr>
<td style="text-align:left">EU</td>
<td style="text-align:left">Eden区使用内存</td>
</tr>
<tr>
<td style="text-align:left">OC</td>
<td style="text-align:left">当前老年代内存容量</td>
</tr>
<tr>
<td style="text-align:left">OU</td>
<td style="text-align:left">老年代使用内存</td>
</tr>
<tr>
<td style="text-align:left">PC</td>
<td style="text-align:left">当前永久代内存容量</td>
</tr>
<tr>
<td style="text-align:left">PU</td>
<td style="text-align:left">永久代使用内存</td>
</tr>
<tr>
<td style="text-align:left">YGC</td>
<td style="text-align:left">年轻代GC事件数量</td>
</tr>
<tr>
<td style="text-align:left">YGCT</td>
<td style="text-align:left">年轻代GC耗费时间</td>
</tr>
<tr>
<td style="text-align:left">FGC</td>
<td style="text-align:left">Full GC事件数量</td>
</tr>
<tr>
<td style="text-align:left">FGCT</td>
<td style="text-align:left">Full GC耗费时间</td>
</tr>
<tr>
<td style="text-align:left">GCT</td>
</tr>
</tbody>
</table>
<h3 id="jinfo-Java配置信息工具"><a href="#jinfo-Java配置信息工具" class="headerlink" title="jinfo: Java配置信息工具"></a>jinfo: Java配置信息工具</h3><p>jinfo功能：</p>
<p>​    实时地查看和调整虚拟机各项参数</p>
<p>jinfo 命令格式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinof  [option] pid</span><br></pre></td></tr></table></figure></div>
<p>option参数</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>查看未被指定的参数的系统默认值</td>
</tr>
<tr>
<td>-sysprops</td>
<td>将虚拟机进程的System.getProperties()的内容打印出来</td>
</tr>
<tr>
<td>-flag</td>
<td>查询参数值</td>
</tr>
<tr>
<td>-flag [+/-] name</td>
<td>查询参数值，修改一部分运行期可写的虚拟机参数</td>
</tr>
<tr>
<td>-flag name=value</td>
<td>同上</td>
</tr>
</tbody>
</table>
<p>示例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询CMSInitiatingOccupancyFraction的参数值</span></span><br><span class="line">jinfo -flag CMSInitiatingOccupancyFraction <span class="number">4578</span></span><br></pre></td></tr></table></figure></div>
<h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><p>jmap功能：</p>
<ul>
<li>用于生产堆转储快照（一般称为heapdump或dump文件）</li>
<li>查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。</li>
</ul>
<p>jmap命令格式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] vmid</span><br></pre></td></tr></table></figure></div>
<p>jmap选项表</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-dump</td>
<td>生成Java堆转储快照，格式为：-dump：[live,]format=b,file=,其中live子参数说明是否只dump出存活的对象</td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-heap</td>
<td>显示Java堆详细信息，如使用哪种回收器，参数配置，分代情况等。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-histo</td>
<td>显示堆中对象的统计信息，包括类、实例数量、合计容量</td>
</tr>
<tr>
<td>-permstat</td>
<td>以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linus/Solaris平台下有效</td>
</tr>
</tbody>
</table>
<h3 id="jhat-虚拟机堆转储快照分析工具"><a href="#jhat-虚拟机堆转储快照分析工具" class="headerlink" title="jhat: 虚拟机堆转储快照分析工具"></a>jhat: 虚拟机堆转储快照分析工具</h3><p><code>jhat</code>功能：</p>
<ul>
<li>与<code>jmap</code>搭配使用，来分析<code>jmap</code>生成的堆转储快照</li>
<li>内置了一个微型的HTTP/HTML服务器，生成<code>dump</code>文件的分析结果后，可以在浏览器中查看</li>
<li>不建议使用，有其他更好的替代，所以不想看下去了</li>
</ul>
<h3 id="jstack-Java堆栈跟踪工具"><a href="#jstack-Java堆栈跟踪工具" class="headerlink" title="jstack: Java堆栈跟踪工具"></a>jstack: Java堆栈跟踪工具</h3><p><code>jstack</code>功能：</p>
<ul>
<li>用于生成虚拟机当前时刻的<code>线程快照</code><a href="【线程快照】当前虚拟机内每一条线程正在执行的方法堆栈集合">^12</a>（一般称为<code>threaddump</code>或者<code>javacore</code>文件）</li>
<li>生成线程快照的主要目的是<strong>定位线程出现长时间停顿的原因</strong>，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因</li>
</ul>
<p><code>jstack</code>命令格式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] vmid</span><br></pre></td></tr></table></figure></div>
<p>jstack工具主要选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l</td>
<td>除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m</td>
<td>如果调用本地方法的话，可以显示C/C++堆栈</td>
</tr>
</tbody>
</table>
<p>在JDk1.5中，java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能。在实际项目中可以用这个方法做管理员页面，以便随时使用浏览器来查看线程堆栈</p>
<h2 id="Java-VisualVM"><a href="#Java-VisualVM" class="headerlink" title="Java VisualVM"></a>Java VisualVM</h2><h3 id="内存监控功能"><a href="#内存监控功能" class="headerlink" title="内存监控功能"></a>内存监控功能</h3><p>限定java堆的大小为100m,最大和最小设置为同一个值可以避免堆自动扩展</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  VM Args: -Xms100m -Xmx100m -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> *  代码作用</span></span><br><span class="line"><span class="comment"> *	以64KB/50毫秒的速度往Java堆中填充数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillHeap</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        fillHeap(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="Class类结构"><a href="#Class类结构" class="headerlink" title="Class类结构"></a>Class类结构</h1><p>一个<code>Class</code>文件对应着唯一的一个类或接口的定义信息，但要注意的是，类和接口的定义信息并不一定在文件里，因为它并不一定以磁盘文件的形式存在</p>
<p>Class文件是一组<strong>以8位字节为基础单位的二进制流</strong>，各个数据之间紧密相连。当数据高于8位时，会按照<code>高位在前</code><a href="【高位在前】被称为“Big-Endian”,具体是指最高位字节在地址最低位，最低为字节在地址最高位的顺序存储数据">^14</a>:的方式分割成若干个8位字节进行存储</p>
<p>Class文件结构中含有两种数据：</p>
<ul>
<li><p>无符号数：</p>
<p>属于基本类型，以u1、u2、u4、u8代表1、2、4、8个字节的无符号数，可以用来描述数字、索引引用、数量值或按照UTF-8编码构成字符串值</p>
</li>
<li><p>表：</p>
<p>表是由多个无符号数和其他表作为数据项构成的复合数据类型，习惯以<code>_info</code>结尾。<strong>整个Class文件，就是一张表</strong></p>
</li>
</ul>
<p>Class文件格式</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td style="text-align:center">magic</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">minor_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">major_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td style="text-align:center">constant_pool</td>
<td>constant_pool_count - 1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">interfaces_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">interfaces</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">fields_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td style="text-align:center">fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td style="text-align:center">methods</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:center">attribute_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td style="text-align:center">attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<h2 id="魔数与Class版本号"><a href="#魔数与Class版本号" class="headerlink" title="魔数与Class版本号"></a>魔数与Class版本号</h2><p>Class文件的头4个字节被称为魔数，它的唯一作用是标识这是一个可以被虚拟机接受的Class文件。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看到0~3 四个字节即为Class的魔数为：CAFEBABE，咖啡宝宝</span></span><br><span class="line"><span class="comment">//4~5字节表示次版本号</span></span><br><span class="line"><span class="comment">//6~7字节表示主版本好,0x34换成10进制就是52，JDK1.1支持45.0~45.65535的Class文件。JDK1.2的话，可以执行45.0~46.65535的Class文件。这里的52，说明使用的是JDK1.8	</span></span><br><span class="line"> Offset: <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> <span class="number">08</span> <span class="number">09</span> <span class="number">0</span>A <span class="number">0</span>B <span class="number">0</span>C <span class="number">0</span>D <span class="number">0</span>E <span class="number">0F</span> 	</span><br><span class="line"><span class="number">00000000</span>: CA FE BA BE <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">41</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>D <span class="number">00</span> <span class="number">2</span>B <span class="number">07</span>    J~:&gt;...<span class="number">4</span>.A....+.</span><br><span class="line"><span class="number">00000010</span>: <span class="number">00</span> <span class="number">2</span>C <span class="number">0</span>A <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">32</span>    .,....+........<span class="number">2</span></span><br><span class="line"><span class="number">00000020</span>: <span class="number">0</span>A <span class="number">00</span> <span class="number">2</span>D <span class="number">00</span> <span class="number">2</span>E <span class="number">07</span> <span class="number">00</span> <span class="number">2F</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">0</span>B <span class="number">00</span> <span class="number">30</span>    ..-..../....+..<span class="number">0</span></span><br><span class="line"><span class="number">00000030</span>: <span class="number">00</span> <span class="number">31</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">32</span> <span class="number">00</span> <span class="number">33</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>C <span class="number">00</span> <span class="number">34</span> <span class="number">07</span> <span class="number">00</span> <span class="number">35</span> <span class="number">07</span>    .<span class="number">1</span>..<span class="number">2.3</span>....<span class="number">4</span>..<span class="number">5</span>.</span><br><span class="line"><span class="number">00000040</span>: <span class="number">00</span> <span class="number">36</span> <span class="number">01</span> <span class="number">00</span> <span class="number">09</span> <span class="number">4F</span> <span class="number">4F</span> <span class="number">4</span>D <span class="number">4F</span> <span class="number">62</span> <span class="number">6</span>A <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">01</span> <span class="number">00</span>    .<span class="number">6</span>...OOMObject..</span><br><span class="line"><span class="number">00000050</span>: <span class="number">0</span>C <span class="number">49</span> <span class="number">6</span>E <span class="number">6</span>E <span class="number">65</span> <span class="number">72</span> <span class="number">43</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">65</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">06</span>    .InnerClasses...</span><br><span class="line"><span class="number">00000060</span>: <span class="number">3</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>E <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span>    &lt;init&gt;...()V...C</span><br><span class="line"><span class="number">00000070</span>: <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0F</span> <span class="number">4</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">65</span> <span class="number">4</span>E <span class="number">75</span> <span class="number">6</span>D <span class="number">62</span> <span class="number">65</span> <span class="number">72</span></span><br></pre></td></tr></table></figure></div>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>常量池</p>
<ul>
<li>可以理解为Class文件中的资源仓库</li>
<li>是Class文件结构中与其他项目关联最多的数据类型</li>
<li>占用Class文件空间最大的项目之一</li>
<li>Class文件中第一个出现的表类型数据项目</li>
</ul>
<p>在回顾Class文件</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8~9字节代表了常量池的的入口，是一个u2类型的数据，代表常量池容量计数值。Ox0041,换成10进制的话就是65，该数值说明常量池中有64项常量，索引范围从1~64。计数从1开始计数（除了常量池，其他计数都从0开始）</span></span><br><span class="line"><span class="comment">//剩下的第0项常量有特殊含义，表示不引用任何一个常量池项目</span></span><br><span class="line"> Offset: <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> <span class="number">08</span> <span class="number">09</span> <span class="number">0</span>A <span class="number">0</span>B <span class="number">0</span>C <span class="number">0</span>D <span class="number">0</span>E <span class="number">0F</span> 	</span><br><span class="line"><span class="number">00000000</span>: CA FE BA BE <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">41</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>D <span class="number">00</span> <span class="number">2</span>B <span class="number">07</span>    J~:&gt;...<span class="number">4</span>.A....+.</span><br><span class="line"><span class="number">00000010</span>: <span class="number">00</span> <span class="number">2</span>C <span class="number">0</span>A <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">32</span>    .,....+........<span class="number">2</span></span><br><span class="line"><span class="number">00000020</span>: <span class="number">0</span>A <span class="number">00</span> <span class="number">2</span>D <span class="number">00</span> <span class="number">2</span>E <span class="number">07</span> <span class="number">00</span> <span class="number">2F</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">0</span>B <span class="number">00</span> <span class="number">30</span>    ..-..../....+..<span class="number">0</span></span><br><span class="line"><span class="number">00000030</span>: <span class="number">00</span> <span class="number">31</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">32</span> <span class="number">00</span> <span class="number">33</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>C <span class="number">00</span> <span class="number">34</span> <span class="number">07</span> <span class="number">00</span> <span class="number">35</span> <span class="number">07</span>    .<span class="number">1</span>..<span class="number">2.3</span>....<span class="number">4</span>..<span class="number">5</span>.</span><br><span class="line"><span class="number">00000040</span>: <span class="number">00</span> <span class="number">36</span> <span class="number">01</span> <span class="number">00</span> <span class="number">09</span> <span class="number">4F</span> <span class="number">4F</span> <span class="number">4</span>D <span class="number">4F</span> <span class="number">62</span> <span class="number">6</span>A <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">01</span> <span class="number">00</span>    .<span class="number">6</span>...OOMObject..</span><br><span class="line"><span class="number">00000050</span>: <span class="number">0</span>C <span class="number">49</span> <span class="number">6</span>E <span class="number">6</span>E <span class="number">65</span> <span class="number">72</span> <span class="number">43</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">65</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">06</span>    .InnerClasses...</span><br><span class="line"><span class="number">00000060</span>: <span class="number">3</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>E <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span>    &lt;init&gt;...()V...C</span><br><span class="line"><span class="number">00000070</span>: <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0F</span> <span class="number">4</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">65</span> <span class="number">4</span>E <span class="number">75</span> <span class="number">6</span>D <span class="number">62</span> <span class="number">65</span> <span class="number">72</span></span><br></pre></td></tr></table></figure></div>
<p>常量池存放两大类常量：</p>
<ul>
<li><p>字面量(Literal):  如字符串，声明为final的常量等</p>
</li>
<li><p>符号引用(Symbolic References)：属于编译原理方面的概念，主要包含以下三类</p>
<p>a. 类和接口的全限定名（Fully Qualified Name）</p>
<p>b. 字段的名称和描述符（Descriptor）</p>
<p>c. 方法的名称和描述符</p>
</li>
</ul>
<p>每一个常量都是一张表，并且一共有14种不同结构的表，表开始的第一位是一个u1类型的标志位，代表当前常量属于那种常量类型。</p>
<h3 id="标志位值对应的具体含义"><a href="#标志位值对应的具体含义" class="headerlink" title="标志位值对应的具体含义"></a>标志位值对应的具体含义</h3><table>
<thead>
<tr>
<th>类型</th>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整形字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>５</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>６</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>７</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>８</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>９</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>１０</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>１１</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>１２</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MothodType_info</td>
<td>１６</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>１５</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>１８</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<h3 id="常量池中常量项结构总表"><a href="#常量池中常量项结构总表" class="headerlink" title="常量池中常量项结构总表"></a>常量池中常量项结构总表</h3><table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:left">选项</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CONSTANT_Utf8_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为1</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">length</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">UTF-8编码的字符串占用的字节数</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">长度为length的UTF-8编码的字符串</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Integer_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为3</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">按照高位在前存储的int值</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Float_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为4</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">按照高位在前存储的float值</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Long_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为5</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u8</td>
<td style="text-align:left">按照高位在前存储的long值</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Double_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为6</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u8</td>
<td style="text-align:left">按照高位在前存储的double值</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Class_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为7</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向全限定名常量项的索引</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_String_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为8</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向字符串字面量的索引</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Fieldref_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为9</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向声明字段的类或接口描述符CONSTANT_Class_info的索引项</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向字段描述符CONSTANT_NameAndType的索引项</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Methodref_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为10</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向声明方法的类描述符CONSTANT_Class_info的索引项</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向名称及类型描述符CONSTANT_NameAndType的索引项</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InterfaceMethodref_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为11</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向声明方法的接口描述符CONSTANT_Class_info的索引项</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向名称及类型描述符CONSTANT_NameAndType的索引项</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_NameAndType_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为12</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向该字段或方法名称常量项的索引</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">指向该字段或方法描述的索引</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodHandle_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为15</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">reference_kind</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">值必须在[1,9]之间，它决定了方法句柄的类型，方法句柄类型的值表示方法句柄的字节码行为</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">reference_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">值必须是对常量池的有效引用</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodType_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为16</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">descriptor_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">值必须是对常量池的有效引用,常量池在索引处的项必须是CONSTANT_Utf8_info结构,表示方法的描述符</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InvokeDynamic_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为18</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bootstrap_method_attr_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">值必须是当前Class文件中引导方法表的bootstrap methods[]数组的有效索引</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">name_and_type_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">值必须是对当前常量池的有效索引,常量池在该处的索引必须是CONSTANT_NameAndType_info结构,表示方法名和方法描述符</td>
</tr>
</tbody>
</table>
<h3 id="Javap-：Class-字节码分析工具"><a href="#Javap-：Class-字节码分析工具" class="headerlink" title="Javap ：Class 字节码分析工具"></a>Javap ：Class 字节码分析工具</h3><p>使用方式<br><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose MyClass.class</span><br></pre></td></tr></table></figure></div></p>
<p>示例</p>
<p>通过Javap分析某文件后，输出如下结果<br><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">D:\idea project\demo\out\production\demo&gt;javap -verbose HeapOOM.class</span><br><span class="line">Classfile /D:/idea project/demo/out/production/demo/HeapOOM.class</span><br><span class="line">  Last modified 2019-4-16; size 1055 bytes</span><br><span class="line">  MD5 checksum 9bb713cc4933abd1b5aa25c296c1c4c7</span><br><span class="line">  Compiled from &quot;HeapOOM.java&quot;</span><br><span class="line">public class HeapOOM</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #13.#43        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #44            // java/util/ArrayList</span><br><span class="line">   #3 = Methodref          #2.#43         // java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Long               50l</span><br><span class="line">   #6 = Methodref          #45.#46        // java/lang/Thread.sleep:(J)V</span><br><span class="line">   #7 = Class              #47            // HeapOOM$OOMObject</span><br><span class="line">   #8 = Methodref          #7.#43         // HeapOOM$OOMObject.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #9 = InterfaceMethodref #48.#49        // java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">  #10 = Methodref          #50.#51        // java/lang/System.gc:()V</span><br><span class="line">  #11 = Methodref          #12.#52        // HeapOOM.fillHeap:(I)V</span><br><span class="line">  #12 = Class              #53            // HeapOOM</span><br><span class="line">  #13 = Class              #54            // java/lang/Object</span><br><span class="line">  #14 = Utf8               OOMObject</span><br><span class="line">  #15 = Utf8               InnerClasses</span><br><span class="line">  #16 = Utf8               &lt;init&gt;</span><br><span class="line">  #17 = Utf8               ()V</span><br><span class="line">  #18 = Utf8               Code</span><br><span class="line">  #19 = Utf8               LineNumberTable</span><br><span class="line">  #20 = Utf8               LocalVariableTable</span><br><span class="line">  #21 = Utf8               this</span><br><span class="line">  #22 = Utf8               LHeapOOM;</span><br><span class="line">  #23 = Utf8               fillHeap</span><br><span class="line">  #24 = Utf8               (I)V</span><br><span class="line">  #25 = Utf8               i</span><br><span class="line">  #26 = Utf8               I</span><br><span class="line">  #27 = Utf8               num</span><br><span class="line">  #28 = Utf8               list</span><br><span class="line">  #29 = Utf8               Ljava/util/List;</span><br><span class="line">  #30 = Utf8               LocalVariableTypeTable</span><br><span class="line">  #31 = Utf8               Ljava/util/List&lt;LHeapOOM$OOMObject;&gt;;</span><br><span class="line">  #32 = Utf8               StackMapTable</span><br><span class="line">  #33 = Class              #55            // java/util/List</span><br><span class="line">  #34 = Utf8               Exceptions</span><br><span class="line">  #35 = Class              #56            // java/lang/InterruptedException</span><br><span class="line">  #36 = Utf8               main</span><br><span class="line">  #37 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #38 = Utf8               args</span><br><span class="line">  #39 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #40 = Class              #57            // java/lang/Exception</span><br><span class="line">  #41 = Utf8               SourceFile</span><br><span class="line">  #42 = Utf8               HeapOOM.java</span><br><span class="line">  #43 = NameAndType        #16:#17        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #44 = Utf8               java/util/ArrayList</span><br><span class="line">  #45 = Class              #58            // java/lang/Thread</span><br><span class="line">  #46 = NameAndType        #59:#60        // sleep:(J)V</span><br><span class="line">  #47 = Utf8               HeapOOM$OOMObject</span><br><span class="line">  #48 = Class              #55            // java/util/List</span><br><span class="line">  #49 = NameAndType        #61:#62        // add:(Ljava/lang/Object;)Z</span><br><span class="line">  #50 = Class              #63            // java/lang/System</span><br><span class="line">  #51 = NameAndType        #64:#17        // gc:()V</span><br><span class="line">  #52 = NameAndType        #23:#24        // fillHeap:(I)V</span><br><span class="line">  #53 = Utf8               HeapOOM</span><br><span class="line">  #54 = Utf8               java/lang/Object</span><br><span class="line">  #55 = Utf8               java/util/List</span><br><span class="line">  #56 = Utf8               java/lang/InterruptedException</span><br><span class="line">  #57 = Utf8               java/lang/Exception</span><br><span class="line">  #58 = Utf8               java/lang/Thread</span><br><span class="line">  #59 = Utf8               sleep</span><br><span class="line">  #60 = Utf8               (J)V</span><br><span class="line">  #61 = Utf8               add</span><br><span class="line">  #62 = Utf8               (Ljava/lang/Object;)Z</span><br><span class="line">  #63 = Utf8               java/lang/System</span><br><span class="line">  #64 = Utf8               gc</span><br></pre></td></tr></table></figure></div></p>
<p>该文件的二进制显示<br><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> Offset: <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> <span class="number">08</span> <span class="number">09</span> <span class="number">0</span>A <span class="number">0</span>B <span class="number">0</span>C <span class="number">0</span>D <span class="number">0</span>E <span class="number">0F</span> 	</span><br><span class="line"><span class="number">00000000</span>: CA FE BA BE <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">41</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>D <span class="number">00</span> <span class="number">2</span>B <span class="number">07</span>    J~:&gt;...<span class="number">4</span>.A....+.</span><br><span class="line"><span class="number">00000010</span>: <span class="number">00</span> <span class="number">2</span>C <span class="number">0</span>A <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">32</span>    .,....+........<span class="number">2</span></span><br><span class="line"><span class="number">00000020</span>: <span class="number">0</span>A <span class="number">00</span> <span class="number">2</span>D <span class="number">00</span> <span class="number">2</span>E <span class="number">07</span> <span class="number">00</span> <span class="number">2F</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">2</span>B <span class="number">0</span>B <span class="number">00</span> <span class="number">30</span>    ..-..../....+..<span class="number">0</span></span><br><span class="line"><span class="number">00000030</span>: <span class="number">00</span> <span class="number">31</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">32</span> <span class="number">00</span> <span class="number">33</span> <span class="number">0</span>A <span class="number">00</span> <span class="number">0</span>C <span class="number">00</span> <span class="number">34</span> <span class="number">07</span> <span class="number">00</span> <span class="number">35</span> <span class="number">07</span>    .<span class="number">1</span>..<span class="number">2.3</span>....<span class="number">4</span>..<span class="number">5</span>.</span><br><span class="line"><span class="number">00000040</span>: <span class="number">00</span> <span class="number">36</span> <span class="number">01</span> <span class="number">00</span> <span class="number">09</span> <span class="number">4F</span> <span class="number">4F</span> <span class="number">4</span>D <span class="number">4F</span> <span class="number">62</span> <span class="number">6</span>A <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">01</span> <span class="number">00</span>    .<span class="number">6</span>...OOMObject..</span><br><span class="line"><span class="number">00000050</span>: <span class="number">0</span>C <span class="number">49</span> <span class="number">6</span>E <span class="number">6</span>E <span class="number">65</span> <span class="number">72</span> <span class="number">43</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">65</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">06</span>    .InnerClasses...</span><br><span class="line"><span class="number">00000060</span>: <span class="number">3</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>E <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span>    &lt;init&gt;...()V...C</span><br><span class="line"><span class="number">00000070</span>: <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0F</span> <span class="number">4</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">65</span> <span class="number">4</span>E <span class="number">75</span> <span class="number">6</span>D <span class="number">62</span> <span class="number">65</span> <span class="number">72</span></span><br></pre></td></tr></table></figure></div></p>
<p>分析：</p>
<ol>
<li>可以看到，常量池的偏移量为(0x0000 0008),其对应的16进制值为<code>0x0041</code>,即10进制的65，与Javap显示结果相同，有64常量；</li>
<li>接下来是第一个常量，偏移量0X0000 000A是其标志位，对应值为<code>0x000A</code>,即进制的10，查阅标志位值对应的具体含义可知，标志10代表的是<code>CONSTANT_Methodref_info</code>,也就是类中方法的符号引用。查阅<code>常量项结构总表</code>,其结构如下</li>
</ol>
<table>
<thead>
<tr>
<th>CONSTANT_Methodref_info</th>
<th>tag</th>
<th>u1</th>
<th>值为10</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向声明方法的类描述符CONSTANT_Class_info的索引项</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向名称及类型描述符CONSTANT_NameAndType的索引项</td>
</tr>
</tbody>
</table>
<p>​    也就是接下来的4个字节，含义为</p>
<p>​    a. 偏移量0x0000 000B: 值0x000D(12),也就是指向了常量池的第十二项常量</p>
<p>​    b. 偏移量0x0000 0000D: 值0x002B(33),也就是指向了常量池的第四十三项常量</p>
<p>​    再来看javap的显示结果的第一个常数,确实是Methodref类型，指向了13,43号常量</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1 = Methodref          #13.#43        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></div>
<p>注意：<code>CONSTANT_Utf8_info</code>类型常量</p>
<ul>
<li>该类型的常量是用来记录<code>UTF-8编码的字符串</code>，它用<code>length</code>选项来表示字符串的大小，因为length的类型为u2，所以其长度最大为65535</li>
<li>该类型的常量会被用来描述Class文件中方法名、字段名，也就是说，这也限制了它们的大小为65535,即Java不能定义超过64K大小的方法名或变量名</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:left">选项</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CONSTANT_Utf8_info</td>
<td style="text-align:left">tag</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">值为1</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">length</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">UTF-8编码的字符串占用的字节数</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bytes</td>
<td style="text-align:left">u1</td>
<td style="text-align:left">长度为length的UTF-8编码的字符串</td>
</tr>
</tbody>
</table>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>常量池结束后，紧接着的<strong>两个字节</strong>代表<code>访问标志（access_flags）</code>,这个标志用于识别一些类或者接口层次的访问信息，包括</p>
<ul>
<li>Class是接口还是类</li>
<li>如果是类，是否被声明为final</li>
<li>是否为public</li>
<li>是否为abstract</li>
<li>……</li>
</ul>
<h3 id="访问标志含义表"><a href="#访问标志含义表" class="headerlink" title="访问标志含义表"></a>访问标志含义表</h3><p>access_flags一共有16个标志位(2字节)可以使用，当前值定义了8个，每个标志位上的值都有特殊含义，没有则都为0</p>
<table>
<thead>
<tr>
<th style="text-align:left">标志名称</th>
<th style="text-align:left">标志值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td style="text-align:left">0x0001</td>
<td style="text-align:left">是否为public类型</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td style="text-align:left">0x0010</td>
<td style="text-align:left">是否被声明为final，只有类可设置</td>
</tr>
<tr>
<td style="text-align:left">ACC_SUPER</td>
<td style="text-align:left">0x0020</td>
<td style="text-align:left">是否允许使用invokespecial字节码指令的新语义，invokespecial指令的语意在JDK 1.0.2发生过改变，为了区别这条指令使用哪种语义，JDK 1.0.2之后编译出来的类的这个标志都必须为真</td>
</tr>
<tr>
<td style="text-align:left">ACC_INTERFACE</td>
<td style="text-align:left">0x0200</td>
<td style="text-align:left">标识这是一个接口</td>
</tr>
<tr>
<td style="text-align:left">ACC_ABSTRACT</td>
<td style="text-align:left">0x0400</td>
<td style="text-align:left">是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类值为假</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td style="text-align:left">0x1000</td>
<td style="text-align:left">标识这个类并非由用户代码产生的</td>
</tr>
<tr>
<td style="text-align:left">ACC_ANNOTATION</td>
<td style="text-align:left">0x2000</td>
<td style="text-align:left">标识这是一个注解</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td style="text-align:left">0x4000</td>
<td style="text-align:left">标识这是一个枚举</td>
</tr>
</tbody>
</table>
<p>示例:假设一个类是普通java类，并不接口、枚举、注解,由用户代码产生，被public修饰，没有被声明为final，abstarct,由JDK1.8编译，那么根据表中定义，它的访问标志就是</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个0:不是枚举、注解,由用户代码产生</span></span><br><span class="line"><span class="comment">//第二个0：不是接口、abstract类型</span></span><br><span class="line"><span class="comment">//2：由JDK1.8编译</span></span><br><span class="line"><span class="comment">//1：为public类型</span></span><br><span class="line"><span class="number">0x0021</span></span><br></pre></td></tr></table></figure></div>
<h2 id="索引、父类索引和与接口索引集合"><a href="#索引、父类索引和与接口索引集合" class="headerlink" title="索引、父类索引和与接口索引集合"></a>索引、父类索引和与接口索引集合</h2><p>Class由<code>类索引、父类索引、接口索引</code>这三项数据来确定这个类的继承关系，三个索引排序在访问标志之后</p>
<p>类索引：</p>
<ul>
<li>使用两个u2类型数据的索引值表示，指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，跟据该常量找到对应的<code>CONSTANT_Utf8_info</code>类型常量中的全限定字符串    </li>
<li>用于确定该类的全限定名</li>
</ul>
<p>父类索引：</p>
<ul>
<li>使用两个u2类型数据的索引值表示，指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，跟据该常量找到对应的<code>CONSTANT_Utf8_info</code>类型常量中的全限定字符串    </li>
<li>用于确定类的父类的全限定名，父类索引只有一个</li>
<li>所有类的父类索引都不为0，当然，除了java.lang.object</li>
</ul>
<p>接口索引</p>
<ul>
<li>u2类型数据的集合</li>
<li>被实现的接口将会按照<code>implements</code>的顺序从左到右排列在索引集合中</li>
<li>入口的u2类型数据为计数器(interfaces_counts)，表示索引表的容量，该类没有索引，则计数器值为0,后面接口索引不占用字节</li>
</ul>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>字段表(field_info)</p>
<ul>
<li>用于描述接口或者类中声明的变量</li>
<li><p>包括类级变量和实例级变量，不包括在方法内部声明的局部变量</p>
</li>
<li><p>字段表不会列出从父类接口中继承的字段，但有可能列出代码之中不存在的字段</p>
</li>
</ul>
<p>字段可包含信息</p>
<ul>
<li>字段的作用域(public、private、protected)</li>
<li>是实例变量还是类变量（static）</li>
<li>可变性（final）</li>
<li>并发可见性（volatile修饰符，是否强制从内存读写）</li>
<li>可否被序列化(transient)</li>
<li>字段数据类型（基本类型、对象、数组）</li>
<li><p>字段名称</p>
</li>
<li><p>以上信息，对于修饰符，很容易用标志位来表示；而对于数据类型，字段名称，就需要引用常量池中的常量了</p>
</li>
</ul>
<h3 id="字段表结构"><a href="#字段表结构" class="headerlink" title="字段表结构"></a>字段表结构</h3><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">数量</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">access_flags</td>
<td style="text-align:center">1</td>
<td style="text-align:center">字段和方法的访问修饰符</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">name_index</td>
<td style="text-align:center">1</td>
<td style="text-align:center">常量池索引，代表字段的简单名称</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">descriptor_index</td>
<td style="text-align:center">1</td>
<td style="text-align:center">常量池索引，代表字段和方法的描述符</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">attributes_count</td>
<td style="text-align:center">1</td>
<td style="text-align:center">字段和方法的额外附加属性数量</td>
</tr>
<tr>
<td style="text-align:center">attribute_info</td>
<td style="text-align:center">attributes</td>
<td style="text-align:center">attributes_count</td>
<td style="text-align:center">字段和方法的额外的附加属性</td>
</tr>
</tbody>
</table>
<p>简单名称：没有类型和参数修饰的方法或字段名称，如<code>text()</code>的简单名称就是<code>text</code></p>
<p>字段和方法的描述符：用来描述字段的数据类型、方法和参数列表（包括数量、类型以及顺序）和返回值</p>
<h3 id="access-flags字段访问标志"><a href="#access-flags字段访问标志" class="headerlink" title="access_flags字段访问标志"></a>access_flags字段访问标志</h3><table>
<thead>
<tr>
<th style="text-align:center">标志名称</th>
<th style="text-align:center">标志值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACC_PUBLIC</td>
<td style="text-align:center">0x0001</td>
<td style="text-align:center">字段是否为public</td>
</tr>
<tr>
<td style="text-align:center">ACC_PRIVATE</td>
<td style="text-align:center">0x0002</td>
<td style="text-align:center">字段是否为private</td>
</tr>
<tr>
<td style="text-align:center">ACC_PROTECTED</td>
<td style="text-align:center">0x0004</td>
<td style="text-align:center">字段是否为protected</td>
</tr>
<tr>
<td style="text-align:center">ACC_STATIC</td>
<td style="text-align:center">0x0008</td>
<td style="text-align:center">字段是否为static</td>
</tr>
<tr>
<td style="text-align:center">ACC_FINAL</td>
<td style="text-align:center">0x0010</td>
<td style="text-align:center">字段是否为final</td>
</tr>
<tr>
<td style="text-align:center">ACC_VOLATILE</td>
<td style="text-align:center">0x0040</td>
<td style="text-align:center">字段是否为volatile</td>
</tr>
<tr>
<td style="text-align:center">ACC_TRANSIENT</td>
<td style="text-align:center">0x0080</td>
<td style="text-align:center">字段是否为transient</td>
</tr>
<tr>
<td style="text-align:center">ACC_SYNTHETIC</td>
<td style="text-align:center">0x1000</td>
<td style="text-align:center">字段是否由编译器自动产生</td>
</tr>
<tr>
<td style="text-align:center">ACC_ENUM</td>
<td style="text-align:center">0x4000</td>
<td style="text-align:center">字段是否是enum类型</td>
</tr>
</tbody>
</table>
<p>使用方法可以查看<code>访问标志/访问标志含义表</code></p>
<h3 id="描述符字符含义"><a href="#描述符字符含义" class="headerlink" title="描述符字符含义"></a>描述符字符含义</h3><p>描述基本数据类型、void、对象</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>基本数据类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>基本数据类型void</td>
</tr>
<tr>
<td>L</td>
<td>对象类型,如Ljava/lang/Object</td>
</tr>
</tbody>
</table>
<p>描述数组：</p>
<p>​    使用<code>[</code> + 描述字符来表示数组，如<code>int[]</code>将会被描述为 “[I” </p>
<p>描述方法：</p>
<ul>
<li>按照先参数列表，后返回值的顺序描述,表示形式为<code>(参数列表)+返回值</code></li>
<li>如<code>void inc()</code>,描述为<code>()V</code>;</li>
<li>如<code>java.lang.String toStirng()</code>描述为<code>()Ljava/lang/String</code>;</li>
<li>如int togo(int i, char[] source);描述为<code>(I[C)I</code></li>
</ul>
<h2 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h2><p>方法表中的代码，存放于方法属性表集合中的<code>Code</code>属性中</p>
<h3 id="方法表结构"><a href="#方法表结构" class="headerlink" title="方法表结构"></a>方法表结构</h3><p>与字段表十分相似</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<h3 id="方法访问标志"><a href="#方法访问标志" class="headerlink" title="方法访问标志"></a>方法访问标志</h3><table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x00 01</td>
<td>方法是否为public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x00 02</td>
<td>方法是否为private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x00 04</td>
<td>方法是否为protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x00 08</td>
<td>方法是否为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x00 10</td>
<td>方法是否为final</td>
</tr>
<tr>
<td>ACC_SYHCHRONRIZED</td>
<td>0x00 20</td>
<td>方法是否为synchronized</td>
</tr>
<tr>
<td>ACC_BRIDGE</td>
<td>0x00 40</td>
<td>方法是否是有编译器产生的方法</td>
</tr>
<tr>
<td>ACC_VARARGS</td>
<td>0x00 80</td>
<td>方法是否接受参数</td>
</tr>
<tr>
<td>ACC_NATIVE</td>
<td>0x01 00</td>
<td>方法是否为native</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x04 00</td>
<td>方法是否为abstract</td>
</tr>
<tr>
<td>ACC_STRICTFP</td>
<td>0x08 00</td>
<td>方法是否为strictfp</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x10 00</td>
<td>方法是否是有编译器自动产生的</td>
</tr>
</tbody>
</table>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>实现重载方法，需要满足</p>
<ul>
<li>与原方法具有相同的简单名称</li>
<li>与原方法不同的特征签名</li>
</ul>
<p>特征签名：一个方法中各个参数在常量中的字段符号引用集合，也就是说返回值不包含在特征签名中，所以Java不能仅仅依靠返回值不同来重载方法。<strong>注意：在Class文件格式中特征签名范围更大，只要描述符不完全一致就可以，也就是返回值不同的两个方法也是可以共存的</strong></p>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>属性表</p>
<ul>
<li>在Class文件、字段表、方法表中，均有携带自己的属性表集合，以用于描述某些场景的专有信息</li>
<li><p>属性表对数据项目的顺序没有严格限制，只需要属性名不重复即可</p>
</li>
<li><p>每个属性的名称都是从常量值中引用一个<code>CONSTANT_Utf8_info</code>常量来表示</p>
</li>
<li>属性的结构完全自定义，只需要一个u4长度的属性去说明属性值所占用的位数</li>
</ul>
<h3 id="最简单的属性表结构"><a href="#最简单的属性表结构" class="headerlink" title="最简单的属性表结构"></a>最简单的属性表结构</h3><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
</tr>
</tbody>
</table>
<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Code</td>
<td>方法表</td>
<td>Java代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final关键字定义的常量池</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类，方法，字段表</td>
<td>被声明为deprecated的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EnclosingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td>InnerClass</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code属性</td>
<td>Java源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code属性</td>
<td>方法的局部便狼描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code属性</td>
<td>JDK1.6中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td>
</tr>
<tr>
<td>Signature</td>
<td>类，方法表，字段表</td>
<td>用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td>SourceFile</td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td>SourceDebugExtension</td>
<td>类文件</td>
<td>用于存储额外的调试信息</td>
</tr>
<tr>
<td>Synthetic</td>
<td>类，方法表，字段表</td>
<td>标志方法或字段为编译器自动生成的</td>
</tr>
<tr>
<td>LocalVariableTypeTable</td>
<td>类</td>
<td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>为动态注解提供支持</td>
</tr>
<tr>
<td>RuntimeInvisibleAnnotations</td>
<td>表，方法表，字段表</td>
<td>用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法</td>
</tr>
<tr>
<td>RuntimeInvisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与RuntimeInvisibleAnnotations属性类似，作用对象哪个为方法参数</td>
</tr>
<tr>
<td>AnnotationDefault</td>
<td>方法表</td>
<td>用于记录注解类元素的默认值</td>
</tr>
<tr>
<td>BootstrapMethods</td>
<td>类文件</td>
<td>用于保存invokeddynamic指令引用的引导方式限定符</td>
</tr>
</tbody>
</table>
<h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>java程序方法体中的代码经过编译器处理后，最终会变为字节码存储在Code属性中。接口或者抽象类中的方法，就可能不存在Code属性。如果将Java程序中的信息分为<code>代码</code><a href="【Code】方法体里的Java代码">^15</a>和<code>元数据</code><a href="【Metadata】包括类、字段、方法定义以及其他信息">^16</a>两部分，那么整个Class文件，Code属性用于描述代码，其他数据项目描述原数据</p>
<h4 id="Code属性结构"><a href="#Code属性结构" class="headerlink" title="Code属性结构"></a>Code属性结构</h4><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>指向CONSTANT_Utf8_info型常量的索引，默认值Code，表示属性名称</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性值长度</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>1</td>
<td>操作数栈深度的最大值，虚拟机根据这个值分配栈帧(Stack Frame)中的操作栈深度</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>1</td>
<td>局部变量表所需的存储空间，单位Slot,除了基本类型，还存放了方法参数（包括this）、显示异常处理参数（catch块定义的异常、方法体中定义的局部变量；Slot可重用，编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>1</td>
<td>编译器编译后生成的字节码指令长度（虽然u4级别长度，但虚拟机限制了一个方法不允许超过65535长度，所以实际只能使用u2的长度）</td>
</tr>
<tr>
<td>u1</td>
<td>code</td>
<td>code_length</td>
<td>c存储字节码指令的一系列字节流，每个 指令为u1类型</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td>exception_length</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<h4 id="JVM是如何使用Code属性？"><a href="#JVM是如何使用Code属性？" class="headerlink" title="JVM是如何使用Code属性？"></a>JVM是如何使用Code属性？</h4><h3 id="Exceptions-属性"><a href="#Exceptions-属性" class="headerlink" title="Exceptions 属性"></a>Exceptions 属性</h3><p>Exceptions 属性:</p>
<p>​    列举出方法中可能抛出的受查异常(Checked Exceptions),即方法描述时在throws关键字后面列举的异常</p>
<p>Exceptions 属性表结构</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">number_of_exceptions</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>抛出受查异常数量</td>
</tr>
<tr>
<td style="text-align:left">exception_index_table</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">number_of_exceptions</td>
<td>指向常量池中的CONSTANT_Class_info型常量的索引，代表该受查异常的类型</td>
</tr>
</tbody>
</table>
<h3 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h3><p>LineNumberTable属性：</p>
<ul>
<li><p>用来描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系</p>
</li>
<li><p>非运行时必需属性,但默认生成到Class文件中，可以通过<code>javac -g:none</code>或<code>javac -g:lines</code>手动取消或生成这项信息</p>
</li>
<li>主要影响为抛出异常时，显示出错的行号；在调式程序时按照源码行来设置断点</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">line_number_table_length</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">line_number_table</td>
<td style="text-align:left">line_number_info</td>
<td style="text-align:left">line_number_table_length</td>
<td>是一个line_number_table_length长度，类型为line_number_info的集合，line_number_info表包含了start_pc(字节码行号)和line_number（Java源码行号）两个u2类型数据项</td>
</tr>
</tbody>
</table>
<h3 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h3><p>LocalVariableTable属性: </p>
<ul>
<li>用于描述栈帧中局部变量表中的变量与java源码中定义的变量之间的关系</li>
<li>非运行时必需属性,但默认生成到Class文件中，可以通过<code>javac -g:none</code>或<code>javac -g:vars</code>手动取消或生成这项信息</li>
<li>主要影响为党其他人引用这个方法时，所有的参数名称丢失，导致IDE将会使用诸如arg0、arg1之类的占位符替代原有参数名，并不影响运行，但会影响代码的编写并且在调式期间无法根据参数名称从上下文中获取参数</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">local_variable_table_length</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">local_variable_table</td>
<td style="text-align:left">local_variable_info</td>
<td style="text-align:left">local_variable_table_lengt</td>
</tr>
</tbody>
</table>
<p>local_variable_info：代表了一个栈帧与源码中的局部变量的关联，其数据结构如下</p>
<ul>
<li>start_pc和length组成了局部变量在字节码之中的作用域范围</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">start_pc</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>局部变量的生命周期开始的字节码偏移</td>
</tr>
<tr>
<td style="text-align:left">length</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>局部变量作用该范围覆盖的长度</td>
</tr>
<tr>
<td style="text-align:left">name_indec</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Utf8_info，代表局部变量的名称</td>
</tr>
<tr>
<td style="text-align:left">descriptor_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Utf8_info，代表局部变量的描述符</td>
</tr>
<tr>
<td style="text-align:left">index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>局部变量在栈帧局部变量表中Slot的位置</td>
</tr>
</tbody>
</table>
<h3 id="LocalVariableTypeTable属性"><a href="#LocalVariableTypeTable属性" class="headerlink" title="LocalVariableTypeTable属性"></a>LocalVariableTypeTable属性</h3><p>在JDK1.5后引入，与<code>LocalVariableTable</code>相似，区别在于将记录描述符的<code>descriptor_index</code>替换成了字段的特征签名，目的时为了描述泛型类型 （原因时描述符中的泛型参数化类型被擦除掉后，描述符无法准确描述泛型类型）</p>
<h3 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h3><p>SourceFile属性</p>
<ul>
<li>用于记录生成这个Class文件的源码文件名，该属性长度固定</li>
<li>非运行时必需属性,但默认生成到Class文件中，可以通过<code>javac -g:none</code>或<code>javac -g:s97rce</code>手动取消或生成这项信息</li>
<li>影响在于对于内部类，其类名和类文件是不一致的，如果不生产这项属性，当抛出异常时，堆栈中将不会显示出错误代码所属的文件名</li>
</ul>
<p>SourceFile属性结构表</p>
<table>
<thead>
<tr>
<th style="text-align:left">SourceFile属性名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">sourcefile_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Utf8_info,常量值为源码文件的文件名</td>
</tr>
</tbody>
</table>
<h3 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h3><p>ConstantValue属性</p>
<ul>
<li>通知虚拟机自动为静态变量赋值，只有被static关键字修饰的变量才可以使用这项属性</li>
</ul>
<p>虚拟机在对非类变量和变量的赋值方式和时刻不同</p>
<ul>
<li><p>非static类型的变量：赋值实在实例构造器&lt; init &gt;方法中进行</p>
</li>
<li><p>对于类变量，有两种方式可以选择</p>
<p>a. 在类构造器&lt; clinit &gt;方法中赋值</p>
<p>b. 使用ConstanValue属性赋值</p>
</li>
<li><p>Sun Javac编译器选择方式为：</p>
<p>a. 如果同时使用final和static修饰变量，并且该变量是基础类型或者String类型，则通过ConstanValue属性进行初始化。</p>
<p>b. 如果这个变量没有被final修饰，或不是基础类型和String类型,则选择&lt; clinit &gt;方法初始化</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">constantvalue_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<h3 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h3><p>InnerClasses属性</p>
<ul>
<li>用于记录内部类和宿主类之间的关联</li>
<li>如果类中定义了内部类，编译器就会为它以及内部类生成InnerClasses属性</li>
</ul>
<p>InnerClasses属性结构表</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">u4</td>
<td style="text-align:left">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">number_of_class</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>内部类信息个数</td>
</tr>
<tr>
<td style="text-align:left">inner_classes</td>
<td style="text-align:left">inner_classes_info</td>
<td style="text-align:left">number_of_class</td>
<td>包含number_of_class个inner_classes_info（描述内部类信息）</td>
</tr>
</tbody>
</table>
<p>inner_classes_info表结构    </p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">inner_class_info_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Class_info，内部类符号引用</td>
</tr>
<tr>
<td style="text-align:left">outer_class_info_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Class_info，外部类符号引用</td>
</tr>
<tr>
<td style="text-align:left">inner_name_index</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>指向CONSTANT_Utf8_info,内部类名称，如果是匿名内部类则为0</td>
</tr>
<tr>
<td style="text-align:left">inner_class_access_flags</td>
<td style="text-align:left">u2</td>
<td style="text-align:left">1</td>
<td>内部类访问标志</td>
</tr>
</tbody>
</table>
<p>inner_class_access_flags访问标志含义</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>内部类是否为public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>内部类是否为private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>内部类是否为protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>内部类是否为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>内部类是否为final</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0020</td>
<td>内部类是否为一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>内部类是否为abstract</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>内部类是否为编译器自动产生</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x4000</td>
<td>内部类是否是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>内部类是否是一个枚举</td>
</tr>
</tbody>
</table>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h3><p><del>Deprecated属性：用于表示某个类、字段或者方法，不推荐使用</del></p>
<h3 id="Synthetic属性"><a href="#Synthetic属性" class="headerlink" title="Synthetic属性"></a>Synthetic属性</h3><p>Synthetic属性：</p>
<ul>
<li><p>属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念</p>
</li>
<li><p>标识一个类、字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加</p>
</li>
<li><p>所有由非用户代码生成的类、方法、字段都应当至少设置Synthetic属性或者ACC_SYNTHETIC标志位，但是，是实例构造器&lt; init &gt; 和类构造器 &lt; clinit &gt;无需设置，最典型的例子： <strong>Bridge Mthod</strong></p>
</li>
</ul>
<p>Sunthetic属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>值必须为0x0000 0000,因为没有任何属性值需要设置</td>
</tr>
</tbody>
</table>
<h3 id="StackMap-Table-属性"><a href="#StackMap-Table-属性" class="headerlink" title="StackMap Table 属性"></a>StackMap Table 属性</h3><p>StackMap Table 属性</p>
<ul>
<li>会在虚拟机加载的字节码验证阶段被<code>新类型检查验证器(Type Checker)</code>使用，目的在于代替以前比较消耗性能的基于数据流分析的<code>类型推导验证器</code></li>
<li>该属性包含多个<code>栈映射帧（Stack Map Frames）</code>,每个栈映射帧都显示或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的严重类型；类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一定字节码指令是否符合逻辑约束</li>
<li>版本号大于等于50的class文件，如果没有该属性，说明它带有隐式的StackMapTable属性，作用等同于<code>number_of_entries</code>值为0的StackMapTable属性</li>
<li>一个Code属性最多只能由一个StackMapTable属性</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>number_of_entries</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>stack_map_frame entries</td>
<td>stack_map_frame</td>
<td>number_of_entries</td>
</tr>
</tbody>
</table>
<h3 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h3><p>Signature属性</p>
<ul>
<li>非运行时必须，长度固定，出现于类、属性表和方法表结构的属性表中</li>
<li>用于任何类、接口、初始化方法或者成员的泛型签名，如果它们包含了类型变量或参数化类型，则Signature属性会为它记录泛型签名信息</li>
<li>使用该属性主要原因是java语言的泛型擦除实现的伪泛型</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>signature_index</td>
<td>u2</td>
<td>1</td>
<td>值必须是一个对常量池的有效索引。常量池在该索引的项必须是CONSTANT_Utf8_info接口，表示类签名、方法签名、字段类型签名（取决于当前的Signature是谁的属性，如类的属性，则就是类签名）</td>
</tr>
</tbody>
</table>
<h3 id="BootStrapMethods属性"><a href="#BootStrapMethods属性" class="headerlink" title="BootStrapMethods属性"></a>BootStrapMethods属性</h3><p>BootStrapMethods属性</p>
<ul>
<li>可变长度属性，位于类文件的属性表中</li>
<li>用于保存<code>invokedynamic</code>指令引用的引导方法限定符</li>
<li>如果某个类文件结构的常量池中曾经出现过<code>CONSTANT_InvokeDynamic_info</code>类型常量，则必须存在一个明确的BootStrapMethods<code>属性</code></li>
<li>类文件属性表中最多只能有一个<code>BootStrapMethods</code>属性</li>
</ul>
<p>BootStrapMethods属性结构</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类 型</th>
<th>数 量</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>num_bootstrap_methods</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>bootstrap_methods</td>
<td>bootstrap_method</td>
<td>num_bootstrap_methods</td>
</tr>
</tbody>
</table>
<p>bootstrap_method属性结构</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类 型</th>
<th>数 量</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bootstrap_method_ref</td>
<td>u2</td>
<td>1</td>
<td>值必须是一个对常量池有效的索引，常量池在该索引处的值必须是一个CONSTANT_MethodHandle结构</td>
</tr>
<tr>
<td>num_bootstrap_arguments</td>
<td>u2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>bootstrap_arguments</td>
<td>u2</td>
<td>num_bootstrap_arguments</td>
<td>数组的每个成员必须是一个对常量池的有效索引，且该索引处的结构必须是CONSTANT_String_info、CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info、CONSTANT_MethodType_info</td>
</tr>
</tbody>
</table>
<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机主要功能</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在验证阶段，虚拟机主要功能</p>
<ol>
<li><p>确保Class文件的字节路中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的 安全</p>
</li>
<li><p>大体上会完成4个人阶段的验证</p>
<p>a. 文件个hi验证</p>
<p>b. 元数据验证</p>
<p>c. 字节码验证<br>d. 符号引用验证</p>
</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在准备阶段，虚拟机主要功能：正式为<strong>类变量</strong>分配内存并设置变量初始值，但需要注意</p>
<ol>
<li><p>仅为类变量分配内存，不包括实例变量</p>
</li>
<li><p>初始值指数据类型的零值，而不是代码中赋值的初始值（真正赋值操作要在初始化阶段）. </p>
</li>
<li><p>存在一个例外，如果字段存在ConstantValue属性，就会直接进行赋值操作（也就是常量字段）</p>
</li>
</ol>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>在解析阶段，虚拟机主要功能：将常量池内的<code>符号引用</code>替换称<code>直接引用</code></p>
<p>符号引用</p>
<ul>
<li>指的是CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info等类型的常量</li>
<li>以一组符号来描述引用的目标，可以是任何形式的字面量</li>
<li>与虚拟机存在布局可以不同，只要能接受的符号引用必须一致</li>
</ul>
<p>直接引用：</p>
<ul>
<li>可以是直接指向目标的 指针、相对偏移量或是一个能间接定位到目标的句柄</li>
<li>直接引用与虚拟机的内存布局相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同</li>
<li>引用的目标必定存在于内存</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在初始阶段，虚拟机主要功能：执行类构造器<code>&lt; clinit &gt;()</code>方法。虚拟机严格规定了<strong>有且只有</strong>的五种情况必须立即对类进行初始化</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，类没有初始化则必须初始化(也就是new关键字对象、读取或设置类的静态字段(常量除外)、调用类静态方法)</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时</li>
<li>当初始化一个类时，发现其父类没初始化，则先触发父类的初始化</li>
<li>当虚拟机启动时，用户指定要执行的主类（main方法），虚拟机会先初始化这个类</li>
<li>使用JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实力最后解析结果为REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄，如果这个方法句柄对应的类没有初始化，则线初始化</li>
</ol>
<h4 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h4><p>所有引用类的方式都不会触发初始化，称为<code>被动引用</code></p>
<ol>
<li><p>通过子类引用父类的静态字段，不会导致子类初始化</p>
</li>
<li><p>通过数组定义来引用类，不会触发此类的数组化</p>
</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触<br>发定义常量所在的类。</li>
</ol>
<h4 id="接口的初始化"><a href="#接口的初始化" class="headerlink" title="接口的初始化"></a>接口的初始化</h4><p>接口的加载过程与类时一致的，编译器会为接口生成”&lt; Clinit &gt;()”类构造器，主要用于初始化接口中所定义的成员变量，与类初始化不同的是，接口不需要接口先完成初始化，只有在真正使用到父接口时（如引用接口中定义的常量）才会初始化</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>在类加载阶段，虚拟机需要<strong>通过一个类的全限定名来获取定义此类的二进制字节流</strong>，而这个动作，被放到了Java虚拟机的外部实现，这个实现的模块就是<code>类加载器</code></p>
<p>类加载器的功能</p>
<ol>
<li>实现类的加载动作</li>
<li>类加载器与类共同确定类在Java虚拟机中的唯一性，也就是说，比较两个类的相等的前提是在同一个类加载器下才有意义，不然肯定不相同</li>
</ol>
<p>类加载分类</p>
<ul>
<li><code>启动类加载器(Bootstrap ClassLoader)</code>： 负责加载 <code>JAVA_HOME\lib</code> 目录中的类，或通过<code>-Xbootclasspath</code> 参数指定路径中的，且被虚拟机认可（仅按文件名识别，如 rt.jar）的类，开发者无法直接使用</li>
<li><code>扩展类加载器(Extension ClassLoader)</code>：负责加载 <code>JAVA_HOME\lib\ext</code> 目录中的类，或通过 <code>java.ext.dirs</code> 系统变量指定路径中的类库，开发者可直接使用</li>
<li><code>应用程序类加载器(Application ClassLoader)</code>:又加系统加载器，应用程序默认类加载器，负责加载用户路径（classpath）上的类库。开发者可以直接使用</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>如图所示的类加载器之间的层次关系，被称为类的<code>双亲委派模型（Parents Delegation Model）</code>。要求除了顶层的启动类加载器外，其他的类加载器必须由父类加载器。</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt></p>
<p>双亲委派模型工作流程</p>
<ol>
<li>如果一个类加载器收到了类加载请求，它会先把这个请求委派给父类加载器区完成，每一个层次的类加载器都是如此（所以加载请求最终传送到启动类加载器中）</li>
<li>当父类加载器反馈无法完成这个加载请求（它的范围内没有找到所需的类），子类加载器才会尝试自己加载</li>
</ol>
<p>双亲委派模型优点：</p>
<ul>
<li>可以让Java类随着它的类加载器一起具备了带有优先级的层次关系，即优先加载父类范围内的类。如类Java.lang.Object,存放于rt.jar之中，由启动类加载器进行加载。在该模型下，只会优先加载Java.lang.Object,从而保证Object类的唯一性。</li>
<li>如果没有使用双亲委派模型，自定义一个Java.lang.Object,并把它放在ClassPath下，然后每一个类加载器都加载了自己的Object，使得一个系统中出现多个Object类，导致Java类型体系中最基础的行为也无法保证</li>
</ul>
<h3 id="OSGI：模块热部署"><a href="#OSGI：模块热部署" class="headerlink" title="OSGI：模块热部署"></a>OSGI：模块热部署</h3><p>OSGI 环境下，类加载器不在世双亲委派模型的树状结构，而是进一步发展为更为复杂的网状接口；它实现了模块化热部署。当收到类加载请求时，OSGI将按照一下的顺序进行类搜索</p>
<ol>
<li>将以java.*开头的类委派给父类加载器</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载</li>
<li>否则，将<code>Import</code>列表中的类委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载</li>
<li>否则，查找当前<code>Bundle</code>的<code>ClassPath</code>,使用自己的类加载器加载</li>
<li>否则，查找类是否在自己的<code>Fragment Bundle</code>中，如果在，则委派个<code>Fragment Bundle</code>的类加载器加载</li>
<li>否则，查找<code>Dynamic Import</code> 列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载</li>
<li>否则，类查找失败</li>
</ol>
<p>除了1、2两点符合双亲委派外，其余的类查找都是在平级类加载器中进行的</p>
<h1 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p> 从语言层面上，创建一个对象只是使用new关键字，而在虚拟机中，当遇到一个new指令，执行步骤如下</p>
<ol>
<li>检查这个指令的参数能够在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否被加载、解析、初始化；如果没有，则先进行类加载</li>
<li>在类加载检查通过后，虚拟机为新的对象分配内存，内存大小在类加载完后可以确定，而内存分配需要考虑两点: 内存的<strong>分配方式</strong>和<strong>分配的安全性</strong></li>
<li>将分配到的内存空间初始化为0(不包括对象头)，如果使用<code>TLAB</code>，可以提前至<code>TLAB</code>分配时进行</li>
<li>对对象进行必要设置，如设置对象是哪个类的示例，对象的hash code等,而这些信息存放在 <code>对象头</code> 中，此时一个对象创建完成</li>
<li>执行<code>init</code>,初始化对象</li>
</ol>
<p>内存分配方式：</p>
<ul>
<li><code>指针碰撞</code>：如果<strong>内存规整</strong>，用过的和没用过的各自一边。那么只需要往中间放置一个指针作为<code>分界点指示器</code>，分配内存仅仅就是移动指针而已。</li>
<li><code>空闲列表(Free List)</code>： 如果<strong>内存不规整</strong>，即用过的和没用过的互相交错，那么就需要虚拟机来维护一个列表，该列表上记录了可用的内存</li>
<li>内存是否规整，<strong>取决于所采用的垃圾收集器</strong></li>
</ul>
<p>分配的安全性：即多线程下的指针指向</p>
<ol>
<li>方式一： 对分配内存空间动作采用同步处理: 实际上虚拟机就是采用CAS配失败重试的方式保证原子性</li>
<li>方式二：将内存分配的动作划分在不同空间中进行，即在每个线程在Java堆中先划分出一小块内存,被称为<code>本地线程分配缓冲(TLAB)</code>,只有<code>TLAB</code>用完并分配新的<code>TLAB</code>时，才需要同步锁定</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p> 在HotSpot虚拟机中，对象在内存中存储布局分三块区域</p>
<ol>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充</li>
</ol>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p> 对象头包括两部分信息</p>
<ul>
<li><p>第一部分：存储对象自身的<strong>运行时数据 </strong> </p>
<p>这部分数据被称为 <code>Mark Word</code>， 如HashCode,GC分代年龄，锁状态标志，线程持有锁，偏向线程id，偏向时间戳等；在32位和64位虚拟机中长度分别为32bit和64bit。它是一个非固定的数据结构，以便于尽量在极小的空间内存储更多的信息。  </p>
</li>
<li><p>第二部分: <code>类型指针</code></p>
<p>虚拟机通过该指针确定对象是哪个类的实例，但并不是所有对象数据必须保留类型指针，即查找对象的元数据并不一定要经过对象本身    </p>
<p>如果是数组，对象头还需要一个额外的数据记录数组长度。(虚拟机可以通过元数据确定Java对象大小，而从数组的元数据是不可能知道数组大小的)  </p>
</li>
</ul>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p> 实例数据存储程序代码中定义的各种类型的字段内容，包括父类继承和子类本身定义。这部分的存储顺序受到<code>虚拟机分配策略</code>参数和字段在java源码中定义的顺序影响。</p>
<p>HotSpot默认分配策略: <code>longs/doubles</code>、<code>ints</code>、<code>shorts/chars</code>、<code>bytes/booleans</code>、<code>oops(Ordinary Object Pointers)</code>,可以明显看出，相同宽度的字段会被分配在一起。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充<strong>不是必须存在</strong>的，仅仅起到占位符的作用，因为HotSpot要求对象起始地址必须是8的倍数（即对象大小必须是8的整数倍），如果对象实例数据部分没有对齐，那么就需要通过对齐填充来补全</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>为了使用对象，必须从栈上的<code>renference</code>数据来操作对上的具体对象。而<code>renference</code>只规定了一个指向对象的引用，并没有定义访问方式。所以，对于对象的访问方式，取决于虚拟机，目前主流方式有使用<code>句柄</code>和<code>直接指针</code>两种。</p>
<h3 id="使用句柄访问"><a href="#使用句柄访问" class="headerlink" title="使用句柄访问"></a>使用句柄访问</h3><p>步骤：</p>
<ul>
<li>java会在堆中划分出一块内存来当<code>句柄池</code></li>
<li>reference中存储的对象就是<code>句柄地址</code></li>
<li>句柄中包含了对象的实例数据与类型数据的具体地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm.png" alt="jvm"></p>
<p>优势：使用句柄访问最大好处就是reference稳定，对象移动时无需更改reference,只会改变j句柄中的实例数据指针</p>
<h3 id="使用直接指针"><a href="#使用直接指针" class="headerlink" title="使用直接指针"></a>使用直接指针</h3><p>reference中存储的对象就是对象实例数据的地址</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm2.png" alt="jvm2"></p>
<p>优势：使用直接指针好处就是速度快，少一层指针定位的时间开销(HotSpot使用这种方式)</p>
<h1 id="虚拟机字节码指令表"><a href="#虚拟机字节码指令表" class="headerlink" title="虚拟机字节码指令表"></a>虚拟机字节码指令表</h1><hr>
<table>
<thead>
<tr>
<th>字节码</th>
<th>助记符</th>
<th>指令含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>nop</td>
<td>None</td>
</tr>
<tr>
<td>0x01</td>
<td>aconst_null</td>
<td>将null推送至栈顶</td>
</tr>
<tr>
<td>0x02</td>
<td>iconst_m1</td>
<td>将int型-1推送至栈顶</td>
</tr>
<tr>
<td>0x03</td>
<td>iconst_0</td>
<td>将int型0推送至栈顶</td>
</tr>
<tr>
<td>0x04</td>
<td>iconst_1</td>
<td>将int型1推送至栈顶</td>
</tr>
<tr>
<td>0x05</td>
<td>iconst_2</td>
<td>将int型2推送至栈顶</td>
</tr>
<tr>
<td>0x06</td>
<td>iconst_3</td>
<td>将int型3推送至栈顶</td>
</tr>
<tr>
<td>0x07</td>
<td>iconst_4</td>
<td>将int型4推送至栈顶</td>
</tr>
<tr>
<td>0x08</td>
<td>iconst_5</td>
<td>将int型5推送至栈顶</td>
</tr>
<tr>
<td>0x09</td>
<td>lconst_0</td>
<td>将long型0推送至栈顶</td>
</tr>
<tr>
<td>0x0a</td>
<td>lconst_1</td>
<td>将long型1推送至栈顶</td>
</tr>
<tr>
<td>0x0b</td>
<td>fconst_0</td>
<td>将float型0推送至栈顶</td>
</tr>
<tr>
<td>0x0c</td>
<td>fconst_1</td>
<td>将float型1推送至栈顶</td>
</tr>
<tr>
<td>0x0d</td>
<td>fconst_2</td>
<td>将float型2推送至栈顶</td>
</tr>
<tr>
<td>0x0e</td>
<td>dconst_0</td>
<td>将double型0推送至栈顶</td>
</tr>
<tr>
<td>0x0f</td>
<td>dconst_1</td>
<td>将double型1推送至栈顶</td>
</tr>
<tr>
<td>0x10</td>
<td>bipush</td>
<td>将单字节的常量值(-128~127)推送至栈顶</td>
</tr>
<tr>
<td>0x11</td>
<td>sipush</td>
<td>将一个短整型常量(-32768~32767)推送至栈顶</td>
</tr>
<tr>
<td>0x12</td>
<td>ldc</td>
<td>将int,float或String型常量值从常量池中推送至栈顶</td>
</tr>
<tr>
<td>0x13</td>
<td>ldc_w</td>
<td>将int,float或String型常量值从常量池中推送至栈顶(宽索引)</td>
</tr>
<tr>
<td>0x14</td>
<td>ldc2_w</td>
<td>将long或double型常量值从常量池中推送至栈顶(宽索引)</td>
</tr>
<tr>
<td>0x15</td>
<td>iload</td>
<td>将指定的int型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x16</td>
<td>lload</td>
<td>将指定的long型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x17</td>
<td>fload</td>
<td>将指定的float型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x18</td>
<td>dload</td>
<td>将指定的double型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x19</td>
<td>aload</td>
<td>将指定的引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1a</td>
<td>iload_0</td>
<td>将第一个int型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1b</td>
<td>iload_1</td>
<td>将第二个int型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1c</td>
<td>iload_2</td>
<td>将第三个int型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1d</td>
<td>iload_3</td>
<td>将第四个int型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1e</td>
<td>lload_0</td>
<td>将第一个long型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x1f</td>
<td>lload_1</td>
<td>将第二个long型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x20</td>
<td>lload_2</td>
<td>将第三个long型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x21</td>
<td>lload_3</td>
<td>将第四个long型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x22</td>
<td>fload_0</td>
<td>将第一个float型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x23</td>
<td>fload_1</td>
<td>将第二个float型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x24</td>
<td>fload_2</td>
<td>将第三个float型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x25</td>
<td>fload_3</td>
<td>将第四个float型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x26</td>
<td>dload_0</td>
<td>将第一个double型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x27</td>
<td>dload_1</td>
<td>将第二个double型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x28</td>
<td>dload_2</td>
<td>将第三个double型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x29</td>
<td>dload_3</td>
<td>将第四个double型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x2a</td>
<td>aload_0</td>
<td>将第一个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x2b</td>
<td>aload_1</td>
<td>将第二个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x2c</td>
<td>aload_2</td>
<td>将第三个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x2d</td>
<td>aload_3</td>
<td>将第四个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>0x2e</td>
<td>iaload</td>
<td>将int型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x2f</td>
<td>laload</td>
<td>将long型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x30</td>
<td>faload</td>
<td>将float型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x31</td>
<td>daload</td>
<td>将double型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x32</td>
<td>aaload</td>
<td>将引用类型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x33</td>
<td>baload</td>
<td>将boolean或byte型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x34</td>
<td>caload</td>
<td>将char型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x35</td>
<td>saload</td>
<td>将short型数组指定索引的值推送至栈顶</td>
</tr>
<tr>
<td>0x36</td>
<td>istore</td>
<td>将栈顶int型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x37</td>
<td>lstore</td>
<td>将栈顶long型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x38</td>
<td>fstore</td>
<td>将栈顶float型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x39</td>
<td>dstore</td>
<td>将栈顶double型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x3a</td>
<td>astore</td>
<td>将栈顶引用类型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x3b</td>
<td>istore_0</td>
<td>将栈顶int型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x3c</td>
<td>istore_1</td>
<td>将栈顶int型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x3d</td>
<td>istore_2</td>
<td>将栈顶int型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x3e</td>
<td>istore_3</td>
<td>将栈顶int型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x3f</td>
<td>lstore_0</td>
<td>将栈顶long型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x40</td>
<td>lstore_1</td>
<td>将栈顶long型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x41</td>
<td>lstore_2</td>
<td>将栈顶long型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x42</td>
<td>lstore_3</td>
<td>将栈顶long型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x43</td>
<td>fstore_0</td>
<td>将栈顶float型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x44</td>
<td>fstore_1</td>
<td>将栈顶float型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x45</td>
<td>fstore_2</td>
<td>将栈顶float型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x46</td>
<td>fstore_3</td>
<td>将栈顶float型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x47</td>
<td>dstore_0</td>
<td>将栈顶double型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x48</td>
<td>dstore_1</td>
<td>将栈顶double型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x49</td>
<td>dstore_2</td>
<td>将栈顶double型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x4a</td>
<td>dstore_3</td>
<td>将栈顶double型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x4b</td>
<td>astore_0</td>
<td>将栈顶引用型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x4c</td>
<td>astore_1</td>
<td>将栈顶引用型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x4d</td>
<td>astore_2</td>
<td>将栈顶引用型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x4e</td>
<td>astore_3</td>
<td>将栈顶引用型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x4f</td>
<td>iastore</td>
<td>将栈顶int型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x50</td>
<td>lastore</td>
<td>将栈顶long型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x51</td>
<td>fastore</td>
<td>将栈顶float型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x52</td>
<td>dastore</td>
<td>将栈顶double型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x53</td>
<td>aastore</td>
<td>将栈顶引用型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x54</td>
<td>bastore</td>
<td>将栈顶boolean或byte型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x55</td>
<td>castore</td>
<td>将栈顶char型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x56</td>
<td>sastore</td>
<td>将栈顶short型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x57</td>
<td>pop</td>
<td>将栈顶数值弹出(数值不能是long或double类型的)</td>
</tr>
<tr>
<td>0x58</td>
<td>pop2</td>
<td>将栈顶的一个(对于非long或double类型)或两个数值(对于非long或double的其他类型)弹出</td>
</tr>
<tr>
<td>0x59</td>
<td>dup</td>
<td>复制栈顶数值并将复制值压入栈顶</td>
</tr>
<tr>
<td>0x5a</td>
<td>dup_x1</td>
<td>复制栈顶数值并将两个复制值压入栈顶</td>
</tr>
<tr>
<td>0x5b</td>
<td>dup_x2</td>
<td>复制栈顶数值并将三个(或两个)复制值压入栈顶</td>
</tr>
<tr>
<td>0x5c</td>
<td>dup2</td>
<td>复制栈顶一个(对于long或double类型)或两个(对于非long或double的其他类型)数值并将复制值压入栈顶</td>
</tr>
<tr>
<td>0x5d</td>
<td>dup2_x1</td>
<td>dup_x1指令的双倍版本</td>
</tr>
<tr>
<td>0x5e</td>
<td>dup2_x2</td>
<td>dup_x2指令的双倍版本</td>
</tr>
<tr>
<td>0x5f</td>
<td>swap</td>
<td>将栈顶最顶端的两个数值互换(数值不能是long或double类型)</td>
</tr>
<tr>
<td>0x60</td>
<td>iadd</td>
<td>将栈顶两int型数值相加并将结果压入栈顶</td>
</tr>
<tr>
<td>0x61</td>
<td>ladd</td>
<td>将栈顶两long型数值相加并将结果压入栈顶</td>
</tr>
<tr>
<td>0x62</td>
<td>fadd</td>
<td>将栈顶两float型数值相加并将结果压入栈顶</td>
</tr>
<tr>
<td>0x63</td>
<td>dadd</td>
<td>将栈顶两double型数值相加并将结果压入栈顶</td>
</tr>
<tr>
<td>0x64</td>
<td>isub</td>
<td>将栈顶两int型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>0x65</td>
<td>lsub</td>
<td>将栈顶两long型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>0x66</td>
<td>fsub</td>
<td>将栈顶两float型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>0x67</td>
<td>dsub</td>
<td>将栈顶两double型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>0x68</td>
<td>imul</td>
<td>将栈顶两int型数值相乘并将结果压入栈顶</td>
</tr>
<tr>
<td>0x69</td>
<td>lmul</td>
<td>将栈顶两long型数值相乘并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6a</td>
<td>fmul</td>
<td>将栈顶两float型数值相乘并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6b</td>
<td>dmul</td>
<td>将栈顶两double型数值相乘并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6c</td>
<td>idiv</td>
<td>将栈顶两int型数值相除并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6d</td>
<td>ldiv</td>
<td>将栈顶两long型数值相除并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6e</td>
<td>fdiv</td>
<td>将栈顶两float型数值相除并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6f</td>
<td>ddiv</td>
<td>将栈顶两double型数值相除并将结果压入栈顶</td>
</tr>
<tr>
<td>0x70</td>
<td>irem</td>
<td>将栈顶两int型数值作取模运算并将结果压入栈顶</td>
</tr>
<tr>
<td>0x71</td>
<td>lrem</td>
<td>将栈顶两long型数值作取模运算并将结果压入栈顶</td>
</tr>
<tr>
<td>0x72</td>
<td>frem</td>
<td>将栈顶两float型数值作取模运算并将结果压入栈顶</td>
</tr>
<tr>
<td>0x73</td>
<td>drem</td>
<td>将栈顶两double型数值作取模运算并将结果压入栈顶</td>
</tr>
<tr>
<td>0x74</td>
<td>ineg</td>
<td>将栈顶int型数值取负并将结果压入栈顶</td>
</tr>
<tr>
<td>0x75</td>
<td>lneg</td>
<td>将栈顶long型数值取负并将结果压入栈顶</td>
</tr>
<tr>
<td>0x76</td>
<td>fneg</td>
<td>将栈顶float型数值取负并将结果压入栈顶</td>
</tr>
<tr>
<td>0x77</td>
<td>dneg</td>
<td>将栈顶double型数值取负并将结果压入栈顶</td>
</tr>
<tr>
<td>0x78</td>
<td>ishl</td>
<td>将int型数值左移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x79</td>
<td>lshl</td>
<td>将long型数值左移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7a</td>
<td>ishr</td>
<td>将int型数值右(带符号)移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7b</td>
<td>lshr</td>
<td>将long型数值右(带符号)移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7c</td>
<td>iushr</td>
<td>将int型数值右(无符号)移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7d</td>
<td>lushr</td>
<td>将long型数值右(无符号)移指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7e</td>
<td>iand</td>
<td>将栈顶两int型数值”按位与”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7f</td>
<td>land</td>
<td>将栈顶两long型数值”按位与”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x80</td>
<td>ior</td>
<td>将栈顶两int型数值”按位或”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x81</td>
<td>lor</td>
<td>将栈顶两long型数值”按位或”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x82</td>
<td>ixor</td>
<td>将栈顶两int型数值”按位异或”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x83</td>
<td>lxor</td>
<td>将栈顶两long型数值”按位异或”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x84</td>
<td>iinc</td>
<td>将指定int型变量增加指定值(如i++, i–, i+=2等)</td>
</tr>
<tr>
<td>0x85</td>
<td>i2l</td>
<td>将栈顶int型数值强制转换为long型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x86</td>
<td>i2f</td>
<td>将栈顶int型数值强制转换为float型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x87</td>
<td>i2d</td>
<td>将栈顶int型数值强制转换为double型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x88</td>
<td>l2i</td>
<td>将栈顶long型数值强制转换为int型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x89</td>
<td>l2f</td>
<td>将栈顶long型数值强制转换为float型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8a</td>
<td>l2d</td>
<td>将栈顶long型数值强制转换为double型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8b</td>
<td>f2i</td>
<td>将栈顶float型数值强制转换为int型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8c</td>
<td>f2l</td>
<td>将栈顶float型数值强制转换为long型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8d</td>
<td>f2d</td>
<td>将栈顶float型数值强制转换为double型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8e</td>
<td>d2i</td>
<td>将栈顶double型数值强制转换为int型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8f</td>
<td>d2l</td>
<td>将栈顶double型数值强制转换为long型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x90</td>
<td>d2f</td>
<td>将栈顶double型数值强制转换为float型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x91</td>
<td>i2b</td>
<td>将栈顶int型数值强制转换为byte型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x92</td>
<td>i2c</td>
<td>将栈顶int型数值强制转换为char型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x93</td>
<td>i2s</td>
<td>将栈顶int型数值强制转换为short型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x94</td>
<td>lcmp</td>
<td>比较栈顶两long型数值大小, 并将结果(1, 0或-1)压入栈顶</td>
</tr>
<tr>
<td>0x95</td>
<td>fcmpl</td>
<td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将-1压入栈顶</td>
</tr>
<tr>
<td>0x96</td>
<td>fcmpg</td>
<td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将1压入栈顶</td>
</tr>
<tr>
<td>0x97</td>
<td>dcmpl</td>
<td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将-1压入栈顶</td>
</tr>
<tr>
<td>0x98</td>
<td>dcmpg</td>
<td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将1压入栈顶</td>
</tr>
<tr>
<td>0x99</td>
<td>ifeq</td>
<td>当栈顶int型数值等于0时跳转</td>
</tr>
<tr>
<td>0x9a</td>
<td>ifne</td>
<td>当栈顶int型数值不等于0时跳转</td>
</tr>
<tr>
<td>0x9b</td>
<td>iflt</td>
<td>当栈顶int型数值小于0时跳转</td>
</tr>
<tr>
<td>0x9c</td>
<td>ifge</td>
<td>当栈顶int型数值大于等于0时跳转</td>
</tr>
<tr>
<td>0x9d</td>
<td>ifgt</td>
<td>当栈顶int型数值大于0时跳转</td>
</tr>
<tr>
<td>0x9e</td>
<td>ifle</td>
<td>当栈顶int型数值小于等于0时跳转</td>
</tr>
<tr>
<td>0x9f</td>
<td>if_icmpeq</td>
<td>比较栈顶两int型数值大小, 当结果等于0时跳转</td>
</tr>
<tr>
<td>0xa0</td>
<td>if_icmpne</td>
<td>比较栈顶两int型数值大小, 当结果不等于0时跳转</td>
</tr>
<tr>
<td>0xa1</td>
<td>if_icmplt</td>
<td>比较栈顶两int型数值大小, 当结果小于0时跳转</td>
</tr>
<tr>
<td>0xa2</td>
<td>if_icmpge</td>
<td>比较栈顶两int型数值大小, 当结果大于等于0时跳转</td>
</tr>
<tr>
<td>0xa3</td>
<td>if_icmpgt</td>
<td>比较栈顶两int型数值大小, 当结果大于0时跳转</td>
</tr>
<tr>
<td>0xa4</td>
<td>if_icmple</td>
<td>比较栈顶两int型数值大小, 当结果小于等于0时跳转</td>
</tr>
<tr>
<td>0xa5</td>
<td>if_acmpeq</td>
<td>比较栈顶两引用型数值, 当结果相等时跳转</td>
</tr>
<tr>
<td>0xa6</td>
<td>if_acmpne</td>
<td>比较栈顶两引用型数值, 当结果不相等时跳转</td>
</tr>
<tr>
<td>0xa7</td>
<td>goto</td>
<td>无条件跳转</td>
</tr>
<tr>
<td>0xa8</td>
<td>jsr</td>
<td>跳转至指定的16位offset位置, 并将jsr的下一条指令地址压入栈顶</td>
</tr>
<tr>
<td>0xa9</td>
<td>ret</td>
<td>返回至本地变量指定的index的指令位置(一般与jsr或jsr_w联合使用)</td>
</tr>
<tr>
<td>0xaa</td>
<td>tableswitch</td>
<td>用于switch条件跳转, case值连续(可变长度指令)</td>
</tr>
<tr>
<td>0xab</td>
<td>lookupswitch</td>
<td>用于switch条件跳转, case值不连续(可变长度指令)</td>
</tr>
<tr>
<td>0xac</td>
<td>ireturn</td>
<td>从当前方法返回int</td>
</tr>
<tr>
<td>0xad</td>
<td>lreturn</td>
<td>从当前方法返回long</td>
</tr>
<tr>
<td>0xae</td>
<td>freturn</td>
<td>从当前方法返回float</td>
</tr>
<tr>
<td>0xaf</td>
<td>dreturn</td>
<td>从当前方法返回double</td>
</tr>
<tr>
<td>0xb0</td>
<td>areturn</td>
<td>从当前方法返回对象引用</td>
</tr>
<tr>
<td>0xb1</td>
<td>return</td>
<td>从当前方法返回void</td>
</tr>
<tr>
<td>0xb2</td>
<td>getstatic</td>
<td>获取指定类的静态域, 并将其压入栈顶</td>
</tr>
<tr>
<td>0xb3</td>
<td>putstatic</td>
<td>为指定类的静态域赋值</td>
</tr>
<tr>
<td>0xb4</td>
<td>getfield</td>
<td>获取指定类的实例域, 并将其压入栈顶</td>
</tr>
<tr>
<td>0xb5</td>
<td>putfield</td>
<td>为指定类的实例域赋值</td>
</tr>
<tr>
<td>0xb6</td>
<td>invokevirtual</td>
<td>调用实例方法</td>
</tr>
<tr>
<td>0xb7</td>
<td>invokespecial</td>
<td>调用超类构建方法, 实例初始化方法, 私有方法</td>
</tr>
<tr>
<td>0xb8</td>
<td>invokestatic</td>
<td>调用静态方法</td>
</tr>
<tr>
<td>0xb9</td>
<td>invokeinterface</td>
<td>调用接口方法</td>
</tr>
<tr>
<td>0xba</td>
<td>invokedynamic</td>
<td>调用动态方法</td>
</tr>
<tr>
<td>0xbb</td>
<td>new</td>
<td>创建一个对象, 并将其引用引用值压入栈顶</td>
</tr>
<tr>
<td>0xbc</td>
<td>newarray</td>
<td>创建一个指定的原始类型(如int, float, char等)的数组, 并将其引用值压入栈顶</td>
</tr>
<tr>
<td>0xbd</td>
<td>anewarray</td>
<td>创建一个引用型(如类, 接口, 数组)的数组, 并将其引用值压入栈顶</td>
</tr>
<tr>
<td>0xbe</td>
<td>arraylength</td>
<td>获取数组的长度值并压入栈顶</td>
</tr>
<tr>
<td>0xbf</td>
<td>athrow</td>
<td>将栈顶的异常抛出</td>
</tr>
<tr>
<td>0xc0</td>
<td>checkcast</td>
<td>检验类型转换, 检验未通过将抛出 ClassCastException</td>
</tr>
<tr>
<td>0xc1</td>
<td>instanceof</td>
<td>检验对象是否是指定类的实际, 如果是将1压入栈顶, 否则将0压入栈顶</td>
</tr>
<tr>
<td>0xc2</td>
<td>monitorenter</td>
<td>获得对象的锁, 用于同步方法或同步块</td>
</tr>
<tr>
<td>0xc3</td>
<td>monitorexit</td>
<td>释放对象的锁, 用于同步方法或同步块</td>
</tr>
<tr>
<td>0xc4</td>
<td>wide</td>
<td>扩展本地变量的宽度</td>
</tr>
<tr>
<td>0xc5</td>
<td>multianewarray</td>
<td>创建指定类型和指定维度的多维数组(执行该指令时, 操作栈中必须包含各维度的长度值), 并将其引用压入栈顶</td>
</tr>
<tr>
<td>0xc6</td>
<td>ifnull</td>
<td>为null时跳转</td>
</tr>
<tr>
<td>0xc7</td>
<td>ifnonnull</td>
<td>不为null时跳转</td>
</tr>
<tr>
<td>0xc8</td>
<td>goto_w</td>
<td>无条件跳转(宽索引)</td>
</tr>
<tr>
<td>0xc9</td>
<td>jsr_w</td>
<td>跳转至指定的32位offset位置, 并将jsr_w的下一条指令地址压入栈顶</td>
</tr>
</tbody>
</table>
<h1 id="Hotspot-虚拟机参数表"><a href="#Hotspot-虚拟机参数表" class="headerlink" title="Hotspot 虚拟机参数表"></a>Hotspot 虚拟机参数表</h1><p>官网查询地址: <a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html?ssSourceSiteId=otncn" target="_blank" rel="noopener">Hotspot 虚拟机参数表</a></p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p><code>TPS（每秒事务处理数 Transactions Per Second）</code>：衡量一个服务器性能的高低好坏的一个重要指标：表示一秒内服务端评价能响应的请求总数</p>
<p><code>Java内存模型(Java Memory Model, JMM)</code>：用于屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致性的内存访问效果</p>
<h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>​    <strong>并发执行计算任务</strong>和<strong>充分利用处理器</strong>，是提升性能的关键。但事实上，想要更好的执行运算任务，光靠处理器是不够的。因为处理器在处理数据时会与内存进行交互，必然会存在IO操作，然而处理器与存储设备之间的运算速度之间差距太大，所以现在的计算机系统加入了一层高速缓存来作为内存与处理器之间的缓冲，使其京可能接近处理器运算速度。它的运作流程为：将运算需要使用到的数据复制到缓存中，让运算快速运行，运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。</p>
<p>​    高速缓存虽然解决了处理器与内存的速度矛盾，但也带来了一个新的问题：<code>缓存一致性（Cache Coherence）</code>。在处理系统中，每个处理器都有独立的高速缓存，但同时又共享同一<code>主内存（Main Memory）</code>,当多个处理器的运算任务都设计同一块主内存的时候，可能会导致缓存数据的不一致。为了解决这个问题，在处理器访问缓存时，会遵循一些协议（不同物理机器协议也会不同），使得缓存数据一致。在这个基础上，<strong>所谓的内存模型，就可以理解为在特定操作协议下，对特定内存或高速缓存进行读写访问的过程抽象</strong></p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/javamode/缓存一致性.png" alt="缓存一致性"></p>
<p>​    除了高速缓存外，<code>乱序执行优化(Out-Of-Order Execution)</code>也是使处理器内部的运算单元能尽量被利用的方法，也就是说，在处理过程中，计算的先后顺序可能与输入代码中的顺序不一致，只保证最后的结果一致。Java虚拟机的即时编译器也有类似的<code>指令重排序(Instruction Reorder)</code>优化</p>
<h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>​    <strong>Java内存模型主要是用于定义程序中各个共享变量（包括实例字段、静态字段、构成数组对象的元素）的访问规则</strong>，即变量在内存和存储设备之间的读写。而对于局部变量、方法参数这些线程私有变量，因其不存在竞争问题，所以并不在Java内存模型中。</p>
<p>​    Java内存模型规定所有变量都存储在主内存中，每条线程拥有自己的<code>工作内存（Working Memroy）</code>,作为高速缓存的角色。工作内存会保存该线程所用到的从主内存拷贝而来的变量（但并不会拷贝整个变量），然后在其中进行操作。不同线程之间的工作内存相互独立，想要传递数值则必须通过主内存进行</p>
<p>​    可以看到，java内存模型与上一节的高速缓存模型结构类似</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/java内存模型.png" alt="java内存模型"></p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>如何从主内存拷贝变量到工作内存，又如何从工作内存将数据同步到主内存，且保证操作为原子性，Java内存模型共定义了8中操作完成</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
<th>作用位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock（锁定）</td>
<td>把一个变量标识为一条线程独占状态</td>
<td>主内存</td>
</tr>
<tr>
<td>unlock（解锁）</td>
<td>把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</td>
<td>主内存</td>
</tr>
<tr>
<td>read（读取）</td>
<td>把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</td>
<td>工作内存</td>
</tr>
<tr>
<td>load（载入）</td>
<td>把通过read操作从主内存中得到的变量值放入工作内存的变量副本中</td>
<td>工作内存</td>
</tr>
<tr>
<td>use（使用）</td>
<td>把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作</td>
<td>工作内存</td>
</tr>
<tr>
<td>assign（赋值）</td>
<td>把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td>
<td>工作内存</td>
</tr>
<tr>
<td>store（存储）</td>
<td>把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作使用</td>
<td>工作内存</td>
</tr>
<tr>
<td>write（写入）</td>
<td>把通过store操作从工作内存中得到的变量的值放入主内存的变量中</td>
<td>工作内存</td>
</tr>
</tbody>
</table>
<p>​    例如，如果要执行变量从主内存复制到工作内存，就需要顺序执行read和load操作；如果需要把工作内存同步到主内存，就需要顺序执行store和write操作。类似于这样的操作，Java内存模型只要求保证执行顺序即可，允许在其中插入其他命令。</p>
<p>​    Java内存模型对8中操作的定制了一些必须满足的规定</p>
<ol>
<li>不允许read和load、store和write操作之一单独出现。</li>
<li>不允许线程丢弃它的最近的assign操作，即变量在工作内存中改变之后，必须同步回主内存。</li>
<li>不允许线程把没有经过assign操作的变量，同步回主内存。</li>
<li>一个新的变量只能在主内存中诞生，即对一个变量进行use、store操作之前，必须先执行过load、assign操作。</li>
<li>一个变量在同一时刻只能被一条线程执行lock操作，一旦lock成功，可以被同一线程重复lock多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>对一个变量执行lock操作，将会清空工作内存中该变量的值，所以在执行引擎使用这个变量前，需要重新执行load或assign操作对其进行初始化。</li>
<li>对一个变量执行unlock操作之前，必须先把该变量同步回主内存(执行store、write操作)。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许unlock一个被其他线程lock的变量</li>
</ol>
<h2 id="对Volatile型变量的特殊规则"><a href="#对Volatile型变量的特殊规则" class="headerlink" title="对Volatile型变量的特殊规则"></a>对Volatile型变量的特殊规则</h2><p>Java内存模型对Volatile定义了一些特殊的访问规则，volatile是Java虚拟机提供了一个轻量级的同步机制，它能保证变量的可见性，但不能保证原子性。</p>
<p>如执行以下程序，该程序虽然使用了volatile，但其仍然是线程不安全的。<code>cool++</code> 指令在虚拟机中，实际上是由四条指令构成，可能在执行iconst_1或者iadd，其他线程完全有可能改变了cool的值（实际上，就算只有一条指令，也不能说明这条指令是原子操作，字节码指令在解释器中也是要运行多行代码）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cool;</span><br><span class="line">cool = cool ++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cool++的字节码指令</span></span><br><span class="line">0: getstatic     #3                  // Field cool:I</span><br><span class="line"><span class="number">3</span>: iconst_1</span><br><span class="line"><span class="number">4</span>: iadd</span><br><span class="line">5: putstatic     #3                  // Field cool:I</span><br></pre></td></tr></table></figure>
<p>除了保证可见性的特性外，volatile的另一个特性是<code>禁止指令重排序优化</code></p>
<p>特殊规则如下</p>
<ol>
<li>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load操作。线程T对变量V的use操作可以认为是与线程T对变量V的load和read操作相关联的，必须一起连续出现。<strong>这条规则要求在工作内存中，每次使用变量V之前都必须先从主内存刷新最新值，用于保证能看到其它线程对变量V所作的修改后的值</strong>。</li>
<li><p>只有当线程T对变量V执行的前一个动是assign的时候，线程T才能对变量V执行store操作；并且，只有当线程T对变量V执行的后一个动作是store操作的时候，线程T才能对变量V执行assign操作。线程T对变量V的assign操作可以认为是与线程T对变量V的store和write操作相关联的，必须一起连续出现。<strong>这一条规则要求在工作内存中，每次修改V后都必须立即同步回主内存中，用于保证其它线程可以看到自己对变量V的修改</strong>。</p>
</li>
<li><p>假定操作A是线程T对变量V实施的use或assign动作，假定操作F是操作A相关联的load或store操作，假定操作P是与操作F相应的对变量V的read或write操作；类型地，假定动作B是线程T对变量W实施的use或assign动作，假定操作G是操作B相关联的load或store操作，假定操作Q是与操作G相应的对变量V的read或write操作。如果A先于B，那么P先于Q。<strong>这条规则要求valitile修改的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同</strong>。</p>
</li>
</ol>
<h2 id="对于long和double性变量的特殊规则"><a href="#对于long和double性变量的特殊规则" class="headerlink" title="对于long和double性变量的特殊规则"></a>对于long和double性变量的特殊规则</h2><p>​    java内存模型对于64位数据的特殊规定：运行虚拟机将<strong>没有被volatile修饰</strong>的64位数据的读写操作划分为两次32位操作（在JDK1.5后，读为原子性，写操作拆分），也就是说对<strong>这两种数据类型的操作是非原子性的</strong>，这就是所谓的非原子性协定（Nonatomic Treatment of double and long Variables）。之所以要分为两次32位操作，主要原因是受限于硬件，必须差分成32bit来处理。虽然，这么做，线程是很有可能得到一个半个变量的值，但实际上是很少见的情况。更何况，现在的虚拟机商家早就自己实现了64位数据的原子性操作，所以我们一般不需要生命volatile变量</p>
<h2 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h2><p>​    原子性（Atomicity）：即对变量的操作在完成前是完全不受干扰，要执行就执行完成，要么就不执行。Java内存除了提供的8个操作用于保证原子性，其中，lock和unlock操作没有开放给用户，但虚拟机提供了monitorenter和monitorexit两个字节码指令来隐式使用这两个操作，sysnchronized关键字便是使用了这两个字节码指令来完成原子性操作的</p>
<p>​    可见性(Visibility)：即一个线程改变共享值，所有线程都可以感知这个变化。Java内存保证可见性的机制为修改变量后同步刷新回主内存，读取变量前会先从主内存中刷新。volatile、synchronized和final，都可以实现可见性。final实现可见性的原理为：被final修饰的字段在构造器中一旦初始化完成，<strong>并且this没有引用逃逸</strong>，其他线程就能看见该字段的值</p>
<p>​    有序性(Ordering)：如果在本线程内观察，所有的操作都是有序的（体现为<code>线程内表现为串行的语义&quot;）；如果在一个线程观察另一个线程，所有的操作都是无序的(体现为</code>指令重排序<code>和</code>工作内存于主内存同步延迟`)。volatile关键字禁止指令重排序，synchronize规定持有同一个锁的两个同步快只能串行地进入</p>
<h2 id="先行发生原则-happens-before"><a href="#先行发生原则-happens-before" class="headerlink" title="先行发生原则(happens-before)"></a>先行发生原则(happens-before)</h2><p>先行发生原则十分重要，它规定了代码执行的顺序，如果没有顺序性的保障，虚拟机就有可能进行重排序。</p>
<p>以一个简单例子为例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a +b;</span><br><span class="line">a= b-<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>
<p>这段代码没有任何问题？是的，但如果没有先行发生原则的保证，那虚拟机重新排序后可能按以下顺序执行,那问题就大了</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">a= b-<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a +b;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>
<p>事实上，在先行发生原则下，保证了虚拟机会按照从上到下来执行语句（当然可能进行重排序优化，但起码保证了执行结果不会出错）</p>
<p>Java提供的具体规则如下</p>
<ol>
<li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对于同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li>
<li>volatile变量规则（Volatile Variable Rule）：对于一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间的先后顺序。</li>
<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则（Thread Interrupt Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ol>
<p><strong>需要注意的是，就算按照先行发生原则下的代码，在时间上的执行也不一定是顺序的，如“指令重排序”</strong></p>
<h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><p><code>as-if-serial</code>:意为所有操作的顺序可以为了优化而重排序，但结果保持不变。但只适用于单线程</p>
<h3 id="单线程下的重排序"><a href="#单线程下的重排序" class="headerlink" title="单线程下的重排序"></a>单线程下的重排序</h3><p>如下示例，step1和step2之间没有数据依赖关系，但stpe1、step2与step3存在数据依赖关系</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//step1</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">//step2</span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">//step3</span></span><br></pre></td></tr></table></figure></div>
<p>上述代码的happens-before关系为</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">step1 happens-before step2 <span class="comment">// 程序顺序次序规则</span></span><br><span class="line">step2 happens-before step3 <span class="comment">// 程序顺序次序规则</span></span><br><span class="line">step1 happens-before step3 <span class="comment">// 传递性</span></span><br></pre></td></tr></table></figure></div>
<p>但事实上并不一定会按照上述的顺序执行，而很有可能为了优化而改变顺序</p>
<h3 id="多线程下的重排序"><a href="#多线程下的重排序" class="headerlink" title="多线程下的重排序"></a>多线程下的重排序</h3><p><strong>多线程下的排序，将会改变执行结果</strong></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">    iboolean flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//step1 </span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//step2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;<span class="comment">//step3</span></span><br><span class="line">            <span class="keyword">int</span> b = a+a;<span class="comment">//step4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果线程A执行wirter()方法，线程B执行read()方法,可能出现以下两种情况</p>
<p>情况1：step1 、step2之间没有依赖关系，进行重排序，导致a的值没有改变的时候，step4就读取了a，导致结果错误</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="keyword">true</span>; <span class="comment">//线程A</span></span><br><span class="line"><span class="keyword">if</span>(flag)<span class="comment">//线程B</span></span><br><span class="line"><span class="keyword">int</span> b = a+a;<span class="comment">//线程B</span></span><br><span class="line">a = <span class="number">1</span><span class="comment">//线程A</span></span><br></pre></td></tr></table></figure></div>
<p>情况2：step3、step4存在<code>控制依赖关系</code>，<strong>当代码中存在控制依赖性时，会影响指令序列执行的并行度</strong>。为此，编译器和处理器会采用<code>猜测（Speculation）</code>执行来克服控制相关性对并行度的影响。在猜测执行的影响下，step的a+a操作很有可能提前读取a的值，然后把计算结果存入到一个。名为<code>重排序缓冲（reorder buffer ROB）</code>的硬件缓存中。当接下来setp3的条件判断为真时，就把该计算结果写入变量b中。但是，结果已经发生改变<br><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp = a *a;<span class="comment">//线程B,读取到了为a初始化之前的值</span></span><br><span class="line">flag = <span class="keyword">true</span>;<span class="comment">//线程A</span></span><br><span class="line"><span class="keyword">if</span>(flag)<span class="comment">//线程B</span></span><br><span class="line"><span class="keyword">int</span> b = temp;<span class="comment">//线程B</span></span><br><span class="line">a = <span class="number">1</span><span class="comment">//线程B</span></span><br></pre></td></tr></table></figure></div></p>
<h3 id="volatile、synchronize、final重排序规则"><a href="#volatile、synchronize、final重排序规则" class="headerlink" title="volatile、synchronize、final重排序规则"></a>volatile、synchronize、final重排序规则</h3><p>volatile：禁止重排序，即当执行到volatile修饰的变量时，位于其前面的语句肯定已经执行（前面语句的顺序可以重排），位于其后面的语句肯定没有执行（后面语句的顺序可以重排）</p>
<p>synchronize：规定持有同一个锁的两个同步快只能串行地进入</p>
<p>final重排序有两个规则</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;                            <span class="comment">//普通变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;                      <span class="comment">//final变量</span></span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinalExample</span> <span class="params">()</span> </span>&#123;     <span class="comment">//构造函数</span></span><br><span class="line">        i = <span class="number">1</span>;                        <span class="comment">//写普通域</span></span><br><span class="line">        j = <span class="number">2</span>;                        <span class="comment">//写final域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span> <span class="params">()</span> </span>&#123;    <span class="comment">//写线程A执行</span></span><br><span class="line">        obj = <span class="keyword">new</span> FinalExample ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;       <span class="comment">//读线程B执行</span></span><br><span class="line">        FinalExample object = obj;       <span class="comment">//读对象引用</span></span><br><span class="line">        <span class="keyword">int</span> a = object.i;                <span class="comment">//读普通域</span></span><br><span class="line">        <span class="keyword">int</span> b = object.j;                <span class="comment">//读final域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>规则1：在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序，如果再细化分解，该规则包含两个方面</p>
<ol>
<li>禁止编译器把 final 域的写重排序到构造函数之外</li>
<li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程A的执行顺序</span></span><br><span class="line">构造函数开始</span><br><span class="line">j = <span class="number">1</span> <span class="comment">// 写入final域</span></span><br><span class="line">StoreStore屏障</span><br><span class="line">构造函数结束</span><br><span class="line">把构造对象的引用赋值给变量obj<span class="comment">//引用赋值</span></span><br><span class="line">i = <span class="number">1</span>; <span class="comment">//写入普通域，随便排序</span></span><br></pre></td></tr></table></figure></div>
<p>规则2：在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程B执行顺序</span></span><br><span class="line"><span class="keyword">int</span> a = object.i;  <span class="comment">//读取普通域，随便排序</span></span><br><span class="line">FinalExample object = obj <span class="comment">//读对象引用</span></span><br><span class="line">LoadLoad屏障 <span class="comment">// 插入屏障，在读final域之前</span></span><br><span class="line"><span class="keyword">int</span> b = object.j;  <span class="comment">// 读final域</span></span><br></pre></td></tr></table></figure></div>
<p>需要注意的是，在使用final要防止<code>this的引用逃逸</code></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;                              <span class="comment">//1写final域</span></span><br><span class="line">        obj = <span class="keyword">this</span>;                          <span class="comment">//2 this引用在此“逸出”</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;   <span class="comment">//线程A执行</span></span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeExample ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reader &#123;  <span class="comment">//线程B执行</span></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                     <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> temp = obj.i;                 <span class="comment">//4 读取final域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如上代码,线程A、B的执行顺序可能如下，</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">构造函数开始 <span class="comment">//线程A</span></span><br><span class="line">obj=<span class="keyword">this</span>; <span class="comment">//线程A，引用逃逸，obj变为可见</span></span><br><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span><span class="comment">// 线程B</span></span><br><span class="line"><span class="keyword">int</span> temp = obj.i; <span class="comment">//线程B，读取final域，读取到了final域初始化之前的值</span></span><br><span class="line">i = <span class="number">1</span>; <span class="comment">//线程A，final域初始化</span></span><br><span class="line">构造函数结束</span><br></pre></td></tr></table></figure></div>
<p>可以看出，在构造函数返回前，<strong>被构造的对象的引用不能为其他线程可见</strong>，因为此时的 final 域可能还没有被初始化</p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/02/java-thread.all/" rel="next" title="java 并发">
                <i class="fa fa-chevron-left"></i> java 并发
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/04/mysql.all/" rel="prev" title="MySQL">
                MySQL <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/toux.jpg" alt="Liisyu">
            
              <p class="site-author-name" itemprop="name">Liisyu</p>
              <div class="site-description motion-element" itemprop="description">我只是一个兴趣使然的程序员</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://liisyu.gitee.io/cv/" title="简历 &rarr; http://liisyu.gitee.io/cv/" rel="noopener" target="_blank"><i class="fa fa-fw fa-user-o"></i>简历</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:575600714@qq.com.com" title="E-Mail(QQ) &rarr; mailto:575600714@qq.com.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail(QQ)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:swordmaster2014@gmail.com" title="E-Mail(Google) &rarr; mailto:swordmaster2014@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>E-Mail(Google)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/FameLsy" title="GitHub &rarr; https://github.com/FameLsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://gitee.com/liisyu" title="Gitee &rarr; https://gitee.com/liisyu" rel="noopener" target="_blank"><i class="fa fa-fw fa-git-square"></i>Gitee</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/masorl" title="CSDN &rarr; https://blog.csdn.net/masorl" rel="noopener" target="_blank"><i class="fa fa-fw fa-tree"></i>CSDN</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="tencent://message/?uin=575600714&Site=qq&Menu=yes" title="QQ &rarr; tencent://message/?uin=575600714&Site=qq&Menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QQ</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://messilessblog.com/" title="https://messilessblog.com/" rel="noopener" target="_blank">汪酱 BLOG</a>
                  </li>
                
              </ul>
			   
            </div>
          

          
            
          
          

    <div class="wechat-box">
      <div class="weixin-description">微信扫一扫，联系我</div>
	  <img src="/images/wechat.jpg" alt="wechat">
    </div>


        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM运行时数据区"><span class="nav-number">1.</span> <span class="nav-text">JVM运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序计数器"><span class="nav-number">1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java虚拟机栈"><span class="nav-number">1.2.</span> <span class="nav-text">Java虚拟机栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地方法栈"><span class="nav-number">1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java堆"><span class="nav-number">1.4.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区"><span class="nav-number">1.5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量池"><span class="nav-number">1.5.1.</span> <span class="nav-text">运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接内存"><span class="nav-number">1.6.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾回收与算法"><span class="nav-number">2.</span> <span class="nav-text">垃圾回收与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象存活判定算法"><span class="nav-number">2.1.</span> <span class="nav-text">对象存活判定算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数法"><span class="nav-number">2.1.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可达性分析算法"><span class="nav-number">2.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收算法"><span class="nav-number">2.2.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-清除算法-Mark-Sweep"><span class="nav-number">2.2.1.</span> <span class="nav-text">标记-清除算法(Mark-Sweep)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制收集算法-Copying"><span class="nav-number">2.2.2.</span> <span class="nav-text">复制收集算法(Copying)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记整理法"><span class="nav-number">2.2.3.</span> <span class="nav-text">标记整理法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集算法（Generational-Collection）"><span class="nav-number">2.2.4.</span> <span class="nav-text">分代收集算法（Generational Collection）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新生代"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">新生代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#老年代"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#永久代"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">永久代</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">2.3.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-收集器"><span class="nav-number">2.3.1.</span> <span class="nav-text">Serial 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew-收集器"><span class="nav-number">2.3.2.</span> <span class="nav-text">ParNew 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scsvenge收集器"><span class="nav-number">2.3.3.</span> <span class="nav-text">Parallel Scsvenge收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-Old-收集器"><span class="nav-number">2.3.4.</span> <span class="nav-text">Serial Old 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Old收集器"><span class="nav-number">2.3.5.</span> <span class="nav-text">Parallel Old收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS收集器"><span class="nav-number">2.3.6.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1收集器"><span class="nav-number">2.3.7.</span> <span class="nav-text">G1收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾收集器参数总结"><span class="nav-number">2.3.8.</span> <span class="nav-text">垃圾收集器参数总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配与回收策略"><span class="nav-number">2.4.</span> <span class="nav-text">内存分配与回收策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区的回收"><span class="nav-number">2.5.</span> <span class="nav-text">方法区的回收</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#引用reference"><span class="nav-number">3.</span> <span class="nav-text">引用reference</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机性能监控和故障处理工具"><span class="nav-number">4.</span> <span class="nav-text">虚拟机性能监控和故障处理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK命令行工具"><span class="nav-number">4.1.</span> <span class="nav-text">JDK命令行工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jps-虚拟机j进程状况工具"><span class="nav-number">4.1.1.</span> <span class="nav-text">jps:虚拟机j进程状况工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jstat-：-虚拟机统计信息监视工具"><span class="nav-number">4.1.2.</span> <span class="nav-text">jstat ： 虚拟机统计信息监视工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jinfo-Java配置信息工具"><span class="nav-number">4.1.3.</span> <span class="nav-text">jinfo: Java配置信息工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jmap：Java内存映像工具"><span class="nav-number">4.1.4.</span> <span class="nav-text">jmap：Java内存映像工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jhat-虚拟机堆转储快照分析工具"><span class="nav-number">4.1.5.</span> <span class="nav-text">jhat: 虚拟机堆转储快照分析工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jstack-Java堆栈跟踪工具"><span class="nav-number">4.1.6.</span> <span class="nav-text">jstack: Java堆栈跟踪工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-VisualVM"><span class="nav-number">4.2.</span> <span class="nav-text">Java VisualVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存监控功能"><span class="nav-number">4.2.1.</span> <span class="nav-text">内存监控功能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class类结构"><span class="nav-number">5.</span> <span class="nav-text">Class类结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#魔数与Class版本号"><span class="nav-number">5.1.</span> <span class="nav-text">魔数与Class版本号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常量池"><span class="nav-number">5.2.</span> <span class="nav-text">常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标志位值对应的具体含义"><span class="nav-number">5.2.1.</span> <span class="nav-text">标志位值对应的具体含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量池中常量项结构总表"><span class="nav-number">5.2.2.</span> <span class="nav-text">常量池中常量项结构总表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Javap-：Class-字节码分析工具"><span class="nav-number">5.2.3.</span> <span class="nav-text">Javap ：Class 字节码分析工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问标志"><span class="nav-number">5.3.</span> <span class="nav-text">访问标志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#访问标志含义表"><span class="nav-number">5.3.1.</span> <span class="nav-text">访问标志含义表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引、父类索引和与接口索引集合"><span class="nav-number">5.4.</span> <span class="nav-text">索引、父类索引和与接口索引集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字段表集合"><span class="nav-number">5.5.</span> <span class="nav-text">字段表集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字段表结构"><span class="nav-number">5.5.1.</span> <span class="nav-text">字段表结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#access-flags字段访问标志"><span class="nav-number">5.5.2.</span> <span class="nav-text">access_flags字段访问标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#描述符字符含义"><span class="nav-number">5.5.3.</span> <span class="nav-text">描述符字符含义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法表"><span class="nav-number">5.6.</span> <span class="nav-text">方法表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法表结构"><span class="nav-number">5.6.1.</span> <span class="nav-text">方法表结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法访问标志"><span class="nav-number">5.6.2.</span> <span class="nav-text">方法访问标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载"><span class="nav-number">5.6.3.</span> <span class="nav-text">重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性表集合"><span class="nav-number">5.7.</span> <span class="nav-text">属性表集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最简单的属性表结构"><span class="nav-number">5.7.1.</span> <span class="nav-text">最简单的属性表结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用属性"><span class="nav-number">5.7.2.</span> <span class="nav-text">常用属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code属性"><span class="nav-number">5.7.3.</span> <span class="nav-text">Code属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Code属性结构"><span class="nav-number">5.7.3.1.</span> <span class="nav-text">Code属性结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM是如何使用Code属性？"><span class="nav-number">5.7.3.2.</span> <span class="nav-text">JVM是如何使用Code属性？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exceptions-属性"><span class="nav-number">5.7.4.</span> <span class="nav-text">Exceptions 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LineNumberTable属性"><span class="nav-number">5.7.5.</span> <span class="nav-text">LineNumberTable属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalVariableTable属性"><span class="nav-number">5.7.6.</span> <span class="nav-text">LocalVariableTable属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalVariableTypeTable属性"><span class="nav-number">5.7.7.</span> <span class="nav-text">LocalVariableTypeTable属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SourceFile属性"><span class="nav-number">5.7.8.</span> <span class="nav-text">SourceFile属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConstantValue属性"><span class="nav-number">5.7.9.</span> <span class="nav-text">ConstantValue属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnerClasses属性"><span class="nav-number">5.7.10.</span> <span class="nav-text">InnerClasses属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deprecated"><span class="nav-number">5.7.11.</span> <span class="nav-text">Deprecated</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synthetic属性"><span class="nav-number">5.7.12.</span> <span class="nav-text">Synthetic属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StackMap-Table-属性"><span class="nav-number">5.7.13.</span> <span class="nav-text">StackMap Table 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signature属性"><span class="nav-number">5.7.14.</span> <span class="nav-text">Signature属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BootStrapMethods属性"><span class="nav-number">5.7.15.</span> <span class="nav-text">BootStrapMethods属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机类加载机制"><span class="nav-number">6.</span> <span class="nav-text">虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载过程"><span class="nav-number">6.1.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载"><span class="nav-number">6.1.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证"><span class="nav-number">6.1.2.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备"><span class="nav-number">6.1.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析"><span class="nav-number">6.1.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">6.1.5.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#被动引用"><span class="nav-number">6.1.5.1.</span> <span class="nav-text">被动引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口的初始化"><span class="nav-number">6.1.5.2.</span> <span class="nav-text">接口的初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器"><span class="nav-number">6.2.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">6.2.1.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSGI：模块热部署"><span class="nav-number">6.2.2.</span> <span class="nav-text">OSGI：模块热部署</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HotSpot虚拟机对象"><span class="nav-number">7.</span> <span class="nav-text">HotSpot虚拟机对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的创建"><span class="nav-number">7.1.</span> <span class="nav-text">对象的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">7.2.</span> <span class="nav-text">对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象头"><span class="nav-number">7.2.1.</span> <span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例数据"><span class="nav-number">7.2.2.</span> <span class="nav-text">实例数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对齐填充"><span class="nav-number">7.2.3.</span> <span class="nav-text">对齐填充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的访问定位"><span class="nav-number">7.3.</span> <span class="nav-text">对象的访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用句柄访问"><span class="nav-number">7.3.1.</span> <span class="nav-text">使用句柄访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用直接指针"><span class="nav-number">7.3.2.</span> <span class="nav-text">使用直接指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机字节码指令表"><span class="nav-number">8.</span> <span class="nav-text">虚拟机字节码指令表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hotspot-虚拟机参数表"><span class="nav-number">9.</span> <span class="nav-text">Hotspot 虚拟机参数表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java内存模型"><span class="nav-number">10.</span> <span class="nav-text">Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件的效率与一致性"><span class="nav-number">10.1.</span> <span class="nav-text">硬件的效率与一致性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主内存和工作内存"><span class="nav-number">10.2.</span> <span class="nav-text">主内存和工作内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存间交互操作"><span class="nav-number">10.3.</span> <span class="nav-text">内存间交互操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对Volatile型变量的特殊规则"><span class="nav-number">10.4.</span> <span class="nav-text">对Volatile型变量的特殊规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对于long和double性变量的特殊规则"><span class="nav-number">10.5.</span> <span class="nav-text">对于long和double性变量的特殊规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性、可见性、有序性"><span class="nav-number">10.6.</span> <span class="nav-text">原子性、可见性、有序性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#先行发生原则-happens-before"><span class="nav-number">10.7.</span> <span class="nav-text">先行发生原则(happens-before)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令重排序"><span class="nav-number">10.8.</span> <span class="nav-text">指令重排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单线程下的重排序"><span class="nav-number">10.8.1.</span> <span class="nav-text">单线程下的重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程下的重排序"><span class="nav-number">10.8.2.</span> <span class="nav-text">多线程下的重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile、synchronize、final重排序规则"><span class="nav-number">10.8.3.</span> <span class="nav-text">volatile、synchronize、final重排序规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#脚注"><span class="nav-number">11.</span> <span class="nav-text">脚注</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liisyu</span>

  

  
</div>






        


  <script>
    var _mtac = {};
    (function() {
      var mta = document.createElement("script");
      mta.src = "https://pingjs.qq.com/h5/stats.js";
      mta.setAttribute("name", "MTAH5");
      mta.setAttribute("sid", "your-tencent-mta-id");
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(mta, s);
    })();
  </script>







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

  <script type="text/javascript" src="/blog/js/clipboard.min.js"></script>  
  <script type="text/javascript" src="/blog/js/clipboard-use.js"></script>
</body>
</html>
