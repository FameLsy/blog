<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/blog/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="java 并发">
<meta property="og:type" content="article">
<meta property="og:title" content="java 并发">
<meta property="og:url" content="https://masol.gitee.io/blog/2018/02/03/java-thread.all/index.html">
<meta property="og:site_name" content="Liisyu Blog">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389510.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread10.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/concurrentHashMap.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/concurrentLinkedQueue.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/BlockingQueue.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/locksupport.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/xcc.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/scc2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/executor.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/thread/executor2.png">
<meta property="og:updated_time" content="2019-04-11T08:04:39.157Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java 并发">
<meta name="twitter:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389510.jpg">





  
  
  <link rel="canonical" href="https://masol.gitee.io/blog/2018/02/03/java-thread.all/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>java 并发 | Liisyu Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liisyu Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/blog/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-navigation">

    
    
    
      
    

    

    <a href="/blog/navigation/" rel="section"><i class="menu-item-icon fa fa-fw fa-diamond"></i> <br>导航</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://masol.gitee.io/blog/blog/2018/02/03/java-thread.all/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/blog/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java 并发

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-03 00:00:01" itemprop="dateCreated datePublished" datetime="2018-02-03T00:00:01-05:00">2018-02-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-11 04:04:39" itemprop="dateModified" datetime="2019-04-11T04:04:39-04:00">2019-04-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-389510.jpg" alt></p>
<a id="more"></a>
<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>》 现代操作系统在运行一个程序时，会为其创建一个<strong>进程</strong> 现代操作系统调度的最小单元是<code>程</code>也叫<strong>量级进程</strong>在一个进程里可以创建多个线程，这些线程都拥有各自的<strong>数器、堆栈和局部变量</strong>属性，并且能够访问共享的<strong>内存变量</strong> </p>
<p>》 线程好处</p>
<ol>
<li>更好的利用处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ol>
<h2 id="线程的安全性"><a href="#线程的安全性" class="headerlink" title="线程的安全性"></a>线程的安全性</h2><p>》 想要编写线程安全的代码，核心在于要对<strong>态访问操作</strong>行管理，特别是对共享的和可变的状态的访问</p>
<p>》 所谓的<strong>线程的状态</strong>指的是存储在状态变量(如实例、静态域)中的数据，当然也可能包括其他以来对象的域(如HashMap的状态不仅是其本身，还存储在多个Map.Entry对象中)</p>
<p>》 共享意味着状态变量可以由多个线程同时访问，而<em>变</em>味着状态变量的值在生命周期内发生变化，当多个线程对一个对象的可变状态变量进行访问时，就可能引发线程安全性问题；所以必须得采用同步机制来协同这些线程对状态变量的访问；</p>
<p>》 java主要的同步机制有</p>
<ol>
<li>synchronized 关键字</li>
<li>volatile </li>
<li>Lock</li>
<li>原子变量</li>
</ol>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>》 既然要运行线程，必然需要创建线程对象，java有两种创建线程的方式</p>
<ol>
<li>通过java.lang.Runnable接口(推荐)</li>
<li>继承java.lang.Thread类</li>
</ol>
<h3 id="通过java-lang-Runnable接口-推荐"><a href="#通过java-lang-Runnable接口-推荐" class="headerlink" title="通过java.lang.Runnable接口(推荐)"></a>通过java.lang.Runnable接口(推荐)</h3><p>》 Runnable接口只有一个run()方法，是一个函数式接口，所以可以运用lambda表达式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Runnable接口源码</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 具体实现方式为</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lambda表达式，省去了实现Runnable接口</span></span><br><span class="line"><span class="comment">//task code 写run()方法的实际逻辑处理</span></span><br><span class="line">Runnable runnable = () -&gt;&#123;task code&#125;</span><br><span class="line">Thread threadA = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">Thread threadB = <span class="keyword">new</span> Thread(runnable);</span><br></pre></td></tr></table></figure></div>
<h3 id="继承java-lang-Thread"><a href="#继承java-lang-Thread" class="headerlink" title="继承java.lang.Thread"></a>继承java.lang.Thread</h3><p>》 具体实现方式为</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承Thread并重写run()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h3><p>》 为什么要选择通过java.lang.Runnable接口的方式创建线程？</p>
<ol>
<li>将运行机制和任务进行分开解耦,Thread类负责运行机制，Runnable接口负责任务方法</li>
<li>减少线程开销，如果使用方式二，对于每个任务都需要创建一个线程；而方式一可以通过传入不同的Runnable,来实现一个线程执行不同任务</li>
</ol>
<h2 id="Thread-源码解析"><a href="#Thread-源码解析" class="headerlink" title="Thread 源码解析"></a>Thread 源码解析</h2><p>》 如下是java.lang.Thread的构造器的部分函数</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Thread</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize, AccessControlContext acc,<span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程就是该线程的父线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="comment">// 将daemon、priority属性设置为父线程的对应属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="comment">// 将父线程的InheritableThreadLocal复制过来</span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">this</span>.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.</span><br><span class="line">    inheritableThreadLocals);</span><br><span class="line">    <span class="comment">// 分配一个线程ID</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 可以看出：</p>
<ol>
<li>一个新构造的线程对象是由其parent线程来进行空间分配的</li>
<li>child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal,同时还会分配一个唯一的ID来标识这个child线程</li>
</ol>
<p>》 启动一个线程前，最好为这个线程设置线程名称，这么做的好处式在使用jstack分析程序或者进行问题排查时，就会给开发人员提供一些提示</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java提供了为线程取名的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target, String name)</span></span></span><br></pre></td></tr></table></figure></div>
<h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><p>》 线程对象在初始化完成之后,调用如下方法启动线程</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aThread.start()</span><br></pre></td></tr></table></figure></div>
<p>》 aThread.run()并不是启动线程，只是运行了run()方法  </p>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>》 线程在以下两种情况下会终止</p>
<ol>
<li>run方法执行到最后一句，并且return返回</li>
<li>出现了方法中没有捕获的异常</li>
</ol>
<p>》 以上的两种终止方式，都是被动的去终止，那么如何手动的去终止？</p>
<ol>
<li>使用stop()，已经废弃</li>
<li>使用interrupt()方法请求中断线程</li>
</ol>
<p>》 <em>断</em>理解为线程的一个标识位属性，来表示该线程是否被中断；</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中断某个线程</span></span><br><span class="line">aThread.interrupt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程是否中断</span></span><br><span class="line"><span class="comment">//如果线程中断，则返回true；但如果线程已经终止，那么无论是否被中断过，都会返回false</span></span><br><span class="line">aThread.isInterrupted();</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法，对当前线程的中断标识位进行复位</span></span><br><span class="line">Thread.interrupted();</span><br></pre></td></tr></table></figure></div>
<p>》 此外，许多声明抛出InterruptedException的方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除</p>
<h2 id="Thread-join-的使用"><a href="#Thread-join-的使用" class="headerlink" title="Thread.join()的使用"></a>Thread.join()的使用</h2><p>》 含义：</p>
<ol>
<li>线程A拥有线程B的索引，并再内部方法调用了线程B的threadB.join()</li>
<li>线程A必须等待线程B终止，才能从threadB.join()方法返回</li>
<li>join()内部利用了通知/等待机制</li>
</ol>
<p>》 此外还有<code>join(long millis)</code>和<code>join(long millis,int nanos)</code>:到达指定时间后，返回。</p>
<p>》 join()的部分源码</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁当前线程对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 条件不满足,继续等待</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 条件符合,方法返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 可以发现，符合先前<strong>通知/等待经典范式</strong>的<strong>加锁、通知、处理逻辑</strong>三个步骤</p>
<h2 id="线程其他方法"><a href="#线程其他方法" class="headerlink" title="线程其他方法"></a>线程其他方法</h2><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使线程休	眠</span></span><br><span class="line"><span class="comment">//单位毫秒。抛出InterruptedException异常</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回代表当前执行线程的对象，静态方法</span></span><br><span class="line">Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="comment">//过期方法,原因是无法保证能释放占有的资源，容易引发死锁</span></span><br><span class="line">suspend()：暂停  </span><br><span class="line">resume()：恢复  </span><br><span class="line">stop()：停止</span><br></pre></td></tr></table></figure></div>
<h2 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h2><p>》ThreadLocal,即<strong>线程变量(泛型)</strong>,是一个以<code>ThreadLocal</code>对象为键、任意对象为值的存储结构；一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">ThreadLocal&lt;T&gt; aThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;T&gt;();</span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">aThreadLocal.set(T);</span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line">aThreadLocal.get();</span><br></pre></td></tr></table></figure></div>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread1.png" alt="thread1"></p>
<p>》 获取线程状态    </p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java 5新增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div>
<p>》 Thread在内部定义了一个枚举类</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line"></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="NEW（新创建）状态"><a href="#NEW（新创建）状态" class="headerlink" title="NEW（新创建）状态"></a>NEW（新创建）状态</h2><p>》 创建了线程但没有执行start()方法，此时处于新创建状态</p>
<h2 id="RUNNABLE-可运行-状态"><a href="#RUNNABLE-可运行-状态" class="headerlink" title="RUNNABLE (可运行) 状态"></a>RUNNABLE (可运行) 状态</h2><p>》 调用了start()方法的线程就处于RUNNABLE状态，需要注意的是，该状态下的线程可能正在运行，也可能没有运行，所以是<em>运行</em>态</p>
<h2 id="BLOCKED-（阻塞）状态"><a href="#BLOCKED-（阻塞）状态" class="headerlink" title="BLOCKED （阻塞）状态"></a>BLOCKED （阻塞）状态</h2><p>》 当系统试图获取一个内部的对象锁（注意，不是java.util.concurrent库中的锁），但该锁已被其他锁持有，当前线程就会进入阻塞状态</p>
<h2 id="WAITING-等待-状态"><a href="#WAITING-等待-状态" class="headerlink" title="WAITING (等待)状态"></a>WAITING (等待)状态</h2><p>》 调用Object.wait方法、Thread.join方法，或者等待java.util.concurrent库中的Lock或Condition时,会进入等待状态</p>
<h2 id="TIME-WAITING-计时等待-状态"><a href="#TIME-WAITING-计时等待-状态" class="headerlink" title="TIME_WAITING (计时等待)状态"></a>TIME_WAITING (计时等待)状态</h2><p>》 线程因调用了某些带超时参数的方法时，会计入该状态。该状态会持续到超时期满或者接收到适当的通知</p>
<h2 id="TERMINATER-终止-状态"><a href="#TERMINATER-终止-状态" class="headerlink" title="TERMINATER (终止)状态"></a>TERMINATER (终止)状态</h2><p>》 线程终止时的状态</p>
<h2 id="线程状态的变迁"><a href="#线程状态的变迁" class="headerlink" title="线程状态的变迁"></a>线程状态的变迁</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread2.png" alt="thread2"></p>
<p>》 Java将操作系统中的运行和就绪两个状态合并称为可运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在<code>java.concurren</code>t包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了<code>LockSupport</code>类中的相关方法</p>
<h1 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h1><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>》 <code>Thred</code>类定义了三个<code>优先级常量</code>和一个<code>成员变量 *priority*</code> ，利用该成员变量来控制优先级;优先级的范围: 1~10,默认5</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>
<p>》 设置优先级  ，需要注意的是，优先级收操作系统的影响，如在ubuntu下会忽略线程优先级</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aThread.setPriority(<span class="keyword">int</span> level)</span><br></pre></td></tr></table></figure></div>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>》 <code>Thread</code>类定义了一个<code>成员变量 *daemon</code>* 来标识该线程是否为<code>守护线程</code>,<code>守护线程</code>是一种支持型线程,它主要被用作程序中后台调度以及支持性工作，当只有守护线程时，Java虚拟机会退出 </p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Whether or not the thread is a daemon thread. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> daemon = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></div>
<p>》 将线程设置成守护线程</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aThread.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></div>
<p>》 需要注意的是</p>
<ol>
<li>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置</li>
<li>Daemon中的finally块并不一定执行(JVM提前退出)</li>
</ol>
<h2 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h2><p>》 Thread中定义了两个处理器，用来处理run()方法可能出现的异常。run()方法不能抛出受查异常，而非受查异常会导致线程终止，但在线程终止之前，异常会被传到处理器中。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不设置，则未捕获异常处理器为空</span></span><br><span class="line"><span class="comment">// null unless explicitly set</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// null unless explicitly set</span></span><br><span class="line"><span class="comment">//静态的默认处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br></pre></td></tr></table></figure></div>
<p>》 设置未捕获异常处理器</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 静态方法为每一个线程设置一个默认的处理器</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span></span></span><br></pre></td></tr></table></figure></div>
<p>》 如果没有设置未捕获异常处理器的话，那么默认的异常处理器为<code>java.lang.ThreadGroup</code>类,该类是<code>UncaughtExceptionHandler</code>的实现类，其处理异常方式如下</p>
<ol>
<li>该线程有父线程，则执行父线程的<code>uncaughtException()</code>方法;没有，则进入2</li>
<li>调用<code>Thread.getDefaultUncaughtExceptionHandler()</code>,调用静态的默认处理器；如果返回null,则进入3</li>
<li>如果异常(Throwable)是<code>TreadDeath</code>的一个实例，则什么都不做；否则，进入4</li>
<li>线程名字一集<code>Throwable</code>的栈轨迹输出到<code>System.err</code>上</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">"Exception in thread \""</span></span><br><span class="line">                             + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="什么是竞争条件"><a href="#什么是竞争条件" class="headerlink" title="什么是竞争条件"></a>什么是竞争条件</h1><p>》 当两个或两个以上线程同时对同一数据进行访问修改，可能会出现错误。这种情况被称为<code>竞争条件(race condition)</code></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码会执行以下几个步骤</span></span><br><span class="line"><span class="comment">//1. 将account[1]加载到寄存器</span></span><br><span class="line"><span class="comment">//2. i +1</span></span><br><span class="line"><span class="comment">//3. 将结果写回account[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果线程A执行了第1、2步，被抢夺了运行权。线程B夺过并修改了i的值，此时再回到线程A执行第3步，就会发生错误。</span></span><br><span class="line">account[<span class="number">1</span>] = i++;</span><br></pre></td></tr></table></figure></div>
<h1 id="锁对象和条件对象"><a href="#锁对象和条件对象" class="headerlink" title="锁对象和条件对象"></a>锁对象和条件对象</h1><p>》 为了实现对 <code>代码块</code> 并发访问的防干扰，java提供了两种机制</p>
<ol>
<li>synchronized 关键字</li>
<li>显示锁的使用</li>
</ol>
<p>》不过 在此之前，先理解锁对象和条件对象</p>
<h2 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h2><p>》 如下代码，一旦一个线程封锁了锁对象，其他任何线程都无法通过<code>lock()</code>语句，会被阻塞，直到第一个线程释放锁对象</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    myLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h2><p>》 条件对象用于管理那些获得锁但无法执行有用工作的线程，当条件不满足时，先释放掉锁，等到条件满足在进行操作。一个锁对象，可以对应对各条件对象</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadA</span></span><br><span class="line">myLcok.lock();<span class="comment">//锁定</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//获取一个条件对象</span></span><br><span class="line">    aCondtion = myLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当条件不满足时，通过条件对象让线程阻塞，并释放锁</span></span><br><span class="line">    <span class="comment">//该线程很一直处于阻塞状态，直到其他线程aCondition.signal()，唤醒等待的线程</span></span><br><span class="line">    <span class="comment">//被唤醒后如果条件满足，则可以退出循环，继续操作了</span></span><br><span class="line">    <span class="keyword">while</span>(!(ok to proceed))&#123;</span><br><span class="line">        aCondition.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 条件对象需要设置几个方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让线程阻塞并释放锁</span></span><br><span class="line">await();</span><br><span class="line"><span class="comment">//唤醒单个被await()阻塞的队列</span></span><br><span class="line">signal();</span><br><span class="line"><span class="comment">//唤醒所有被await()阻塞的队列</span></span><br><span class="line">signalAll()</span><br></pre></td></tr></table></figure></div>
<p>》 在Object中，已经定义了三个类似的方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让线程阻塞并释放锁</span></span><br><span class="line">wait();</span><br><span class="line"><span class="comment">//唤醒单个被await()阻塞的队列</span></span><br><span class="line">notify();</span><br><span class="line"><span class="comment">//唤醒所有被await()阻塞的队列</span></span><br><span class="line">notifyAll();</span><br></pre></td></tr></table></figure></div>
<p>》 Condition和Object的三个方法使用了不同的方法名，这样可以避免方法之间的冲突</p>
<h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><p>》 java从1.0开始，每个对象都有一个<code>内部的对象锁</code>，关键字<code>synchronized</code>可以修饰<code>方法</code>或者<code>方法块</code>所使用的就是该对象的内部对象锁和相关的条件</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span> something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以把它看成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//this.intrinsicLock相当于内部对象锁</span></span><br><span class="line">    <span class="keyword">this</span>.intrinsicLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">do</span> something;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intrinsicLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 不同的是，内部对象只有一个条件对象(毕竟，不能显式的<code>newCondition</code>来获取条件对象)</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.intrinsiCondition.await();</span><br><span class="line"><span class="keyword">this</span>.intrinsiCondition.signal();</span><br><span class="line"><span class="keyword">this</span>.intrinsiCondition.signalAll();</span><br></pre></td></tr></table></figure></div>
<p>》 事实上，<code>synchronized</code>关键字锁的是<code>this</code>,可以通过如下代码来验证</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种synchronized(obj)的方式通过一个对象来实现额外的原子操作，被称为客户端锁定，但并不推荐使用</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 此外，可以通过如下代码来验证关键字也可以使用在<strong>静态方法</strong>上，此时锁的是对象的<code>class文件</code>,可以通过如下代码来验证</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(aObject.class)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 synchronized带来便捷的同时，也存在了一些局限性</p>
<ol>
<li>不能中断一个试图获取锁的程序</li>
<li>试图获取锁不能设置超时</li>
<li>只能单一条件</li>
</ol>
<hr>
<h2 id="JVM中的synchronized"><a href="#JVM中的synchronized" class="headerlink" title="JVM中的synchronized"></a>JVM中的synchronized</h2><p>》对于<code>同步块</code>的实现使用了<code>monitorenter</code>和<code>monitorexit</code>指令；<code>同步方法</code>则是依靠方法修饰符上的<code>ACC_SYNCHRONIZED</code>。本质是对一个对象的<code>监视器（monitor）</code>进行获取，而这个获取过程是排他的。</p>
<p>》监视器</p>
<ol>
<li>任意一个对象都拥有自己的监视器</li>
<li>同步块或同步方法执行时必须获取该对象的监视器，才能进入；</li>
<li>没有获取到监视的线程将会被阻塞在同步块和同步方法的入口处，线程进入同步队列，状态变为BLOCKED状态。</li>
</ol>
<p>》名词解释： </p>
<ol>
<li>可见性：一个线程对共享变量值的修改，能够及实地被其他线程看到 </li>
<li>排他性：即线程对块或方法的独立占有　</li>
</ol>
<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p>》 java是支持多个线程访问同一个对象或者对象的成员变量，但每个线程，拥有的是它们的<strong>拷贝</strong>.因此，这个拷贝的对象<strong>可能不是最新</strong>的。当然，如果使用锁机制的话肯定没问题，但如果仅仅为了读写一两个实例域而使用锁，<strong>开销就显得有点大</strong>了。volatile关键字就是为实例域提供了一种免锁的机制。</p>
<p>》volatile</p>
<ol>
<li>访问数据时，告知程序需要从共享内存中获取</li>
<li>改变数据时，告知程序需要同步刷新回共享内存。</li>
<li>保证所有线程对变量访问的可见性，但不保证其原子性</li>
</ol>
<p>》 如果想要使用volatile来打到线程安全，必须同时满足下面两个条件</p>
<ol>
<li><p>对变量的写操作不依赖于当前值(如x++,其操作其实是读-&gt;添加-&gt;赋值三个操作，需要保证原子性，所以不能使用volatile)</p>
</li>
<li><p>该变量没有包含在具有其他变量的不变式中</p>
</li>
</ol>
<h2 id="正确使用-volatile-的模式"><a href="#正确使用-volatile-的模式" class="headerlink" title="正确使用 volatile 的模式"></a>正确使用 volatile 的模式</h2><h3 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h3><p>》 实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; shutdownRequested = <span class="keyword">true</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//每次循环，都会读取最新的shutdownRequested值，如果使用synchronized,就需要加锁，阻塞、唤醒等一些列操作</span></span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="一次性安全发布"><a href="#一次性安全发布" class="headerlink" title="一次性安全发布"></a>一次性安全发布</h2><p>》对于以下语句，实际上又三个步骤</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>对象指向内存空间</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theFlooble = <span class="keyword">new</span> Flooble();</span><br></pre></td></tr></table></figure></div>
<p>》 但实际上，2，3可能重排，变为</p>
<ol>
<li>分配内存空间</li>
<li>对象指向内存空间</li>
<li>初始化对象</li>
</ol>
<p>》 再看如下代码</p>
<ol>
<li>Thread A进行initInBackground()时，到达第二步，对象指向内存空间</li>
<li>Thread B在此时读取theFlooble,不为空，但对象却还没初始化</li>
<li>使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundFloobleLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do lots of stuff</span></span><br><span class="line">        theFlooble = <span class="keyword">new</span> Flooble();  <span class="comment">// this is the only write to theFlooble</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Thread B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="comment">// do some stuff...</span></span><br><span class="line">            <span class="comment">// use the Flooble, but only if it is ready</span></span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="keyword">null</span>) </span><br><span class="line">                doSomething(floobleLoader.theFlooble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="队列同步器-AbstractQueuedSynchronizer"><a href="#队列同步器-AbstractQueuedSynchronizer" class="headerlink" title="队列同步器(AbstractQueuedSynchronizer)"></a>队列同步器(AbstractQueuedSynchronizer)</h1><p>》 简称<strong>AQS</strong>，是一个抽象类，用来构建锁或者其他同步组件的基础框架，<strong>同步器设计是基于模板方法模式</strong>，它使用了一个<strong>int成员变量表示同步状态</strong>，通过内置的<strong>FIFO队列</strong>来完成资源获取线程的排队工作。子类通过继承他，来进行管理同步状态，AQS主要提供三个方法来改变或访问同步状态</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前同步状态。</span></span><br><span class="line">getState()</span><br><span class="line"><span class="comment">//设置当前同步状态。</span></span><br><span class="line">setState(<span class="keyword">int</span> newState)：</span><br><span class="line"><span class="comment">//使用CAS设置当前状态，该方法能够保证状态设置的原子性。传递当前线程“认为”的尾节点和当前节点，如果设置成功（即tail成功指向当前节点）,则返回true</span></span><br><span class="line">compareAndSetState(<span class="keyword">int</span> expect,<span class="keyword">int</span> update)：</span><br></pre></td></tr></table></figure></div>
<h2 id="同步器可重写的方法"><a href="#同步器可重写的方法" class="headerlink" title="同步器可重写的方法"></a>同步器可重写的方法</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread6.png" alt="thread6"></p>
<h2 id="同步器的模板方法"><a href="#同步器的模板方法" class="headerlink" title="同步器的模板方法"></a>同步器的模板方法</h2><p>》 实现自定义同步组件时，将会调用同步器提供的模板方法，同步器提供的模板方法如下,其大致分为三类</p>
<ol>
<li>独占式获取与释放同步状态</li>
<li>共享式获取与释放同步状态</li>
<li>查询同步队列中的等待线程情况</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread7.png" alt="thread7"></p>
<h2 id="队列同步器的实现分析"><a href="#队列同步器的实现分析" class="headerlink" title="队列同步器的实现分析"></a>队列同步器的实现分析</h2><p>》 实现一个同步器，主要包括</p>
<ol>
<li>同步队列</li>
<li>提供独占式同步状态获取与释放方法</li>
<li>提供共享式同步状态获取与释放方法</li>
<li>提供超时获取同步状态等同步器的核心数据结构与模板方法。</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------同步队列结构---------------------------</span></span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="comment">//同步状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//一个Node节点类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------独占式同步状态获取与释放方法---------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------共享式同步状态获取与释放方法---------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 当我们调用锁的lock()和unlock()方法时，实际上操作的就是同步器获取和释放同步状态</p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>》 同步队列是为了将没有获取同步状态的线程先保存，然后通过<strong>FIFO双向队</strong>列完成 <strong>*`同步状态</strong>`* 的管理,其处理逻辑如下</p>
<ul>
<li>线程A和线程B同时获取同步状态，A获取成功，相当于获取到了锁；B获取失败后进入线程中断，将B打包成节点放入到队列尾部</li>
<li>线程A执行完毕，释放同步状态（释放锁），因为FIFO的原则，获取到队列的首节点，从节点获取到相应的线程信息，唤醒该线程，线程被唤醒后，再次尝试获取同步状态；</li>
</ul>
<p>》 节点属性描述：</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread8.png" alt="thread8"></p>
<p>》 此外，同步器拥有<strong>首节点（head）和尾节点（tail）</strong>，以下是同步器的基本结构</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread9.png" alt="thread9"></p>
<h4 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h4><p>》 对于入列操作，因为可能又多个线程同时操作入列，所以需要保证其安全性，同步器提供了一个基于CAS的设置尾节点的方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法时调用了Unsafe类的方法，Unsafe可以保证原子操作</span></span><br><span class="line">compareAndSetTail(Node expect,Node update)&#123;</span><br><span class="line">    <span class="comment">//this为需要更新的对象</span></span><br><span class="line">    <span class="comment">//tailOffset:对象中变量的偏移量，可以理解为尾节点的引用地址</span></span><br><span class="line">    <span class="comment">//expect:期望的值</span></span><br><span class="line">    <span class="comment">//updaet: 更新值</span></span><br><span class="line">    <span class="comment">//如果expect的值与update值一样，则更新tailOffset;相当于将tail指向update节点</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 入队的完整操作需要实现三个操作</p>
<ol>
<li>node.prev指向原tail节点</li>
<li>tail节点指向node</li>
<li>原tail节点的后继节点指向node</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node为需要入列的节点</span></span><br><span class="line"><span class="comment">//先将node的前驱节点设置为tail</span></span><br><span class="line">node.prev = t;</span><br><span class="line"><span class="comment">//然后通过同步器提供的CAS设置尾节点方式，将tail节点指向node节点</span></span><br><span class="line"><span class="comment">//如果成功，那么再将原tail节点的后继结点指向node</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">    t.next = node;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h4><p>》 对于获取首节点而言，并不需要使用CAS来保证，只需要正常的出队列即可</p>
<h3 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h3><p>》 独占式同步状态获取释放流程</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread10.png" alt="thread10"></p>
<h4 id="获取流程"><a href="#获取流程" class="headerlink" title="获取流程"></a>获取流程</h4><p>》 源码:AQS通过模板方法acquire()方法来进行独占式的同步状态获取，获取成功，则由该方法返回；失败，则进入等待队列</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS源码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>》 对于<code>tryAcquire(int arg)</code>方法，它是同步器自定义的获取同步状态的方法,如果不重写，原方法只是抛出一个<code>UnsupportedOperationException</code>；(具体实现在后面的锁中讲，因为根据非公平性和公平性，实现方式是不同的)</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS中的tryAcquire</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>》 对于<code>addWaiter()</code>方法,它会构造一个节点并加入队列列尾，在AQS，构造的是<code>Node.EXCLUSIVE</code>的节点；他会现场时快速添加一个节点，如果失败，在进入<code>enq(node)</code>,进入死循环中进行CAS添加</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//尾节点</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试快速添加，可能由于多个请求并发进行而添加失败</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//尾节点设置为新节点的前驱节点</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">//使用compareAndSetTail,确保节点能够被线程安全添加列尾</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//快速添加失败，进入死循环添加，将并发添加节点的请求通过CAS变得“串行化”</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//通过“死循环”来保证节点的正确添加，CAS</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>》 对于<code>acquireQueued()</code>方法,可以看到，它会以死循环的方式从头节点开始获取同步状态，获取同步状态依旧是利用了<code>tryAcquire()</code>方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS</span></span><br><span class="line"><span class="comment">//在“死循环”中尝试获取同步状态，而只有 前驱节点 是头节点才能够尝试获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置中断标记</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//判断结点的前驱节点是否为头节点，因为头节点是获取成功状态的节点，如果当前节点的前驱节点是头节点的话，那么下一个获取同步状态的就是这个节点了</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>》 对于<code>selfInterrupt()</code>，它是当两种方式获取状态都失败后，让线程中断等待唤醒</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="释放流程"><a href="#释放流程" class="headerlink" title="释放流程"></a>释放流程</h4><p>》 当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，唤醒其后继节点能够继续获取同步状态。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//unparkSuccessor()使用LockSupport来唤醒处于等待状态的线程</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h3><p>》 与独占式的区别在于:同一时刻能否有多个线程同时获取到同步状态，如对于同一份文件的读操作，对于共享式的访问均被允许，而独占式只能有一个被访问，其他的独占式访问均被拒绝</p>
<h4 id="获取流程-1"><a href="#获取流程-1" class="headerlink" title="获取流程"></a>获取流程</h4><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryAcquireShared(int arg)方法会返回一个int，如果int大于0，说明能够获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="comment">//doAcquireShared()在当前节点的前驱节点为头节点时，会尝试获取同步状态，如果返回值大于等于0，表示获取成功</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="释放流程-1"><a href="#释放流程-1" class="headerlink" title="释放流程"></a>释放流程</h4><p>》 通过调用releaseShared(int arg)方法释放同步状态</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryReleaseShared:必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证,，因为释放同步状态的操作会同时来自多个线程。(独占式则不需要，因为是一个线程释放)</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h3><p>》 独占式超时同步状态获取流程</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread11.png" alt="thread11"></p>
<p>》 同步器通过调用<code>doAcquireNanos(int arg,long nanosTimeout)</code>方法可以超时获取同步状态，即在指定的时间段内获取同步状态，其逻辑如下</p>
<ol>
<li>主要需要计算出需要睡眠的时间间隔<code>nanosTimeout</code>，公式为：<code>nanosTimeout-=now-lastTime</code>（其中now为当前唤醒时间，lastTime为上次唤醒时间）</li>
<li>如果<code>nanosTimeout</code>大于0则表示超时时间未到，需要重新计算超时间隔<code>nanosTimeout</code>，继续睡眠<code>nanosTimeout</code>纳秒，反之，表示已经超时</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前唤醒时间</span></span><br><span class="line"><span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上次唤醒时间</span></span><br><span class="line">        <span class="keyword">long</span> lastTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//-----------------重点-----------------------------</span></span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)</span><br><span class="line">                        &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">                <span class="comment">//计算时间，当前时间now减去睡眠之前的时间lastTime得到已经睡眠的时间delta，然后被原有超时时间nanosTimeout减去，得到了还应该睡眠的时间</span></span><br><span class="line">                nanosTimeout -= now - lastTime;</span><br><span class="line">                lastTime = now;</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>》 如果<code>nanosTimeout</code>小于等于<code>spinForTimeoutThreshold</code>（1000纳秒）时，将不会使该线程进行超时等待，而是进入快速的<strong>自旋过程</strong>(非常短的超时等待无法做到十分精确)</p>
<h1 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h1><h2 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h2><p>》 Java SE 5之后，并发包中新增了Lock接口,在使用时需要显式地获取和释放锁。</p>
<p>》 不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放</p>
<p>》 Lock接口提供的synchronized关键字不具备的主要特性</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread4.png" alt="thread4"></p>
<p>》 Lock的API</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread5.png" alt="thread5"></p>
<h2 id="重入锁-ReentrantLock"><a href="#重入锁-ReentrantLock" class="headerlink" title="重入锁(ReentrantLock)"></a>重入锁(ReentrantLock)</h2><p>》 支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。</p>
<p>》 为什么要用到重入锁，如下场景</p>
<ol>
<li>线程A通过aLock.lock()获取了锁</li>
<li>锁未被释放，线程A再次aLock.lock()获取锁，此时将无法获取，导致自己被自己阻塞</li>
</ol>
<p>》 除此之外，该锁的还支持获取锁时的公平和非公平性选择</p>
<ol>
<li>公平性：锁获取是顺序的，先请求锁的先获取锁</li>
<li>非公平性: 效率比公平性锁高</li>
</ol>
<h3 id="实现重进入"><a href="#实现重进入" class="headerlink" title="实现重进入"></a>实现重进入</h3><p>》 线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞,需要解决两个问题</p>
<ol>
<li>线程再次获取锁,判断当前线程是否为锁的占有者，是，则获取成功</li>
<li>锁的最终释放,利用计数器记录锁获取的次数，每次释放时计数器自减，当为0时表示锁成功释放</li>
</ol>
<p>》 ReentrantLock默认为以非公平性实现</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁</span></span><br><span class="line"><span class="comment">//判断当前线程是否为获取锁的线程来决定获取操作是否成功</span></span><br><span class="line"><span class="comment">//重复获取只是添加了同步状态值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//通过判断当前线程是否跟获取锁的线程是同一个线程</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//则将同步状态值进行增加并返回true,表示获取成功,相当于成功获取锁的线程再次获取锁，只是增加了同步状态值</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="comment">//前n-1次方法必定返回false，只有同步状态为0时，才返回true</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 ReentrantLock公平性实现</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区别在于判断条件多了hasQueuedPredecessors(),判断出当前线程所对应的节点是否有前驱节点，如果有，则返回true</span></span><br><span class="line"><span class="comment">//也就是说，只有前驱线程获取并释放锁之后才能继续获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node t = tail; </span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">//判断头节点和尾节点是否是同一节点，如果h == t,说明同步队列没有节点，肯定没有前驱节点</span></span><br><span class="line">        <span class="comment">// 第二步判断，如果头节点的后继节点为空(只有一个节点，自然没有前驱节点) 或者 有后继节点但判断后继节点对应的线程是否是当前线程</span></span><br><span class="line">        <span class="comment">//通过三个判断来判断出当前线程的是否是下一个需要执行的</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>》 非公平性锁的一个线程连续获取锁的情况  </p>
<ul>
<li>原因为刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待,可能造成线程饥饿（使得其他线程只能在同步队列中等待）</li>
</ul>
<p>》 为什么非公平锁为默认？</p>
<ul>
<li>公平锁锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</li>
</ul>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>》 读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞;读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升</p>
<p>》 java 5.0之前是如何做的?</p>
<ul>
<li>使用Java的等待通知机制</li>
<li>写操作开始，其他读操作等待，直到通知(防止幻读)</li>
</ul>
<p>》 有了读写锁后怎么做？</p>
<ul>
<li>读操作，获取读锁，允许多个线程获取读锁进行访问，后继无法获取写锁</li>
<li>写操作，获取写锁,后续其他线程读写操作均被阻塞</li>
</ul>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>》 Java并发包提供读写锁的实现是<code>ReentrantReadWriteLock</code>，它实现于<code>ReadWriteLock</code>,其特性如下</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock.png" alt="lock"></p>
<p>》 <code>ReadWriteLock</code>仅定义了获取读锁和写锁的两个方法，即<code>readLock()</code>方法和<code>writeLock()</code>方法，而<code>ReentrantReadWriteLock</code>，还提供了一些便于外界监控其内部工作状态的方法</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock2.png" alt="lock2"></p>
<h3 id="读写锁的实现分析"><a href="#读写锁的实现分析" class="headerlink" title="读写锁的实现分析"></a>读写锁的实现分析</h3><p>》 ReentrantReadWriteLock的实现，主要包括：</p>
<ol>
<li>读写状态的设计</li>
<li>写锁的获取与释放</li>
<li>读锁的获取与释放</li>
<li>锁降级</li>
</ol>
<h3 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h3><p>》 读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态.写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态</p>
<p>》 如何在一个变量上维护多种状态？</p>
<ul>
<li>使用“按位切割”</li>
<li>高16位表示读，低16位表示写</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/lock3.png" alt="lock3"></p>
<p>》 如何确定状态?</p>
<ul>
<li>通过位运算</li>
<li>写状态：status_value&amp;0x0000FFFF(高16位全部抹去)</li>
<li>写状态+1：status_value +1</li>
<li>读状态：status_value&gt;&gt;&gt;16(无符号补0右移16位)</li>
<li>读状态+1：status_value+(1&lt;&lt;16)，也就是status_value+0x00010000</li>
</ul>
<h3 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h3><p>》 写锁是一个支持重进入的排它锁</p>
<ul>
<li>如果当前线程已经获取了写锁，则增加写状态</li>
<li>如果当前线程在获取写锁时，读锁已经被获取其他或当前线程获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写锁获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//获取写锁状态</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//从c != 0-&gt;当前线程存在锁，w == 0,没有写锁，说明存在的是读锁</span></span><br><span class="line">        <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 写锁释放与ReentrantLock类似</p>
<h3 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h3><p>》 读锁是一个支持重进入的共享锁，它能够被多个线程同时获取,在没有其他<em>写线程</em>访问（或者写状态为0）时，读锁总会被成功地获取;如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态</p>
<p>》 逻辑如下：</p>
<ol>
<li>如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</li>
<li>如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">//如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//增加读状态，成功获取读锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>》 读锁释放，每次减少读状态(线程安全的，可能有多个读线程同时释放读锁)，减少的值是（1&lt;&lt;16）</p>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>》 锁降级指的是写锁降级成为读锁,步骤为</p>
<ol>
<li>持有写锁(不释放,当前拥有的)</li>
<li>获取读锁</li>
<li>释放（先前拥有的）写锁</li>
</ol>
<p>》 为什么要使用锁降级?从以下示例来解释,逻辑如下</p>
<ol>
<li>数据发生变更后，update变为false(布尔类型且volatile修饰)</li>
<li>所有访问该方法的线程，感知变化，但只有一个线程能获取到写锁</li>
<li>写锁修改完数据后，释放锁（注意在写锁是释放前，又获取了读锁）</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读锁会被写锁阻塞</span></span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 必须先释放读锁</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">// 锁降级从写锁获取到开始</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 准备数据的流程（略）</span></span><br><span class="line">                update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再次获取读锁</span></span><br><span class="line">            readLock.lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//step_join</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用数据的流程（略）</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 为什么要再次获取读锁?</p>
<ul>
<li>假设线程A释放写锁后不获取读锁</li>
<li>此时线程B在step_join 位置获取到了获取了写锁并修改了数据，但线程A无法获取到线程B更新的数据,继续使用数据就会不一致（注意此时setp_join位置线程A是没有任何锁的）</li>
<li>但如果加了读锁呢，线程A拥有读锁，线程B因为线程A持有读锁，导致其进入等待状态，直到线程A释放读锁，才能进行数据修改</li>
</ul>
<p>》 问题：其实不用锁降级，单单依靠volatile和写锁，也能保证数据的安全性，那么为什么要用锁降级呢？</p>
<p>》》 个人猜想：写锁会导致其他线程完全堵塞，而读锁是可以多线程访问的。比方说除了写锁锁定的代码外，其他代码是可以线程共享的，那么写锁降级读锁可以充分利用读锁的共享机制。</p>
<h1 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h1><p>》相关方法：<br><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/thread3.png" alt="thread3"></p>
<p>》等待/通知机制:  </p>
<ol>
<li>线程A调用对象O的wait()进入等待状态</li>
<li>线程B执行完程序后，调用对象O的notify()/notifyAll()方法</li>
<li>线程A收到通知从wait()方法返回，执行它的操作</li>
</ol>
<p>》调用<code>wait()、notify()</code>以及<code>notifyAll()</code>时需要注意的细节</p>
<ol>
<li>使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</li>
<li>调用wait()方法后,线程状态由RUNNING变为WAITING,并将当前线程放置到对象的等待队列。</li>
<li>notify()或notifyAll()方法调用后,等待线程依旧不会从wait()返回,需要调用notify()或notifAll()的线程释放锁之后,等待线程才有机会从wait()返回。</li>
<li>notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中,而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列,被移动的线程状态由WAITING变为BLOCKED。</li>
<li>从wait()方法返回的前提是获得了调用对象的锁</li>
</ol>
<h2 id="等待-通知经典范式"><a href="#等待-通知经典范式" class="headerlink" title="等待/通知经典范式"></a>等待/通知经典范式</h2><p>》将线程分为</p>
<ol>
<li>等待方（消费者线程,感知变化，进行相应的操作）</li>
<li>通知方(生产者线程,修改某个对象的值)  </li>
</ol>
<p>》等待方规则:</p>
<ol>
<li>获取锁对象</li>
<li>如果条件不满足,那么调用对象的wait()方法,被通知后仍要检查条件。</li>
<li>条件满足则执行对应的逻辑。</li>
</ol>
<p>》伪代码:</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(aObject.class) &#123;</span><br><span class="line">    <span class="keyword">while</span>(condition) &#123;</span><br><span class="line">        aObject.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    doSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》通知方规则：</p>
<ol>
<li>获取所对象</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程。</li>
</ol>
<p>》伪代码：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(aObject.class) &#123;</span><br><span class="line">    change condition to <span class="keyword">true</span>;</span><br><span class="line">    aObject.notifyAll();`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h1><p>》 任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括<code>wait()、wait(long timeout)、notify()</code>以及<code>notifyAll()</code>方法，这些方法与<code>synchronized</code>同步关键字配合，可以实现<strong>等待/通知模式</strong>；而Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式</p>
<p>》 Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁,Condition依赖Lock对象</p>
<h2 id="Condition的（部分）方法以及描述"><a href="#Condition的（部分）方法以及描述" class="headerlink" title="Condition的（部分）方法以及描述"></a>Condition的（部分）方法以及描述</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition2.png" alt="condition2"></p>
<h2 id="condition对比Object"><a href="#condition对比Object" class="headerlink" title="condition对比Object"></a>condition对比Object</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition.png" alt="condition"></p>
<h2 id="Condition的实现分析"><a href="#Condition的实现分析" class="headerlink" title="Condition的实现分析"></a>Condition的实现分析</h2><p>》 <code>ConditionObject</code>是同步器A<code>bstractQueuedSynchronizer</code>的 <strong>内部类</strong>,每个<code>Condition</code>对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。</p>
<p>》 Condition的实现，主要包括：</p>
<ol>
<li>等待队列</li>
<li>等待</li>
<li>通知</li>
</ol>
<h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>》 等待队列</p>
<ul>
<li>FIFO的队列</li>
<li>节点包含了一个线程引用（在Condition对象上等待的线程），复用了同步器中节点的定义</li>
<li>拥有首节点（firstWaiter）和尾节点（lastWaiter）</li>
<li>节点更新无需CAS,因为await()方法必然是获取了锁的线程</li>
</ul>
<p>》 同步器拥有一个同步队列和多个等待队列</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition3.png" alt="condition3"></p>
<h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><p>》 调用了Condition.await()方法，该线程将会释放锁、构造成节点加入等待队列并进入等待状态</p>
<p>》 逻辑如下</p>
<ol>
<li>当前线程必定是获取到锁的线程,即同步队列的首节点</li>
<li>该方法会将当前线程构造成节点并加入等待队列</li>
<li>释放同步状态,也就是释放锁</li>
<li>阻塞当前队列</li>
<li>调用acquireQueued()方法加入到获取同步状态的竞争中，为的是唤醒后重写抢回锁，并从await()返回</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 被唤醒的程序将从循环中退出，isOnSyncQueue(node)判断当前节点是否已经在同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用同步器的acquireQueued()方法加入到获取同步状态的竞争中</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 注意:</p>
<ol>
<li>释放锁之后，线程只有被唤醒才能从LockSupport.park(this)返回</li>
<li>返回之后，只有抢到锁才能从await()方法中返回,所以需要通过acquireQueued()来重写抢回锁</li>
</ol>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>》 调用<code>Condition</code>的<code>signal()</code>方法,将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中</p>
<p>》 逻辑如下</p>
<ol>
<li>当前线程必须是获取了到锁的线程（通过isHeldExclusively()检查）</li>
<li>移动等待队列首节点到同步队列并使用LockSupport唤醒节点中的线程</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前线程获取到了锁的线程</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 获取等待队列的首节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 移动到同步队列并使用LockSupport唤醒节点中的线程</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/condition4.png" alt="condition4"></p>
<p>》 <code>Condition</code>的signalAll()<code>方法</code>，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>
<h1 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a>管道输入/输出流</h1><p>》 主要用于线程之间的数据传输,而传输的媒介为内存,管道输入/输出流主要包括了如下4种具体实现:</p>
<ol>
<li>PipedOutputStream</li>
<li>PipedInputStream、</li>
<li>PipedReader</li>
<li>PipedWriter</li>
</ol>
<p>》 输入/输出流必须绑定起来,也就是调用<code>connect()</code>方法,否则会抛出异常</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将输出流和输入流进行连接,否则在使用时会抛出IOException</span></span><br><span class="line">aPipedWriter.connect(aPipedReader);</span><br></pre></td></tr></table></figure></div>
<h1 id="java并发中的集合"><a href="#java并发中的集合" class="headerlink" title="java并发中的集合"></a>java并发中的集合</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>》 为什么要使用ConcurrentHashMap？</p>
<ol>
<li>线程不安全的HashMap会引起死循环</li>
<li>用线程安全的HashTable效率又非常低下（线程都竞争同一把锁）</li>
<li>java 1.8中的CurrentHashMap有了较大的不同（以下介绍的是java 7 的版本）</li>
</ol>
<p><a href="https://juejin.im/post/5a66a08d5188253dc3321da0" target="_blank" rel="noopener">》  HashMap会引起死循环</a></p>
<p>》 ConcurrentHashMap的锁分段技术</p>
<ul>
<li>数据分段存储，并为每段数据配锁</li>
<li>当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li>
</ul>
<p>》 concurrentHashMap类图</p>
<ol>
<li>由Segment数组结构和HashEntry数组结构组成</li>
<li>Segment是一种可重入锁（ReentrantLock）,包含一个HashEntry数组</li>
<li>HashEntry则用于存储键值对数据</li>
<li>当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/concurrentHashMap.png" alt="concurrentHashMap"></p>
<h3 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h3><p>》 ConcurrentHashMap初始化方法是通过<code>initialCapacity、loadFactor和concurrencyLevel</code>等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的</p>
<h4 id="初始化segments数组、segmentShift和segmentMask"><a href="#初始化segments数组、segmentShift和segmentMask" class="headerlink" title="初始化segments数组、segmentShift和segmentMask"></a>初始化segments数组、segmentShift和segmentMask</h4><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//segments长度</span></span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度 (为了能通过按位与的散列算法来定位segments数组的索引)</span></span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;<span class="comment">//ssize从1向左移位的次数</span></span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;<span class="comment">//用于定位参与散列运算的位数（之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的）</span></span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;<span class="comment">//散列运算的掩码（掩码的二进制各个位的值都是1）</span></span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure></div>
<p>》 concurrencyLevel的最大值是65535，这意味着segments数组的长度最大为65536，对应的二进制是16位;所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1</p>
<h4 id="初始化每个segment"><a href="#初始化每个segment" class="headerlink" title="初始化每个segment"></a>初始化每个segment</h4><p>》 segment的容量 threshold = （int）cap*loadFactor</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initialCapacity是ConcurrentHashMap的初始化容量,默认16 </span></span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;<span class="comment">//变量cap就是segment里HashEntry数组的长度,大小为2^c [c∈(0,n)]</span></span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line">    <span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);<span class="comment">//，loadfactor是每个segment的负载因子，默认0.75</span></span><br></pre></td></tr></table></figure></div>
<h4 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h4><p>》 虽然ConcurrentHashMap在插入和获取元素的时候，必须先通过散列算法定位到Segment,才能使用不同段的数据。ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再散列</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 ConcurrentHashMap通过以下散列算法定位segment</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到散列运算中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 此外，定位HashEntry所使用的hash算法如下</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>
<h3 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h3><p>》 ConcurrentHashMap的3种操作</p>
<ol>
<li>get操作</li>
<li>put操作</li>
<li>size操作</li>
</ol>
<h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><p>》 get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先进行一次再散列</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="comment">//再使用使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素</span></span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 为什么get方法不用加锁？</p>
<ul>
<li>是它的get方法里将要使用的共享变量都定义成了volatile类型</li>
<li>根据ava内存模型的happen before原则，对volatile字段的写入操作先于读操作</li>
</ul>
<h4 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h4><p>》 put方法里需要对共享变量进行写入操作，在操作共享变量时必须加锁，其逻辑如下</p>
<ol>
<li>首先定位到Segment，然后在Segment里进行插入操作</li>
<li>第一步判断是否需要对Segment里的HashEntry数组进行扩容(在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold）)</li>
<li>第二步定位添加元素的位置，然后将其放在HashEntry数组里</li>
</ol>
<p>》 如何扩容?</p>
<ul>
<li>创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里(对Segment的扩容)</li>
</ul>
<h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>》 要计算CurrentHashMap的大小，需要将Segment里的全局变量count累计相加，count是一个volatile变量，在获取时将得到最新的数据，但在计算相加前可能发生改变。</p>
<p>》 ConcurrentHashMap的做法如下</p>
<ul>
<li>先尝试2次通过不锁住Segment的方式来统计各个Segment大小</li>
<li>如果果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小</li>
<li>通过使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化</li>
</ul>
<h1 id="Java并发中的队列"><a href="#Java并发中的队列" class="headerlink" title="Java并发中的队列"></a>Java并发中的队列</h1><p>》 实现一个线程安全的队列有两种方式：</p>
<ul>
<li><p>使用阻塞算法（可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现）</p>
</li>
<li><p>使用非阻塞算法(用循环CAS的方式来实现)</p>
</li>
</ul>
<h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>》 ConcurrentLinkedQueue</p>
<ul>
<li>基于链接节点的无界线程安全队列</li>
<li>FIFO规则排序</li>
<li>采用了“wait-free”算法（即CAS算法）来实现</li>
</ul>
<p>》 concurrentLinkedQueue类图</p>
<ul>
<li>由head节点和tail节点组成</li>
<li>每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成</li>
<li>默认情况下head节点存储的元素为空，tail节点等于head节点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/concurrentLinkedQueue.png" alt="concurrentLinkedQueue"></p>
<h4 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h4><p>》 首先要理解入队操作(java入队操作与数据结构算法中的有些不同)</p>
<ol>
<li>一个空的队列，插入节点A，Head.next设置为节点A，tail默认与head节点相同，也指向A</li>
<li>添加第二个节点B,节点A.next设置为节点B，同时更新tail指向节点B</li>
<li>添加第三个节点C，节点B.next设置为节点C</li>
<li>添加第四个节点D，节点C.next设置为节点D，同时更新tail指向节点D</li>
<li>可以看出，tail节点有可能不是尾节点(重点)</li>
</ol>
<p>》 个入队过程逻辑如下</p>
<ol>
<li>定位出尾节点(tail节点或者tail.next是尾节点)</li>
<li>使用CAS算法将入队节点设置成尾节点的next节点，如不成功则重试</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">        Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        retry:</span><br><span class="line">        <span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">            Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">            Node&lt;E&gt; p = t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">        <span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">                Node&lt;E&gt; next = succ(p);</span><br><span class="line">        <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">                    <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                    p = next;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;</span><br><span class="line">        <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class="line">                    <span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">                        casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p = succ(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>》 为什么ConcurrentLinkedQueue入队不是每次都变化tail节点?</p>
<ol>
<li>减少CAS更新tail节点的次数，能提高入队的效率</li>
<li>ConcurrentLinkedQueue使用hops变量来控制并减少tail节点的更新频率</li>
<li>hops变量相当于tail与尾节点的长度，如果大于等于HOPS(默认1)，才更新节点</li>
<li>tail与尾节点越长，那么更新tail节点操作就越少，但是相对的每次定位到尾节点需要读取更多的节点（相当于通过添加对volatile变量的读操作减少写操作，而读操作开销要远远小于写操作，从而得到提升）</li>
</ol>
<p>》 入队方法永远返回true，所以不能靠返回值判断是否入队成功</p>
<h4 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h4><p>》 逻辑如下</p>
<ol>
<li>与入队列相同，通过hops来减少更新head节点操作</li>
<li>head 节点内有元素，则弹出元素</li>
<li>head节点为空，弹出head.next,更新head节点</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line"><span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">        Node&lt;E&gt; p = h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line"><span class="comment">// 获取p节点的元素</span></span><br><span class="line">            E item = p.getItem();</span><br><span class="line"><span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</span></span><br><span class="line"><span class="comment">// 如果成功则返回p节点的元素。</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS) &#123;</span><br><span class="line"><span class="comment">// 将p节点下一个节点设置成head节点</span></span><br><span class="line">                    Node&lt;E&gt; q = p.getNext();</span><br><span class="line">                    updateHead(h, (q != <span class="keyword">null</span>)q :p);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</span></span><br><span class="line"><span class="comment">// 一个线程修改了。那么获取p节点的下一个节点</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line"><span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 更新头节点。</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="阻塞队列（BlockingQueue）"><a href="#阻塞队列（BlockingQueue）" class="headerlink" title="阻塞队列（BlockingQueue）"></a>阻塞队列（BlockingQueue）</h2><p>》 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞<br>的插入和移除方法。</p>
<ol>
<li>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满</li>
<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空</li>
<li>常用于生产者和消费者的场景</li>
</ol>
<p>》 在阻塞队列不可用时，这两个附加操作提供了4种处理方式</p>
<ol>
<li>抛出异常：队列满，再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常；队列空，当队列空时，从队列里获取元素会抛出NoSuchElementException异常</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null</li>
<li>一直阻塞：队列满，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空</li>
<li>·超时退出：队列满，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出；队列空，抛出元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/BlockingQueue.png" alt="BlockingQueue"></p>
<p>》 如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true。</p>
<p>》 JDK 7提供了7个阻塞队列</p>
<ol>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ol>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>》 ArrayBlockingQueue:</p>
<ul>
<li>由数组结构组成的有界阻塞队列</li>
<li>此队列按照先进先出（FIFO）的原则对元素进行排序</li>
<li>默认不保证线程公平的访问队列</li>
</ul>
<p>》 创建一个公平的阻塞队列(即先阻塞先访问)</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></div>
<p>》 访问者的公平性是使用可重入锁实现的</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>》 LinkedBlockingQueue</p>
<ul>
<li>用链表实现的有界阻塞队列</li>
<li>默认和最大长度为Integer.MAX_VALUE</li>
<li>FIFO</li>
</ul>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p> 》 PriorityBlockingQueue</p>
<ul>
<li>支持优先级的无界阻塞队列</li>
<li>默认情况下元素采取自然顺序升序排列</li>
<li>可以自定义类实现compareTo()方法来指定元素排序规则;也可以初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序</li>
<li>但不能保证同优先级元素的顺序</li>
</ul>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>》 DelayQueue</p>
<ul>
<li>支持延时获取元素的无界阻塞队列</li>
<li>使用PriorityQueue来实现，</li>
<li>队列中的元素必须实现Delayed接口</li>
<li>在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</li>
</ul>
<p>》 应用场景</p>
<ul>
<li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li>
<li>定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</li>
</ul>
<h4 id="实现Delayed接口"><a href="#实现Delayed接口" class="headerlink" title="实现Delayed接口"></a>实现Delayed接口</h4><p>》 第一步，在对象创建的时候，初始化基本数据</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;<span class="comment">//time记录当前对象延迟到什么时候可以使用</span></span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();<span class="comment">//sequenceNumber来标识元素在队列中的先后顺序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 第二步，实现getDelay方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法返回当前元素还需要延时多长时间，单位是纳秒(注意当time小于当前时间时，getDelay会返回负数)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》 第三步，实现compareTo方法来指定元素的顺序</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="keyword">this</span>)　　<span class="comment">// compare zero ONLY if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">            ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other;</span><br><span class="line">            <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) -</span><br><span class="line">                other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">        <span class="keyword">return</span> (d == <span class="number">0</span>) <span class="number">0</span> : ((d &lt; <span class="number">0</span>) -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="实现延时阻塞队列"><a href="#实现延时阻塞队列" class="headerlink" title="实现延时阻塞队列"></a>实现延时阻塞队列</h4><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> q.poll();</span><br><span class="line"><span class="comment">//leader：等待获取队列头部元素的线程</span></span><br><span class="line"><span class="comment">//如果leader不等于空，表示已经有线程在等待获取队列的头元素,使用await()方法让当前线程等待信号</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">    available.await();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间</span></span><br><span class="line">    Thread thisThread = Thread.currentThread();</span><br><span class="line">    leader = thisThread;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        available.awaitNanos(delay);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>》 SynchronousQueue</p>
<ul>
<li>不存储元素的阻塞队列</li>
<li>每一个put操作必须等待一个take操作，否则不能继续添加元素</li>
<li>支持公平访问队列,默认非公平访问</li>
<li>非常适合传递性场景</li>
<li>吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue</li>
</ul>
<p>》 创建公平性访问的SynchronousQueue</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fair == true -&gt; 公平访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>》 LinkedTransferQueue</p>
<ul>
<li>由链表结构组成的无界阻塞TransferQueue队列</li>
<li>相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</li>
</ul>
<h4 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h4><p>》 transfer方法</p>
<ul>
<li>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者;。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试把存放当前元素的s节点作为tail节点</span></span><br><span class="line">Node pred = tryAppend(s, haveData);</span><br><span class="line"><span class="comment">//让CPU自旋等待消费者消费元素（自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。）</span></span><br><span class="line"><span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br></pre></td></tr></table></figure></div>
<h4 id="tryTransfer方法"><a href="#tryTransfer方法" class="headerlink" title="tryTransfer方法"></a>tryTransfer方法</h4><p>》 用来试探生产者传入的元素是否能直接传给消费者</p>
<ul>
<li>如果没有消费者等待接收元素，则返回false</li>
<li>如果消费了元素，则返回true</li>
<li>该方法无论消费者是否接收，方法立即返回；，而transfer方法是必须等到消费者消费了才返回</li>
</ul>
<p>》 此外还有带有时间限制的tryTransfer（E e，long timeout，TimeUnit unit）方法</p>
<ul>
<li>试图把生产者传入的元素直接传给消费者</li>
<li>如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false</li>
<li>如果在超时时间内消费了元素，则返回true。</li>
</ul>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>》 LinkedBlockingDeque</p>
<ul>
<li>由链表结构组成的双向阻塞队列</li>
<li>因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争</li>
<li>相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法</li>
<li>在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。</li>
<li>双向阻塞队列可以  运用在“工作窃取”模式中。</li>
</ul>
<h2 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h2><p>》 在JDK中，使用通知模式实现;所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用</p>
<p>todo</p>
<h1 id="Java中的13个原子操作类"><a href="#Java中的13个原子操作类" class="headerlink" title="Java中的13个原子操作类"></a>Java中的13个原子操作类</h1><p>》 Java从JDK 1.5开始提供了<code>java.util.concurrent.atomic</code>包,一共包含13个类，属于4种类型的原子更新方式，分别是</p>
<ol>
<li>原子更新基本类型</li>
<li>原子更新数组</li>
<li>原子更新引用</li>
<li>原子更新属性（字段）</li>
</ol>
<p>》 Atomic包里的类基本都是使用Unsafe实现的包装类</p>
<h2 id="原子更新基本类型类"><a href="#原子更新基本类型类" class="headerlink" title="原子更新基本类型类"></a>原子更新基本类型类</h2><p>》 Atomic包提供了以下3个类</p>
<ol>
<li>AtomicBoolean：原子更新布尔类型。</li>
<li>AtomicInteger：原子更新整型。</li>
<li>AtomicLong：原子更新长整</li>
</ol>
<p>》 以AtomicIntege为例,常用方法如下</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</span></span><br><span class="line"><span class="keyword">int</span> addAndGet（<span class="keyword">int</span> delta）</span><br><span class="line"><span class="comment">//update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</span></span><br><span class="line"><span class="keyword">boolean</span> compareAndSet（<span class="keyword">int</span> expect，<span class="keyword">int</span> update）</span><br><span class="line"><span class="comment">//以原子方式将当前值加1，注意，这里返回的是自增前的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> lazySet（<span class="keyword">int</span> newValue）</span></span><br><span class="line"><span class="function"><span class="comment">//以原子方式设置为newValue的值，并返回旧值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> getAndSet（<span class="keyword">int</span> newValue）</span></span><br></pre></td></tr></table></figure></div>
<h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p>》 Atomic包提供了以下3个类</p>
<ol>
<li>AtomicIntegerArray：原子更新整型数组里的元素。</li>
<li>AtomicLongArray：原子更新长整型数组里的元素。</li>
<li>AtomicReferenceArray：原子更新引用类型数组里的元素。</li>
</ol>
<p>》 以AtomicIntegerArray为例，其主要是提供原子的方式更新数组里的整型，常用方法如下</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以原子方式将输入值与数组中索引i的元素相加。</span></span><br><span class="line"><span class="keyword">int</span> addAndGet（<span class="keyword">int</span> i，<span class="keyword">int</span> delta）：</span><br><span class="line"><span class="comment">//如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</span></span><br><span class="line"><span class="keyword">boolean</span> compareAndSet（<span class="keyword">int</span> i，<span class="keyword">int</span> expect，<span class="keyword">int</span> update）</span><br></pre></td></tr></table></figure></div>
<h2 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h2><p>》 Atomic包提供了以下3个类</p>
<ol>
<li>AtomicReference：原子更新引用类型。</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型</li>
</ol>
<h2 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h2><p>》 Atomic包提供了以下3个类</p>
<ol>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类</li>
</ol>
<h1 id="Java并发中的工具类"><a href="#Java并发中的工具类" class="headerlink" title="Java并发中的工具类"></a>Java并发中的工具类</h1><h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><p>》在JDK的并发包里提供了几个非常有用的并发工具类</p>
<ol>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>Exchanger</li>
</ol>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>》CountDownLatch允许一个或多个线程等待其他线程完成操作。</p>
<p>todo</p>
<h2 id="LockSupport工具类"><a href="#LockSupport工具类" class="headerlink" title="LockSupport工具类"></a>LockSupport工具类</h2><p>》当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作;LockSupport定义了一组静态方法，以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程</p>
<p>》LockSupport提供的阻塞和唤醒方法</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/locksupport.png" alt="locksupport"></p>
<p>》java6 添加</p>
<ol>
<li>park(Object blocker)</li>
<li>parkNanos(Object blocker,long nanos)</li>
<li>parkUn   til(Object blocker,long deadline)</li>
<li>用于实现阻塞当前线程的功能,blocker是用来标识当前线程在等待的对象(阻塞对象),该对象主要用于问题排查和系统监控(能传递更多的信息)，可以通过dump 线程来对比</li>
</ol>
<h1 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h1><p>》线程池能够带来3个好处</p>
<ol>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ol>
<h2 id="线程池的初始化"><a href="#线程池的初始化" class="headerlink" title="线程池的初始化"></a>线程池的初始化</h2><p>》ThreadPoolExecutor是Java提供的一个核心的线程池,通过它来创建一个线程池</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(     <span class="keyword">int</span> corePoolSize,</span><br><span class="line">                            <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                            <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                            TimeUnit unit,</span><br><span class="line">                            BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                            ThreadFactory threadFactory,</span><br><span class="line">                            RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure></div>
<p>》其参数定义如下</p>
<p>》corePoolSize</p>
<ul>
<li>线程池的基本大小</li>
<li>任务数在小于它时每提交一个任务就会创建一个新的线程（无论其他线程是否空闲）</li>
<li>当任务数大于它时，不会再创建线程</li>
<li>可以使用prestartAllCoreThreads()方法提前创建并开启所有基本线程</li>
</ul>
<p>》maximumPoolSize</p>
<ul>
<li>线程池最大数量</li>
<li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务</li>
<li>使用了无界的任务队列此参数失效</li>
</ul>
<p>》keepAliveTime</p>
<ul>
<li>线程活动保持时间</li>
<li>线程池的工作线程空闲后，保持存活的时间</li>
<li>任务多时且执行时间短，可以调大它提高线程利用率</li>
</ul>
<p>》TimeUnit</p>
<ul>
<li>线程活动保持时间的单位</li>
<li>可选单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）</li>
</ul>
<p>》BlockingQueue</p>
<ul>
<li>任务队列</li>
<li>用于保存等待执行的任务的阻塞队列</li>
<li>可以选择阻塞队列的有：ArrayBlockingQueue、SynchronousQueue、LinkedBlockingQueue、PriorityBlockingQueue</li>
</ul>
<p>》ThreadFactory</p>
<ul>
<li>创建线程的工厂</li>
<li>可以通过线程工厂给每个创建出来的线程设  置更有意义的名字</li>
<li>(使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字)</li>
</ul>
<p>》RejectedExecutionHandler</p>
<ul>
<li>饱和策略</li>
<li>在队列和线程池都满情况下使用，可选策略有</li>
<li>AbortPolicy，表示无法处理新任务时抛出异常,默认</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</li>
<li>DiscardPolicy：不处理，丢弃掉</li>
<li>也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略</li>
</ul>
<h2 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h2><p>》可以使用两个方法向线程池提交任务</p>
<ol>
<li>execute()：提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功</li>
<li>submit()：提交需要返回值的任务，线程池会返回一个Future类型的对象，</li>
</ol>
<p>》Future：</p>
<ul>
<li>通过该对象可以判断任务是否执行成功</li>
<li>可以通过future的get()方法来获取返回值，get()方法造成阻塞</li>
<li>可以使用超时方法get（long timeout，TimeUnit unit）</li>
</ul>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>》可以通过调用线程池提供的两个方法来关闭线程池</p>
<ol>
<li>shutdown：只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程（通常使用）</li>
<li>shutdownNow：将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表（如果任务无需执行完成，则可以使用）</li>
<li>原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程(无法响应中断的任务可能永远无法终止)</li>
</ol>
<p>》判断是否关闭</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行shutdown()和shutdownNow后就会返回true</span></span><br><span class="line">aThreadPoolExecutor.isShutdown()</span><br><span class="line"><span class="comment">//执行shutdown()和shutdownNow后,且任务全部关闭才返回true</span></span><br><span class="line">aThreadPoolExecutor.isTerminaed()</span><br></pre></td></tr></table></figure></div>
<h2 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h2><p>》要想合理地配置线程池，就必须首先分析任务特性</p>
<ol>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</li>
<li>任务的优先级：高、中和低。</li>
<li>任务的执行时间：长、中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接</li>
</ol>
<p>》建议使用有界队列</p>
<h2 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h2><p>》监控线程池的时候可以使用以下属性</p>
<ol>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li>
<li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li>
<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li>
<li>getActiveCount：获取活动的线程数。</li>
</ol>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>》线程池的处理逻辑</p>
<ol>
<li>判断核心线程池里的线程是否都在执行任务；否，则创建新的线程来执行任务；是，则进入2</li>
<li>判断工作队列是否已经满；否，则将新提交的任务存储在这个工作队列里；是，则进入3</li>
<li>判断线程池的线程是否都处于工作状态;否，则创建一个新的工作线程来执行任务；是，则交给饱和策略来处理这个任务</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/xcc.png" alt="xcc"></p>
<p>》执行过程(ThreadPoolExecutor为例)</p>
<ol>
<li>判断：如果当前运行的线程数n与corePoolSize<br>如果n &lt; corePoolSize 则创建新线程来执行任务（执行这一步骤需要获取全局锁）;结束；<br>如果n &gt;= corePoolSize,则将任务加入BlockingQueue,进行下一步判断</li>
<li>判断：BlockingQueue是否已满<br>否则，则将任务加入队列中;结束；<br>如果队列已满，则需要创建新的线程来处理任务（需要获取全局锁）;继续判断</li>
<li>判断：创建新进程后进程数是否超出maximumPoolSize<br>是，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法<br>否，则创建线程，结束</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/scc2.png" alt="scc2"> </p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务</span></span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            <span class="comment">// 抛出RejectedExecutionException异常</span></span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>》线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Woker类的run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable task = firstTask;</span><br><span class="line">            firstTask = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                runTask(task);</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerDone(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>》线程池中的线程执行任务分两种情况</p>
<ol>
<li>在execute()方法中创建一个线程时，会让这个线程执行当前任务</li>
<li>线程执行完任务后，会反复从BlockingQueue获取任务来执行。</li>
</ol>
<h1 id="Java框架"><a href="#Java框架" class="headerlink" title="Java框架"></a>Java框架</h1><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>》 Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>》 工作窃取（work-stealing）算法</p>
<ul>
<li>指某个线程从其他队列里窃取任务来执行.</li>
<li>通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行</li>
<li>窃取任务的线程永远从双端队列的尾部拿任务执行</li>
<li>优点:充分利用线程进行并行计算，减少了线程间的竞争</li>
<li>缺点:在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列</li>
</ul>
<h4 id="Fork-Join框架的设计"><a href="#Fork-Join框架的设计" class="headerlink" title="Fork/Join框架的设计"></a>Fork/Join框架的设计</h4><p>》 步骤</p>
<ol>
<li>分割任务，通过fork类将任务切割成足够小的子任务</li>
<li>执行任务并合并结果，子任务放入双端队列中，多个线程从队列中获取；子任务执行结果放在同一个队列里，启动一个线程合并结果</li>
</ol>
<p>》 Fork/Join使用两个类完成任务</p>
<ol>
<li>ForkJoinTask,创建ForkJoin任务，提供fork()和join()方法,一般继承它的子类<br>RecursiveAction：用于没有返回结果的任务。<br>RecursiveTask：用于有返回结果的任</li>
<li>ForkJoinPool,ForkJoinTask需要通过ForkJoinPool来执行</li>
</ol>
<p>》 任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p>
<h3 id="使用Fork-Join框架"><a href="#使用Fork-Join框架" class="headerlink" title="使用Fork/Join框架"></a>使用Fork/Join框架</h3><p>》 以计算1+2+3+4的结果为例</p>
<ol>
<li>假设每个子任务最多执行两个数的相加，则设置分割的阈值是2</li>
<li>因为是有结果的任务，所以必须继承RecursiveTask</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;　　<span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line"><span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"><span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult=leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult=rightTask.join();</span><br><span class="line"><span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"><span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="Fork-Join框架的异常处理"><a href="#Fork-Join框架的异常处理" class="headerlink" title="Fork/Join框架的异常处理"></a>Fork/Join框架的异常处理</h3><p>》 检查任务是否已经抛出异常或已经被取消</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aForkJoinTask.isCompletedAbnormally()</span><br></pre></td></tr></table></figure></div>
<p>》 获取异常</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回Throwable对象，如果任务被取消了则返回CancellationException;任务没有完成或者没有抛出异常则返回null</span></span><br><span class="line">aForkJoinTask.getException()</span><br></pre></td></tr></table></figure></div>
<h3 id="Fork-Join框架的实现原理"><a href="#Fork-Join框架的实现原理" class="headerlink" title="Fork/Join框架的实现原理"></a>Fork/Join框架的实现原理</h3><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>》 在JDK 5之前，java线程既是工作单元，也是执行机制，JDK 5之后把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供,其内部使用了线程池机制,通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作</p>
<h3 id="Executor框架的两级调度模型"><a href="#Executor框架的两级调度模型" class="headerlink" title="Executor框架的两级调度模型"></a>Executor框架的两级调度模型</h3><p>》 在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。</p>
<p>》 如图所示</p>
<ul>
<li>上层：ava多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程</li>
<li>底层：操作系统内核将这些线程映射到硬件处理器CPU上</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/executor.png" alt="executor"></p>
<h3 id="Executor框架的成员"><a href="#Executor框架的成员" class="headerlink" title="Executor框架的成员"></a>Executor框架的成员</h3><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>》 ThreadPoolExecutor：</p>
<ul>
<li>线程池的核心实现类</li>
<li>用来执行被提交的任务。</li>
<li>通常使用工厂类Executors来创建</li>
</ul>
<p>》 ThreadPoolExecutor主要由下列4个组件构成。</p>
<ol>
<li>corePool：核心线程池的大小。</li>
<li>maximumPool：最大线程池的大小。</li>
<li>BlockingQueue：用来暂时保存任务的工作队列</li>
<li>RejectedExecutionHandler：当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已经饱和时（达到了最大线程池大小且工作队列已满），execute()方法将要调用的Handler</li>
</ol>
<p>》 Executors可以创建3种类型的ThreadPoolExecutor</p>
<ol>
<li>FixedThreadPool：创建使用固定线程数的FixedThreadPool(适用于负载比较重的服务器)</li>
<li>SingleThreadExecutor：创建使用单个线程的SingleThreadExecutor（适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。）</li>
<li>CachedThreadPoo：创建一个会根据需要创建新线程的CachedThreadPool（大小无界线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。）</li>
</ol>
<h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                nThreads, </span><br><span class="line">                nThreads,</span><br><span class="line">                <span class="number">0L</span>, <span class="comment">//keepAliveTime设置为0L，意味着多余的空闲线程会被立即终止</span></span><br><span class="line">                TimeUnit.MILLISECONDS, </span><br><span class="line">                <span class="keyword">new</span> inkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p>》 ScheduledThreadPoolExecutor</p>
<ul>
<li>线程池实现类</li>
<li>可以在给定的延迟后运行命令，或者定期执行命令</li>
<li>通常使用工厂类Executors来创建</li>
</ul>
<p>》 Executors可以创建2种类型的ScheduledThreadPoolExecutor</p>
<ol>
<li>ScheduledThreadPoolExecutor：，创建固定个数线程的ScheduledThreadPoolExecutor(适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景)</li>
<li>SingleThreadScheduledExecutor：创建单个线程的ScheduledThreadPoolExecutor(适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。)</li>
</ol>
<h2 id="Future接口和实现Future接口的FutureTask类"><a href="#Future接口和实现Future接口的FutureTask类" class="headerlink" title="Future接口和实现Future接口的FutureTask类"></a>Future接口和实现Future接口的FutureTask类</h2><p>》 Future接口和实现Future接口的FutureTask类</p>
<ul>
<li>表示异步计算的结果</li>
<li>通过sumbit()提交给线程池后返回该类型的数据</li>
</ul>
<h2 id="Runnable接口和Callable接口"><a href="#Runnable接口和Callable接口" class="headerlink" title="Runnable接口和Callable接口"></a>Runnable接口和Callable接口</h2><p>》 Runnable接口和Callable接口</p>
<ul>
<li>可以被ThreadPoolExecutor或Scheduled-ThreadPoolExecutor执行</li>
<li>Runnable不会返回结果</li>
<li>Callable可以返回结果</li>
<li>工具类Executors可以把一个Runnable对象封装为一个Callable对象</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Runnable-&gt;Callable</span></span><br><span class="line"><span class="comment">// sumbit后返回null</span></span><br><span class="line">Executors.callable（Runnable task）</span><br><span class="line"><span class="comment">// sumbit 后返回result</span></span><br><span class="line">Executors.callable（Runnable task，Object result）</span><br></pre></td></tr></table></figure></div>
<p>任务的执行：  </p>
<h2 id="Executor框架的使用"><a href="#Executor框架的使用" class="headerlink" title="Executor框架的使用"></a>Executor框架的使用</h2><p>示意图</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/thread/executor2.png" alt="executor2"></p>
<p>》 执行流程</p>
<ol>
<li>主线程创建实现Runnable或者Callable接口的任务对象</li>
<li>Runnable对象直接交给ExecutorService执行;或者把Runnable对象或Callable对象提交给ExecutorService执行</li>
</ol>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接执行</span></span><br><span class="line">ExecutorService.execute（Runnablecommand）;</span><br><span class="line"><span class="comment">//提交,会返回实现Future接口的对象（一般是FutureTask对象）</span></span><br><span class="line"><span class="comment">//FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。</span></span><br><span class="line">Executor-Service.submit（Runnable task）</span><br><span class="line">ExecutorService.submit（Callable&lt;T&gt;task）</span><br></pre></td></tr></table></figure></div>
<ol start="3">
<li>主线程可以执行FutureTask.get()方法来等待任务执行完成。主也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</li>
</ol>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/java-并发/" rel="tag"># java 并发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2018/02/02/java.all/" rel="next" title="java 基础">
                <i class="fa fa-chevron-left"></i> java 基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2018/02/04/jvm.all/" rel="prev" title="JVM">
                JVM <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/toux.jpg" alt="Liisyu">
            
              <p class="site-author-name" itemprop="name">Liisyu</p>
              <div class="site-description motion-element" itemprop="description">我只是一个兴趣使然的程序员</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/blog/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/blog/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/blog/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:575600714@qq.com.com" title="E-Mail(QQ) &rarr; mailto:575600714@qq.com.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail(QQ)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:swordmaster2014@gmail.com" title="E-Mail(Google) &rarr; mailto:swordmaster2014@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>E-Mail(Google)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/FameLsy" title="GitHub &rarr; https://github.com/FameLsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/masorl" title="CSDN &rarr; https://blog.csdn.net/masorl" rel="noopener" target="_blank"><i class="fa fa-fw fa-tree"></i>CSDN</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="tencent://message/?uin=575600714&Site=qq&Menu=yes" title="QQ &rarr; tencent://message/?uin=575600714&Site=qq&Menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QQ</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://liisyu.gitee.io/cv/" title="简历 &rarr; http://liisyu.gitee.io/cv/" rel="noopener" target="_blank"><i class="fa fa-fw fa-user-o"></i>简历</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://messilessblog.com/" title="https://messilessblog.com/" rel="noopener" target="_blank">汪酱 BLOG</a>
                  </li>
                
              </ul>
			   
            </div>
          

          
            
          
          

    <div class="wechat-box">
      <div class="weixin-description">微信扫一扫，联系我</div>
	  <img src="/blog/images/wechat.jpg" alt="wechat">
    </div>


        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#线程基础"><span class="nav-number">1.</span> <span class="nav-text">线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程"><span class="nav-number">1.1.</span> <span class="nav-text">什么是线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的安全性"><span class="nav-number">1.2.</span> <span class="nav-text">线程的安全性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建线程"><span class="nav-number">1.3.</span> <span class="nav-text">创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过java-lang-Runnable接口-推荐"><span class="nav-number">1.3.1.</span> <span class="nav-text">通过java.lang.Runnable接口(推荐)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承java-lang-Thread"><span class="nav-number">1.3.2.</span> <span class="nav-text">继承java.lang.Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种方式的区别"><span class="nav-number">1.3.3.</span> <span class="nav-text">两种方式的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-源码解析"><span class="nav-number">1.4.</span> <span class="nav-text">Thread 源码解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动线程"><span class="nav-number">1.5.</span> <span class="nav-text">启动线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中断线程"><span class="nav-number">1.6.</span> <span class="nav-text">中断线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-join-的使用"><span class="nav-number">1.7.</span> <span class="nav-text">Thread.join()的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程其他方法"><span class="nav-number">1.8.</span> <span class="nav-text">线程其他方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal的使用"><span class="nav-number">1.9.</span> <span class="nav-text">ThreadLocal的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程状态"><span class="nav-number">2.</span> <span class="nav-text">线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NEW（新创建）状态"><span class="nav-number">2.1.</span> <span class="nav-text">NEW（新创建）状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RUNNABLE-可运行-状态"><span class="nav-number">2.2.</span> <span class="nav-text">RUNNABLE (可运行) 状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BLOCKED-（阻塞）状态"><span class="nav-number">2.3.</span> <span class="nav-text">BLOCKED （阻塞）状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WAITING-等待-状态"><span class="nav-number">2.4.</span> <span class="nav-text">WAITING (等待)状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIME-WAITING-计时等待-状态"><span class="nav-number">2.5.</span> <span class="nav-text">TIME_WAITING (计时等待)状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TERMINATER-终止-状态"><span class="nav-number">2.6.</span> <span class="nav-text">TERMINATER (终止)状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程状态的变迁"><span class="nav-number">2.7.</span> <span class="nav-text">线程状态的变迁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程的属性"><span class="nav-number">3.</span> <span class="nav-text">线程的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程优先级"><span class="nav-number">3.1.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#守护线程"><span class="nav-number">3.2.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未捕获异常处理器"><span class="nav-number">3.3.</span> <span class="nav-text">未捕获异常处理器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是竞争条件"><span class="nav-number">4.</span> <span class="nav-text">什么是竞争条件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#锁对象和条件对象"><span class="nav-number">5.</span> <span class="nav-text">锁对象和条件对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#锁对象"><span class="nav-number">5.1.</span> <span class="nav-text">锁对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件对象"><span class="nav-number">5.2.</span> <span class="nav-text">条件对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized关键字"><span class="nav-number">6.</span> <span class="nav-text">synchronized关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM中的synchronized"><span class="nav-number">6.1.</span> <span class="nav-text">JVM中的synchronized</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile关键字"><span class="nav-number">7.</span> <span class="nav-text">volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#正确使用-volatile-的模式"><span class="nav-number">7.1.</span> <span class="nav-text">正确使用 volatile 的模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#状态标志"><span class="nav-number">7.1.1.</span> <span class="nav-text">状态标志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一次性安全发布"><span class="nav-number">7.2.</span> <span class="nav-text">一次性安全发布</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#队列同步器-AbstractQueuedSynchronizer"><span class="nav-number">8.</span> <span class="nav-text">队列同步器(AbstractQueuedSynchronizer)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#同步器可重写的方法"><span class="nav-number">8.1.</span> <span class="nav-text">同步器可重写的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步器的模板方法"><span class="nav-number">8.2.</span> <span class="nav-text">同步器的模板方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列同步器的实现分析"><span class="nav-number">8.3.</span> <span class="nav-text">队列同步器的实现分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步队列"><span class="nav-number">8.3.1.</span> <span class="nav-text">同步队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#入队操作"><span class="nav-number">8.3.1.1.</span> <span class="nav-text">入队操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#出队操作"><span class="nav-number">8.3.1.2.</span> <span class="nav-text">出队操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#独占式同步状态获取与释放"><span class="nav-number">8.3.2.</span> <span class="nav-text">独占式同步状态获取与释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取流程"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">获取流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放流程"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">释放流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享式同步状态获取与释放"><span class="nav-number">8.3.3.</span> <span class="nav-text">共享式同步状态获取与释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取流程-1"><span class="nav-number">8.3.3.1.</span> <span class="nav-text">获取流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放流程-1"><span class="nav-number">8.3.3.2.</span> <span class="nav-text">释放流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#独占式超时获取同步状态"><span class="nav-number">8.3.4.</span> <span class="nav-text">独占式超时获取同步状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java中的锁"><span class="nav-number">9.</span> <span class="nav-text">Java中的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock-接口"><span class="nav-number">9.1.</span> <span class="nav-text">Lock 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重入锁-ReentrantLock"><span class="nav-number">9.2.</span> <span class="nav-text">重入锁(ReentrantLock)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现重进入"><span class="nav-number">9.2.1.</span> <span class="nav-text">实现重进入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写锁"><span class="nav-number">9.3.</span> <span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-number">9.3.1.</span> <span class="nav-text">ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁的实现分析"><span class="nav-number">9.3.2.</span> <span class="nav-text">读写锁的实现分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写状态的设计"><span class="nav-number">9.3.3.</span> <span class="nav-text">读写状态的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写锁的获取与释放"><span class="nav-number">9.3.4.</span> <span class="nav-text">写锁的获取与释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读锁的获取与释放"><span class="nav-number">9.3.5.</span> <span class="nav-text">读锁的获取与释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁降级"><span class="nav-number">9.3.6.</span> <span class="nav-text">锁降级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#等待-通知机制"><span class="nav-number">10.</span> <span class="nav-text">等待/通知机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#等待-通知经典范式"><span class="nav-number">10.1.</span> <span class="nav-text">等待/通知经典范式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Condition接口"><span class="nav-number">11.</span> <span class="nav-text">Condition接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition的（部分）方法以及描述"><span class="nav-number">11.1.</span> <span class="nav-text">Condition的（部分）方法以及描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#condition对比Object"><span class="nav-number">11.2.</span> <span class="nav-text">condition对比Object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition的实现分析"><span class="nav-number">11.3.</span> <span class="nav-text">Condition的实现分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#等待队列"><span class="nav-number">11.3.1.</span> <span class="nav-text">等待队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待"><span class="nav-number">11.3.2.</span> <span class="nav-text">等待</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通知"><span class="nav-number">11.3.3.</span> <span class="nav-text">通知</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#管道输入-输出流"><span class="nav-number">12.</span> <span class="nav-text">管道输入/输出流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java并发中的集合"><span class="nav-number">13.</span> <span class="nav-text">java并发中的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">13.1.</span> <span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap的初始化"><span class="nav-number">13.1.1.</span> <span class="nav-text">ConcurrentHashMap的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化segments数组、segmentShift和segmentMask"><span class="nav-number">13.1.1.1.</span> <span class="nav-text">初始化segments数组、segmentShift和segmentMask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化每个segment"><span class="nav-number">13.1.1.2.</span> <span class="nav-text">初始化每个segment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定位Segment"><span class="nav-number">13.1.1.3.</span> <span class="nav-text">定位Segment</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap的操作"><span class="nav-number">13.1.2.</span> <span class="nav-text">ConcurrentHashMap的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#get操作"><span class="nav-number">13.1.2.1.</span> <span class="nav-text">get操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put-操作"><span class="nav-number">13.1.2.2.</span> <span class="nav-text">put 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#size操作"><span class="nav-number">13.1.2.3.</span> <span class="nav-text">size操作</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java并发中的队列"><span class="nav-number">14.</span> <span class="nav-text">Java并发中的队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#非阻塞队列"><span class="nav-number">14.1.</span> <span class="nav-text">非阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-number">14.1.1.</span> <span class="nav-text">ConcurrentLinkedQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#入队列"><span class="nav-number">14.1.1.1.</span> <span class="nav-text">入队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#出队列"><span class="nav-number">14.1.1.2.</span> <span class="nav-text">出队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞队列（BlockingQueue）"><span class="nav-number">14.2.</span> <span class="nav-text">阻塞队列（BlockingQueue）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">14.2.1.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">14.2.2.</span> <span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityBlockingQueue"><span class="nav-number">14.2.3.</span> <span class="nav-text">PriorityBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DelayQueue"><span class="nav-number">14.2.4.</span> <span class="nav-text">DelayQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现Delayed接口"><span class="nav-number">14.2.4.1.</span> <span class="nav-text">实现Delayed接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现延时阻塞队列"><span class="nav-number">14.2.4.2.</span> <span class="nav-text">实现延时阻塞队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SynchronousQueue"><span class="nav-number">14.2.5.</span> <span class="nav-text">SynchronousQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedTransferQueue"><span class="nav-number">14.2.6.</span> <span class="nav-text">LinkedTransferQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#transfer方法"><span class="nav-number">14.2.6.1.</span> <span class="nav-text">transfer方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tryTransfer方法"><span class="nav-number">14.2.6.2.</span> <span class="nav-text">tryTransfer方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedBlockingDeque"><span class="nav-number">14.2.7.</span> <span class="nav-text">LinkedBlockingDeque</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞队列的实现原理"><span class="nav-number">14.3.</span> <span class="nav-text">阻塞队列的实现原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java中的13个原子操作类"><span class="nav-number">15.</span> <span class="nav-text">Java中的13个原子操作类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原子更新基本类型类"><span class="nav-number">15.1.</span> <span class="nav-text">原子更新基本类型类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子更新数组"><span class="nav-number">15.2.</span> <span class="nav-text">原子更新数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子更新引用类型"><span class="nav-number">15.3.</span> <span class="nav-text">原子更新引用类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子更新字段类"><span class="nav-number">15.4.</span> <span class="nav-text">原子更新字段类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java并发中的工具类"><span class="nav-number">16.</span> <span class="nav-text">Java并发中的工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#并发工具类"><span class="nav-number">16.1.</span> <span class="nav-text">并发工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">16.1.1.</span> <span class="nav-text">CountDownLatch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LockSupport工具类"><span class="nav-number">16.2.</span> <span class="nav-text">LockSupport工具类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java中的线程池"><span class="nav-number">17.</span> <span class="nav-text">Java中的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的初始化"><span class="nav-number">17.1.</span> <span class="nav-text">线程池的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向线程池提交任务"><span class="nav-number">17.2.</span> <span class="nav-text">向线程池提交任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关闭线程池"><span class="nav-number">17.3.</span> <span class="nav-text">关闭线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合理地配置线程池"><span class="nav-number">17.4.</span> <span class="nav-text">合理地配置线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的监控"><span class="nav-number">17.5.</span> <span class="nav-text">线程池的监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的实现原理"><span class="nav-number">17.6.</span> <span class="nav-text">线程池的实现原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java框架"><span class="nav-number">18.</span> <span class="nav-text">Java框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Fork-Join框架"><span class="nav-number">18.1.</span> <span class="nav-text">Fork/Join框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工作窃取算法"><span class="nav-number">18.1.1.</span> <span class="nav-text">工作窃取算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Fork-Join框架的设计"><span class="nav-number">18.1.1.1.</span> <span class="nav-text">Fork/Join框架的设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Fork-Join框架"><span class="nav-number">18.1.2.</span> <span class="nav-text">使用Fork/Join框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join框架的异常处理"><span class="nav-number">18.1.3.</span> <span class="nav-text">Fork/Join框架的异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join框架的实现原理"><span class="nav-number">18.1.4.</span> <span class="nav-text">Fork/Join框架的实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor框架"><span class="nav-number">18.2.</span> <span class="nav-text">Executor框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor框架的两级调度模型"><span class="nav-number">18.2.1.</span> <span class="nav-text">Executor框架的两级调度模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor框架的成员"><span class="nav-number">18.2.2.</span> <span class="nav-text">Executor框架的成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">18.2.2.1.</span> <span class="nav-text">ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FixedThreadPool"><span class="nav-number">18.2.2.2.</span> <span class="nav-text">FixedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SingleThreadExecutor"><span class="nav-number">18.2.2.3.</span> <span class="nav-text">SingleThreadExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CachedThreadPool"><span class="nav-number">18.2.2.4.</span> <span class="nav-text">CachedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledThreadPoolExecutor"><span class="nav-number">18.2.2.5.</span> <span class="nav-text">ScheduledThreadPoolExecutor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Future接口和实现Future接口的FutureTask类"><span class="nav-number">18.3.</span> <span class="nav-text">Future接口和实现Future接口的FutureTask类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runnable接口和Callable接口"><span class="nav-number">18.4.</span> <span class="nav-text">Runnable接口和Callable接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor框架的使用"><span class="nav-number">18.5.</span> <span class="nav-text">Executor框架的使用</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liisyu</span>

  

  
</div>






        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/blog/js/utils.js?v=7.1.0"></script>

  <script src="/blog/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/blog/js/schemes/muse.js?v=7.1.0"></script>



  
  <script src="/blog/js/scrollspy.js?v=7.1.0"></script>
<script src="/blog/js/post-details.js?v=7.1.0"></script>



  


  <script src="/blog/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/blog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

  <script type="text/javascript" src="/blog/js/clipboard.min.js"></script>  
  <script type="text/javascript" src="/blog/js/clipboard-use.js"></script>
</body>
</html>
