<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="DataStructure">
<meta property="og:type" content="article">
<meta property="og:title" content="DataStructure">
<meta property="og:url" content="https://famelsy.github.io/2018/02/17/DataStructure.all/index.html">
<meta property="og:site_name" content="Liisyu Blog">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-382608.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/array.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/array2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/array3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/stack.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/stack2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/queue.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/queue2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/queue3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/queue3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/hashtable.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/开放寻址.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/链表法.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/树2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/完全二叉树.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/满二叉树.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/链式存储法.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/顺序存储法.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/顺序存储法2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/二叉树遍历.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/二叉查找树.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/二叉查找树2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/二叉查找树3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/二叉树删除.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/重复插入.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/重复查找.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/重复删除.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/平衡二叉树.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/左右旋.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/case1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/case2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/case3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/M叉树.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树4.png">
<meta property="og:updated_time" content="2019-05-07T13:46:31.804Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DataStructure">
<meta name="twitter:image" content="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-382608.jpg">





  
  
  <link rel="canonical" href="https://famelsy.github.io/2018/02/17/DataStructure.all/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>DataStructure | Liisyu Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liisyu Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-navigation">

    
    
    
      
    

    

    <a href="/navigation/" rel="section"><i class="menu-item-icon fa fa-fw fa-diamond"></i> <br>导航</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://famelsy.github.io/2018/02/17/DataStructure.all/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liisyu">
      <meta itemprop="description" content="我只是一个兴趣使然的程序员">
      <meta itemprop="image" content="/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liisyu Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">DataStructure

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-18 00:00:01" itemprop="dateCreated datePublished" datetime="2018-02-18T00:00:01+08:00">2018-02-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-07 21:46:31" itemprop="dateModified" datetime="2019-05-07T21:46:31+08:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DataStructure/" itemprop="url" rel="index"><span itemprop="name">DataStructure</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/Fullmetal%20Alchemist/wallhaven-382608.jpg" alt></p>
<a id="more"></a>
<h1 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h1><h2 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h2><p>数组（Array）：是一种 线性表 数据结构，用一组 连续 的内存空间，来存储一组具有相同类型的数据</p>
<p>数组两大关键概念</p>
<ul>
<li>线性表：即数据成直线一样的结构，每个线性表上的数据可访问前后两个方向</li>
<li>连续的内存空间和相同的类型数据: 这两个限制使数组具备了“随机访问” 的特性，同时使得数组的部分操作变得低效（删除、更新等）</li>
</ul>
<p>示例：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] a= new int[10];</span><br></pre></td></tr></table></figure></div>
<p>数组的内存地址计算如下</p>
<ul>
<li>a[i]_addree = base_address + i * data_type_size</li>
<li>假设内存块的首地址base_address = 10;</li>
<li>int数据类型，所以data_type_size = 4</li>
</ul>
<p>由此可以得到a[10]的内存空间为连续的1000~1039</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/array.png" alt="array"></p>
<hr>
<p>关于“数组适合查找，查找时间复杂度为O(1)”的描述 实际上不够准确,因为即使是排序好的数组，使用二分查找，复杂度也是O(longn)</p>
<p>正确描述应该是：“数组适合查找，且支持随机访问，根绝下表随机访问的时间复杂度为O(1)”</p>
<hr>
<h2 id="数组的插入"><a href="#数组的插入" class="headerlink" title="数组的插入"></a>数组的插入</h2><p>数组为了保持内存的连续性，插入和删除操作比较低效</p>
<p>比如我们要将一个数据插入到数组中的第K个位置，需要</p>
<ul>
<li>把第K个位置腾出来</li>
<li>k~n的元素往后移动一位</li>
<li>如果k是末尾，那时间复杂度就是O(1)；如果是头部时间复杂度就是O(n),平均复杂度就是(1+2+3…+n)/n = O(n)</li>
</ul>
<p>由此可见，对于插入一个数的操作，非常低效。</p>
<p>但是，对于数组仅仅只是被当作一个存储数据的集合，对于其内的数据没有任何规律的话，可以避免大规模的数据迁移，方法就是</p>
<ul>
<li>将第K位置的元素放到数组元素最后</li>
<li>新的元素放到k的位置</li>
<li>好处就是插入的复杂度降为O(1)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/array2.png" alt="array2"></p>
<h2 id="数组的删除"><a href="#数组的删除" class="headerlink" title="数组的删除"></a>数组的删除</h2><p>如果我们要将一个数据从第k的位置删除，那么</p>
<ul>
<li>把第k位置的元素删除</li>
<li>k~n的数据向前一迁移</li>
<li>平均复杂度：O(n)</li>
</ul>
<p>但是，如果我们对数组数据的连续性并没有要求，为了防止删除一次，就迁移一次数据，而是将多次删除一起执行，可以使用如下方法</p>
<ul>
<li>并不删除数据，而是标识该数据已经被删除</li>
<li>当数组空间不足时，再执行一次真正的删除操作</li>
<li>好处就是大大减少了删除导致的数据迁移</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/array3.png" alt="array3"></p>
<h2 id="数组的访问越界"><a href="#数组的访问越界" class="headerlink" title="数组的访问越界"></a>数组的访问越界</h2><p>众所周知,如下代码会出现访问越界</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int [] a = new int[3];</span><br><span class="line">a[3] = 10;</span><br></pre></td></tr></table></figure></div>
<p>访问数组，其本质时访问一段连续内存，只要数组通过偏移计算得到的内存地址可用，程序可能不会报错(Java自身会做越界检查，越界抛出java.lang.ArrayIndexOutOfBoundsException)</p>
<h2 id="数组和容器选择"><a href="#数组和容器选择" class="headerlink" title="数组和容器选择"></a>数组和容器选择</h2><p>针对数组类型，Java提供了很多容器，如ArrayList,并且实现很多逻辑，如扩容逻辑。但是，有些时候，使用数组会更加合适</p>
<ul>
<li>存储基本类型，ArrayList无法存储基本类型，而Autoboxing、Unboxing有一定的性能消耗</li>
<li>数据大小事先已知，且对数据操作非常简单，不需要容器提供的大部分方法，也可以使用数组</li>
<li>多维数组，用数组会更加直观</li>
</ul>
<h2 id="为什么数组会是从0开始"><a href="#为什么数组会是从0开始" class="headerlink" title="为什么数组会是从0开始"></a>为什么数组会是从0开始</h2><p>前面看完后，基本上可以了解数组为什么从0开始</p>
<p>从数组内存模型可以看出，所谓的下标其实就是“偏移offset”如,a[0]就是偏移为0的位置，也就是首地址</p>
<p>计算公式如下</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure></div>
<p>但如果从1开始计算，那么计算公式如下</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k-1) * type_size</span><br></pre></td></tr></table></figure></div>
<p>两个公式相比较，从1开始计算，对于CPU来说，需要多一次减法操作</p>
<h1 id="数组列表-ArrayList"><a href="#数组列表-ArrayList" class="headerlink" title="数组列表(ArrayList)"></a>数组列表(ArrayList)</h1><p>利用数组的连续存储空间顺序存放线性表的各元素</p>
<p>基本构成：</p>
<ul>
<li>用于存放数据的数组,数组的大小即长度</li>
<li>最后一个数组元素的索引</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object[] elementData;<span class="comment">//用于存放数据的数组</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> last;<span class="comment">//最后一个数组元素的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>初始化操作： </p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">List</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空数组</span></span><br><span class="line">    <span class="keyword">this</span>.elementData =<span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//last设为-1</span></span><br><span class="line">    <span class="keyword">this</span>.last = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>查询元素所在位置：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从0开始找直到最后或者找到x，停止循环</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= last &amp;&amp; elementData[i] != x) i++;</span><br><span class="line">    <span class="comment">//i 大于last时，表示找到最后一个没找到，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; last) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找到的话直接返回i就是x所在的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>插入操作：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> x 要插入的元素</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> i 要插入的位置，i &gt;= 1,因为0前面是没有索引的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Object x, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果last指向最后一个位置，表示空间已满，不能插入</span></span><br><span class="line">    <span class="keyword">if</span> (last == elementData.length-<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//检查插入位置的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; last + <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = last; j &gt;= i-<span class="number">1</span>; j--)&#123;</span><br><span class="line">        elementData[j + <span class="number">1</span>] = elementData[j];<span class="comment">//从最后一个数开始往后存数</span></span><br><span class="line">        elementData[i-<span class="number">1</span>] = x; <span class="comment">//将x插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    last++; <span class="comment">//last仍指向最后的元素</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>删除操作</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//检查空表以及删除位置的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;<span class="number">0</span> || i &gt; last+<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= last; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j == last) elementData[last] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> elementData[j] = elementData[j + <span class="number">1</span>]; <span class="comment">// 从i位置一个一个往前挪</span></span><br><span class="line">    &#125;</span><br><span class="line">    last--;<span class="comment">//last仍指向最后的元素</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="链表（linkedList）"><a href="#链表（linkedList）" class="headerlink" title="链表（linkedList）"></a>链表（linkedList）</h1><p>什么是链表？</p>
<ol>
<li>链表是通过将零散的内存块串联起来，该内存块被称为”结点”；</li>
<li>结点除了存储数据之外，还需要记录链上的下一个结点的地址，该地址被称为”后继指针next”</li>
</ol>
<h2 id="链表与数组的区别"><a href="#链表与数组的区别" class="headerlink" title="链表与数组的区别"></a>链表与数组的区别</h2><p>区别如下：</p>
<ol>
<li>数组需要连续的空间，如1000MB的数组，必须要有1000MB的连续空间，否则就算内存有充足的空间但不连续，数组就申请失败;而链表无需连续的内存空间，通过“指针”将零散的内存快串联起来</li>
<li>数组大小固定，而链表没有大小限制</li>
<li>数组使用连续内存空间，可借助CPU缓存机制，预读数组中的数据，访问效率更高；链表没有办法有效预读</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist.png" alt="linkedlist"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>数组</td>
<td>链表</td>
</tr>
<tr>
<td>插入/删除</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>随机访问</td>
<td>0(1)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<h2 id="常见链表"><a href="#常见链表" class="headerlink" title="常见链表"></a>常见链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表存在两个特殊的结点</p>
<ul>
<li>第一个结点：称为头结点，用来记录链表的基地址</li>
<li>最后一个结点：尾结点，指针指向NULL</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist2.png" alt="linkedlist2"></p>
<p>删除和插入操作</p>
<ul>
<li>只需要改变插入位置相邻结点的指向极客</li>
<li>时间复杂度为O(1)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist3.png" alt="linkedlist3"></p>
<p>查询操作</p>
<ul>
<li>因为链表数据并非连续存储，所以无法想数组一样靠首地址和下标，只能通过遍历结点获取</li>
<li>时间复杂度：O(n)</li>
</ul>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>属于一种特殊的单链表</p>
<ul>
<li>循环链表的尾结点指向链表的头结点</li>
<li>优点在于处理数据具有环形结构特点比较方便，如约瑟夫问题</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist4.png" alt="linkedlist4"></p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>特点：</p>
<ul>
<li>每个结点不知有一个后继指针next,还有一个前驱指针prev</li>
<li>因为存储后继结点和前驱结点，需要额外的空间</li>
<li>双向链表查找前驱结点的时间复杂度是O(1)</li>
<li>双向链表再某些情况下插入删除操作比单链表更简单高效</li>
</ul>
<p>在java中，LinkedHashMap使用了双项链表结构</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist5.png" alt="linkedlist5"></p>
<hr>
<p>单链表的插入删除操作已经是O(1),双向链表如何更高效？</p>
<p>通常开发中的删除数据情况</p>
<ul>
<li>情况1：给定某个值，删除对应结点</li>
<li>情况2：给定某个指针，删除给定指针指向的结点</li>
</ul>
<p>对于情况1，具体流程为：</p>
<ul>
<li>查找需要的结点（需遍历结点，复杂度O(n)）</li>
<li>改变相邻结点指针指向（复杂度O(1))</li>
<li>总的时间复杂度为O(n)</li>
</ul>
<p>对于情况2，直接获取到需要删除的结点q，但需要知道该结点的前驱结点</p>
<ul>
<li>对于单链表，为了找前驱结点p，还是需要遍历链表，直到p.next=q,复杂度为0(n)</li>
<li>对于双向链表，复杂度就是O(1)了</li>
</ul>
<p>链表的插入同理</p>
<hr>
<h2 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h2><p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist6.png" alt="linkedlist6"></p>
<h2 id="如何写好链表"><a href="#如何写好链表" class="headerlink" title="如何写好链表"></a>如何写好链表</h2><h3 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h3><p>所谓指针：</p>
<ul>
<li>将某个标量赋值给指针，就是将变量的地址复制给指针。通过指针保存的内存地址，找到这个变量</li>
<li>对于java，就是引用</li>
</ul>
<p>常用的代码</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p结点中的next针织存储了q结点的地址</span></span><br><span class="line">p-&gt;next = q</span><br><span class="line"><span class="comment">//p结点next指针存储p结点的下下个结点内存地址（删除了下一个结点）</span></span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next</span><br></pre></td></tr></table></figure></div>
<h3 id="警惕指针丢失和内存泄露"><a href="#警惕指针丢失和内存泄露" class="headerlink" title="警惕指针丢失和内存泄露"></a>警惕指针丢失和内存泄露</h3><p>假设想将x插入到p和b之间</p>
<p>如下代码，会导致指针丢失和内存泄漏</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向了自己</span></span><br><span class="line">p-&gt;next = x;</span><br><span class="line">x-&gt;next = p-&gt;next;</span><br></pre></td></tr></table></figure></div>
<p>正确的插入x的做法应该是</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先将x指向b</span></span><br><span class="line">x-&gt;next = p-&gt;next;</span><br><span class="line"><span class="comment">//再将p指向x</span></span><br><span class="line">p-&gt;next = x;</span><br></pre></td></tr></table></figure></div>
<h3 id="利用哨兵简化实现难度"><a href="#利用哨兵简化实现难度" class="headerlink" title="利用哨兵简化实现难度"></a>利用哨兵简化实现难度</h3><p>假设在头结点p后插入新结点x</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = x;</span><br></pre></td></tr></table></figure></div>
<p>看似没有问题，但如果该链表其实是空表呢?(需要插入到表头)</p>
<p>对于插入到头结点head，与其他插入逻辑不同</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">    head = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>再来看删除操作</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = p-&gt;next-&gt;next</span><br></pre></td></tr></table></figure></div>
<p>正常来讲没有问题，但如果删除的是链表的最后一个结点，那就出错了,需要进行特殊处理</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head-&gt;next == <span class="keyword">null</span>)&#123;</span><br><span class="line">    head = <span class="keyword">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看出，对于头尾结点，需要特殊处理。哨兵的作用，就是解决这样的“边界问题”</p>
<ul>
<li>拥有哨兵的结点，被称为带头链表</li>
<li>不管链表是否为空，head结点永远指向哨兵结点</li>
<li>哨兵结点不存储数据</li>
<li>好处就是对于插入第一个结点和其他结点，或者删除最后一个结点和删除其他结点，可以统一为相同的逻辑代码了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist7.png" alt="linkedlist7"></p>
<h3 id="留意边界条件处理"><a href="#留意边界条件处理" class="headerlink" title="留意边界条件处理"></a>留意边界条件处理</h3><p>写完链表后，检查边界条件下是否可以正常允许，通常考虑</p>
<ul>
<li>链表为空的情况</li>
<li>链表只包含一个结点</li>
<li>链表只包含两个结点</li>
<li>代码逻辑处理头结点和尾结点</li>
</ul>
<h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><p>利用画图，更加清醒插入、删除等操作</p>
<p>比如：<br><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/linkedlist8.png" alt="linkedlist8"></p>
<h2 id="链表应用场景"><a href="#链表应用场景" class="headerlink" title="链表应用场景"></a>链表应用场景</h2><p>链表经典的应用场景，就是LRU缓存淘汰算法</p>
<p>缓存</p>
<ul>
<li>一种提高数据读取性能的技术</li>
<li>大小有限，缓存被用满时，需要决定删除那些数据，此时就需要缓存淘汰策略</li>
</ul>
<p>缓存淘汰策略，常见有三种</p>
<ul>
<li>先进先出FIFO（First In, First Out）</li>
<li>最少使用策略LFU(Least Frequently Used)</li>
<li>最近最少使用策略LRU(Least Recently Used)</li>
</ul>
<h3 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h3><p>思路：</p>
<ul>
<li>维护一个有序单链表</li>
<li>越靠近链表尾结点，说明是越早之前访问的</li>
<li>一个新的数据被访问，从链表头开始顺序遍历链表</li>
<li>如果此数据已经缓存在链表内，将这个数据对应的结点从原来的位置删除，插入到链表表头</li>
<li>否则，有可以分为两种情况</li>
<li>如果此时缓存未满，则直接将该数据对应的结点插入表头</li>
<li>否则，则删除链表尾结点，数据对应的结点插入表头</li>
</ul>
<h1 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h1><h2 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h2><ul>
<li>栈是一种“操作受限”的线性表，只允许在一端插入和删除数据</li>
<li>栈的操作主要为入栈和出栈</li>
</ul>
<p>栈的复杂度</p>
<ul>
<li>在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度为O(1)</li>
<li>入栈、出栈是对栈顶个别数据操作，时间复杂度也是O(1)</li>
</ul>
<h2 id="简单的栈代码"><a href="#简单的栈代码" class="headerlink" title="简单的栈代码"></a>简单的栈代码</h2><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于数组实现的顺序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] items; <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 栈中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//栈的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组，申请一个大小为n的数组空间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 数组空间不够了，直接返回false，入栈失败。</span></span><br><span class="line">        <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 将item放到下标为count的位置，并且count加一</span></span><br><span class="line">        items[count] = item;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 栈为空，则直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span></span><br><span class="line">        String tmp = items[count - <span class="number">1</span>];</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h3><p>比较经典的一个应用场景：函数调用栈</p>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构,用来存储函数调用时的临时变量。每进入一个函数，就会将临时变<br>量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈</p>
<p>假设如下方法</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    res = a + ret;</span><br><span class="line">    printf(<span class="string">"%d"</span>, res);</span><br><span class="line">    reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其内存情况如下图</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/stack.png" alt="stack"></p>
<h3 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h3><p>栈的另一种常见应用场景，编译器通过栈来实现表达式求值</p>
<p>编译器通过两个栈来实现表达式求值</p>
<ul>
<li>其中一个保存操作数的栈，另一个是保存运算符的栈。</li>
<li>编译器从左向右遍历表达式，当遇到数字，就直接压入操作数栈；</li>
<li>当遇到运算符，就与运算符栈的栈顶元素进行比较。</li>
<li>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；</li>
<li>如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</li>
</ul>
<p>如：3+5*8-6的计算过程图如下</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/stack2.png" alt="stack2"></p>
<h3 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h3><p>可以借助栈来检查表达式中的括号是否匹配</p>
<p>如表达式中含有:”()”、”{}”、”[]”</p>
<ul>
<li>({[]}):像这种就是合法的</li>
<li>}){]([)：这样的就是不合法的</li>
</ul>
<p>那么如何用栈解决</p>
<ul>
<li>从左到右一次扫描</li>
<li>扫描到左括号时，存入栈中</li>
<li>扫描到右括号时，从栈顶去除一个左括号，如果匹配，则继续扫描；如果不匹配或者没有数据时，说明为非法格式</li>
</ul>
<h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><h2 id="什么是队列？"><a href="#什么是队列？" class="headerlink" title="什么是队列？"></a>什么是队列？</h2><ul>
<li>类似于排队买午饭，先进先出</li>
<li>最基本操作为入队<br>enqueue(): 放一个数据到尾部<br>dequeue(): 从队列头部取一个数据  </li>
</ul>
<p>高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；java.concurrent并发包利用ArrayBlockingQueue实现公平锁</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/queue.png" alt="queue"></p>
<h2 id="常见队列"><a href="#常见队列" class="headerlink" title="常见队列"></a>常见队列</h2><h3 id="顺序队列代码"><a href="#顺序队列代码" class="headerlink" title="顺序队列代码"></a>顺序队列代码</h3><p>特点：</p>
<ul>
<li>队列需要两个指针：头指针head，指向队头；尾tail，指向队尾</li>
<li>当进行入队操作后，tail指针右移</li>
<li>当进行出队操作后，head指针右移</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组实现的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// head表示队头下标，tail表示队尾下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请一个大小为capacity的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">        n = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果tail == n 表示队列已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (tail == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        items[tail] = item;</span><br><span class="line">        ++tail;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果head == tail 表示队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String ret = items[head];</span><br><span class="line">        ++head;s</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果tail==n时，则无法继续往队列中加数据，但很有可能队列前面还有空间，所以，需要触发一次搬移操作，此时修改enqueue()操作</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tail == n表示队列末尾没有空间了</span></span><br><span class="line">    <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">    <span class="comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 数据搬移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">    items[i-head] = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搬移完之后重新更新head和tail</span></span><br><span class="line">    tail -= head;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    ++tail;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/queue2.png" alt="queue2"></p>
<h3 id="基础链表的队列实现"><a href="#基础链表的队列实现" class="headerlink" title="基础链表的队列实现"></a>基础链表的队列实现</h3><p>要想实现基于链表的队列</p>
<ul>
<li>需要两个指针，head指针和tail指针</li>
<li>入队：tail-&gt;next = new_node,tail = tail-&gt;next</li>
<li>出队：head = head-&gt;next<br>如图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/queue3.png" alt="queue3"></p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>当tail==n时，前面做法时通过数据搬移来解决，为了避免使用数据搬移，可以使用循环队列，即tail==n时，让它变为tail=0,而不是+1</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/queue3.png" alt="queue4"></p>
<p>若要实现循环队列，必须考虑两种情况</p>
<ul>
<li>队列空：一般判断条件是tail==head</li>
<li>队列满：一般判断条件是tail==n</li>
</ul>
<p>对于队列空，依旧可以使用tail==head来判断，但对于队列满，tail==n已经不适用了，而是有这样一条规律：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tail+1)%n=head</span><br></pre></td></tr></table></figure></div>
<p>实现代码为</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列满了</span></span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列其实就是在队列基础上加了阻塞操作</p>
<ul>
<li>队列空时，从对头取数据会被阻塞，知道队列中有了数据才能返回</li>
<li>队列满，插入如数据操作会被阻塞，知道队列有空闲位置再插入数据，然后返回</li>
<li>(典型的生产者-消费者模型)</li>
</ul>
<h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>并发队列即线程安全的队列</p>
<ul>
<li>最简单实现方式是直接再enqueue()、dequeue()上枷锁，锁力度大，并发度低</li>
</ul>
<h2 id="队列相关应用"><a href="#队列相关应用" class="headerlink" title="队列相关应用"></a>队列相关应用</h2><h2 id="线程池没有空闲线程时，如何处理新的请求线程资源"><a href="#线程池没有空闲线程时，如何处理新的请求线程资源" class="headerlink" title="线程池没有空闲线程时，如何处理新的请求线程资源"></a>线程池没有空闲线程时，如何处理新的请求线程资源</h2><p>线程池底部数据结构，就是使用了队列</p>
<p>一般解决使用两种策略</p>
<ul>
<li>非阻塞式：直接拒绝任务请求</li>
<li>阻塞式：将请求排队，等到有空闲线程时，取出排队的请求继续处理</li>
</ul>
<p>如何来设计存储请求排队？</p>
<ul>
<li>第一种：基于链表实现队列，可无限制排队，对响应时间敏感的系统不合适</li>
<li>第二种：基于数组实现队列，比较适合对响应时间敏感的系统，但对队列的大小设计有一定要求</li>
</ul>
<h1 id="跳表（Skip-list）"><a href="#跳表（Skip-list）" class="headerlink" title="跳表（Skip list）"></a>跳表（Skip list）</h1><h2 id="什么是跳表？"><a href="#什么是跳表？" class="headerlink" title="什么是跳表？"></a>什么是跳表？</h2><ul>
<li>链表的改造，可以实现类似于二分查找的算法</li>
<li>(Redis中的有序集合（Sorted Set）就是用跳表来实现的)</li>
</ul>
<p>核心思想：</p>
<ul>
<li>对链表建立“索引”</li>
<li>如，每两个结点提取一个结点到上一级，把抽出来的那一级叫作索引或索引层(当然，可以每n个结点取一个结点，这样可以节省额外空间，不过当存储的对象值比索引大的多少，可以忽略占用额外空间)</li>
<li>结点存在next结点指向下一个结点，down结点指向下一级结点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表.png" alt="跳表"></p>
<h2 id="跳表查找"><a href="#跳表查找" class="headerlink" title="跳表查找"></a>跳表查找</h2><p>算法</p>
<ol>
<li>有数据x，首先查询最顶级索引结点y</li>
<li>如果Node[y] &lt; x，再查询next结点z</li>
<li>如果Node[z] &gt; x, 说明该值再[y,z]之间，然后找到y的down结点</li>
<li>重复1-3</li>
<li>如果 Node[y] &gt; x,则表明x不存在(已经是最小的了)</li>
</ol>
<p>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是n/2，第二级索引的结点个数大约就是n/4，第三级索引<br>的结点个数大约就是n/8，依次类推，也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那第k级索引结点的个数就是n/(2k)。</p>
<p>假设索引有h级，最高级的索引有2个结点。通过上面的公式，我们可以得到n/(2h)=2，从而求得h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是log2n。<br>我们在跳表中查询某个数据的时候，如果每一层都要遍历m个结点，那在跳表中查询一个数据的时间复杂度就是O(m*logn)。</p>
<p>空间复杂度分析</p>
<ul>
<li>空间复杂度为O(n),非原地排序算法</li>
</ul>
<p>稳定性分析</p>
<ul>
<li>是一种数据结构，不存在稳定性</li>
</ul>
<p>时间复杂度分析</p>
<ul>
<li>最好情况,时间复杂度O(logn)</li>
<li>最坏情况,时间复杂度O(logn)</li>
<li>平均时间复杂度O(logn)</li>
</ul>
<p>时间复杂度分析</p>
<ul>
<li>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是n/2，第二级索引的结点个数大约就是n/4，第k级的个数就是n/(2k)</li>
<li>假设索引的k级最高级结点数为2，则n/(2k) = 2-&gt; k= logn-1</li>
<li>对于每一层，需要遍历m个结点，那么时间复杂度即为O(m*logn)</li>
<li>因为我们使用的是每两个结点取一个索引，所以，最多也就需要遍历3个结点(y、z以及它们中间的结点)，即m &lt;=3,则整个的时间复杂度为O(logn)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表2.png" alt="跳表2"></p>
<h2 id="跳表插入删除"><a href="#跳表插入删除" class="headerlink" title="跳表插入删除"></a>跳表插入删除</h2><p>跳表的插入和删除，只需要通过查找找到位置，然后进行O(1)的插入/删除操作即可，所以时间复杂度为O(logn)</p>
<h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><p>当不停地往跳表中插入数据时，如果不更新索引，就有可能出现某2个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表3.png" alt="跳表3"></p>
<p>跳表通过随机函数来维护“平衡性”,比如随机函数生成了值K，就将这个结点添加到第一级到第K级这K级索引中</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表4.png" alt="跳表4"></p>
<h2 id="跳表示例代码"><a href="#跳表示例代码" class="headerlink" title="跳表示例代码"></a>跳表示例代码</h2><p>跳表的实现较为复杂，可以查看Redis中关于有序集合的跳表实现。</p>
<h1 id="散列表-HashTable"><a href="#散列表-HashTable" class="headerlink" title="散列表(HashTable)"></a>散列表(HashTable)</h1><h2 id="什么是散列表"><a href="#什么是散列表" class="headerlink" title="什么是散列表?"></a>什么是散列表?</h2><ul>
<li>key-value形式存储数据</li>
<li>通过散列函数将key转换成value(Hash值)</li>
<li>散列函数把元素的key映射为下标，然后将value存储在数组中对应下标的位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/hashtable.png" alt="hashtable"></p>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>散列函数设计的基本要求：</p>
<ol>
<li>散列函数计算得到的散列值是一个非负整数</li>
<li>如果key1 = key2，那hash(key1) == hash(key2)</li>
<li>如果key1 ≠ key2，那hash(key1) ≠ hash(key2)（不可能实现，无法避免散列冲突）</li>
</ol>
<h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>所谓的散列冲突，指的是在同key的情况下，获取到相同的Hash值，并且这是不可避免的。常用的散列冲突解决方法有两类</p>
<ol>
<li>开放寻址法（open addressing）</li>
<li>链表法（chaining）</li>
<li>其他如平方取中法、折叠法、随机数法</li>
</ol>
<p>装载因子：用装载因子（load factor）来表示空位的多少</p>
<ul>
<li>散列表的装载因子=填入表中的元素个数/散列表的长度</li>
<li>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降</li>
</ul>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>核心思想：</p>
<ul>
<li>出现了散列冲突，就重新探测一个空闲位置，将其插入</li>
</ul>
<p>线性探测（Linear Probing）</p>
<ul>
<li>插入：当存储位置被占用，从当前位置开始依次查找，直到找到空闲位置</li>
<li>删除：对于删除一个数据，特殊标记为deleted（为了防止本来应该存在的数据，因为删除后有了空闲位置而不继续查找）</li>
<li>查找：从当前位置开始依次查找，知道空闲位置说明不存在，如果遇到deleted标记，继续向下查找</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/开放寻址.png" alt="开放寻址"></p>
<p>二次探测（Quadratic probing)</p>
<ul>
<li>与线性探测类似</li>
<li>区别是线性探测每次探测的步长是1，探测的下标序列就是hash(key)+0，hash(key)+1，hash(key)+2； 而二次探测探测的步长就变成了原来的“二次方”，探测的下标序列就是hash(key)+0，hash(key)+1²，hash(key)+2²</li>
</ul>
<p>双重散列（Double hashing）</p>
<ul>
<li>使用一组散列函数hash1(key)，hash2(key)，hash3(key)</li>
<li>第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</li>
</ul>
<h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>核心思想：</p>
<ul>
<li>在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中</li>
<li>插入：通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可（O(n)）</li>
<li>查找、删除：通过散列函数计算出对应的槽，然后遍历链表查找或者删除（O(k),k为链表长度）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/链表法.png" alt="链表法"></p>
<h2 id="如何设计散列函数"><a href="#如何设计散列函数" class="headerlink" title="如何设计散列函数"></a>如何设计散列函数</h2><p>需要考虑的因素有：关键字长度、特点、分布、散列表大小等。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次<br>寻址或者拉很长的链，查找的过程也会因此变得很慢。</p>
<p>解决办法：</p>
<ol>
<li>对于没有频繁插入和删除的静态数据集合（即数据已知），完全可以根据数据特点等设计出散列函数</li>
<li>对于动态散列表，数据集合频繁变动，当装载因子达到一定程度时，需要进行<strong>扩容</strong></li>
</ol>
<h3 id="选择合适的冲突解决办法"><a href="#选择合适的冲突解决办法" class="headerlink" title="选择合适的冲突解决办法"></a>选择合适的冲突解决办法</h3><h2 id="散列表与链表的结合使用"><a href="#散列表与链表的结合使用" class="headerlink" title="散列表与链表的结合使用"></a>散列表与链表的结合使用</h2><h1 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h1><h2 id="数的基本概念"><a href="#数的基本概念" class="headerlink" title="数的基本概念"></a>数的基本概念</h2><p>关于“树”，有三个概念：高度（Height）、深度（Depth）、层（Level）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>节点</td>
<td>树中的每个元素称为节点</td>
</tr>
<tr>
<td>父节点</td>
<td>指向子节点的节点</td>
</tr>
<tr>
<td>子节点</td>
<td>被父节点指向的节点</td>
</tr>
<tr>
<td>根节点</td>
<td>没有父节点的节点</td>
</tr>
<tr>
<td>叶子节点</td>
<td>没有子节点的节点</td>
</tr>
<tr>
<td>兄弟节点</td>
<td>具有相同父节点的多个节点称为兄弟节点关系</td>
</tr>
<tr>
<td>节点的高度</td>
<td>节点到叶子节点的最长路径（边数）</td>
</tr>
<tr>
<td>节点的深度</td>
<td>根节点到节点的路径所经历的边的个数</td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/树2.png" alt="树2"></p>
<h2 id="二叉树基础（Binary-Tree）"><a href="#二叉树基础（Binary-Tree）" class="headerlink" title="二叉树基础（Binary Tree）"></a>二叉树基础（Binary Tree）</h2><p>所谓的二叉树，即树有两个节点，分别为左子节点和右子节点。二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树的特征为：</p>
<ul>
<li>叶子节点都在最底下两层</li>
<li><strong>最后一层的叶子节点都靠左排列</strong></li>
<li>并且除了最后一层，其他层的节点个数都要达到最大</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/完全二叉树.png" alt="完全二叉树"></p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>满二叉树特征更为明显，它除了叶子节点之外，每个节点都有左右两个子节点</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/满二叉树.png" alt="满二叉树"></p>
<h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><p>有两种方法</p>
<ol>
<li>基于指针或者引用的二叉链式存储法</li>
<li>基于数组的顺序存储法。</li>
</ol>
<h4 id="链式存储法"><a href="#链式存储法" class="headerlink" title="链式存储法"></a>链式存储法</h4><p>核心思想：</p>
<ol>
<li>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/链式存储法.png" alt="链式存储法"></p>
<h4 id="顺序存储法"><a href="#顺序存储法" class="headerlink" title="顺序存储法"></a>顺序存储法</h4><p>核心思想</p>
<ol>
<li>把根节点存储在下标1的位置(设为1为根节点，方便计算)</li>
<li>如果节点为i,其左子节点存储在下标2 * i的位置</li>
<li>如果节点为i,其右子节点存储在2 * i 的位置</li>
</ol>
<p>存储非完全二叉树</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/顺序存储法.png" alt="顺序存储法"></p>
<p>存储完全二叉树</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/顺序存储法2.png" alt="顺序存储法2"></p>
<h4 id="两种存储法对比"><a href="#两种存储法对比" class="headerlink" title="两种存储法对比"></a>两种存储法对比</h4><p>从内存来说，如果存储的是完全二叉树的话，使用顺序存储法不会浪费空间（仅浪费下标为0的存储位置），而链式存储法需要存储额外的左右子节点的指针。但对于非完全二叉树来说，顺序存储法会浪费比较多的数组存储空间</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树遍历有三种经典的方法</p>
<ol>
<li>前序遍历（对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。）</li>
<li>中序遍历（对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。）</li>
<li>后序遍历（对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/二叉树遍历.png" alt="二叉树遍历"></p>
<p>实际上，二叉树的前、中、后序遍历就是一个递归的过程</p>
<p>遍历代码示例</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">    preOrder(root-&gt;left);</span><br><span class="line">    preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root-&gt;left);</span><br><span class="line">    postOrder(root-&gt;right);</span><br><span class="line">    print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>特点</p>
<ul>
<li>支持动态数据集合的快速插入、删除、查找操作</li>
<li>在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/二叉查找树.png" alt="二叉查找树"></p>
<h3 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a>二叉查找树的查找操作</h3><p>核心思想</p>
<ul>
<li>先取根节点，如果它等于我们要查找的数据，那就返回</li>
<li>如果要查找的数据比根节点的值小，那就在左子树中递归查找</li>
<li>如果要查找的数据比根节点的值大，那就在右子树中递归查找</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/二叉查找树2.png" alt="二叉查找树2"></p>
<p>示例代码</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node tree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; p.data) p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="二叉查找树的插入操作"><a href="#二叉查找树的插入操作" class="headerlink" title="二叉查找树的插入操作"></a>二叉查找树的插入操作</h3><p>核心思想</p>
<ul>
<li>类似查找操作</li>
<li>从根节点开始</li>
<li>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置</li>
<li>如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/二叉查找树3.png" alt="二叉查找树3"></p>
<p>示例代码</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt; p.data</span></span><br><span class="line">                <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="二叉查找树的删除操作"><a href="#二叉查找树的删除操作" class="headerlink" title="二叉查找树的删除操作"></a>二叉查找树的删除操作</h3><p>较为复杂，需要分三种情况处理</p>
<ol>
<li>如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null(如图删除节点55)</li>
<li>如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。（如图删除节点13）</li>
<li>如果要删除的节点有两个子节点,需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了）（如图删除节点18）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/二叉树删除.png" alt="二叉树删除"></p>
<p>示例代码</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        Node p = tree; <span class="comment">// p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">        Node pp = <span class="keyword">null</span>; <span class="comment">// pp记录的是p的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">            pp = p;</span><br><span class="line">            <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">            <span class="keyword">else</span> p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到</span></span><br><span class="line">        <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">            Node minP = p.right;</span><br><span class="line">            Node minPP = p; <span class="comment">// minPP表示minP的父节点</span></span><br><span class="line">            <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                minPP = minP;</span><br><span class="line">                minP = minP.left;</span><br><span class="line">            &#125;</span><br><span class="line">            p.data = minP.data; <span class="comment">// 将minP的数据替换到p中</span></span><br><span class="line">            p = minP; <span class="comment">// 下面就变成了删除minP了</span></span><br><span class="line">            pp = minPP;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">        Node child; <span class="comment">// p的子节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) child = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) child = p.right;</span><br><span class="line">        <span class="keyword">else</span> child = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>) tree = child; <span class="comment">// 删除的是根节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) pp.left = child;</span><br><span class="line">        <span class="keyword">else</span> pp.right = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="二叉查找树的时间复杂度"><a href="#二叉查找树的时间复杂度" class="headerlink" title="二叉查找树的时间复杂度"></a>二叉查找树的时间复杂度</h3><p>无论是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，在较为想的情况下，树的高度为log2(n),则此时复杂度为O(logn)。当根节点的左右子树即为不平衡时，二叉查找树会退化成链表，时间复杂度变为O(n)</p>
<h2 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h2><p>方法一：二叉查找树中每一个节点不仅会存储一个数据，通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
<p>方法二：（更优雅）每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/重复插入.png" alt="重复插入"></p>
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p>遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/重复查找.png" alt="重复查找"></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/重复删除.png" alt="重复删除"></p>
<h2 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h2><p><code>平衡二叉查找树</code>，是为了解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。（即尽量让树保存左右平衡，防止链表化）</p>
<p>平衡二叉查找树核心思想</p>
<ol>
<li>二叉树中任意一个节点的左右子树的高度相差不能大于1</li>
<li>（完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/平衡二叉树.png" alt="平衡二叉树"></p>
<h3 id="平衡二叉树的种类"><a href="#平衡二叉树的种类" class="headerlink" title="平衡二叉树的种类"></a>平衡二叉树的种类</h3><ol>
<li>AVL树(严格符合平衡二叉查找树的定义)</li>
<li>Splay Tree（伸展树）</li>
<li>Treap（树堆)</li>
<li>红黑树(使用最多，非严格符合平衡二叉查找树的定义)</li>
</ol>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树，英文名<code>Reb-Black Tree</code>或<code>R-B Tree</code>，是一种<strong>不严格的平衡二叉查找树</strong>,它的特征如下</p>
<ol>
<li>红黑树中的节点，一类被标记为黑色，一类被标记为红色。根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树2.png" alt="红黑树2"></p>
<h3 id="红黑树的近似平衡"><a href="#红黑树的近似平衡" class="headerlink" title="红黑树的近似平衡"></a>红黑树的近似平衡</h3><p>红黑树的近似平衡，可以分析比较红黑树的高度是否稳定地趋近log2(n)即可</p>
<p>如果将红色节点从红黑树中去掉，这些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树.而这样的四叉树，其高度肯定要小于拥有相同节点数的完全二叉树，也就是高度不会超过log2(n)</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树3.png" alt="红黑树3"></p>
<p>如果加入一个红色节点，因为红色节点不能相邻，且规定每个叶子节点都是黑色的空节点，所以事实上有一个红色节点必然有一个黑色子节点，但这样其高度也不会超过2log2(n),也就是红黑树的高度仅仅比AVL树高了一倍，性能下降并不多（<strong>更何况实际上红黑树的性能不仅没降低反而更好</strong>）</p>
<h3 id="左右旋"><a href="#左右旋" class="headerlink" title="左右旋"></a>左右旋</h3><p>实际上，在插入、删除节点的过程中，<strong>红黑树的第三、第四点核心思想可能会被破坏</strong>，所谓的“平衡调整 ”，实际上就是要把被破坏的第三、第四点恢复过来</p>
<p>首先必须掌握两个重要的操作</p>
<ol>
<li>左旋</li>
<li>右旋</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/左右旋.png" alt="左右旋"></p>
<p>可以看出，无论左旋还是右旋，都会将y提升为x的父节点，且x会继承y的子节点</p>
<h3 id="插入操作，特殊情况的平衡调整"><a href="#插入操作，特殊情况的平衡调整" class="headerlink" title="插入操作，特殊情况的平衡调整"></a>插入操作，特殊情况的平衡调整</h3><p>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上</p>
<p>对于特殊情况，操作比较简单</p>
<ol>
<li>如果插入节点的父节点是黑色的，什么都不用做，它仍然满足红黑树的定义。</li>
<li>如果插入的节点是根节点，直接改变它的颜色，把它变成黑色就可以了</li>
</ol>
<h3 id="插入操作，其他情况的平衡调整"><a href="#插入操作，其他情况的平衡调整" class="headerlink" title="插入操作，其他情况的平衡调整"></a>插入操作，其他情况的平衡调整</h3><p>其他情况，需要两种基础的操作</p>
<ol>
<li>左右旋转</li>
<li>改变颜色</li>
</ol>
<p>红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫作<code>关注节点</code>。关注节点会随着不停地迭代处理，而不断发生变化。<strong>最开始的关注节点就是新插入的节点</strong></p>
<p>新节点插入之后，如果红黑树的平衡被打破，一般会有下面三种情况，根据不同情况，需要进行不同的调整</p>
<p>CASE 1：如果关注节点是a，它的叔叔节点d是<strong>红色</strong></p>
<ol>
<li>将关注节点a的父节点b、叔叔节点d的颜色都设置成黑色；</li>
<li>将关注节点a的祖父节点c的颜色设置成红色；</li>
<li>关注节点变成a的祖父节点c；</li>
<li>跳到CASE 2或者CASE 3。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/case1.png" alt="case1"></p>
<p>CASE 2：如果关注节点是a，它的叔叔节点d是<strong>黑色</strong>，关注节点a是其父节点b的<strong>右子节点</strong></p>
<ol>
<li>关注节点变成节点a的父节点b；</li>
<li>围绕新的关注节点 b<strong>左旋</strong>；</li>
<li>跳到CASE 3。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/case2.png" alt="case2"></p>
<p>CASE 3 ：如果关注节点是a，它的叔叔节点d是<strong>黑色</strong>，关注节点a是其父节点b的<strong>左子节点</strong></p>
<ol>
<li>围绕关注节点a的祖父节点c<strong>右旋</strong>；</li>
<li>将关注节点a的父节点b、兄弟节点c的颜色互换。</li>
<li>调整结束。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/case3.png" alt="case3"></p>
<h3 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h3><p>删除操作的平衡调整分为两步</p>
<ol>
<li>第一步是针对删除节点初步调整。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求都包含相同数目的黑色节点；</li>
<li>第二步是针对关注节点进行二次调整，使其满足红黑树的第三条定义</li>
</ol>
<h4 id="第一次调整"><a href="#第一次调整" class="headerlink" title="第一次调整"></a>第一次调整</h4><p>CASE 1：如果要删除的节点是a，它只有一个子节点b，就依次进行下面的操作：</p>
<ol>
<li>删除节点a，并且把节点b替换到节点a的位置，这一部分操作跟普通的二叉查找树的删除操作一样；</li>
<li>节点a只能是黑色，节点b也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点b改为黑色；</li>
<li>调整结束，不需要进行二次调整</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整1.png" alt="红黑树删除调整1"></p>
<p>CASE 2：如果要删除的节点a有两个非空子节点，并且它的后继节点就是节点a的右子节点c。就依次进行下面的操作：</p>
<ol>
<li>如果节点a的后继节点就是右子节点c，那右子节点c肯定没有左子树。我们把节点a删除，并且将节点c替换到节点a的位置。这一部分操作跟普通的二叉查找树的删除操作无异；</li>
<li>然后把节点c的颜色设置为跟节点a相同的颜色；</li>
<li>如果节点c是黑色，为了不违反红黑树的最后一条定义，我们给节点c的右子节点d多加一个黑色，这个时候节点d就成了“红-黑”或者“黑-黑”；</li>
<li>这个时候，关注节点变成了节点d，第二步的调整操作就会针对关注节点来做</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整2.png" alt="红黑树删除调整2"></p>
<p>CASE 3：如果要删除的是节点a，它有两个非空子节点，并且节点a的后继节点不是右子节点，我们就依次进行下面的操作：</p>
<ol>
<li>找到后继节点d，并将它删除，删除后继节点d的过程参照CASE 1；</li>
<li>将节点a替换成后继节点d</li>
<li>把节点d的颜色设置为跟节点a相同的颜色；</li>
<li>如果节点d是黑色，为了不违反红黑树的最后一条定义，我们给节点d的右子节点c多加一个黑色，这个时候节点c就成了“红-黑”或者“黑-黑”；</li>
<li>这个时候，关注节点变成了节点c，第二步的调整操作就会针对关注节点来做</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整3.png" alt="红黑树删除调整3"></p>
<h4 id="第二次调整"><a href="#第二次调整" class="headerlink" title="第二次调整"></a>第二次调整</h4><p>CASE 1：如果关注节点是a，它的兄弟节点c是红色的，我们就依次进行下面的操作：</p>
<ol>
<li>围绕关注节点a的父节点b左旋；</li>
<li>关注节点a的父节点b和祖父节点c交换颜色；</li>
<li>关注节点不变；</li>
<li>继续从四种情况中选择适合的规则来调整</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整4.png" alt="红黑树删除调整4"></p>
<p>CASE 2：如果关注节点是a，它的兄弟节点c是黑色的，并且节点c的左右子节点d、e都是黑色的，我们就依次进行下面的操作：</p>
<ol>
<li>将关注节点a的兄弟节点c的颜色变成红色；</li>
<li>从关注节点a中去掉一个黑色，这个时候节点a就是单纯的红色或者黑色；</li>
<li>给关注节点a的父节点b添加一个黑色，这个时候节点b就变成了“红-黑”或者“黑-黑”；</li>
<li>关注节点从a变成其父节点b；</li>
<li>继续从四种情况中选择符合的规则来调整</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整4.png" alt="红黑树删除调整4"></p>
<p>CASE 3：如果关注节点是a，它的兄弟节点c是黑色，c的左子节点d是红色，c的右子节点e是黑色，我们就依次进行下面的操作：</p>
<ol>
<li>围绕关注节点a的兄弟节点c右旋；</li>
<li>节点c和节点d交换颜色；</li>
<li>关注节点不变；</li>
<li>跳转到CASE 4，继续调整</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整4.png" alt="红黑树删除调整4"></p>
<p>CASE 4：如果关注节点a的兄弟节点c是黑色的，并且c的右子节点是红色的，我们就依次进行下面的操作：</p>
<ol>
<li>围绕关注节点a的父节点b左旋；</li>
<li>将关注节点a的兄弟节点c的颜色，跟关注节点a的父节点b设置成相同的颜色；</li>
<li>将关注节点a的父节点b的颜色设置为黑色；</li>
<li>从关注节点a中去掉一个黑色，节点a就变成了单纯的红色或者黑色；</li>
<li>将关注节点a的叔叔节点e设置为黑色；</li>
<li>调整结束</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/红黑树删除调整4.png" alt="红黑树删除调整4"></p>
<h2 id="递归树"><a href="#递归树" class="headerlink" title="递归树"></a>递归树</h2><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>MySQL底层使用的是B+ Tree数据结构，而该数据结构，需要满足以下需求</p>
<ol>
<li>根据某个值查找数据，比如select * from user where id=1234；</li>
<li>根据区间值来查找某些数据，比如select * from user where id &gt; 1234 and id &lt; 2345</li>
<li>支持快速查询、插入等操作</li>
</ol>
<p>综合以上需求来分析，我们来看一下较为合适的数据结构散列表、平衡二叉查找树、跳表</p>
<ol>
<li>散列表：查询性能很好，时间复杂度是O(1)；但散列表不能支持按照区间快速查找数据</li>
<li>平衡二叉查找树：查询的性能也很高，时间复杂度是O(logn)，同样不支持按照区间快速查找数据</li>
<li>跳表：支持快速地插入、查找、删除数据，对应的时间复杂度是O(logn)，并且支持区间快速地查找数据</li>
</ol>
<p>跳表显然是可以解决这个问题，但MySQL使用的B+树，虽然与跳表类似，但是通过改造平衡二叉查找树演化而来的</p>
<h3 id="平衡二叉树到B-树"><a href="#平衡二叉树到B-树" class="headerlink" title="平衡二叉树到B+ 树"></a>平衡二叉树到B+ 树</h3><p>改造如下</p>
<ol>
<li>树中的节点并不存储数据本身，而是只是作为索引</li>
<li>把每个叶子节点串在一条链表上，链表中的<strong>数据是从小到大有序的</strong></li>
</ol>
<p>如下图插入7的话，会插入到6-10之间，会导致10节点有3个字节点，必须进行索引调整(调整方法稍后看到)</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树.png" alt="B+树"></p>
<p>如果要求某个区间的值只需要拿区间的起始值，在树中进行查找），当查找到某个叶子节点之后（如查找到少于这个区间的叶子节点，再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树2.png" alt="B+树2"></p>
<p>不过，如此设计，必定会占用太多内存。比方说有1亿数据，每个节点占16字节，那么就是差不多1G的空间占用。解决如此大的空间问题，思路是：内存速度为纳秒级别，但容量小。而硬盘容量大，但速度为毫秒级别。，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘IO操作。<strong>树的高度就等于每次查询数据时磁盘IO操作的次数</strong>，所以，优化重点是利用硬盘存储节点，并尽量减少IO次数，即减少树的高度。</p>
<p>如何减少树的高度: 从二叉树到M叉树,如下图，16个数据二叉树高度为4，而五叉树高度为2</p>
<p><img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/M叉树.png" alt="M叉树"></p>
<p>不难发现，对于相同个数的数据构建m叉树索引，m叉树中的m越大，那树的高度就越小。那么，M该如何取值？<br>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次IO操作。所以，我们在选择m大小的时候，要<strong>尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘IO操作。</strong></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># linux 获取内存页大小，一般都是4K</span><br><span class="line">getconf PAGE_SIZE</span><br></pre></td></tr></table></figure></div>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过m（m值是提前计算号的），这个节点的大小超过了一个页的大小，一旦超过，那必然会进行多次IO了；所以，必须保证该树是个M叉树，必须进行索引调整(会导致导致写入速度降低)</p>
<p>调整思路:<br>将这个节点分裂成两个节点。但是，节点分裂之后，如果上层父节点的子节点个数就有可能超过m个,将父节点也分裂成两个节点，如下图，图中的B+树是一个三叉树。我们限定叶子节点中，数据的个数超过2个就分裂节点；非叶子节点中，子节点的个数超过3个就分裂节点(注意B+树中链表顺序是由大到小，一旦超出就需要进行索引调整)</p>
<p>-<img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树3.png" alt="B+树3"></p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>同样的，删除数据也需要重新调整索引，因为频繁的数据删除，就会导致某些结点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率</p>
<p>调整思路：设置一个阈值</p>
<ul>
<li>在B+树中，这个阈值等于m/2</li>
<li>如果某个节点的子节点个数小于m/2，将它跟相邻的兄弟节点合并</li>
<li>如果合并之后结点的子节点个数超过m，就使用插入时的调整方法，分裂节点</li>
</ul>
<p>-<img src="https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树4.png" alt="B+树4"></p>
<h1 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h1><h1 id="图（Graph）"><a href="#图（Graph）" class="headerlink" title="图（Graph）"></a>图（Graph）</h1>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/DataStructure/" rel="tag"># DataStructure</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/16/Algorithm.all/" rel="next" title="DataStructure">
                <i class="fa fa-chevron-left"></i> DataStructure
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/18/DesignPatterns.all/" rel="prev" title="DesignPatterns">
                DesignPatterns <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/toux.jpg" alt="Liisyu">
            
              <p class="site-author-name" itemprop="name">Liisyu</p>
              <div class="site-description motion-element" itemprop="description">我只是一个兴趣使然的程序员</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://liisyu.gitee.io/cv/" title="简历 &rarr; http://liisyu.gitee.io/cv/" rel="noopener" target="_blank"><i class="fa fa-fw fa-user-o"></i>简历</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:575600714@qq.com.com" title="E-Mail(QQ) &rarr; mailto:575600714@qq.com.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail(QQ)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:swordmaster2014@gmail.com" title="E-Mail(Google) &rarr; mailto:swordmaster2014@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>E-Mail(Google)</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/FameLsy" title="GitHub &rarr; https://github.com/FameLsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://gitee.com/liisyu" title="Gitee &rarr; https://gitee.com/liisyu" rel="noopener" target="_blank"><i class="fa fa-fw fa-git-square"></i>Gitee</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/masorl" title="CSDN &rarr; https://blog.csdn.net/masorl" rel="noopener" target="_blank"><i class="fa fa-fw fa-tree"></i>CSDN</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="tencent://message/?uin=575600714&Site=qq&Menu=yes" title="QQ &rarr; tencent://message/?uin=575600714&Site=qq&Menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QQ</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://messilessblog.com/" title="https://messilessblog.com/" rel="noopener" target="_blank">汪酱 BLOG</a>
                  </li>
                
              </ul>
			   
            </div>
          

          
            
          
          

    <div class="wechat-box">
      <div class="weixin-description">微信扫一扫，联系我</div>
	  <img src="/blog/images/wechat.jpg" alt="wechat">
    </div>


        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数组（Array）"><span class="nav-number">1.</span> <span class="nav-text">数组（Array）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组概念"><span class="nav-number">1.1.</span> <span class="nav-text">数组概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的插入"><span class="nav-number">1.2.</span> <span class="nav-text">数组的插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的删除"><span class="nav-number">1.3.</span> <span class="nav-text">数组的删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的访问越界"><span class="nav-number">1.4.</span> <span class="nav-text">数组的访问越界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组和容器选择"><span class="nav-number">1.5.</span> <span class="nav-text">数组和容器选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么数组会是从0开始"><span class="nav-number">1.6.</span> <span class="nav-text">为什么数组会是从0开始</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组列表-ArrayList"><span class="nav-number">2.</span> <span class="nav-text">数组列表(ArrayList)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表（linkedList）"><span class="nav-number">3.</span> <span class="nav-text">链表（linkedList）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链表与数组的区别"><span class="nav-number">3.1.</span> <span class="nav-text">链表与数组的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见链表"><span class="nav-number">3.2.</span> <span class="nav-text">常见链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单链表"><span class="nav-number">3.2.1.</span> <span class="nav-text">单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环链表"><span class="nav-number">3.2.2.</span> <span class="nav-text">循环链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双向链表"><span class="nav-number">3.2.3.</span> <span class="nav-text">双向链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向循环链表"><span class="nav-number">3.3.</span> <span class="nav-text">双向循环链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何写好链表"><span class="nav-number">3.4.</span> <span class="nav-text">如何写好链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解指针"><span class="nav-number">3.4.1.</span> <span class="nav-text">理解指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#警惕指针丢失和内存泄露"><span class="nav-number">3.4.2.</span> <span class="nav-text">警惕指针丢失和内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用哨兵简化实现难度"><span class="nav-number">3.4.3.</span> <span class="nav-text">利用哨兵简化实现难度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#留意边界条件处理"><span class="nav-number">3.4.4.</span> <span class="nav-text">留意边界条件处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画图"><span class="nav-number">3.4.5.</span> <span class="nav-text">画图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表应用场景"><span class="nav-number">3.5.</span> <span class="nav-text">链表应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU缓存淘汰算法"><span class="nav-number">3.5.1.</span> <span class="nav-text">LRU缓存淘汰算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#栈（Stack）"><span class="nav-number">4.</span> <span class="nav-text">栈（Stack）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是栈？"><span class="nav-number">4.1.</span> <span class="nav-text">什么是栈？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的栈代码"><span class="nav-number">4.2.</span> <span class="nav-text">简单的栈代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈的应用"><span class="nav-number">4.3.</span> <span class="nav-text">栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#栈在函数调用中的应用"><span class="nav-number">4.3.1.</span> <span class="nav-text">栈在函数调用中的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈在表达式求值中的应用"><span class="nav-number">4.3.2.</span> <span class="nav-text">栈在表达式求值中的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈在括号匹配中的应用"><span class="nav-number">4.3.3.</span> <span class="nav-text">栈在括号匹配中的应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#队列（Queue）"><span class="nav-number">5.</span> <span class="nav-text">队列（Queue）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是队列？"><span class="nav-number">5.1.</span> <span class="nav-text">什么是队列？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见队列"><span class="nav-number">5.2.</span> <span class="nav-text">常见队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序队列代码"><span class="nav-number">5.2.1.</span> <span class="nav-text">顺序队列代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础链表的队列实现"><span class="nav-number">5.2.2.</span> <span class="nav-text">基础链表的队列实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环队列"><span class="nav-number">5.2.3.</span> <span class="nav-text">循环队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞队列"><span class="nav-number">5.2.4.</span> <span class="nav-text">阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发队列"><span class="nav-number">5.2.5.</span> <span class="nav-text">并发队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列相关应用"><span class="nav-number">5.3.</span> <span class="nav-text">队列相关应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池没有空闲线程时，如何处理新的请求线程资源"><span class="nav-number">5.4.</span> <span class="nav-text">线程池没有空闲线程时，如何处理新的请求线程资源</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#跳表（Skip-list）"><span class="nav-number">6.</span> <span class="nav-text">跳表（Skip list）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是跳表？"><span class="nav-number">6.1.</span> <span class="nav-text">什么是跳表？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳表查找"><span class="nav-number">6.2.</span> <span class="nav-text">跳表查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳表插入删除"><span class="nav-number">6.3.</span> <span class="nav-text">跳表插入删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳表索引动态更新"><span class="nav-number">6.4.</span> <span class="nav-text">跳表索引动态更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳表示例代码"><span class="nav-number">6.5.</span> <span class="nav-text">跳表示例代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#散列表-HashTable"><span class="nav-number">7.</span> <span class="nav-text">散列表(HashTable)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是散列表"><span class="nav-number">7.1.</span> <span class="nav-text">什么是散列表?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#散列函数"><span class="nav-number">7.2.</span> <span class="nav-text">散列函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#散列冲突"><span class="nav-number">7.3.</span> <span class="nav-text">散列冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#开放寻址法"><span class="nav-number">7.3.1.</span> <span class="nav-text">开放寻址法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表法"><span class="nav-number">7.3.2.</span> <span class="nav-text">链表法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何设计散列函数"><span class="nav-number">7.4.</span> <span class="nav-text">如何设计散列函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扩容"><span class="nav-number">7.4.1.</span> <span class="nav-text">扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择合适的冲突解决办法"><span class="nav-number">7.4.2.</span> <span class="nav-text">选择合适的冲突解决办法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#散列表与链表的结合使用"><span class="nav-number">7.5.</span> <span class="nav-text">散列表与链表的结合使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树（Tree）"><span class="nav-number">8.</span> <span class="nav-text">树（Tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数的基本概念"><span class="nav-number">8.1.</span> <span class="nav-text">数的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树基础（Binary-Tree）"><span class="nav-number">8.2.</span> <span class="nav-text">二叉树基础（Binary Tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#完全二叉树"><span class="nav-number">8.2.1.</span> <span class="nav-text">完全二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#满二叉树"><span class="nav-number">8.2.2.</span> <span class="nav-text">满二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的存储"><span class="nav-number">8.2.3.</span> <span class="nav-text">二叉树的存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#链式存储法"><span class="nav-number">8.2.3.1.</span> <span class="nav-text">链式存储法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序存储法"><span class="nav-number">8.2.3.2.</span> <span class="nav-text">顺序存储法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两种存储法对比"><span class="nav-number">8.2.3.3.</span> <span class="nav-text">两种存储法对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的遍历"><span class="nav-number">8.2.4.</span> <span class="nav-text">二叉树的遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉查找树"><span class="nav-number">8.3.</span> <span class="nav-text">二叉查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树的查找操作"><span class="nav-number">8.3.1.</span> <span class="nav-text">二叉查找树的查找操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树的插入操作"><span class="nav-number">8.3.2.</span> <span class="nav-text">二叉查找树的插入操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树的删除操作"><span class="nav-number">8.3.3.</span> <span class="nav-text">二叉查找树的删除操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树的时间复杂度"><span class="nav-number">8.3.4.</span> <span class="nav-text">二叉查找树的时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#支持重复数据的二叉查找树"><span class="nav-number">8.4.</span> <span class="nav-text">支持重复数据的二叉查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查找操作"><span class="nav-number">8.4.1.</span> <span class="nav-text">查找操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除操作"><span class="nav-number">8.4.2.</span> <span class="nav-text">删除操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平衡二叉查找树"><span class="nav-number">8.5.</span> <span class="nav-text">平衡二叉查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#平衡二叉树的种类"><span class="nav-number">8.5.1.</span> <span class="nav-text">平衡二叉树的种类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#红黑树"><span class="nav-number">8.6.</span> <span class="nav-text">红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#红黑树的近似平衡"><span class="nav-number">8.6.1.</span> <span class="nav-text">红黑树的近似平衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#左右旋"><span class="nav-number">8.6.2.</span> <span class="nav-text">左右旋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入操作，特殊情况的平衡调整"><span class="nav-number">8.6.3.</span> <span class="nav-text">插入操作，特殊情况的平衡调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入操作，其他情况的平衡调整"><span class="nav-number">8.6.4.</span> <span class="nav-text">插入操作，其他情况的平衡调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除操作的平衡调整"><span class="nav-number">8.6.5.</span> <span class="nav-text">删除操作的平衡调整</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一次调整"><span class="nav-number">8.6.5.1.</span> <span class="nav-text">第一次调整</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二次调整"><span class="nav-number">8.6.5.2.</span> <span class="nav-text">第二次调整</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归树"><span class="nav-number">8.7.</span> <span class="nav-text">递归树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-树"><span class="nav-number">8.8.</span> <span class="nav-text">B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#平衡二叉树到B-树"><span class="nav-number">8.8.1.</span> <span class="nav-text">平衡二叉树到B+ 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入数据"><span class="nav-number">8.8.2.</span> <span class="nav-text">插入数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除数据"><span class="nav-number">8.8.3.</span> <span class="nav-text">删除数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#堆（Heap）"><span class="nav-number">9.</span> <span class="nav-text">堆（Heap）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#图（Graph）"><span class="nav-number">10.</span> <span class="nav-text">图（Graph）</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liisyu</span>

  

  
</div>






        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

  <script type="text/javascript" src="/blog/js/clipboard.min.js"></script>  
  <script type="text/javascript" src="/blog/js/clipboard-use.js"></script>
</body>
</html>
